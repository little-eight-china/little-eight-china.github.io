<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>八达博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://little8.top/"/>
  <updated>2019-07-23T13:00:40.947Z</updated>
  <id>https://little8.top/</id>
  
  <author>
    <name>小八</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ThreadPoolExecutor类解析</title>
    <link href="https://little8.top/2019/07/23/ThreadPoolExecutor%E7%B1%BB%E8%A7%A3%E6%9E%90/"/>
    <id>https://little8.top/2019/07/23/ThreadPoolExecutor类解析/</id>
    <published>2019-07-23T12:07:44.000Z</published>
    <updated>2019-07-23T13:00:40.947Z</updated>
    
    <content type="html"><![CDATA[<p>在《阿里巴巴java开发手册》中指出了线程资源必须通过线程池提供，不允许在应用中自行显示的创建线程，这样一方面是线程的创建更加规范，可以合理控制开辟线程的数量；另一方面线程的细节管理交给线程池处理，优化了资源的开销。而线程池不允许使用Executors去创建，而要通过ThreadPoolExecutor方式，这一方面是由于jdk中Executor框架虽然提供了如newFixedThreadPool()、newSingleThreadExecutor()、newCachedThreadPool()等创建线程池的方法，但都有其局限性，不够灵活；另外由于前面几种方法内部也是通过ThreadPoolExecutor方式实现，使用ThreadPoolExecutor有助于大家明确线程池的运行规则，创建符合自己的业务场景需要的线程池，避免资源耗尽的风险。</p><h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 线程池的控制状态，是AtomicInteger类型的，里面包含两部分，workcount---线程的数量，</span><br><span class="line"> * runState---线程池的运行状态。这里限制了最大线程数是2^29-1，大约500百万个线程，</span><br><span class="line"> * 这也是个问题，所以ctl也可以变成AtomicLong类型的</span><br><span class="line"> */</span><br><span class="line">private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));</span><br><span class="line">/**</span><br><span class="line"> * 线程数量所占位数</span><br><span class="line"> */</span><br><span class="line">private static final int COUNT_BITS = Integer.SIZE - 3;</span><br><span class="line">/**</span><br><span class="line"> * 理论上的最大活跃线程数</span><br><span class="line"> */</span><br><span class="line">private static final int CAPACITY   = (1 &lt;&lt; COUNT_BITS) - 1;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * RUNNING - 接受新任务并且继续处理阻塞队列中的任务</span><br><span class="line"> * SHUTDOWN - 不接受新任务但是会继续处理阻塞队列中的任务</span><br><span class="line"> * STOP -  不接受新任务，不在执行阻塞队列中的任务，中断正在执行的任务</span><br><span class="line"> * TIDYING - 所有任务都已经完成，线程数都被回收，线程会转到TIDYING状态会继续执行钩子方法</span><br><span class="line"> * TERMINATED - 钩子方法执行完毕</span><br><span class="line"> */</span><br><span class="line">private static final int RUNNING    = -1 &lt;&lt; COUNT_BITS;</span><br><span class="line">private static final int SHUTDOWN   =  0 &lt;&lt; COUNT_BITS;</span><br><span class="line">private static final int STOP       =  1 &lt;&lt; COUNT_BITS;</span><br><span class="line">private static final int TIDYING    =  2 &lt;&lt; COUNT_BITS;</span><br><span class="line">private static final int TERMINATED =  3 &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  存放任务的队列，只有当线程数&gt;核心线程数，才会把其他的任务放入queue，</span><br><span class="line"> * 一般常用的是queue就是ArrayBlockingQueue，LinkedBlockingQueue，</span><br><span class="line"> * SynchronousQueue， ConcurrentLinkedQueue。</span><br><span class="line"> *</span><br><span class="line">　　 * 1）ArrayBlockingQueue：基于数组的先进先出队列，此队列创建时必须指定大小；</span><br><span class="line"> *    </span><br><span class="line">　　 * 2）LinkedBlockingQueue：基于链表的先进先出队列，如果创建时没有指定此队列大小，则默认为Integer.MAX_VALUE；</span><br><span class="line">　　 * 3）synchronousQueue：这个队列比较特殊，它不会保存提交的任务，而是将直接新建一个线程来执行新来的任务。</span><br><span class="line">　　 * 4) ConcurrentLinkedQueue: 无界线程安全队列</span><br><span class="line"> */</span><br><span class="line">private final BlockingQueue&lt;Runnable&gt; workQueue;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 包含池中所有工作线程的集合。仅当保持主锁.</span><br><span class="line"> */</span><br><span class="line">private final HashSet&lt;Worker&gt; workers = new HashSet&lt;Worker&gt;();</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 支持等待终止的等待条件</span><br><span class="line"> */</span><br><span class="line">private final Condition termination = mainLock.newCondition();</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 跟踪获得的最大池大小。仅在主锁下访问。</span><br><span class="line"> */</span><br><span class="line">private int largestPoolSize;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 已完成任务的计数器。仅在工作线程终止时更新。仅在主锁下访问</span><br><span class="line"> */</span><br><span class="line">private long completedTaskCount;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 创建线程的工厂类</span><br><span class="line"> */</span><br><span class="line">private volatile ThreadFactory threadFactory;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 在执行中饱和或关闭时调用的处理程序。拒绝策略；当任务太多来不及处理时，如何拒绝任务</span><br><span class="line"> */</span><br><span class="line">private volatile RejectedExecutionHandler handler;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 当线程池中创建的线程超过了核心线程数的时候，这些多余的空闲线程在结束之前等待新的                  * 创建线程的工厂类任务最大的存活时间。</span><br><span class="line"> */</span><br><span class="line">private volatile long keepAliveTime;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 允许核心线程被回收</span><br><span class="line"> */</span><br><span class="line">private volatile boolean allowCoreThreadTimeOut;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 线程池中的核心线程数，空闲的线程也不会回收，除非把allowCoreThreadTimeOut设置为true，              * 这时核心线程才会被回收</span><br><span class="line"> */</span><br><span class="line">private volatile int corePoolSize;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 线程池中可以创建的最大线程数，限定为2^29-1，大约500百万个线程。</span><br><span class="line"> * 需要注意的是，当使用无界的阻塞队列的时候，maximumPoolSize就起不到作用了。</span><br><span class="line"> */</span><br><span class="line">private volatile int maximumPoolSize;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 默认被拒绝的执行处理程序</span><br><span class="line"> */</span><br><span class="line">private static final RejectedExecutionHandler defaultHandler =</span><br><span class="line">    new AbortPolicy();</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 终止的权限</span><br><span class="line"> */</span><br><span class="line">private static final RuntimePermission shutdownPerm =</span><br><span class="line">    new RuntimePermission(&quot;modifyThread&quot;);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> */</span><br><span class="line">private final AccessControlContext acc;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 有多个构造方法，只讲最终实现的</span><br><span class="line"> */</span><br><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                          int maximumPoolSize,</span><br><span class="line">                          long keepAliveTime,</span><br><span class="line">                          TimeUnit unit,</span><br><span class="line">                          BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                          ThreadFactory threadFactory,</span><br><span class="line">                          RejectedExecutionHandler handler) &#123;</span><br><span class="line">    // 设置的核心线程数小于0，或者最大线程数小于0，或者最大线程数小于核心线程数，</span><br><span class="line">    // 创建线程的工厂类任务最大的存活时间小于0都抛出异常</span><br><span class="line">    if (corePoolSize &lt; 0 ||</span><br><span class="line">        maximumPoolSize &lt;= 0 ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; 0)</span><br><span class="line">        throw new IllegalArgumentException();</span><br><span class="line">    // 存放任务的队列、线程工厂、处理程序为null也抛出异常</span><br><span class="line">    if (workQueue == null || threadFactory == null || handler == null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    this.acc = System.getSecurityManager() == null ?</span><br><span class="line">            null :</span><br><span class="line">            AccessController.getContext();</span><br><span class="line">    // 下面就是设置参数了</span><br><span class="line">    this.corePoolSize = corePoolSize;</span><br><span class="line">    this.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    this.workQueue = workQueue;</span><br><span class="line">    this.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    this.threadFactory = threadFactory;</span><br><span class="line">    this.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="主要方法（从用法入手）"><a href="#主要方法（从用法入手）" class="headerlink" title="主要方法（从用法入手）"></a>主要方法（从用法入手）</h2><h3 id="execute"><a href="#execute" class="headerlink" title="execute"></a>execute</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 执行入口</span><br><span class="line"> *</span><br><span class="line"> * 三步操作</span><br><span class="line"> *</span><br><span class="line"> * 1. 如果当前运行的线程数&lt;核心线程数,创建一个新的线程执行任务,调用addWorker方法原子性地检查</span><br><span class="line"> *    运行状态和线程数,通过返回false防止不需要的时候添加线程</span><br><span class="line"> * 2. 如果一个任务能够成功的入队,仍然需要双重检查,因为我们添加了一个线程(有可能这个线程在上次检查后就已经死亡了)</span><br><span class="line"> *    或者进入此方法的时候调用了shutdown,所以需要重新检查线程池的状态,如果必要的话,当停止的时候要回滚入队操作,</span><br><span class="line"> *    或者当线程池为空的话创建一个新的线程</span><br><span class="line"> * 3. 如果不能入队,尝试着开启一个新的线程,如果开启失败,说明线程池已经是shutdown状态或饱和了,所以拒绝执行该任务</span><br><span class="line"> */</span><br><span class="line">  public void execute(Runnable command) &#123;</span><br><span class="line">     if (command == null)</span><br><span class="line">         throw new NullPointerException();</span><br><span class="line">     // 获取当前线程池的控制状态</span><br><span class="line">     int c = ctl.get();</span><br><span class="line">     // 如果当前运行的线程数&lt;核心线程数</span><br><span class="line">     if (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">         // 调用addWorker方法原子性地检查运行状态和线程数,通过返回false防止不需要的时候添加线程</span><br><span class="line">         // 添加worker,成功则返回,下面再解析这个方法</span><br><span class="line">         if (addWorker(command, true))</span><br><span class="line">             return;</span><br><span class="line">         // 不成功则再次获取线程池控制状态</span><br><span class="line">         c = ctl.get();</span><br><span class="line">     &#125;</span><br><span class="line">     // 线程池处于RUNNING状态，将命令（用户自定义的Runnable对象）添加进workQueue队列</span><br><span class="line">     if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">          // 再次检查，获取线程池控制状态</span><br><span class="line">         int recheck = ctl.get();</span><br><span class="line">         // 线程池不处于RUNNING状态，将命令从workQueue队列中移除</span><br><span class="line">         if (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">             // 拒绝执行命令</span><br><span class="line">             reject(command);</span><br><span class="line">         // worker数量等于0,添加worker</span><br><span class="line">         else if (workerCountOf(recheck) == 0)</span><br><span class="line">             addWorker(null, false);</span><br><span class="line">     &#125;</span><br><span class="line">     // 添加worker失败,拒绝执行命令</span><br><span class="line">     else if (!addWorker(command, false))</span><br><span class="line">         reject(command);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="addWorker"><a href="#addWorker" class="headerlink" title="addWorker"></a>addWorker</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> */</span><br><span class="line"> private boolean addWorker(Runnable firstTask, boolean core) &#123;</span><br><span class="line">    retry:</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int c = ctl.get();</span><br><span class="line">        int rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        // 检查线程池状态是否正常，否则返回false</span><br><span class="line">        if (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask == null &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            return false;</span><br><span class="line"></span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            int wc = workerCountOf(c);</span><br><span class="line">            // 检查工作线程数是否正常，否则返回false</span><br><span class="line">            if (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                return false;</span><br><span class="line">            // 用到了原子CAS方法比较，使用CAS增加worker计数器成功，才能进入下一步</span><br><span class="line">            if (compareAndIncrementWorkerCount(c))</span><br><span class="line">                break retry;</span><br><span class="line">            c = ctl.get(); </span><br><span class="line">             // 这里表示执行到这里的时候线程池的运行状态发生改变的话，需要重新跳到retry处执行</span><br><span class="line">            if (runStateOf(c) != rs)</span><br><span class="line">                continue retry;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // worker开始标识</span><br><span class="line">    boolean workerStarted = false;</span><br><span class="line">    // worker被添加标识</span><br><span class="line">    boolean workerAdded = false;</span><br><span class="line">    Worker w = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 使用firstTask初始化Worker，first可能为null，那么则表示该worker为空闲</span><br><span class="line">        w = new Worker(firstTask);</span><br><span class="line">        // 获取worker对应的线程</span><br><span class="line">        final Thread t = w.thread;</span><br><span class="line">        if (t != null) &#123;</span><br><span class="line">             // 获取线程池锁</span><br><span class="line">            final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            try &#123;</span><br><span class="line">                // 线程池的运行状态</span><br><span class="line">                int rs = runStateOf(ctl.get());</span><br><span class="line">                // 判断线程池状态</span><br><span class="line">                if (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123;</span><br><span class="line">                    // 线程刚添加进来，还未启动就存活,抛出线程状态异常</span><br><span class="line">                    if (t.isAlive())</span><br><span class="line">                        throw new IllegalThreadStateException();</span><br><span class="line">                    // 添加worker</span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    int s = workers.size();</span><br><span class="line">                    // 如果队列大小大于最大池大小，让后者等于前者</span><br><span class="line">                    if (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    // 标识worker添加成功</span><br><span class="line">                    workerAdded = true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                // 解锁</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            // 如果worker添加成功，就标识运行成功</span><br><span class="line">            if (workerAdded) &#123;</span><br><span class="line">                // 开始执行worker的run方法</span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        // worker没有运行</span><br><span class="line">        if (! workerStarted)</span><br><span class="line">            // 添加worker失败，后面解析这个方法</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    // 返回worker的运行状态</span><br><span class="line">    return workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="addWorkerFailed"><a href="#addWorkerFailed" class="headerlink" title="addWorkerFailed"></a>addWorkerFailed</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> */</span><br><span class="line"> private void addWorkerFailed(Worker w) &#123;</span><br><span class="line">    // 获取主锁</span><br><span class="line">    final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        if (w != null)</span><br><span class="line">            // 移除该worker</span><br><span class="line">            workers.remove(w);</span><br><span class="line">        // 数量减1</span><br><span class="line">        decrementWorkerCount();</span><br><span class="line">        // 调用tryTerminate方法来尝试中止线程池,或者是清理一下线程池，下面说</span><br><span class="line">        tryTerminate();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="tryTerminate"><a href="#tryTerminate" class="headerlink" title="tryTerminate"></a>tryTerminate</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">    /**</span><br><span class="line">     * 尝试终止线程池</span><br><span class="line">     */</span><br><span class="line">final void tryTerminate() &#123;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            // 获取线程池控制状态</span><br><span class="line">            int c = ctl.get();</span><br><span class="line">            // 线程池的运行状态为RUNNING</span><br><span class="line">            if (isRunning(c) ||      </span><br><span class="line">                // 线程池的运行状态最小要大于TIDYING</span><br><span class="line">                runStateAtLeast(c, TIDYING) ||   </span><br><span class="line">                 // 线程池的运行状态为SHUTDOWN并且workQueue队列不为null</span><br><span class="line">                (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))   </span><br><span class="line">                // 不能终止，直接返回</span><br><span class="line">                return;</span><br><span class="line">            // 线程池正在运行的worker数量不为0   </span><br><span class="line">            if (workerCountOf(c) != 0) &#123; </span><br><span class="line">                // 仅仅中断一个空闲的worker，下面说</span><br><span class="line">                interruptIdleWorkers(ONLY_ONE);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            // 获取线程池的锁</span><br><span class="line">            final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">            // 获取锁</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            try &#123;</span><br><span class="line">                // 比较并设置线程池控制状态为TIDYING</span><br><span class="line">                if (ctl.compareAndSet(c, ctlOf(TIDYING, 0))) &#123; </span><br><span class="line">                    try &#123;</span><br><span class="line">                        // 终止，钩子函数</span><br><span class="line">                        terminated();</span><br><span class="line">                    &#125; finally &#123;</span><br><span class="line">                        // 设置线程池控制状态为TERMINATED</span><br><span class="line">                        ctl.set(ctlOf(TERMINATED, 0));</span><br><span class="line">                        // 释放在termination条件上等待的所有线程</span><br><span class="line">                        termination.signalAll();</span><br><span class="line">                    &#125;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                // 释放锁</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            // else retry on failed CAS</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="interruptIdleWorkers"><a href="#interruptIdleWorkers" class="headerlink" title="interruptIdleWorkers"></a>interruptIdleWorkers</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">    /**</span><br><span class="line">     * 尝试中断线程，onlyOne标识是否只中断一个</span><br><span class="line">     */</span><br><span class="line">private void interruptIdleWorkers(boolean onlyOne) &#123;</span><br><span class="line">        // 线程池的锁</span><br><span class="line">        final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">        // 获取锁</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            for (Worker w : workers) &#123; // 遍历workers队列</span><br><span class="line">                // worker对应的线程</span><br><span class="line">                Thread t = w.thread;</span><br><span class="line">                if (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123; // 线程未被中断并且成功获得锁</span><br><span class="line">                    try &#123;</span><br><span class="line">                        // 中断线程</span><br><span class="line">                        t.interrupt();</span><br><span class="line">                    &#125; catch (SecurityException ignore) &#123;</span><br><span class="line">                    &#125; finally &#123;</span><br><span class="line">                        // 释放锁</span><br><span class="line">                        w.unlock();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (onlyOne) // 若只中断一个，则跳出循环</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            // 释放锁</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="runWorker-重点关注这个"><a href="#runWorker-重点关注这个" class="headerlink" title="runWorker 重点关注这个"></a>runWorker 重点关注这个</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> */</span><br><span class="line"> final void runWorker(Worker w) &#123;</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = null;</span><br><span class="line">    w.unlock(); // allow interrupts</span><br><span class="line">    boolean completedAbruptly = true;</span><br><span class="line">    try &#123;</span><br><span class="line">         // 不断循环getTask来获取任务，getTask后面说</span><br><span class="line">        while (task != null || (task = getTask()) != null) &#123;</span><br><span class="line">            w.lock();</span><br><span class="line">            // 如果当前线程是stop，那么将确认其为interrupted</span><br><span class="line">            if ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            try &#123;</span><br><span class="line">                // 调用钩子函数</span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                Throwable thrown = null;</span><br><span class="line">                try &#123;</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; catch (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; throw x;</span><br><span class="line">                &#125; catch (Error x) &#123;</span><br><span class="line">                    thrown = x; throw x;</span><br><span class="line">                &#125; catch (Throwable x) &#123;</span><br><span class="line">                    thrown = x; throw new Error(x);</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    // 调用钩子函数</span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                task = null;</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = false;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        // 处理完成后，调用,下面会说</span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="getTask"><a href="#getTask" class="headerlink" title="getTask"></a>getTask</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 获取任务</span><br><span class="line"> */</span><br><span class="line"> private Runnable getTask() &#123;</span><br><span class="line">    // 超时标识</span><br><span class="line">    boolean timedOut = false;</span><br><span class="line"></span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int c = ctl.get();</span><br><span class="line">        int rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        // 检验线程池状态 </span><br><span class="line">        if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">        // 是否允许coreThread超时或者workerCount大于核心大小</span><br><span class="line">        boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line">        // 检查线程数量</span><br><span class="line">        if ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">            &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) &#123;</span><br><span class="line">            if (compareAndDecrementWorkerCount(c))</span><br><span class="line">                return null;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            Runnable r = timed ?</span><br><span class="line">                // 等待指定时间</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                // 一直等待，直到有元素</span><br><span class="line">                workQueue.take();</span><br><span class="line">            if (r != null)</span><br><span class="line">                return r;</span><br><span class="line">            // 等待指定时间后，没有获取元素，则超时</span><br><span class="line">            timedOut = true;</span><br><span class="line">        &#125; catch (InterruptedException retry) &#123;</span><br><span class="line">            // 抛出了被中断异常，重试，没有超时</span><br><span class="line">            timedOut = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="processWorkerExit"><a href="#processWorkerExit" class="headerlink" title="processWorkerExit"></a>processWorkerExit</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 根据是否中断了空闲线程来确定是否减少workerCount的值，并且将worker从workers集合中移除并且会尝试终止线程池。</span><br><span class="line"> */</span><br><span class="line">private void processWorkerExit(Worker w, boolean completedAbruptly) &#123;</span><br><span class="line">    // 如果被中断，则需要减少workCount</span><br><span class="line">    if (completedAbruptly)</span><br><span class="line">        decrementWorkerCount();</span><br><span class="line">    // 获取可重入锁</span><br><span class="line">    final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">    // 获取锁</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        // 将worker完成的任务添加到总的完成任务中</span><br><span class="line">        completedTaskCount += w.completedTasks;</span><br><span class="line">        // 从workers集合中移除该worker</span><br><span class="line">        workers.remove(w);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        // 释放锁</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    // 尝试终止</span><br><span class="line">    tryTerminate();</span><br><span class="line">    // 获取线程池控制状态</span><br><span class="line">    int c = ctl.get();</span><br><span class="line">    // 小于STOP的运行状态</span><br><span class="line">    if (runStateLessThan(c, STOP)) &#123; </span><br><span class="line">        if (!completedAbruptly) &#123;</span><br><span class="line">            int min = allowCoreThreadTimeOut ? 0 : corePoolSize;</span><br><span class="line">             // 允许核心超时并且workQueue阻塞队列不为空</span><br><span class="line">            if (min == 0 &amp;&amp; ! workQueue.isEmpty())</span><br><span class="line">                min = 1;</span><br><span class="line">            // workerCount大于等于min</span><br><span class="line">            if (workerCountOf(c) &gt;= min) </span><br><span class="line">                // 直接返回</span><br><span class="line">                return; // replacement not needed</span><br><span class="line">        &#125;</span><br><span class="line">        // 添加worker</span><br><span class="line">        addWorker(null, false);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在《阿里巴巴java开发手册》中指出了线程资源必须通过线程池提供，不允许在应用中自行显示的创建线程，这样一方面是线程的创建更加规范，可以合理控制开辟线程的数量；另一方面线程的细节管理交给线程池处理，优化了资源的开销。而线程池不允许使用Executors去创建，而要通过ThreadPoolExecutor方式，这一方面是由于jdk中Executor框架虽然提供了如newFixedThreadPool()、newSingleThreadExecutor()、newCachedThreadPool()等创建线程池的方法，但都有其局限性，不够灵活；另外由于前面几种方法内部也是通过ThreadPoolExecutor方式实现，使用ThreadPoolExecutor有助于大家明确线程池的运行规则，创建符合自己的业务场景需要的线程池，避免资源耗尽的风险。&lt;/p&gt;&lt;h2 id=&quot;成员变量&quot;&gt;&lt;a href=&quot;#成员变量&quot; class=&quot;headerlink&quot; title=&quot;成员变量&quot;&gt;&lt;/a&gt;成员变量&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;65&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;66&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;67&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;68&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;69&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;70&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;71&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;72&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;73&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;74&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;75&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;76&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;77&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;78&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;79&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;80&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;81&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;82&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;83&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;84&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;85&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;86&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;87&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;88&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;89&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;90&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;91&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;92&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;93&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;94&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;95&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;96&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;97&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;98&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;99&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;100&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;101&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;102&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;103&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;104&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;105&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;106&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;107&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;108&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;109&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * 线程池的控制状态，是AtomicInteger类型的，里面包含两部分，workcount---线程的数量，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * runState---线程池的运行状态。这里限制了最大线程数是2^29-1，大约500百万个线程，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * 这也是个问题，所以ctl也可以变成AtomicLong类型的&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * 线程数量所占位数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;private static final int COUNT_BITS = Integer.SIZE - 3;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * 理论上的最大活跃线程数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;private static final int CAPACITY   = (1 &amp;lt;&amp;lt; COUNT_BITS) - 1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * RUNNING - 接受新任务并且继续处理阻塞队列中的任务&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * SHUTDOWN - 不接受新任务但是会继续处理阻塞队列中的任务&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * STOP -  不接受新任务，不在执行阻塞队列中的任务，中断正在执行的任务&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * TIDYING - 所有任务都已经完成，线程数都被回收，线程会转到TIDYING状态会继续执行钩子方法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * TERMINATED - 钩子方法执行完毕&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;private static final int RUNNING    = -1 &amp;lt;&amp;lt; COUNT_BITS;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;private static final int SHUTDOWN   =  0 &amp;lt;&amp;lt; COUNT_BITS;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;private static final int STOP       =  1 &amp;lt;&amp;lt; COUNT_BITS;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;private static final int TIDYING    =  2 &amp;lt;&amp;lt; COUNT_BITS;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;private static final int TERMINATED =  3 &amp;lt;&amp;lt; COUNT_BITS;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *  存放任务的队列，只有当线程数&amp;gt;核心线程数，才会把其他的任务放入queue，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * 一般常用的是queue就是ArrayBlockingQueue，LinkedBlockingQueue，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * SynchronousQueue， ConcurrentLinkedQueue。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;　　 * 1）ArrayBlockingQueue：基于数组的先进先出队列，此队列创建时必须指定大小；&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;　　 * 2）LinkedBlockingQueue：基于链表的先进先出队列，如果创建时没有指定此队列大小，则默认为Integer.MAX_VALUE；&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;　　 * 3）synchronousQueue：这个队列比较特殊，它不会保存提交的任务，而是将直接新建一个线程来执行新来的任务。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;　　 * 4) ConcurrentLinkedQueue: 无界线程安全队列&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;private final BlockingQueue&amp;lt;Runnable&amp;gt; workQueue;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * 包含池中所有工作线程的集合。仅当保持主锁.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;private final HashSet&amp;lt;Worker&amp;gt; workers = new HashSet&amp;lt;Worker&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * 支持等待终止的等待条件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;private final Condition termination = mainLock.newCondition();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * 跟踪获得的最大池大小。仅在主锁下访问。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;private int largestPoolSize;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * 已完成任务的计数器。仅在工作线程终止时更新。仅在主锁下访问&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;private long completedTaskCount;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * 创建线程的工厂类&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;private volatile ThreadFactory threadFactory;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * 在执行中饱和或关闭时调用的处理程序。拒绝策略；当任务太多来不及处理时，如何拒绝任务&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;private volatile RejectedExecutionHandler handler;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * 当线程池中创建的线程超过了核心线程数的时候，这些多余的空闲线程在结束之前等待新的                  * 创建线程的工厂类任务最大的存活时间。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;private volatile long keepAliveTime;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * 允许核心线程被回收&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;private volatile boolean allowCoreThreadTimeOut;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * 线程池中的核心线程数，空闲的线程也不会回收，除非把allowCoreThreadTimeOut设置为true，              * 这时核心线程才会被回收&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;private volatile int corePoolSize;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * 线程池中可以创建的最大线程数，限定为2^29-1，大约500百万个线程。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * 需要注意的是，当使用无界的阻塞队列的时候，maximumPoolSize就起不到作用了。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;private volatile int maximumPoolSize;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * 默认被拒绝的执行处理程序&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;private static final RejectedExecutionHandler defaultHandler =&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    new AbortPolicy();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * 终止的权限&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;private static final RuntimePermission shutdownPerm =&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    new RuntimePermission(&amp;quot;modifyThread&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;private final AccessControlContext acc;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="java1.8源码" scheme="https://little8.top/categories/java1-8%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="little_eight" scheme="https://little8.top/tags/little-eight/"/>
    
  </entry>
  
  <entry>
    <title>java.lang.String类解析</title>
    <link href="https://little8.top/2019/05/09/java-lang-String%E7%B1%BB%E8%A7%A3%E6%9E%90/"/>
    <id>https://little8.top/2019/05/09/java-lang-String类解析/</id>
    <published>2019-05-09T15:37:16.000Z</published>
    <updated>2019-07-23T13:00:40.947Z</updated>
    
    <content type="html"><![CDATA[<h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 底层由数组存数据</span><br><span class="line"> */</span><br><span class="line">private final char value[];</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * hash值</span><br><span class="line"> */</span><br><span class="line">private int hash;</span><br></pre></td></tr></table></figure><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><a id="more"></a><h3 id="charAt"><a href="#charAt" class="headerlink" title="charAt"></a>charAt</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> /**</span><br><span class="line">  * 返回指定下标的字符</span><br><span class="line">  */</span><br><span class="line">public char charAt(int index) &#123;</span><br><span class="line">     if ((index &lt; 0) || (index &gt;= value.length)) &#123;</span><br><span class="line">         throw new StringIndexOutOfBoundsException(index);</span><br><span class="line">     &#125;</span><br><span class="line">     return value[index];</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="compareTo、compareToIgnoreCase"><a href="#compareTo、compareToIgnoreCase" class="headerlink" title="compareTo、compareToIgnoreCase"></a>compareTo、compareToIgnoreCase</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">  /**</span><br><span class="line">   * 比较两个字符串的字典顺序，anotherString在后面的话就返回负数，相等为0，前面就正数</span><br><span class="line">   */</span><br><span class="line">public int compareTo(String anotherString) &#123;</span><br><span class="line">      int len1 = value.length;</span><br><span class="line">      int len2 = anotherString.value.length;</span><br><span class="line">      int lim = Math.min(len1, len2);</span><br><span class="line">      char v1[] = value;</span><br><span class="line">      char v2[] = anotherString.value;</span><br><span class="line"></span><br><span class="line">      int k = 0;</span><br><span class="line">      while (k &lt; lim) &#123;</span><br><span class="line">          char c1 = v1[k];</span><br><span class="line">          char c2 = v2[k];</span><br><span class="line">          if (c1 != c2) &#123;</span><br><span class="line">              return c1 - c2;</span><br><span class="line">          &#125;</span><br><span class="line">          k++;</span><br><span class="line">      &#125;</span><br><span class="line">      return len1 - len2;</span><br><span class="line">  &#125;</span><br><span class="line">  /**</span><br><span class="line">   * 忽略大小写的对比</span><br><span class="line">   */</span><br><span class="line">  public int compareToIgnoreCase(String str) &#123;</span><br><span class="line">      return CASE_INSENSITIVE_ORDER.compare(this, str);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 将指定的字符串参数连接到字符串上</span><br><span class="line"> */</span><br><span class="line">public String concat(String str) &#123;</span><br><span class="line">    int otherLen = str.length();</span><br><span class="line">    if (otherLen == 0) &#123;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">    int len = value.length;</span><br><span class="line">    char buf[] = Arrays.copyOf(value, len + otherLen);</span><br><span class="line">    str.getChars(buf, len);</span><br><span class="line">    return new String(buf, true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="contains"><a href="#contains" class="headerlink" title="contains"></a>contains</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> /**</span><br><span class="line">  * 是否存在此字符</span><br><span class="line">  */</span><br><span class="line">public boolean contains(CharSequence s) &#123;</span><br><span class="line">     return indexOf(s.toString()) &gt; -1;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="contentEquals"><a href="#contentEquals" class="headerlink" title="contentEquals"></a>contentEquals</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">  /**</span><br><span class="line">   * 比较两者的内容是否相同，不检查被比较对象的类型</span><br><span class="line">   */</span><br><span class="line">public boolean contentEquals(CharSequence cs) &#123;</span><br><span class="line">      // Argument is a StringBuffer, StringBuilder</span><br><span class="line">      if (cs instanceof AbstractStringBuilder) &#123;</span><br><span class="line">          if (cs instanceof StringBuffer) &#123;</span><br><span class="line">              synchronized(cs) &#123;</span><br><span class="line">                 return nonSyncContentEquals((AbstractStringBuilder)cs);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">              return nonSyncContentEquals((AbstractStringBuilder)cs);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      // Argument is a String</span><br><span class="line">      if (cs instanceof String) &#123;</span><br><span class="line">          return equals(cs);</span><br><span class="line">      &#125;</span><br><span class="line">      // Argument is a generic CharSequence</span><br><span class="line">      char v1[] = value;</span><br><span class="line">      int n = v1.length;</span><br><span class="line">      if (n != cs.length()) &#123;</span><br><span class="line">          return false;</span><br><span class="line">      &#125;</span><br><span class="line">      for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">          if (v1[i] != cs.charAt(i)) &#123;</span><br><span class="line">              return false;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return true;</span><br><span class="line">  &#125;</span><br><span class="line">  /**</span><br><span class="line">   * 还可以直接传入StringBuffer对比</span><br><span class="line">   */</span><br><span class="line">  public boolean contentEquals(StringBuffer sb) &#123;</span><br><span class="line">      return contentEquals((CharSequence)sb);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="copyValueOf"><a href="#copyValueOf" class="headerlink" title="copyValueOf"></a>copyValueOf</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 根据char数组new一个新的string</span><br><span class="line"> */</span><br><span class="line">public static String copyValueOf(char data[]) &#123;</span><br><span class="line">    return new String(data);</span><br><span class="line">&#125;</span><br><span class="line"> /**</span><br><span class="line"> * 更多参数new一个新的string</span><br><span class="line"> */</span><br><span class="line">public static String copyValueOf(char data[], int offset, int count) &#123;</span><br><span class="line">    return new String(data, offset, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="endsWith、startsWith"><a href="#endsWith、startsWith" class="headerlink" title="endsWith、startsWith"></a>endsWith、startsWith</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 比较是否与尾部的字符串一致</span><br><span class="line"> */</span><br><span class="line">public boolean endsWith(String suffix) &#123;</span><br><span class="line">    return startsWith(suffix, value.length - suffix.value.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 对比指定范围的字符串是否一致</span><br><span class="line"> */</span><br><span class="line">public boolean startsWith(String prefix, int toffset) &#123;</span><br><span class="line">    char ta[] = value;</span><br><span class="line">    int to = toffset;</span><br><span class="line">    char pa[] = prefix.value;</span><br><span class="line">    int po = 0;</span><br><span class="line">    int pc = prefix.value.length;</span><br><span class="line">    // Note: toffset might be near -1&gt;&gt;&gt;1.</span><br><span class="line">    if ((toffset &lt; 0) || (toffset &gt; value.length - pc)) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    while (--pc &gt;= 0) &#123;</span><br><span class="line">        if (ta[to++] != pa[po++]) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">/**</span><br><span class="line"> * 比较是否与头部的字符串一致</span><br><span class="line"> */</span><br><span class="line"> public boolean startsWith(String prefix) &#123;</span><br><span class="line">    return startsWith(prefix, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">  /**</span><br><span class="line">   * 比较两者的内容是否相同，还会检查被比较对象的类型</span><br><span class="line">   */</span><br><span class="line">public boolean equals(Object anObject) &#123;</span><br><span class="line">      if (this == anObject) &#123;</span><br><span class="line">          return true;</span><br><span class="line">      &#125;</span><br><span class="line">      if (anObject instanceof String) &#123;</span><br><span class="line">          String anotherString = (String)anObject;</span><br><span class="line">          int n = value.length;</span><br><span class="line">          if (n == anotherString.value.length) &#123;</span><br><span class="line">              char v1[] = value;</span><br><span class="line">              char v2[] = anotherString.value;</span><br><span class="line">              int i = 0;</span><br><span class="line">              while (n-- != 0) &#123;</span><br><span class="line">                  if (v1[i] != v2[i])</span><br><span class="line">                      return false;</span><br><span class="line">                  i++;</span><br><span class="line">              &#125;</span><br><span class="line">              return true;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return false;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="format"><a href="#format" class="headerlink" title="format"></a>format</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 字符串格式化</span><br><span class="line"> * %s 字符串类型、 %c 字符类型、 %b 布尔类型、%d 整数类型（十进制）、%f 浮点类型.....</span><br><span class="line"> */</span><br><span class="line">public static String format(String format, Object... args) &#123;</span><br><span class="line">    return new Formatter().format(format, args).toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="getBytes"><a href="#getBytes" class="headerlink" title="getBytes"></a>getBytes</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> /**</span><br><span class="line">  * char数组转换成byte 数组</span><br><span class="line">  */</span><br><span class="line">public byte[] getBytes() &#123;</span><br><span class="line">     return StringCoding.encode(value, 0, value.length);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="indexOf、lastIndexOf"><a href="#indexOf、lastIndexOf" class="headerlink" title="indexOf、lastIndexOf"></a>indexOf、lastIndexOf</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> /**</span><br><span class="line">  * 其实有很多重载方法，这是最常用的，返回第一次出现该字符串的下标，不存在返回-1</span><br><span class="line">  */</span><br><span class="line">public int indexOf(String str) &#123;</span><br><span class="line">     return indexOf(str, 0);</span><br><span class="line"> &#125;</span><br><span class="line"> /**</span><br><span class="line">  * 返回最后一次出现该字符串的下标，不存在返回-1</span><br><span class="line">  */</span><br><span class="line"> public int lastIndexOf(String str) &#123;</span><br><span class="line">     return lastIndexOf(str, value.length);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="length"><a href="#length" class="headerlink" title="length"></a>length</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 经常会提问的数组跟String是属性还是方法</span><br><span class="line"> */</span><br><span class="line">public int length() &#123;</span><br><span class="line">    return value.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="matches"><a href="#matches" class="headerlink" title="matches"></a>matches</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 检测字符串是否匹配给定的正则表达式</span><br><span class="line"> */</span><br><span class="line">    public boolean matches(String regex) &#123;</span><br><span class="line">    return Pattern.matches(regex, this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="replaceAll"><a href="#replaceAll" class="headerlink" title="replaceAll"></a>replaceAll</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 替换指定字符串的内容</span><br><span class="line"> */</span><br><span class="line">public String replaceAll(String regex, String replacement) &#123;</span><br><span class="line">    return Pattern.compile(regex).matcher(this).replaceAll(replacement);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="split"><a href="#split" class="headerlink" title="split"></a>split</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 转换成数组，regex为区分标识</span><br><span class="line"> */</span><br><span class="line">public String[] split(String regex) &#123;</span><br><span class="line">    return split(regex, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="substring"><a href="#substring" class="headerlink" title="substring"></a>substring</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 从指定下标开始截取字符串</span><br><span class="line"> * 感觉直接返回substring(beginIndex, value.length - beginIndex)可以吧</span><br><span class="line"> */</span><br><span class="line">    public String substring(int beginIndex) &#123;</span><br><span class="line">    if (beginIndex &lt; 0) &#123;</span><br><span class="line">        throw new StringIndexOutOfBoundsException(beginIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    int subLen = value.length - beginIndex;</span><br><span class="line">    if (subLen &lt; 0) &#123;</span><br><span class="line">        throw new StringIndexOutOfBoundsException(subLen);</span><br><span class="line">    &#125;</span><br><span class="line">    return (beginIndex == 0) ? this : new String(value, beginIndex, subLen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 从指定下标开始截取字符串</span><br><span class="line"> */</span><br><span class="line"> public String substring(int beginIndex, int endIndex) &#123;</span><br><span class="line">    if (beginIndex &lt; 0) &#123;</span><br><span class="line">        throw new StringIndexOutOfBoundsException(beginIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    if (endIndex &gt; value.length) &#123;</span><br><span class="line">        throw new StringIndexOutOfBoundsException(endIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    int subLen = endIndex - beginIndex;</span><br><span class="line">    if (subLen &lt; 0) &#123;</span><br><span class="line">        throw new StringIndexOutOfBoundsException(subLen);</span><br><span class="line">    &#125;</span><br><span class="line">    return ((beginIndex == 0) &amp;&amp; (endIndex == value.length)) ? this</span><br><span class="line">            : new String(value, beginIndex, subLen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="toCharArray"><a href="#toCharArray" class="headerlink" title="toCharArray"></a>toCharArray</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 转换成字符数组</span><br><span class="line"> */</span><br><span class="line">public char[] toCharArray() &#123;</span><br><span class="line">    // Cannot use Arrays.copyOf because of class initialization order issues</span><br><span class="line">    char result[] = new char[value.length];</span><br><span class="line">    System.arraycopy(value, 0, result, 0, value.length);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="toLowerCase、toUpperCase"><a href="#toLowerCase、toUpperCase" class="headerlink" title="toLowerCase、toUpperCase"></a>toLowerCase、toUpperCase</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 全部转换小写</span><br><span class="line"> */</span><br><span class="line"> public String toLowerCase() &#123;</span><br><span class="line">    return toLowerCase(Locale.getDefault());</span><br><span class="line">&#125;</span><br><span class="line"> /**</span><br><span class="line"> * 全部转换大写</span><br><span class="line"> */</span><br><span class="line">public String toUpperCase() &#123;</span><br><span class="line">    return toUpperCase(Locale.getDefault());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="valueOf-NaN"><a href="#valueOf-NaN" class="headerlink" title="valueOf"></a>valueOf</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> /**</span><br><span class="line">  * 转换成z</span><br><span class="line">  */</span><br><span class="line"> public static String valueOf(boolean b) &#123;</span><br><span class="line">     return b ? &quot;true&quot; : &quot;false&quot;;</span><br><span class="line"> &#125;</span><br><span class="line"> public static String valueOf(char data[]) &#123;</span><br><span class="line">     return new String(data);</span><br><span class="line"> &#125;</span><br><span class="line"> public static String valueOf(char c) &#123;</span><br><span class="line">     char data[] = &#123;c&#125;;</span><br><span class="line">     return new String(data, true);</span><br><span class="line"> &#125;</span><br><span class="line"> public static String valueOf(char data[], int offset, int count) &#123;</span><br><span class="line">     return new String(data, offset, count);</span><br><span class="line"> &#125;</span><br><span class="line"> public static String valueOf(double d) &#123;</span><br><span class="line">     return Double.toString(d);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">public static String valueOf(float f) &#123;</span><br><span class="line">     return Float.toString(f);</span><br><span class="line"> &#125;</span><br><span class="line"> public static String valueOf(int i) &#123;</span><br><span class="line">     return Integer.toString(i);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> public static String valueOf(long l) &#123;</span><br><span class="line">     return Long.toString(l);</span><br><span class="line"> &#125;</span><br><span class="line"> public static String valueOf(Object obj) &#123;</span><br><span class="line">     return (obj == null) ? &quot;null&quot; : obj.toString();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;成员变量&quot;&gt;&lt;a href=&quot;#成员变量&quot; class=&quot;headerlink&quot; title=&quot;成员变量&quot;&gt;&lt;/a&gt;成员变量&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * 底层由数组存数据&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;private final char value[];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * hash值&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;private int hash;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;h2 id=&quot;方法&quot;&gt;&lt;a href=&quot;#方法&quot; class=&quot;headerlink&quot; title=&quot;方法&quot;&gt;&lt;/a&gt;方法&lt;/h2&gt;
    
    </summary>
    
    
      <category term="java1.8源码" scheme="https://little8.top/categories/java1-8%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="little_eight" scheme="https://little8.top/tags/little-eight/"/>
    
  </entry>
  
  <entry>
    <title>红黑树</title>
    <link href="https://little8.top/2019/04/22/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    <id>https://little8.top/2019/04/22/红黑树/</id>
    <published>2019-04-22T13:28:15.000Z</published>
    <updated>2019-07-23T13:00:40.951Z</updated>
    
    <content type="html"><![CDATA[<h2 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h2><ul><li>节点都有颜色</li><li>在插入和删除的过程中，要遵循保持这些颜色的不同排列规则</li></ul><h2 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h2><ul><li>每个节点不是红色就是黑色的</li><li>根节点总是黑色的</li><li>如果节点是红色的，则它的子节点必须是黑色的（反之不一定）,(也就是从每个叶子到根的所有路径上不能有两个连续的红色节点)</li><li>从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）<blockquote><p>注意：新插入的节点颜色总是红色的，这是因为插入一个红色节点比插入一个黑色节点违背红-黑规则的可能性更小，原因是插入黑色节点总会改变黑色高度（违背规则4），但是插入红色节点只有一半的机会会违背规则3（因为父节点是黑色的没事，父节点是红色的就违背规则3）。</p></blockquote></li></ul><h2 id="修正"><a href="#修正" class="headerlink" title="修正"></a>修正</h2><p>插入新节点可能会破坏规则，有2种修正方法，变色跟旋转，旋转分左旋转跟右旋转</p><h3 id="左旋转"><a href="#左旋转" class="headerlink" title="左旋转"></a>左旋转</h3><ul><li>子右节点Y上升为父节点</li><li>父节点X降级为子左节点</li><li>把旧子右节点Y的子左节点搞过来当子新左节点子X的子右节点</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  X                                             Y</span><br><span class="line"> / \              以X为轴旋转                  / \</span><br><span class="line">a   Y              -------------&gt;&gt;            X   c</span><br><span class="line">   / \                                       / \</span><br><span class="line">  b   c                                     a   b</span><br></pre></td></tr></table></figure><h3 id="右旋转"><a href="#右旋转" class="headerlink" title="右旋转"></a>右旋转</h3><ul><li>子左节点Y上升为父节点</li><li>父节点X降级为子右节点</li><li>把旧子左节点Y的子右节点搞过来当新子右节点X的子左节点</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    X                                             Y</span><br><span class="line">   / \              以X为轴旋转                  / \</span><br><span class="line">  Y   c              -------------&gt;&gt;            a   X</span><br><span class="line"> / \                                               / \</span><br><span class="line">a   b                                             b   c</span><br></pre></td></tr></table></figure><blockquote><p>多看几次就懂了，明白旋转规则即可</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;特征&quot;&gt;&lt;a href=&quot;#特征&quot; class=&quot;headerlink&quot; title=&quot;特征&quot;&gt;&lt;/a&gt;特征&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;节点都有颜色&lt;/li&gt;&lt;li&gt;在插入和删除的过程中，要遵循保持这些颜色的不同排列规则&lt;/li&gt;&lt;/ul&gt;&lt;h2 id=&quot;规则&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="杂类" scheme="https://little8.top/categories/%E6%9D%82%E7%B1%BB/"/>
    
    
      <category term="little_eight" scheme="https://little8.top/tags/little-eight/"/>
    
  </entry>
  
  <entry>
    <title>java.util.Optional类解析</title>
    <link href="https://little8.top/2019/04/22/java-util-Optional%E7%B1%BB%E8%A7%A3%E6%9E%90/"/>
    <id>https://little8.top/2019/04/22/java-util-Optional类解析/</id>
    <published>2019-04-22T13:28:01.000Z</published>
    <updated>2019-07-23T13:00:40.947Z</updated>
    
    <content type="html"><![CDATA[<h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 从后面的构造方法可以看出，这里new一个value为null的Optional</span><br><span class="line"> */</span><br><span class="line">private static final Optional&lt;?&gt; EMPTY = new Optional&lt;&gt;();</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 值</span><br><span class="line"> */</span><br><span class="line">private final T value;</span><br></pre></td></tr></table></figure><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * value = null</span><br><span class="line"> */</span><br><span class="line">private Optional() &#123;</span><br><span class="line">    this.value = null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 自定义value值，value为null会抛异常</span><br><span class="line"> */</span><br><span class="line">private Optional(T value) &#123;</span><br><span class="line">    this.value = Objects.requireNonNull(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static &lt;T&gt; T requireNonNull(T obj) &#123;</span><br><span class="line">    if (obj == null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="empty"><a href="#empty" class="headerlink" title="empty"></a>empty</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 返回一个空Optional</span><br><span class="line"> */</span><br><span class="line"> public static&lt;T&gt; Optional&lt;T&gt; empty() &#123;</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    Optional&lt;T&gt; t = (Optional&lt;T&gt;) EMPTY;</span><br><span class="line">    return t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 重写equals，为了实现最后2行代码</span><br><span class="line"> */</span><br><span class="line">public boolean equals(Object obj) &#123;</span><br><span class="line">    if (this == obj) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!(obj instanceof Optional)) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Optional&lt;?&gt; other = (Optional&lt;?&gt;) obj;</span><br><span class="line">    return Objects.equals(value, other.value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 如果value不为空并且满足断言条件返回包含该值的Optional，否则返回空Optional。</span><br><span class="line"> * 用法：filter((value) -&gt; xx())</span><br><span class="line"> */</span><br><span class="line">public Optional&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate) &#123;</span><br><span class="line">    Objects.requireNonNull(predicate);</span><br><span class="line">    if (!isPresent())</span><br><span class="line">        return this;</span><br><span class="line">    else</span><br><span class="line">        return predicate.test(value) ? this : empty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="get"><a href="#get" class="headerlink" title="get"></a>get</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 获取value，为null抛异常</span><br><span class="line"> */</span><br><span class="line">public T get() &#123;</span><br><span class="line">    if (value == null) &#123;</span><br><span class="line">        throw new NoSuchElementException(&quot;No value present&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="isPresent"><a href="#isPresent" class="headerlink" title="isPresent"></a>isPresent</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * value是否为null</span><br><span class="line"> */</span><br><span class="line">public boolean isPresent() &#123;</span><br><span class="line">    return value != null;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 跟上面一样，不过是迎合lambda，写法ifPresent((value) -&gt; xx()）</span><br><span class="line"> */</span><br><span class="line">public void ifPresent(Consumer&lt;? super T&gt; consumer) &#123;</span><br><span class="line">    if (value != null)</span><br><span class="line">        consumer.accept(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 如果value不为null，则对其执行调用mapping函数得到返回值。</span><br><span class="line"> * 如果返回值不为null，则创建包含mapping返回值的Optional作为map方法返回值，否则返回空Optional。</span><br><span class="line"> */</span><br><span class="line">public&lt;U&gt; Optional&lt;U&gt; map(Function&lt;? super T, ? extends U&gt; mapper) &#123;</span><br><span class="line">    Objects.requireNonNull(mapper);</span><br><span class="line">    if (!isPresent())</span><br><span class="line">        return empty();</span><br><span class="line">    else &#123;</span><br><span class="line">        return Optional.ofNullable(mapper.apply(value));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="of"><a href="#of" class="headerlink" title="of"></a>of</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  返回一个带value的Optional</span><br><span class="line"> */</span><br><span class="line">public static &lt;T&gt; Optional&lt;T&gt; of(T value) &#123;</span><br><span class="line">    return new Optional&lt;&gt;(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ofNullable"><a href="#ofNullable" class="headerlink" title="ofNullable"></a>ofNullable</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  相当于综合了empty跟of</span><br><span class="line"> */</span><br><span class="line"> public static &lt;T&gt; Optional&lt;T&gt; ofNullable(T value) &#123;</span><br><span class="line">    return value == null ? empty() : of(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="orElse"><a href="#orElse" class="headerlink" title="orElse"></a>orElse</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * value为null就返回other，不为空返回value</span><br><span class="line"> */</span><br><span class="line">public T orElse(T other) &#123;</span><br><span class="line">    return value != null ? value : other;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="orElseGet"><a href="#orElseGet" class="headerlink" title="orElseGet"></a>orElseGet</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * value为null就返回other，不为空返回value</span><br><span class="line"> * 用法 orElseGet(() -&gt; xx())</span><br><span class="line"> */</span><br><span class="line">public T orElseGet(Supplier&lt;? extends T&gt; other) &#123;</span><br><span class="line">    return value != null ? value : other.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="orElseThrow"><a href="#orElseThrow" class="headerlink" title="orElseThrow"></a>orElseThrow</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 如果value不为空返回value，否则抛出supplier接口创建的异常。</span><br><span class="line"> * 用法： orElseThrow(XXException::new)</span><br><span class="line"> */</span><br><span class="line">public &lt;X extends Throwable&gt; T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier) throws X &#123;</span><br><span class="line">    if (value != null) &#123;</span><br><span class="line">        return value;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        throw exceptionSupplier.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;成员变量&quot;&gt;&lt;a href=&quot;#成员变量&quot; class=&quot;headerlink&quot; title=&quot;成员变量&quot;&gt;&lt;/a&gt;成员变量&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * 从后面的构造方法可以看出，这里new一个value为null的Optional&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;private static final Optional&amp;lt;?&amp;gt; EMPTY = new Optional&amp;lt;&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * 值&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;private final T value;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;h2 id=&quot;构造方法&quot;&gt;&lt;a href=&quot;#构造方法&quot; class=&quot;headerlink&quot; title=&quot;构造方法&quot;&gt;&lt;/a&gt;构造方法&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * value = null&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;private Optional() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    this.value = null;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * 自定义value值，value为null会抛异常&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;private Optional(T value) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    this.value = Objects.requireNonNull(value);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public static &amp;lt;T&amp;gt; T requireNonNull(T obj) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (obj == null)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        throw new NullPointerException();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return obj;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="java1.8源码" scheme="https://little8.top/categories/java1-8%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="little_eight" scheme="https://little8.top/tags/little-eight/"/>
    
  </entry>
  
  <entry>
    <title>java.util.LinkedHashSet类解析</title>
    <link href="https://little8.top/2019/04/22/java-util-LinkedHashSet%E7%B1%BB%E8%A7%A3%E6%9E%90/"/>
    <id>https://little8.top/2019/04/22/java-util-LinkedHashSet类解析/</id>
    <published>2019-04-22T13:27:48.000Z</published>
    <updated>2019-07-23T13:00:40.947Z</updated>
    
    <content type="html"><![CDATA[<p>元素有序且不能重复。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * 实现 Cloneable 接口</span><br><span class="line">    *          这个类是 java.lang.Cloneable，前面我们讲解深拷贝和浅拷贝的原理时，</span><br><span class="line">    *          我们介绍了浅拷贝可以通过调用 Object.clone() 方法来实现，</span><br><span class="line">    *          但是调用该方法的对象必须要实现 Cloneable 接口，</span><br><span class="line">    *          否则会抛出 CloneNoSupportException异常。</span><br><span class="line">    * 实现 Serializable 接口</span><br><span class="line">    *          序列化</span><br><span class="line">    */</span><br><span class="line">    public class LinkedHashSet&lt;E&gt; extends HashSet&lt;E&gt; implements Set&lt;E&gt;,</span><br><span class="line">    Cloneable,java.io.Serializable&#123;&#125;</span><br></pre></td></tr></table></figure><p></p><p>看上面似乎LinkedHashSet 是由HashSet实现的集合，其实是LinkedHashMap实现的。从下面的构造方法即可看出。</p><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> /**</span><br><span class="line">  * 依然是提供三种构造方法，实现都是super方法，下面我们看看是怎么实现的 </span><br><span class="line">  */</span><br><span class="line">public LinkedHashSet() &#123;</span><br><span class="line">     super(16, .75f, true);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">public LinkedHashSet(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">     super(Math.max(2*c.size(), 11), .75f, true);</span><br><span class="line">     addAll(c);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> public LinkedHashSet(int initialCapacity) &#123;</span><br><span class="line">     super(initialCapacity, .75f, true);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> /**</span><br><span class="line">  * 之前还疑惑这里dummy为啥没用，原来是为了用到这里做区分的</span><br><span class="line">  * 明显看出看出LinkedHashSet 是由LinkedHashMap实现的集合</span><br><span class="line">  */</span><br><span class="line"> HashSet(int initialCapacity, float loadFactor, boolean dummy) &#123;</span><br><span class="line">     map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="其他方法基本都可以看HashSet了"><a href="#其他方法基本都可以看HashSet了" class="headerlink" title="其他方法基本都可以看HashSet了"></a>其他方法基本都可以看HashSet了</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;元素有序且不能重复。&lt;br&gt;&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;
      
    
    </summary>
    
    
      <category term="java1.8源码" scheme="https://little8.top/categories/java1-8%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="little_eight" scheme="https://little8.top/tags/little-eight/"/>
    
  </entry>
  
  <entry>
    <title>java.util.LinkedHashMap类解析</title>
    <link href="https://little8.top/2019/04/22/java-util-LinkedHashMap%E7%B1%BB%E8%A7%A3%E6%9E%90/"/>
    <id>https://little8.top/2019/04/22/java-util-LinkedHashMap类解析/</id>
    <published>2019-04-22T13:27:25.000Z</published>
    <updated>2019-07-23T13:00:40.947Z</updated>
    
    <content type="html"><![CDATA[<p>LinkedHashMap 是基于 HashMap实现的一种集合，有序，它单独维护了一个具有所有数据的双向链表，该链表保证了元素迭代的顺序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 继承HashMap，实现Map</span><br><span class="line"> */</span><br><span class="line">public class LinkedHashMap&lt;K,V&gt; extends HashMap&lt;K,V&gt; implements Map&lt;K,V&gt;&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * 双向链表头</span><br><span class="line">    */</span><br><span class="line">   transient LinkedHashMap.Entry&lt;K,V&gt; head;</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * 双向链表尾</span><br><span class="line">    */</span><br><span class="line">   transient LinkedHashMap.Entry&lt;K,V&gt; tail;</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * 决定迭代排序方法：true是根据访问顺序来排序，false是根据插入顺序来排序</span><br><span class="line">    */</span><br><span class="line">   final boolean accessOrder;</span><br></pre></td></tr></table></figure><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>4种构造方法，都用HaspMap的实现方法。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public LinkedHashMap() &#123;</span><br><span class="line">    super();</span><br><span class="line">    accessOrder = false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public LinkedHashMap(int initialCapacity) &#123;</span><br><span class="line">    super(initialCapacity);</span><br><span class="line">    accessOrder = false;</span><br><span class="line">&#125;</span><br><span class="line">public LinkedHashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">    super(initialCapacity, loadFactor);</span><br><span class="line">    accessOrder = false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public LinkedHashMap(int initialCapacity,</span><br><span class="line">                     float loadFactor,</span><br><span class="line">                     boolean accessOrder) &#123;</span><br><span class="line">    super(initialCapacity, loadFactor);</span><br><span class="line">    this.accessOrder = accessOrder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><a id="more"></a><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="afterNodeAccess"><a href="#afterNodeAccess" class="headerlink" title="afterNodeAccess"></a>afterNodeAccess</h3><blockquote><p>这个方法除了在LinkedHashMap的get方法用到，还在HashMap的put、replace用到，因为这些方法是直接实现HashMap的，下面的afterNodeInsertion、afterNodeRemoval同理。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"> /**</span><br><span class="line">  *  把指定节点放到双向链表的尾部</span><br><span class="line">  */</span><br><span class="line">void afterNodeAccess(Node&lt;K,V&gt; e) &#123; // move node to last</span><br><span class="line">     LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">     // 当accessOrder为true，指定节点不是链表尾才有效</span><br><span class="line">     if (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class="line">         // 把p当做指定节点，并注明它的前后节点 b，a</span><br><span class="line">         LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">             (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">         // 清除p的后节点指向</span><br><span class="line">         p.after = null;</span><br><span class="line">         /**</span><br><span class="line">          * 下面会分别对a跟b判空，是为了把p提取出来同时，成功接上断掉的节点</span><br><span class="line">          */</span><br><span class="line">         // 如果b是空的，说明p是链表头，把head等于p的后节点</span><br><span class="line">         if (b == null)</span><br><span class="line">             head = a;</span><br><span class="line">         // 如果b不为空，就让p的前节点的后节点指向p的后节点</span><br><span class="line">         else</span><br><span class="line">             b.after = a;</span><br><span class="line">         // 如果a不为空，就让p的后节点的前节点指向p的前节点</span><br><span class="line">         if (a != null)</span><br><span class="line">             a.before = b;</span><br><span class="line">         /**</span><br><span class="line">          * 本人对下面注释可能有问题，理解不到位吧</span><br><span class="line">          */</span><br><span class="line">         // 如果a是空的，说明链表尾tail为null（不然就解释不通p不等于tail了），last等于p的前节点</span><br><span class="line">         else</span><br><span class="line">             last = b;</span><br><span class="line">         // last为空 说明链表条还没有链表，而且p的前节点为null，链表头设置为p</span><br><span class="line">         if (last == null)</span><br><span class="line">             head = p;</span><br><span class="line">         // last不为空，就把last跟p连到一起</span><br><span class="line">         else &#123;</span><br><span class="line">             p.before = last;</span><br><span class="line">             last.after = p;</span><br><span class="line">         &#125;</span><br><span class="line">         // 最后把p设为链表尾</span><br><span class="line">         tail = p;</span><br><span class="line">         ++modCount;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="afterNodeInsertion"><a href="#afterNodeInsertion" class="headerlink" title="afterNodeInsertion"></a>afterNodeInsertion</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 移除链表头</span><br><span class="line"> */</span><br><span class="line">void afterNodeInsertion(boolean evict) &#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line">    // 当evict = true，并且 头节点不为null，removeEldestEntry(first)为true，才进行移除</span><br><span class="line">    if (evict &amp;&amp; (first = head) != null &amp;&amp; removeEldestEntry(first)) &#123;</span><br><span class="line">        K key = first.key;</span><br><span class="line">        // 用到HashMap的，里面有个方法afterNodeRemoval，下面讲</span><br><span class="line">        removeNode(hash(key), key, null, false, true);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 再看看这个方法，其实是返回false的，所以要想实现移除链表头，必须得继承LinkedHashMap然后重写这个方法</span><br><span class="line"> */</span><br><span class="line">protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest) &#123;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="afterNodeRemoval"><a href="#afterNodeRemoval" class="headerlink" title="afterNodeRemoval"></a>afterNodeRemoval</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  /**</span><br><span class="line">   * 移除了e后，保证链表条不断掉</span><br><span class="line">   */</span><br><span class="line">void afterNodeRemoval(Node&lt;K,V&gt; e) &#123;</span><br><span class="line">      LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">          (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">      p.before = p.after = null;</span><br><span class="line">      if (b == null)</span><br><span class="line">          head = a;</span><br><span class="line">      else</span><br><span class="line">          b.after = a;</span><br><span class="line">      if (a == null)</span><br><span class="line">          tail = b;</span><br><span class="line">      else</span><br><span class="line">          a.before = b;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="containsValue"><a href="#containsValue" class="headerlink" title="containsValue"></a>containsValue</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 是否包含此值</span><br><span class="line"> */</span><br><span class="line">public boolean containsValue(Object value) &#123;</span><br><span class="line">    // 很明显是遍历链表条了</span><br><span class="line">    for (LinkedHashMap.Entry&lt;K,V&gt; e = head; e != null; e = e.after) &#123;</span><br><span class="line">        V v = e.value;</span><br><span class="line">        if (v == value || (value != null &amp;&amp; value.equals(v)))</span><br><span class="line">            return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="get、getOrDefault"><a href="#get、getOrDefault" class="headerlink" title="get、getOrDefault"></a>get、getOrDefault</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> /**</span><br><span class="line">  * 根据key获取对应值</span><br><span class="line">  */</span><br><span class="line"> public V get(Object key) &#123;</span><br><span class="line">     Node&lt;K,V&gt; e;</span><br><span class="line">     if ((e = getNode(hash(key), key)) == null)</span><br><span class="line">         return null;</span><br><span class="line">     // 如果true，还会把这个链表放到尾部</span><br><span class="line">     if (accessOrder)</span><br><span class="line">         afterNodeAccess(e);</span><br><span class="line">     return e.value;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> /**</span><br><span class="line">  * 还提供一个不存在就返回默认值</span><br><span class="line">  */</span><br><span class="line"> public V getOrDefault(Object key, V defaultValue) &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    if ((e = getNode(hash(key), key)) == null)</span><br><span class="line">        return defaultValue;</span><br><span class="line">    if (accessOrder)</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">    return e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="keySet"><a href="#keySet" class="headerlink" title="keySet"></a>keySet</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 获取key集合，有兴趣可以自己看LinkedKeySet</span><br><span class="line"> */</span><br><span class="line">public Set&lt;K&gt; keySet() &#123;</span><br><span class="line">    Set&lt;K&gt; ks = keySet;</span><br><span class="line">    if (ks == null) &#123;</span><br><span class="line">        ks = new LinkedKeySet();</span><br><span class="line">        keySet = ks;</span><br><span class="line">    &#125;</span><br><span class="line">    return ks;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final class LinkedKeySet extends AbstractSet&lt;K&gt; &#123;</span><br><span class="line">    public final int size()                 &#123; return size; &#125;</span><br><span class="line">    public final void clear()               &#123; LinkedHashMap.this.clear(); &#125;</span><br><span class="line">    public final Iterator&lt;K&gt; iterator() &#123;</span><br><span class="line">        return new LinkedKeyIterator();</span><br><span class="line">    &#125;</span><br><span class="line">    public final boolean contains(Object o) &#123; return containsKey(o); &#125;</span><br><span class="line">    public final boolean remove(Object key) &#123;</span><br><span class="line">        return removeNode(hash(key), key, null, false, true) != null;</span><br><span class="line">    &#125;</span><br><span class="line">    public final Spliterator&lt;K&gt; spliterator()  &#123;</span><br><span class="line">        return Spliterators.spliterator(this, Spliterator.SIZED |</span><br><span class="line">                                        Spliterator.ORDERED |</span><br><span class="line">                                        Spliterator.DISTINCT);</span><br><span class="line">    &#125;</span><br><span class="line">    public final void forEach(Consumer&lt;? super K&gt; action) &#123;</span><br><span class="line">        if (action == null)</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        int mc = modCount;</span><br><span class="line">        for (LinkedHashMap.Entry&lt;K,V&gt; e = head; e != null; e = e.after)</span><br><span class="line">            action.accept(e.key);</span><br><span class="line">        if (modCount != mc)</span><br><span class="line">            throw new ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="newNode、newTreeNode"><a href="#newNode、newTreeNode" class="headerlink" title="newNode、newTreeNode"></a>newNode、newTreeNode</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 新建链表</span><br><span class="line"> */</span><br><span class="line">Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; e) &#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">        new LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e);</span><br><span class="line">    linkNodeLast(p);</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 新建红黑树节点</span><br><span class="line"> */ </span><br><span class="line">TreeNode&lt;K,V&gt; newTreeNode(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; p = new TreeNode&lt;K,V&gt;(hash, key, value, next);</span><br><span class="line">    linkNodeLast(p);</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 上面都有用到，把p接到旧链表尾后面</span><br><span class="line"> */</span><br><span class="line">private void linkNodeLast(LinkedHashMap.Entry&lt;K,V&gt; p) &#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last = tail;</span><br><span class="line">    tail = p;</span><br><span class="line">    if (last == null)</span><br><span class="line">        head = p;</span><br><span class="line">    else &#123;</span><br><span class="line">        p.before = last;</span><br><span class="line">        last.after = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="values"><a href="#values" class="headerlink" title="values"></a>values</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 获取value集合</span><br><span class="line"> */</span><br><span class="line">public Collection&lt;V&gt; values() &#123;</span><br><span class="line">    Collection&lt;V&gt; vs = values;</span><br><span class="line">    if (vs == null) &#123;</span><br><span class="line">        vs = new LinkedValues();</span><br><span class="line">        values = vs;</span><br><span class="line">    &#125;</span><br><span class="line">    return vs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final class LinkedValues extends AbstractCollection&lt;V&gt; &#123;</span><br><span class="line">    public final int size()                 &#123; return size; &#125;</span><br><span class="line">    public final void clear()               &#123; LinkedHashMap.this.clear(); &#125;</span><br><span class="line">    public final Iterator&lt;V&gt; iterator() &#123;</span><br><span class="line">        return new LinkedValueIterator();</span><br><span class="line">    &#125;</span><br><span class="line">    public final boolean contains(Object o) &#123; return containsValue(o); &#125;</span><br><span class="line">    public final Spliterator&lt;V&gt; spliterator() &#123;</span><br><span class="line">        return Spliterators.spliterator(this, Spliterator.SIZED |</span><br><span class="line">                                        Spliterator.ORDERED);</span><br><span class="line">    &#125;</span><br><span class="line">    public final void forEach(Consumer&lt;? super V&gt; action) &#123;</span><br><span class="line">        if (action == null)</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        int mc = modCount;</span><br><span class="line">        for (LinkedHashMap.Entry&lt;K,V&gt; e = head; e != null; e = e.after)</span><br><span class="line">            action.accept(e.value);</span><br><span class="line">        if (modCount != mc)</span><br><span class="line">            throw new ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LinkedHashMap 是基于 HashMap实现的一种集合，有序，它单独维护了一个具有所有数据的双向链表，该链表保证了元素迭代的顺序。&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * 继承HashMap，实现Map&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public class LinkedHashMap&amp;lt;K,V&amp;gt; extends HashMap&amp;lt;K,V&amp;gt; implements Map&amp;lt;K,V&amp;gt;&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;h2 id=&quot;成员变量&quot;&gt;&lt;a href=&quot;#成员变量&quot; class=&quot;headerlink&quot; title=&quot;成员变量&quot;&gt;&lt;/a&gt;成员变量&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    * 双向链表头&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   transient LinkedHashMap.Entry&amp;lt;K,V&amp;gt; head;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   /**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    * 双向链表尾&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   transient LinkedHashMap.Entry&amp;lt;K,V&amp;gt; tail;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   /**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    * 决定迭代排序方法：true是根据访问顺序来排序，false是根据插入顺序来排序&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   final boolean accessOrder;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;h2 id=&quot;构造函数&quot;&gt;&lt;a href=&quot;#构造函数&quot; class=&quot;headerlink&quot; title=&quot;构造函数&quot;&gt;&lt;/a&gt;构造函数&lt;/h2&gt;&lt;p&gt;4种构造方法，都用HaspMap的实现方法。&lt;br&gt;&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public LinkedHashMap() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    super();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    accessOrder = false;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public LinkedHashMap(int initialCapacity) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    super(initialCapacity);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    accessOrder = false;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public LinkedHashMap(int initialCapacity, float loadFactor) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    super(initialCapacity, loadFactor);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    accessOrder = false;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public LinkedHashMap(int initialCapacity,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                     float loadFactor,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                     boolean accessOrder) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    super(initialCapacity, loadFactor);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    this.accessOrder = accessOrder;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="java1.8源码" scheme="https://little8.top/categories/java1-8%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="little_eight" scheme="https://little8.top/tags/little-eight/"/>
    
  </entry>
  
  <entry>
    <title>java.util.HashSet类解析</title>
    <link href="https://little8.top/2019/04/16/java-util-HashSet%E7%B1%BB%E8%A7%A3%E6%9E%90/"/>
    <id>https://little8.top/2019/04/16/java-util-HashSet类解析/</id>
    <published>2019-04-16T13:23:50.000Z</published>
    <updated>2019-07-23T13:00:40.947Z</updated>
    
    <content type="html"><![CDATA[<p>HashSet 是一个由 HashMap 实现的集合，元素无序且不能重复。<br>其方法基本都是HashMap的方法。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * 继承 AbstractSet</span><br><span class="line">    *          AbstractSet也是实现了Set接口的，跟HashMap一个毛病，脱裤子放屁....</span><br><span class="line">    * 实现 Set 接口</span><br><span class="line">    *          这个接口是 Set 类集合的上层接口，定义了实现该接口的类都必须要实现的一组方法</span><br><span class="line">    * 实现 Cloneable 接口</span><br><span class="line">    *          这个类是 java.lang.Cloneable，前面我们讲解深拷贝和浅拷贝的原理时，</span><br><span class="line">    *          我们介绍了浅拷贝可以通过调用 Object.clone() 方法来实现，</span><br><span class="line">    *          但是调用该方法的对象必须要实现 Cloneable 接口，</span><br><span class="line">    *          否则会抛出 CloneNoSupportException异常。</span><br><span class="line">    * 实现 Serializable 接口</span><br><span class="line">    *          序列化</span><br><span class="line">    */</span><br><span class="line">   public class HashSet&lt;E&gt; extends AbstractSet&lt;E&gt;</span><br><span class="line">   implements Set&lt;E&gt;, Cloneable, java.io.Serializable&#123;&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 就是一个HashMap，说明靠这个来存储数据了</span><br><span class="line"> */</span><br><span class="line">  private transient HashMap&lt;E,Object&gt; map;</span><br><span class="line">/**</span><br><span class="line"> * 向HashSet中添加数据，数据在上面的 map 结构是作为 key 存在的，而value统一都是 PRESENT</span><br><span class="line"> */</span><br><span class="line">private static final Object PRESENT = new Object();</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 就是new一个HashMap</span><br><span class="line"> */</span><br><span class="line">public HashSet() &#123;</span><br><span class="line">    map = new HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 指定初始容量HashMap </span><br><span class="line"> */</span><br><span class="line">public HashSet(int initialCapacity) &#123;</span><br><span class="line">    map = new HashMap&lt;&gt;(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 指定初始容量和加载因子HashMap </span><br><span class="line"> */</span><br><span class="line">public HashSet(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">    map = new HashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 这个dummy都没用到,兼容旧版本用的吧。</span><br><span class="line"> */</span><br><span class="line">HashSet(int initialCapacity, float loadFactor, boolean dummy) &#123;</span><br><span class="line">    map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 构造包含指定集合中的元素</span><br><span class="line"> */</span><br><span class="line">public HashSet(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">    map = new HashMap&lt;&gt;(Math.max((int) (c.size()/.75f) + 1, 16));</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="add"><a href="#add" class="headerlink" title="add"></a>add</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 往map里put值</span><br><span class="line"> */</span><br><span class="line"> public boolean add(E e) &#123;</span><br><span class="line">    return map.put(e, PRESENT)==null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 清除map</span><br><span class="line"> */</span><br><span class="line">public void clear() &#123;</span><br><span class="line">    map.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 克隆</span><br><span class="line"> */</span><br><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">public Object clone() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        HashSet&lt;E&gt; newSet = (HashSet&lt;E&gt;) super.clone();</span><br><span class="line">        newSet.map = (HashMap&lt;E, Object&gt;) map.clone();</span><br><span class="line">        return newSet;</span><br><span class="line">    &#125; catch (CloneNotSupportedException e) &#123;</span><br><span class="line">        throw new InternalError(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="contains"><a href="#contains" class="headerlink" title="contains"></a>contains</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 是否包含此值，也就是判断是否包含此key</span><br><span class="line"> */</span><br><span class="line">public boolean contains(Object o) &#123;</span><br><span class="line">    return map.containsKey(o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="isEmpty"><a href="#isEmpty" class="headerlink" title="isEmpty"></a>isEmpty</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 是否为空</span><br><span class="line"> */</span><br><span class="line">public boolean isEmpty() &#123;</span><br><span class="line">    return map.isEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="iterator"><a href="#iterator" class="headerlink" title="iterator"></a>iterator</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 迭代类</span><br><span class="line"> */</span><br><span class="line">public Iterator&lt;E&gt; iterator() &#123;</span><br><span class="line">    return map.keySet().iterator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 移除某值</span><br><span class="line"> */</span><br><span class="line">public boolean remove(Object o) &#123;</span><br><span class="line">    return map.remove(o)==PRESENT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HashSet 是一个由 HashMap 实现的集合，元素无序且不能重复。&lt;br&gt;其方法基本都是HashMap的方法。&lt;br&gt;&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    * 继承 AbstractSet&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    *          AbstractSet也是实现了Set接口的，跟HashMap一个毛病，脱裤子放屁....&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    * 实现 Set 接口&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    *          这个接口是 Set 类集合的上层接口，定义了实现该接口的类都必须要实现的一组方法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    * 实现 Cloneable 接口&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    *          这个类是 java.lang.Cloneable，前面我们讲解深拷贝和浅拷贝的原理时，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    *          我们介绍了浅拷贝可以通过调用 Object.clone() 方法来实现，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    *          但是调用该方法的对象必须要实现 Cloneable 接口，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    *          否则会抛出 CloneNoSupportException异常。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    * 实现 Serializable 接口&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    *          序列化&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   public class HashSet&amp;lt;E&amp;gt; extends AbstractSet&amp;lt;E&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   implements Set&amp;lt;E&amp;gt;, Cloneable, java.io.Serializable&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 id=&quot;成员变量&quot;&gt;&lt;a href=&quot;#成员变量&quot; class=&quot;headerlink&quot; title=&quot;成员变量&quot;&gt;&lt;/a&gt;成员变量&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * 就是一个HashMap，说明靠这个来存储数据了&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  private transient HashMap&amp;lt;E,Object&amp;gt; map;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * 向HashSet中添加数据，数据在上面的 map 结构是作为 key 存在的，而value统一都是 PRESENT&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;private static final Object PRESENT = new Object();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="java1.8源码" scheme="https://little8.top/categories/java1-8%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="little_eight" scheme="https://little8.top/tags/little-eight/"/>
    
  </entry>
  
  <entry>
    <title>java.util.HashMap类解析</title>
    <link href="https://little8.top/2019/04/16/java-util-HashMap%E7%B1%BB%E8%A7%A3%E6%9E%90/"/>
    <id>https://little8.top/2019/04/16/java-util-HashMap类解析/</id>
    <published>2019-04-16T13:22:49.000Z</published>
    <updated>2019-07-23T13:00:40.947Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h2><p>Hash表也称为散列表，也有直接译作哈希表，Hash表是一种根据关键字值（key-value）而直接进行访问的数据结构。也就是说它通过把关键码值映射到表中的一个位置来访问记录，以此来加快查找的速度。在链表、数组等数据结构中，查找某个关键字，通常要遍历整个数据结构，也就是O(N)的时间级，但是对于哈希表来说，只是O(1)的时间级。（更多知识自行百度Google）</p><p>HashMap是一个利用哈希表原理来存储元素的无序不安全键值都可为空的集合。遇到冲突时，HashMap 是采用的链地址法来解决，在 JDK1.7 中，HashMap 是由 数组+链表构成的。但是在JDK1.8中，HashMap是由数组+链表+红黑树构成，新增了红黑树作为底层数据结构，结构变得复杂了，但是效率也变的更高效。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 继承 AbstractMap</span><br><span class="line"> *          AbstractMap也是实现了Map类的，既继承AbstractMap又实现Map，脱裤子放屁....</span><br><span class="line"> * 实现 Map 接口</span><br><span class="line"> *          这个接口是 Map 类集合的上层接口，定义了实现该接口的类都必须要实现的一组方法</span><br><span class="line"> * 实现 Cloneable 接口</span><br><span class="line"> *          这个类是 java.lang.Cloneable，前面我们讲解深拷贝和浅拷贝的原理时，</span><br><span class="line"> *          我们介绍了浅拷贝可以通过调用 Object.clone() 方法来实现，</span><br><span class="line"> *          但是调用该方法的对象必须要实现 Cloneable 接口，</span><br><span class="line"> *          否则会抛出 CloneNoSupportException异常。</span><br><span class="line"> * 实现 Serializable 接口</span><br><span class="line"> *          序列化</span><br><span class="line"> */</span><br><span class="line">public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;</span><br><span class="line">    implements Map&lt;K,V&gt;, Cloneable, Serializable &#123;&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * 初始容量为16，容量都必须是偶数</span><br><span class="line">    */</span><br><span class="line">   static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * 集合的最大容量，如果通过带参构造指定的最大容量超过此数，默认还是使用此数</span><br><span class="line">    */</span><br><span class="line">   static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * 默认的填充因子</span><br><span class="line">    */</span><br><span class="line">   static final float DEFAULT_LOAD_FACTOR = 0.75f;</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * 当桶(bucket)上的结点数大于这个值时会转成红黑树</span><br><span class="line">    */</span><br><span class="line">   static final int TREEIFY_THRESHOLD = 8;</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * 当桶(bucket)上的节点数小于这个值时会转成链表</span><br><span class="line">    */</span><br><span class="line">   static final int UNTREEIFY_THRESHOLD = 6;</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * 当集合中的容量大于这个值时，表中的桶才能进行树形化 ，否则桶内元素太多时会扩容，</span><br><span class="line">    * 而不是树形化 为了避免进行扩容、树形化选择的冲突，这个值不能小于 4 * TREEIFY_THRESHOLD</span><br><span class="line">    */</span><br><span class="line">   static final int MIN_TREEIFY_CAPACITY = 64;</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * 存链表的数组，初始化使用，长度总是 2的幂</span><br><span class="line">    */</span><br><span class="line">   transient Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * 保存缓存的entrySet（）</span><br><span class="line">    */</span><br><span class="line">   transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * 此映射中包含的键值映射的数量。（集合存储键值对的数量）</span><br><span class="line">    */</span><br><span class="line">   transient int size;</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * 跟前面ArrayList和LinkedList集合中的字段modCount一样，记录集合被修改的次数</span><br><span class="line">    * 主要用于迭代器中的快速失败</span><br><span class="line">    */</span><br><span class="line">   transient int modCount;</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * 调整大小的下一个大小值（容量*加载因子）,相当于阈值。计算公式：capacity * loadFactor。</span><br><span class="line">    * 这个值是当前已占用数组长度的最大值。过这个数目就重新resize(扩容)，</span><br><span class="line">    * 扩容后的 HashMap 容量是之前容量的两倍</span><br><span class="line">    */</span><br><span class="line">   int threshold;</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * 散列表的加载因子，是用来衡量HashMap满的程度，</span><br><span class="line">    * 计算HashMap的实时装载因子的方法为：size/capacity，而不是占用桶的数量去除以capacity。</span><br><span class="line">    * capacity 是桶的数量，也就是 table 的长度length。</span><br><span class="line">    */</span><br><span class="line">   final float loadFactor;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 链表的类</span><br><span class="line"> */</span><br><span class="line">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    // hash值</span><br><span class="line">    final int hash;</span><br><span class="line">    final K key;</span><br><span class="line">    V value;</span><br><span class="line">    // 下一个链表</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        this.hash = hash;</span><br><span class="line">        this.key = key;</span><br><span class="line">        this.value = value;</span><br><span class="line">        this.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final K getKey()        &#123; return key; &#125;</span><br><span class="line">    public final V getValue()      &#123; return value; &#125;</span><br><span class="line">    public final String toString() &#123; return key + &quot;=&quot; + value; &#125;</span><br><span class="line"></span><br><span class="line">    public final int hashCode() &#123;</span><br><span class="line">        return Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final V setValue(V newValue) &#123;</span><br><span class="line">        V oldValue = value;</span><br><span class="line">        value = newValue;</span><br><span class="line">        return oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final boolean equals(Object o) &#123;</span><br><span class="line">        if (o == this)</span><br><span class="line">            return true;</span><br><span class="line">        if (o instanceof Map.Entry) &#123;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">            if (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                Objects.equals(value, e.getValue()))</span><br><span class="line">                return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 默认构造函数，初始化加载因子loadFactor = 0.75</span><br><span class="line"> */</span><br><span class="line">public HashMap() &#123;</span><br><span class="line">    this.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 指定容量，实现看下一个方法</span><br><span class="line"> */</span><br><span class="line">public HashMap(int initialCapacity) &#123;</span><br><span class="line">    this(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 指定Map集合构造函数。</span><br><span class="line"> */</span><br><span class="line">public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123;</span><br><span class="line">    this.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    // 就是把这个集合put进去，后面再详细说</span><br><span class="line">    putMapEntries(m, false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 指定容量和加载因子</span><br><span class="line"> */</span><br><span class="line">public HashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">    if (initialCapacity &lt; 0)</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    // 最大容量只会设置为MAXIMUM_CAPACITY                                       </span><br><span class="line">    if (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    this.loadFactor = loadFactor;</span><br><span class="line">    // 调整下一个扩容值</span><br><span class="line">    this.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 返回给定目标容量的二次幂，</span><br><span class="line">     * | 位或运算</span><br><span class="line">     */</span><br><span class="line">  static final int tableSizeFor(int cap) &#123;</span><br><span class="line">    int n = cap - 1;</span><br><span class="line">    // 也就是 n = n | n &gt;&gt;&gt; xx</span><br><span class="line">    n |= n &gt;&gt;&gt; 1;</span><br><span class="line">    n |= n &gt;&gt;&gt; 2;</span><br><span class="line">    n |= n &gt;&gt;&gt; 4;</span><br><span class="line">    n |= n &gt;&gt;&gt; 8;</span><br><span class="line">    n |= n &gt;&gt;&gt; 16;</span><br><span class="line">    return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>位或运算 （|）<br>0|0=0； 0|1=1； 1|0=1； 1|1=1<br>即：两位只要有一个为1，其值为1，其它都为0。<br>扩展：异或运算符（^），后面计算hash值用到<br>0^0=0； 0^1=1； 1^0=1； 1^1=0；<br>即：参加运算的两个对象，如果两个相应位为“异”（值不同），则该位结果为1，否则为0。<br>扩展：位与运算（&amp;），后面的取模运算用到<br>0&amp;0=0; 0&amp;1=0; 1&amp;0=0; 1&amp;1=1<br>即：两位同时为1，结果才为1，否则为0。</p></blockquote><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="capacity"><a href="#capacity" class="headerlink" title="capacity"></a>capacity</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  返回当前容量</span><br><span class="line"> */</span><br><span class="line">final int capacity() &#123;</span><br><span class="line">    return (table != null) ? table.length :</span><br><span class="line">        (threshold &gt; 0) ? threshold :</span><br><span class="line">        DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 把所有链表都设置为null，清空hashMap</span><br><span class="line"> */</span><br><span class="line">public void clear() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab;</span><br><span class="line">    modCount++;</span><br><span class="line">    if ((tab = table) != null &amp;&amp; size &gt; 0) &#123;</span><br><span class="line">        size = 0;</span><br><span class="line">        for (int i = 0; i &lt; tab.length; ++i)</span><br><span class="line">            tab[i] = null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 浅拷贝</span><br><span class="line"> */</span><br><span class="line">    public Object clone() &#123;</span><br><span class="line">    HashMap&lt;K,V&gt; result;</span><br><span class="line">    try &#123;</span><br><span class="line">        result = (HashMap&lt;K,V&gt;)super.clone();</span><br><span class="line">    &#125; catch (CloneNotSupportedException e) &#123;</span><br><span class="line">        // this shouldn&apos;t happen, since we are Cloneable</span><br><span class="line">        throw new InternalError(e);</span><br><span class="line">    &#125;</span><br><span class="line">    // 把关键成员变量都设置成null</span><br><span class="line">    result.reinitialize();</span><br><span class="line">    result.putMapEntries(this, false);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="containsKey"><a href="#containsKey" class="headerlink" title="containsKey"></a>containsKey</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 判断是否包含此key</span><br><span class="line"> */</span><br><span class="line">public boolean containsKey(Object key) &#123;</span><br><span class="line">    // 下面再详细说getNode</span><br><span class="line">    return getNode(hash(key), key) != null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="entrySet"><a href="#entrySet" class="headerlink" title="entrySet"></a>entrySet</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 返回this.entrySet，没有就new一个</span><br><span class="line"> */</span><br><span class="line">public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;</span><br><span class="line">    Set&lt;Map.Entry&lt;K,V&gt;&gt; es;</span><br><span class="line">    return (es = entrySet) == null ? (entrySet = new EntrySet()) : es;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 内部EntrySet类</span><br><span class="line"> */</span><br><span class="line">final class  extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; &#123;</span><br><span class="line">    public final int size()                 &#123; return size; &#125;</span><br><span class="line">    public final void clear()               &#123; HashMap.this.clear(); &#125;</span><br><span class="line">    public final Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123;</span><br><span class="line">        return new EntryIterator();</span><br><span class="line">    &#125;</span><br><span class="line">    public final boolean contains(Object o) &#123;</span><br><span class="line">        if (!(o instanceof Map.Entry))</span><br><span class="line">            return false;</span><br><span class="line">        Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;</span><br><span class="line">        Object key = e.getKey();</span><br><span class="line">        Node&lt;K,V&gt; candidate = getNode(hash(key), key);</span><br><span class="line">        return candidate != null &amp;&amp; candidate.equals(e);</span><br><span class="line">    &#125;</span><br><span class="line">    public final boolean remove(Object o) &#123;</span><br><span class="line">        if (o instanceof Map.Entry) &#123;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;</span><br><span class="line">            Object key = e.getKey();</span><br><span class="line">            Object value = e.getValue();</span><br><span class="line">            return removeNode(hash(key), key, value, true, true) != null;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    public final Spliterator&lt;Map.Entry&lt;K,V&gt;&gt; spliterator() &#123;</span><br><span class="line">        return new EntrySpliterator&lt;&gt;(HashMap.this, 0, -1, 0, 0);</span><br><span class="line">    &#125;</span><br><span class="line">    public final void forEach(Consumer&lt;? super Map.Entry&lt;K,V&gt;&gt; action) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab;</span><br><span class="line">        if (action == null)</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        if (size &gt; 0 &amp;&amp; (tab = table) != null) &#123;</span><br><span class="line">            int mc = modCount;</span><br><span class="line">            for (int i = 0; i &lt; tab.length; ++i) &#123;</span><br><span class="line">                for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next)</span><br><span class="line">                    action.accept(e);</span><br><span class="line">            &#125;</span><br><span class="line">            if (modCount != mc)</span><br><span class="line">                throw new ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="get、getNode、getOrDefault"><a href="#get、getNode、getOrDefault" class="headerlink" title="get、getNode、getOrDefault"></a>get、getNode、getOrDefault</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 根据key返回value</span><br><span class="line"> */</span><br><span class="line">public V get(Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    return (e = getNode(hash(key), key)) == null ? null : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 获取对应链表</span><br><span class="line"> */</span><br><span class="line">final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;</span><br><span class="line">    // 数组不为空，且hash对应的链表头也不为空</span><br><span class="line">    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">        (first = tab[(n - 1) &amp; hash]) != null) &#123;</span><br><span class="line">        // 校验是否是链表头的，不是的话，就next遍历下去找到对应的链表</span><br><span class="line">        if (first.hash == hash &amp;&amp; // always check first node</span><br><span class="line">            ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">            return first;</span><br><span class="line">        if ((e = first.next) != null) &#123;</span><br><span class="line">            // 如果是红黑树，就去getTreeNode，红黑树的部分看最后面TreeNode类解析</span><br><span class="line">            if (first instanceof TreeNode)</span><br><span class="line">                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            do &#123;</span><br><span class="line">                if (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                    return e;</span><br><span class="line">            &#125; while ((e = e.next) != null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 如果取到的链表为null，则返回设定的defaultValue，否则就返回链表的value</span><br><span class="line"> */</span><br><span class="line">public V getOrDefault(Object key, V defaultValue，) &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    return (e = getNode(hash(key), key)) == null ? defaultValue : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>取模运算 (n - 1) &amp; hash ，在计算机中 &amp; 的效率比 % 高很多，所以采用&amp;<br>且有这么一条结论，当 lenth = 2n 时，X % length = X &amp; (length - 1)<br>具体可以去看下这篇博客分析<a href="https://blog.csdn.net/ysvae/article/details/81090894" target="_blank" rel="noopener">https://blog.csdn.net/ysvae/article/details/81090894</a></p></blockquote><h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 获取hash值，</span><br><span class="line"> * (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)，这段代码叫“扰动函数”，具体可以看这篇博客解析</span><br><span class="line"> * https://www.cnblogs.com/zhengwang/p/8136164.html</span><br><span class="line"> */</span><br><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">    int h;</span><br><span class="line">    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="isEmpty"><a href="#isEmpty" class="headerlink" title="isEmpty"></a>isEmpty</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 根据size判断集合是否为空</span><br><span class="line"> */</span><br><span class="line">public boolean isEmpty() &#123;</span><br><span class="line">    return size == 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="keySet"><a href="#keySet" class="headerlink" title="keySet"></a>keySet</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 返回所有key的Set集合</span><br><span class="line"> */</span><br><span class="line">public Set&lt;K&gt; keySet() &#123;</span><br><span class="line">    Set&lt;K&gt; ks = keySet;</span><br><span class="line">    if (ks == null) &#123;</span><br><span class="line">        ks = new KeySet();</span><br><span class="line">        keySet = ks;</span><br><span class="line">    &#125;</span><br><span class="line">    return ks;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 内部KeySet类</span><br><span class="line"> */</span><br><span class="line">final class KeySet extends AbstractSet&lt;K&gt; &#123;</span><br><span class="line">    public final int size()                 &#123; return size; &#125;</span><br><span class="line">    public final void clear()               &#123; HashMap.this.clear(); &#125;</span><br><span class="line">    public final Iterator&lt;K&gt; iterator()     &#123; return new KeyIterator(); &#125;</span><br><span class="line">    public final boolean contains(Object o) &#123; return containsKey(o); &#125;</span><br><span class="line">    public final boolean remove(Object key) &#123;</span><br><span class="line">        return removeNode(hash(key), key, null, false, true) != null;</span><br><span class="line">    &#125;</span><br><span class="line">    public final Spliterator&lt;K&gt; spliterator() &#123;</span><br><span class="line">        return new KeySpliterator&lt;&gt;(HashMap.this, 0, -1, 0, 0);</span><br><span class="line">    &#125;</span><br><span class="line">    public final void forEach(Consumer&lt;? super K&gt; action) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab;</span><br><span class="line">        if (action == null)</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        if (size &gt; 0 &amp;&amp; (tab = table) != null) &#123;</span><br><span class="line">            int mc = modCount;</span><br><span class="line">            for (int i = 0; i &lt; tab.length; ++i) &#123;</span><br><span class="line">                for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next)</span><br><span class="line">                    action.accept(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            if (modCount != mc)</span><br><span class="line">                throw new ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="put、putIfAbsent、putVal"><a href="#put、putIfAbsent、putVal" class="headerlink" title="put、putIfAbsent、putVal"></a>put、putIfAbsent、putVal</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 设值</span><br><span class="line"> */</span><br><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    return putVal(hash(key), key, value, false, true);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 如果存在此key的值，那就不设值用原值</span><br><span class="line"> */</span><br><span class="line">public V putIfAbsent(K key, V value) &#123;</span><br><span class="line">    return putVal(hash(key), key, value, true, true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 设值</span><br><span class="line"> * @param onlyIfAbsent 为true，就不改动原值</span><br><span class="line"> * @param evict 如果为false，则表处于创建模式</span><br><span class="line"> */</span><br><span class="line">   final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">               boolean evict) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">    // 如果数组为null，也就是第一次put值，就resize进行扩容，这个方法后面再讲</span><br><span class="line">    if ((tab = table) == null || (n = tab.length) == 0)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    // 在数组中这个下标下如果这个链表为null，就根据传进的参数新建一个给它，也就是新建成链表头</span><br><span class="line">    if ((p = tab[i = (n - 1) &amp; hash]) == null)</span><br><span class="line">        tab[i] = newNode(hash, key, value, null);</span><br><span class="line">    else &#123;</span><br><span class="line">        // 链表头不为null，e、k会当做循环这条链表的暂时值</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        // 如果刚好就是链表头，那就是e等于链表头</span><br><span class="line">        if (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        // 红黑树的部分看TreeNode类解析</span><br><span class="line">        else if (p instanceof TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">        else &#123;</span><br><span class="line">            // 循环这条链表</span><br><span class="line">            for (int binCount = 0; ; ++binCount) &#123;</span><br><span class="line">                // next==null说明到链表尾了</span><br><span class="line">                if ((e = p.next) == null) &#123;</span><br><span class="line">                    // 根据参数新建一个链表，作为链表尾</span><br><span class="line">                    p.next = newNode(hash, key, value, null);</span><br><span class="line">                    // 如果链表长度不小于TREEIFY_THRESHOLD（8），就转换成红黑树</span><br><span class="line">                    if (binCount &gt;= TREEIFY_THRESHOLD - 1)</span><br><span class="line">                        // 如何转换的，这个后面再详解</span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                // 如果在循环过程中发现存在此key，那就不用新建链表尾了</span><br><span class="line">                if (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                    break;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果设值的key是已存在的</span><br><span class="line">        if (e != null) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            // onlyIfAbsent为false，或者原值等于null，就设置成传入参数的value</span><br><span class="line">            if (!onlyIfAbsent || oldValue == null)</span><br><span class="line">                e.value = value;</span><br><span class="line">            // 这里是空方法，在LinkedHashMap才会实现</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            // 返回的旧值哦</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    // 超过最大容量，进行扩容</span><br><span class="line">    if (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    // 这里是空方法，在LinkedHashMap才会实现</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="remove、removeNode"><a href="#remove、removeNode" class="headerlink" title="remove、removeNode"></a>remove、removeNode</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 移除某个对应的值（链表），返回对应的value，没的话就返回null</span><br><span class="line"> */</span><br><span class="line">public V remove(Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    return (e = removeNode(hash(key), key, null, false, true)) == null ?</span><br><span class="line">        null : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 移除某个对应的值（链表），有对应的value就返回true，没的话就返回false</span><br><span class="line"> */</span><br><span class="line">public boolean remove(Object key, Object value) &#123;</span><br><span class="line">    return removeNode(hash(key), key, value, true, true) != null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 移除某个对应的值（链表）</span><br><span class="line"> * @param matchValue 为true时，进行移除</span><br><span class="line"> * @param movable 如果为false，则在删除时不要移动其他节点</span><br><span class="line"> */</span><br><span class="line">final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value,</span><br><span class="line">                           boolean matchValue, boolean movable) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index;</span><br><span class="line">    // 数组不为空，且hash对应的链表头也不为空</span><br><span class="line">    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - 1) &amp; hash]) != null) &#123;</span><br><span class="line">        Node&lt;K,V&gt; node = null, e; K k; V v;</span><br><span class="line">        // 这里就是为了得到key对应的链表node</span><br><span class="line">        if (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">            node = p;</span><br><span class="line">        else if ((e = p.next) != null) &#123;</span><br><span class="line">            if (p instanceof TreeNode)</span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            else &#123;</span><br><span class="line">                do &#123;</span><br><span class="line">                    if (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                         (key != null &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125; while ((e = e.next) != null);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 是否符合移除该node的条件</span><br><span class="line">        if (node != null &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                             (value != null &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            // 如果是红黑树，就去TreeNode的方法处理</span><br><span class="line">            if (node instanceof TreeNode)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable);</span><br><span class="line">            // 两者相等，说明node刚好是链表头，直接等于next即可</span><br><span class="line">            else if (node == p)</span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            else</span><br><span class="line">                // 不是链表头，改p的next，相当于移除下一位的node</span><br><span class="line">                p.next = node.next;</span><br><span class="line">            ++modCount;</span><br><span class="line">            --size;</span><br><span class="line">            // 这里是空方法，在LinkedHashMap才会实现</span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            return node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="replace、replaceAll"><a href="#replace、replaceAll" class="headerlink" title="replace、replaceAll"></a>replace、replaceAll</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 根据key替换对应value，返回旧值</span><br><span class="line"> */</span><br><span class="line">public V replace(K key, V value) &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    if ((e = getNode(hash(key), key)) != null) &#123;</span><br><span class="line">        V oldValue = e.value;</span><br><span class="line">        e.value = value;</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">        return oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 根据key，newValue替换旧值</span><br><span class="line"> * 当旧值等于oldValue时，才会去替换，否则返回false</span><br><span class="line"> */</span><br><span class="line">public boolean replace(K key, V oldValue, V newValue) &#123;</span><br><span class="line">    Node&lt;K,V&gt; e; V v;</span><br><span class="line">    if ((e = getNode(hash(key), key)) != null &amp;&amp;</span><br><span class="line">        ((v = e.value) == oldValue || (v != null &amp;&amp; v.equals(oldValue)))) &#123;</span><br><span class="line">        e.value = newValue;</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 这个不常用，不解析了..</span><br><span class="line"> */</span><br><span class="line">public void replaceAll(BiFunction&lt;? super K, ? super V, ? extends V&gt; function) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab;</span><br><span class="line">    if (function == null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    if (size &gt; 0 &amp;&amp; (tab = table) != null) &#123;</span><br><span class="line">        int mc = modCount;</span><br><span class="line">        for (int i = 0; i &lt; tab.length; ++i) &#123;</span><br><span class="line">            for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) &#123;</span><br><span class="line">                e.value = function.apply(e.key, e.value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (modCount != mc)</span><br><span class="line">            throw new ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="resize"><a href="#resize" class="headerlink" title="resize"></a>resize</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 扩容</span><br><span class="line"> */</span><br><span class="line">final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    // 原数组的长度，也就是旧容量</span><br><span class="line">    int oldCap = (oldTab == null) ? 0 : oldTab.length;</span><br><span class="line">    // 旧阀值</span><br><span class="line">    int oldThr = threshold;</span><br><span class="line">    // 新容量、新阀值</span><br><span class="line">    int newCap, newThr = 0;</span><br><span class="line">    if (oldCap &gt; 0) &#123;</span><br><span class="line">        // 如果原数组已经是最大了，就不扩容了，返回原数组</span><br><span class="line">        if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            // 修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            return oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        // 否则就扩容一倍</span><br><span class="line">        else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; 1;</span><br><span class="line">    &#125;</span><br><span class="line">    // 旧阀值大于0，则将新容量直接等于就阀值 </span><br><span class="line">    else if (oldThr &gt; 0)</span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    // 旧容量、旧阀值都为0，也就是未初始化，就设置新容量、新阀值为默认值</span><br><span class="line">    else &#123;               </span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果新阀值为0，计算新的阀值上限</span><br><span class="line">    if (newThr == 0) &#123;</span><br><span class="line">        float ft = (float)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (int)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class="line">        // 新建扩容一倍的新数组</span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    if (oldTab != null) &#123;</span><br><span class="line">        // 遍历旧数组，把它们的链表搬到新数组</span><br><span class="line">        for (int j = 0; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            if ((e = oldTab[j]) != null) &#123;</span><br><span class="line">                // 便于gc回收</span><br><span class="line">                oldTab[j] = null;</span><br><span class="line">                // 这条链表只有一个链表头</span><br><span class="line">                if (e.next == null)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - 1)] = e;</span><br><span class="line">                // 是红黑树，就红黑树处理</span><br><span class="line">                else if (e instanceof TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</span><br><span class="line">                // 遍历链表条</span><br><span class="line">                else &#123;</span><br><span class="line">                    // loHead - loTail、hiHead - hiTail，分别对应 链表头 - 链表尾</span><br><span class="line">                    // 这样作为暂时值处理，得到链表尾</span><br><span class="line">                    Node&lt;K,V&gt; loHead = null, loTail = null;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = null, hiTail = null;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    do &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        // 原索引（没懂。。）</span><br><span class="line">                        if ((e.hash &amp; oldCap) == 0) &#123;</span><br><span class="line">                            if (loTail == null)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            else</span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        else &#123;</span><br><span class="line">                            if (hiTail == null)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            else</span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; while ((e = next) != null);</span><br><span class="line">                    // loTail链表尾不为null，</span><br><span class="line">                    // 就设链表头尾到新数组对应的下标（也就是转移对应的链表条）</span><br><span class="line">                    if (loTail != null) &#123;</span><br><span class="line">                        loTail.next = null;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    // hiTail链表尾不为null，</span><br><span class="line">                    // 就设链表头尾到新数组对应的下标（也就是转移对应的链表条）</span><br><span class="line">                    if (hiTail != null) &#123;</span><br><span class="line">                        hiTail.next = null;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="values"><a href="#values" class="headerlink" title="values"></a>values</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 返回所有value值的Collection集合，（莫名奇妙就有了这个值。。。）</span><br><span class="line"> */</span><br><span class="line">public Collection&lt;V&gt; values() &#123;</span><br><span class="line">    Collection&lt;V&gt; vs = values;</span><br><span class="line">    if (vs == null) &#123;</span><br><span class="line">        vs = new Values();</span><br><span class="line">        values = vs;</span><br><span class="line">    &#125;</span><br><span class="line">    return vs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="TreeNode"><a href="#TreeNode" class="headerlink" title="TreeNode"></a>TreeNode</h2><p>比较特殊，专门来讲的红黑树类<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; &#123;&#125;</span><br></pre></td></tr></table></figure><p></p><p>然后看下LinkedHashMap.Entry&lt;K,V&gt;类，居然是继承回HashMap的Node类。。有点意思<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123;&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="基本知识-1"><a href="#基本知识-1" class="headerlink" title="基本知识"></a>基本知识</h3><p>红黑树的概念</p><ul><li>每个结点都是红色的或者是黑色的</li><li>根结点是黑色的</li><li>每个叶结点NIL是黑色的，但是通常我们不考虑NIL叶结点。</li><li>如果一个结点是红色的，它的两个子结点都是黑色的</li><li>每个结点到其他所有后代叶结点的简单路径上，均包含相同数目的黑色结点，这个属性被称为黑高，记作bh(x)</li></ul><h3 id="成员变量-1"><a href="#成员变量-1" class="headerlink" title="成员变量"></a>成员变量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 父节点</span><br><span class="line">TreeNode&lt;K,V&gt; parent;</span><br><span class="line">// 左子节点</span><br><span class="line">TreeNode&lt;K,V&gt; left;</span><br><span class="line">// 右子节点</span><br><span class="line">TreeNode&lt;K,V&gt; right;</span><br><span class="line">// 前方节点</span><br><span class="line">TreeNode&lt;K,V&gt; prev;</span><br><span class="line">// 是否红色</span><br><span class="line">boolean red;</span><br></pre></td></tr></table></figure><h3 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 就是用HashMap.Node的构造函数</span><br><span class="line"> */</span><br><span class="line">TreeNode(int hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">    super(hash, key, val, next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里解析的方法从HashMap的get、put等入手</p><h3 id="getTreeNode"><a href="#getTreeNode" class="headerlink" title="getTreeNode"></a>getTreeNode</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 得到对应的节点</span><br><span class="line"> */</span><br><span class="line">final TreeNode&lt;K,V&gt; getTreeNode(int h, Object k) &#123;</span><br><span class="line">    return ((parent != null) ? root() : this).find(h, k, null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="root"><a href="#root" class="headerlink" title="root"></a>root</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 返回根节点</span><br><span class="line"> */</span><br><span class="line"> final TreeNode&lt;K,V&gt; root() &#123;</span><br><span class="line">        for (TreeNode&lt;K,V&gt; r = this, p;;) &#123;</span><br><span class="line">            if ((p = r.parent) == null)</span><br><span class="line">                return r;</span><br><span class="line">            r = p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 从根结点p开始根据hash和key值寻找指定的结点。二叉树的查找</span><br><span class="line"> */</span><br><span class="line">  final TreeNode&lt;K,V&gt; find(int h, Object k, Class&lt;?&gt; kc) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; p = this;</span><br><span class="line">        // 遍历红黑树</span><br><span class="line">        do &#123;</span><br><span class="line">            int ph, dir; K pk;</span><br><span class="line">            TreeNode&lt;K,V&gt; pl = p.left, pr = p.right, q;</span><br><span class="line">            // p.hash大于参数hash时，移向左子树</span><br><span class="line">            if ((ph = p.hash) &gt; h)</span><br><span class="line">                p = pl;</span><br><span class="line">            // p.hash小于参数hash时，移向右子树</span><br><span class="line">            else if (ph &lt; h)</span><br><span class="line">                p = pr;</span><br><span class="line">            // p.hash等于参数hash，且参数k也等于p.key，返回这个p，也就是根节点</span><br><span class="line">            else if ((pk = p.key) == k || (k != null &amp;&amp; k.equals(pk)))</span><br><span class="line">                return p;</span><br><span class="line">            // 若hash相等但key不等，向左右子树非空的一侧移动</span><br><span class="line">            else if (pl == null)</span><br><span class="line">                p = pr;</span><br><span class="line">            else if (pr == null)</span><br><span class="line">                p = pl;</span><br><span class="line">            else if ((kc != null ||</span><br><span class="line">                      (kc = comparableClassFor(k)) != null) &amp;&amp; // kc是否是一个可比较的类</span><br><span class="line">                     (dir = compareComparables(kc, k, pk)) != 0)  // 比较k和p.key</span><br><span class="line">                p = (dir &lt; 0) ? pl : pr;</span><br><span class="line">            else if ((q = pr.find(h, k, kc)) != null)</span><br><span class="line">                return q;</span><br><span class="line">            else</span><br><span class="line">                p = pl;</span><br><span class="line">        &#125; while (p != null);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="putTreeVal"><a href="#putTreeVal" class="headerlink" title="putTreeVal"></a>putTreeVal</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">  /**</span><br><span class="line">   * </span><br><span class="line">   */</span><br><span class="line">final TreeNode&lt;K,V&gt; putTreeVal(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span><br><span class="line">                                     int h, K k, V v) &#123;</span><br><span class="line">          Class&lt;?&gt; kc = null;</span><br><span class="line">          boolean searched = false;</span><br><span class="line">          // 根节点</span><br><span class="line">          TreeNode&lt;K,V&gt; root = (parent != null) ? root() : this;</span><br><span class="line">          // </span><br><span class="line">          for (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">              int dir, ph; K pk;</span><br><span class="line">              if ((ph = p.hash) &gt; h)</span><br><span class="line">                  dir = -1;</span><br><span class="line">              else if (ph &lt; h)</span><br><span class="line">                  dir = 1;</span><br><span class="line">              else if ((pk = p.key) == k || (k != null &amp;&amp; k.equals(pk)))</span><br><span class="line">                  return p;</span><br><span class="line">              else if ((kc == null &amp;&amp;</span><br><span class="line">                        (kc = comparableClassFor(k)) == null) ||</span><br><span class="line">                       (dir = compareComparables(kc, k, pk)) == 0) &#123;</span><br><span class="line">                  if (!searched) &#123;</span><br><span class="line">                      TreeNode&lt;K,V&gt; q, ch;</span><br><span class="line">                      searched = true;</span><br><span class="line">                      if (((ch = p.left) != null &amp;&amp;</span><br><span class="line">                           (q = ch.find(h, k, kc)) != null) ||</span><br><span class="line">                          ((ch = p.right) != null &amp;&amp;</span><br><span class="line">                           (q = ch.find(h, k, kc)) != null))</span><br><span class="line">                          return q;</span><br><span class="line">                  &#125;</span><br><span class="line">                  dir = tieBreakOrder(k, pk);</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">              if ((p = (dir &lt;= 0) ? p.left : p.right) == null) &#123;</span><br><span class="line">                  Node&lt;K,V&gt; xpn = xp.next;</span><br><span class="line">                  TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn);</span><br><span class="line">                  if (dir &lt;= 0)</span><br><span class="line">                      xp.left = x;</span><br><span class="line">                  else</span><br><span class="line">                      xp.right = x;</span><br><span class="line">                  xp.next = x;</span><br><span class="line">                  x.parent = x.prev = xp;</span><br><span class="line">                  if (xpn != null)</span><br><span class="line">                      ((TreeNode&lt;K,V&gt;)xpn).prev = x;</span><br><span class="line">                  moveRootToFront(tab, balanceInsertion(root, x));</span><br><span class="line">                  return null;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h3 id="treeifyBin"><a href="#treeifyBin" class="headerlink" title="treeifyBin"></a>treeifyBin</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">  /**</span><br><span class="line">   * 转换成红黑树，但其实只是链表转成TreeNode，里面的treeify（）才是对链表条转换成红黑树</span><br><span class="line">   */</span><br><span class="line">final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) &#123;</span><br><span class="line">      int n, index; Node&lt;K,V&gt; e;</span><br><span class="line">      // 数组为空，或者数组长度小于64，只扩容不转换</span><br><span class="line">      if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">          resize();</span><br><span class="line">      // 跳到该链表条的链表头，准备循环</span><br><span class="line">      else if ((e = tab[index = (n - 1) &amp; hash]) != null) &#123;</span><br><span class="line">          // 定义头尾节点，因为一直遍历，尾节点的值会一直变化</span><br><span class="line">          TreeNode&lt;K,V&gt; hd = null, tl = null;</span><br><span class="line">          do &#123;</span><br><span class="line">              // 这里replacementTreeNode就是new TreeNode&lt;&gt;(e.hash, e.key, e.value, null)</span><br><span class="line">              // p为当前节点</span><br><span class="line">              TreeNode&lt;K,V&gt; p = replacementTreeNode(e, null);</span><br><span class="line">              // 尾节点为null，说明是初始化阶段，把头节点=p</span><br><span class="line">              if (tl == null)</span><br><span class="line">                  hd = p;</span><br><span class="line">              // 尾节点不为null，设置p的prev（上一个节点）为尾节点，尾节点的next为p，</span><br><span class="line">              // 也就是把p接到当前暂时的尾节点后面</span><br><span class="line">              else &#123;</span><br><span class="line">                  p.prev = tl;</span><br><span class="line">                  tl.next = p;</span><br><span class="line">              &#125;</span><br><span class="line">              // 把p设为暂时尾节点</span><br><span class="line">              tl = p;</span><br><span class="line">          &#125; while ((e = e.next) != null);</span><br><span class="line">          // 上面只是把链表转换成TreeNode，现在才进行链表条转换成红黑树</span><br><span class="line">          if ((tab[index] = hd) != null)</span><br><span class="line">              // 看下面解析</span><br><span class="line">              hd.treeify(tab);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="treeify"><a href="#treeify" class="headerlink" title="treeify"></a>treeify</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">  /**</span><br><span class="line">   * 把链表条转换成红黑树</span><br><span class="line">   */</span><br><span class="line">final void treeify(Node&lt;K,V&gt;[] tab) &#123;</span><br><span class="line">          TreeNode&lt;K,V&gt; root = null;</span><br><span class="line">          // 从this开始遍历，x为当前节点，next为当前节点的下一节点</span><br><span class="line">          for (TreeNode&lt;K,V&gt; x = this, next; x != null; x = next) &#123;</span><br><span class="line">              next = (TreeNode&lt;K,V&gt;)x.next;</span><br><span class="line">              x.left = x.right = null;</span><br><span class="line">              // 如果还没有根节点，把x设为跟节点</span><br><span class="line">              if (root == null) &#123;</span><br><span class="line">                  x.parent = null;</span><br><span class="line">                  x.red = false;</span><br><span class="line">                  root = x;</span><br><span class="line">              &#125;</span><br><span class="line">              else &#123;</span><br><span class="line">                  K k = x.key;</span><br><span class="line">                  int h = x.hash;</span><br><span class="line">                  Class&lt;?&gt; kc = null;</span><br><span class="line">                  /*</span><br><span class="line">                   * 从根节点开始遍历，此遍历没有设置边界，只能从内部跳出</span><br><span class="line">                   * x为要插进的节点，p为遍历到的要进行对比的节点</span><br><span class="line">                   */</span><br><span class="line">                  for (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">                      // dir 标识方向（-1为左，1为右）、ph标识当前树节点的hash值</span><br><span class="line">                      int dir, ph;</span><br><span class="line">                      K pk = p.key;</span><br><span class="line">                      if ((ph = p.hash) &gt; h)</span><br><span class="line">                          dir = -1;</span><br><span class="line">                      else if (ph &lt; h)</span><br><span class="line">                          dir = 1;</span><br><span class="line">                      // 对比的两个节点x、p的hash值相等，判断hash碰撞再决定dir的值</span><br><span class="line">                      else if ((kc == null &amp;&amp;</span><br><span class="line">                                (kc = comparableClassFor(k)) == null) ||</span><br><span class="line">                               (dir = compareComparables(kc, k, pk)) == 0)</span><br><span class="line">                          dir = tieBreakOrder(k, pk);</span><br><span class="line">                      // 先保存好当前对比的p，可能要作为x即将插入的父节点</span><br><span class="line">                      TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">                      // 根据dir来决定下一个遍历的对比节点p，如果p为null说明到末节点了，把x插进去</span><br><span class="line">                    </span><br><span class="line">                      if ((p = (dir &lt;= 0) ? p.left : p.right) == null) &#123;</span><br><span class="line">                          // x的父节点</span><br><span class="line">                          x.parent = xp;</span><br><span class="line">                          // 决定x在左还是右节点</span><br><span class="line">                          if (dir &lt;= 0)</span><br><span class="line">                              xp.left = x;</span><br><span class="line">                          else</span><br><span class="line">                              xp.right = x;</span><br><span class="line">                          // 加入新的节点，要对红黑树进行重新平衡，这个下面分析</span><br><span class="line">                          root = balanceInsertion(root, x);</span><br><span class="line">                          break;</span><br><span class="line">                      &#125;</span><br><span class="line">                  // p不为null，就重新开始整个遍历</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          // 把红黑树的根节点设为其所在的链表条的链表头，下面会有分析</span><br><span class="line">          moveRootToFront(tab, root);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h3 id="balanceInsertion"><a href="#balanceInsertion" class="headerlink" title="balanceInsertion"></a>balanceInsertion</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">  /**</span><br><span class="line">   * 平衡红黑树，root为根节点，x为新插入的节点</span><br><span class="line">   * 有兴趣可以看这篇图文讲解，https://www.cnblogs.com/oldbai/p/9890808.html</span><br><span class="line">   * 还有这篇 https://blog.csdn.net/weixin_42340670/article/details/80550932</span><br><span class="line">   */</span><br><span class="line">static &lt;K,V&gt; TreeNode&lt;K,V&gt; balanceInsertion(TreeNode&lt;K,V&gt; root,</span><br><span class="line">                                                  TreeNode&lt;K,V&gt; x) &#123;</span><br><span class="line">          // 设x为红色</span><br><span class="line">          x.red = true;</span><br><span class="line">          // 循环依然只能内部跳出</span><br><span class="line">          // xp：x的父节点、xpp：x的爷爷节点、xppl：x的左叔叔节点、xppr：x的右叔叔节点</span><br><span class="line">          for (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) &#123;</span><br><span class="line">              // xp为x的父节点，为null说明x为根节点，设成黑色，返回x</span><br><span class="line">              if ((xp = x.parent) == null) &#123;</span><br><span class="line">                  x.red = false;</span><br><span class="line">                  return x;</span><br><span class="line">              &#125;</span><br><span class="line">              // xp为黑色或者x的爷爷节点xpp为null，返回root</span><br><span class="line">              else if (!xp.red || (xpp = xp.parent) == null)</span><br><span class="line">                  return root;</span><br><span class="line">              // xpp不为null，xp与xpp的左子节点相等，则说明xp在xpp的左子节点</span><br><span class="line">              if (xp == (xppl = xpp.left)) &#123;</span><br><span class="line">                  // 如果 xpp 的右子节点xppr不为空且为红色，进行变色操作</span><br><span class="line">                  // 这里直接变色可达到关于黑色数量规则，且无连续红色，</span><br><span class="line">                  // 然后继续往上循环判断</span><br><span class="line">                  if ((xppr = xpp.right) != null &amp;&amp; xppr.red) &#123;</span><br><span class="line">                      xppr.red = false;</span><br><span class="line">                      xp.red = false;</span><br><span class="line">                      xpp.red = true;</span><br><span class="line">                      // x设为xpp，作为下次循环的指定节点</span><br><span class="line">                      x = xpp;</span><br><span class="line">                  &#125;</span><br><span class="line">                  // 如果 xpp 的右子节点xppr为空，或者为黑色，变色已经不能满足红黑树规则</span><br><span class="line">                  else &#123;</span><br><span class="line">                      // 如果x为右子节点,左旋转</span><br><span class="line">                      if (x == xp.right) &#123;</span><br><span class="line">                          root = rotateLeft(root, x = xp);</span><br><span class="line">                          xpp = (xp = x.parent) == null ? null : xp.parent;</span><br><span class="line">                      &#125;</span><br><span class="line">                      if (xp != null) &#123;</span><br><span class="line">                          xp.red = false;</span><br><span class="line">                          if (xpp != null) &#123;</span><br><span class="line">                              xpp.red = true;</span><br><span class="line">                              root = rotateRight(root, xpp);</span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              else &#123;</span><br><span class="line">                  if (xppl != null &amp;&amp; xppl.red) &#123;</span><br><span class="line">                      xppl.red = false;</span><br><span class="line">                      xp.red = false;</span><br><span class="line">                      xpp.red = true;</span><br><span class="line">                      x = xpp;</span><br><span class="line">                  &#125;</span><br><span class="line">                  else &#123;</span><br><span class="line">                      if (x == xp.left) &#123;</span><br><span class="line">                          root = rotateRight(root, x = xp);</span><br><span class="line">                          xpp = (xp = x.parent) == null ? null : xp.parent;</span><br><span class="line">                      &#125;</span><br><span class="line">                      if (xp != null) &#123;</span><br><span class="line">                          xp.red = false;</span><br><span class="line">                          if (xpp != null) &#123;</span><br><span class="line">                              xpp.red = true;</span><br><span class="line">                              root = rotateLeft(root, xpp);</span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h3 id="rotateLeft"><a href="#rotateLeft" class="headerlink" title="rotateLeft"></a>rotateLeft</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> /**</span><br><span class="line">  * 左旋转</span><br><span class="line">  */</span><br><span class="line">static &lt;K,V&gt; TreeNode&lt;K,V&gt; rotateLeft(TreeNode&lt;K,V&gt; root,</span><br><span class="line">                                           TreeNode&lt;K,V&gt; p) &#123;</span><br><span class="line">         TreeNode&lt;K,V&gt; r, pp, rl;</span><br><span class="line">         if (p != null &amp;&amp; (r = p.right) != null) &#123;</span><br><span class="line">             if ((rl = p.right = r.left) != null)</span><br><span class="line">                 rl.parent = p;</span><br><span class="line">             if ((pp = r.parent = p.parent) == null)</span><br><span class="line">                 (root = r).red = false;</span><br><span class="line">             else if (pp.left == p)</span><br><span class="line">                 pp.left = r;</span><br><span class="line">             else</span><br><span class="line">                 pp.right = r;</span><br><span class="line">             r.left = p;</span><br><span class="line">             p.parent = r;</span><br><span class="line">         &#125;</span><br><span class="line">         return root;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><h3 id="rotateRight"><a href="#rotateRight" class="headerlink" title="rotateRight"></a>rotateRight</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 右旋转</span><br><span class="line"> */</span><br><span class="line">static &lt;K,V&gt; TreeNode&lt;K,V&gt; rotateRight(TreeNode&lt;K,V&gt; root,</span><br><span class="line">                                           TreeNode&lt;K,V&gt; p) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; l, pp, lr;</span><br><span class="line">        if (p != null &amp;&amp; (l = p.left) != null) &#123;</span><br><span class="line">            if ((lr = p.left = l.right) != null)</span><br><span class="line">                lr.parent = p;</span><br><span class="line">            if ((pp = l.parent = p.parent) == null)</span><br><span class="line">                (root = l).red = false;</span><br><span class="line">            else if (pp.right == p)</span><br><span class="line">                pp.right = l;</span><br><span class="line">            else</span><br><span class="line">                pp.left = l;</span><br><span class="line">            l.right = p;</span><br><span class="line">            p.parent = l;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>方法有点难懂，深入研究红黑树后再补充。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;基本知识&quot;&gt;&lt;a href=&quot;#基本知识&quot; class=&quot;headerlink&quot; title=&quot;基本知识&quot;&gt;&lt;/a&gt;基本知识&lt;/h2&gt;&lt;p&gt;Hash表也称为散列表，也有直接译作哈希表，Hash表是一种根据关键字值（key-value）而直接进行访问的数据结构。也就是说它通过把关键码值映射到表中的一个位置来访问记录，以此来加快查找的速度。在链表、数组等数据结构中，查找某个关键字，通常要遍历整个数据结构，也就是O(N)的时间级，但是对于哈希表来说，只是O(1)的时间级。（更多知识自行百度Google）&lt;/p&gt;&lt;p&gt;HashMap是一个利用哈希表原理来存储元素的无序不安全键值都可为空的集合。遇到冲突时，HashMap 是采用的链地址法来解决，在 JDK1.7 中，HashMap 是由 数组+链表构成的。但是在JDK1.8中，HashMap是由数组+链表+红黑树构成，新增了红黑树作为底层数据结构，结构变得复杂了，但是效率也变的更高效。&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * 继承 AbstractMap&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *          AbstractMap也是实现了Map类的，既继承AbstractMap又实现Map，脱裤子放屁....&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * 实现 Map 接口&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *          这个接口是 Map 类集合的上层接口，定义了实现该接口的类都必须要实现的一组方法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * 实现 Cloneable 接口&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *          这个类是 java.lang.Cloneable，前面我们讲解深拷贝和浅拷贝的原理时，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *          我们介绍了浅拷贝可以通过调用 Object.clone() 方法来实现，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *          但是调用该方法的对象必须要实现 Cloneable 接口，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *          否则会抛出 CloneNoSupportException异常。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * 实现 Serializable 接口&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *          序列化&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public class HashMap&amp;lt;K,V&amp;gt; extends AbstractMap&amp;lt;K,V&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    implements Map&amp;lt;K,V&amp;gt;, Cloneable, Serializable &amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="java1.8源码" scheme="https://little8.top/categories/java1-8%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="little_eight" scheme="https://little8.top/tags/little-eight/"/>
    
  </entry>
  
  <entry>
    <title>linux安装redis</title>
    <link href="https://little8.top/2019/04/15/linux%E5%AE%89%E8%A3%85redis/"/>
    <id>https://little8.top/2019/04/15/linux安装redis/</id>
    <published>2019-04-15T14:15:27.000Z</published>
    <updated>2019-07-23T13:00:40.951Z</updated>
    
    <content type="html"><![CDATA[<h2 id="假设没有虚拟机！"><a href="#假设没有虚拟机！" class="headerlink" title="假设没有虚拟机！"></a>假设没有虚拟机！</h2><p><a href="https://blog.csdn.net/babyxue/article/details/80970526" target="_blank" rel="noopener">vm安装centos7</a></p><h2 id="redis的操作"><a href="#redis的操作" class="headerlink" title="redis的操作"></a>redis的操作</h2><ul><li>下载忽略，下载到/usr/local</li><li>进到redis根目录，yum install gcc，下载gcc，然后make MALLOC=libc</li><li>进入src, make install</li><li><p>回到根目录，vi redis.conf</p><blockquote><p>1、注释bind 127.0.0.1或一些bind相关的<br>2、修改protected-mode=no，开放外界访问redis<br>3、daemonize属性改为yes，表明需要在后台运行</p></blockquote></li><li><p>防火墙的处理</p><blockquote><p>停止使用firewall<br>systemctl stop firewalld.service<br>禁止在开机启动<br>systemctl disable firewalld.service docker ps</p></blockquote></li><li><p>安装结束</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;假设没有虚拟机！&quot;&gt;&lt;a href=&quot;#假设没有虚拟机！&quot; class=&quot;headerlink&quot; title=&quot;假设没有虚拟机！&quot;&gt;&lt;/a&gt;假设没有虚拟机！&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/babyxue/article
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://little8.top/categories/Linux/"/>
    
    
      <category term="little_eight" scheme="https://little8.top/tags/little-eight/"/>
    
  </entry>
  
  <entry>
    <title>部署到Linux服务器上访问很卡的排查方法</title>
    <link href="https://little8.top/2019/04/15/%E9%83%A8%E7%BD%B2%E5%88%B0Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E8%AE%BF%E9%97%AE%E5%BE%88%E5%8D%A1%E7%9A%84%E6%8E%92%E6%9F%A5%E6%96%B9%E6%B3%95/"/>
    <id>https://little8.top/2019/04/15/部署到Linux服务器上访问很卡的排查方法/</id>
    <published>2019-04-15T14:12:41.000Z</published>
    <updated>2019-07-23T13:00:40.951Z</updated>
    
    <content type="html"><![CDATA[<h2 id="查看内存使用情况"><a href="#查看内存使用情况" class="headerlink" title="查看内存使用情况"></a>查看内存使用情况</h2><p>free -g</p><p>当观察到free栏已为0的时候，表示内存基本被吃完了，那就释放内存吧</p><h2 id="查看磁盘使用情况"><a href="#查看磁盘使用情况" class="headerlink" title="查看磁盘使用情况"></a>查看磁盘使用情况</h2><p>df -h</p><p>当发现磁盘使用率很高时，那就要释放磁盘空间了，删除一些不必要的文件（查看各个目录占用磁盘空间，参考之前的du命令文章）</p><a id="more"></a><h2 id="查看磁盘IO使用情况"><a href="#查看磁盘IO使用情况" class="headerlink" title="查看磁盘IO使用情况"></a>查看磁盘IO使用情况</h2><p>iostat -x 1</p><p>1表示1秒刷新一次</p><p>当发现最右侧%util很高时，表示IO就很高了，若想看哪个进程占用IO，执行iotop命令查看</p><p>你也可以测试自己的读写速率多大<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd if=/dev/zero of=test bs=64k count=4k oflag=dsync</span><br></pre></td></tr></table></figure><p></p><p>输出的依次是:复制的大小、用时跟写速率</p><h2 id="查看cpu使用情况"><a href="#查看cpu使用情况" class="headerlink" title="查看cpu使用情况"></a>查看cpu使用情况</h2><p>top</p><p>下图中红框里表是cpu使用情况，最右侧的%id表示剩余，若很低，则表示cpu被吃完了，在top界面按shift+p对进程使用cpu排序，能看到哪些进程占用cpu较多</p><p>（暂时没图、、）</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;查看内存使用情况&quot;&gt;&lt;a href=&quot;#查看内存使用情况&quot; class=&quot;headerlink&quot; title=&quot;查看内存使用情况&quot;&gt;&lt;/a&gt;查看内存使用情况&lt;/h2&gt;&lt;p&gt;free -g&lt;/p&gt;&lt;p&gt;当观察到free栏已为0的时候，表示内存基本被吃完了，那就释放内存吧&lt;/p&gt;&lt;h2 id=&quot;查看磁盘使用情况&quot;&gt;&lt;a href=&quot;#查看磁盘使用情况&quot; class=&quot;headerlink&quot; title=&quot;查看磁盘使用情况&quot;&gt;&lt;/a&gt;查看磁盘使用情况&lt;/h2&gt;&lt;p&gt;df -h&lt;/p&gt;&lt;p&gt;当发现磁盘使用率很高时，那就要释放磁盘空间了，删除一些不必要的文件（查看各个目录占用磁盘空间，参考之前的du命令文章）&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://little8.top/categories/Linux/"/>
    
    
      <category term="little_eight" scheme="https://little8.top/tags/little-eight/"/>
    
  </entry>
  
  <entry>
    <title>java.util.LinkedList类解析</title>
    <link href="https://little8.top/2019/04/15/java-util-LinkedList%E7%B1%BB%E8%A7%A3%E6%9E%90/"/>
    <id>https://little8.top/2019/04/15/java-util-LinkedList类解析/</id>
    <published>2019-04-15T14:11:43.000Z</published>
    <updated>2019-07-23T13:00:40.947Z</updated>
    
    <content type="html"><![CDATA[<p>　LinkedList 是一个用链表实现的集合，元素有序且可以重复。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 实现 List 接口</span><br><span class="line"> *          这个接口是 List 类集合的上层接口，定义了实现该接口的类都必须要实现的一组方法</span><br><span class="line"> * 实现 Deque 接口</span><br><span class="line"> *          这是一个双向队列接口，双向队列就是两端都可以进行增加和删除操作。</span><br><span class="line"> * 实现 Cloneable 接口</span><br><span class="line"> *          这个类是 java.lang.Cloneable，前面我们讲解深拷贝和浅拷贝的原理时，</span><br><span class="line"> *          我们介绍了浅拷贝可以通过调用 Object.clone() 方法来实现，</span><br><span class="line"> *          但是调用该方法的对象必须要实现 Cloneable 接口，</span><br><span class="line"> *          否则会抛出 CloneNoSupportException异常。</span><br><span class="line"> * 实现 Serializable 接口</span><br><span class="line"> *          序列化</span><br><span class="line"> */</span><br><span class="line">public class LinkedList&lt;E&gt;</span><br><span class="line">extends AbstractSequentialList&lt;E&gt;</span><br><span class="line">implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 链表的个数，也就是集合的大小吧</span><br><span class="line"> */</span><br><span class="line">transient int size = 0;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 链表的头</span><br><span class="line"> */</span><br><span class="line">transient Node&lt;E&gt; first;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 链表的尾</span><br><span class="line"> */</span><br><span class="line">transient Node&lt;E&gt; last;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> /**</span><br><span class="line">  * 链表的类</span><br><span class="line">  */</span><br><span class="line">private static class Node&lt;E&gt; &#123;</span><br><span class="line">     // 存的值</span><br><span class="line">     E item;</span><br><span class="line">     // 指向下一个节点的引用</span><br><span class="line">     Node&lt;E&gt; next;</span><br><span class="line">     // 指向上一个节点的引用</span><br><span class="line">     Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">     Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">         this.item = element;</span><br><span class="line">         this.next = next;</span><br><span class="line">         this.prev = prev;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * 什么都没初始化。。。</span><br><span class="line">   */</span><br><span class="line">  public LinkedList() &#123;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 就是集合c转换成LinkedList吧，addAll方法后面再说</span><br><span class="line"> */</span><br><span class="line">public LinkedList(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">    this();</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    int numNew = a.length;</span><br><span class="line">    if (numNew == 0)</span><br><span class="line">        return false;</span><br><span class="line"></span><br><span class="line">    Node&lt;E&gt; pred, succ;</span><br><span class="line">    if (index == size) &#123;</span><br><span class="line">        succ = null;</span><br><span class="line">        pred = last;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        succ = node(index);</span><br><span class="line">        pred = succ.prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (Object o : a) &#123;</span><br><span class="line">        @SuppressWarnings(&quot;unchecked&quot;) E e = (E) o;</span><br><span class="line">        Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, null);</span><br><span class="line">        if (pred == null)</span><br><span class="line">            first = newNode;    </span><br><span class="line">        else</span><br><span class="line">            pred.next = newNode;</span><br><span class="line">        pred = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (succ == null) &#123;</span><br><span class="line">        last = pred;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        pred.next = succ;</span><br><span class="line">        succ.prev = pred;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    size += numNew;</span><br><span class="line">    modCount++;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="add"><a href="#add" class="headerlink" title="add"></a>add</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"> /**</span><br><span class="line">  *把元素加到指定下标，也就是在指定下标插入（新建）链表</span><br><span class="line">  */</span><br><span class="line"></span><br><span class="line">public void add(int index, E element) &#123;</span><br><span class="line">        checkPositionIndex(index);</span><br><span class="line">        // 如果下标刚好是集合大小，就直接把这个元素加到链表尾</span><br><span class="line">        if (index == size)</span><br><span class="line">            linkLast(element);</span><br><span class="line">        else</span><br><span class="line">            linkBefore(element, node(index));</span><br><span class="line">    &#125;</span><br><span class="line">      /**</span><br><span class="line">       * 加到链表尾的方法</span><br><span class="line">       */</span><br><span class="line">      void linkLast(E e) &#123;</span><br><span class="line">        // 现在的链表尾赋给 l</span><br><span class="line">        final Node&lt;E&gt; l = last;</span><br><span class="line">        // 新建链表，上一节点为 l，下一节点为null</span><br><span class="line">        final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);</span><br><span class="line">        // newNode为链表尾</span><br><span class="line">        last = newNode;</span><br><span class="line">        // 如果l为空，说明是没有链表的，把newNode也设置成链表头</span><br><span class="line">        if (l == null)</span><br><span class="line">            first = newNode;</span><br><span class="line">        // 否则的话 就把newNode赋值给l.next，让整条链表完整</span><br><span class="line">        else</span><br><span class="line">            l.next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br><span class="line">        /**</span><br><span class="line">         * 在某个链表前面插入一个链表</span><br><span class="line">         */</span><br><span class="line">       void linkBefore(E e, Node&lt;E&gt; succ) &#123;</span><br><span class="line">        final Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">        final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ);</span><br><span class="line">        succ.prev = newNode;</span><br><span class="line">        if (pred == null)</span><br><span class="line">            first = newNode;</span><br><span class="line">        else</span><br><span class="line">            pred.next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="addAll"><a href="#addAll" class="headerlink" title="addAll"></a>addAll</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 在下标index后，添加集合c</span><br><span class="line"> */</span><br><span class="line">public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">       checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">       Object[] a = c.toArray();</span><br><span class="line">       int numNew = a.length;</span><br><span class="line">       if (numNew == 0)</span><br><span class="line">           return false;</span><br><span class="line"></span><br><span class="line">       Node&lt;E&gt; pred, succ;</span><br><span class="line">       if (index == size) &#123;</span><br><span class="line">           succ = null;</span><br><span class="line">           pred = last;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           succ = node(index);</span><br><span class="line">           pred = succ.prev;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       for (Object o : a) &#123;</span><br><span class="line">           @SuppressWarnings(&quot;unchecked&quot;) E e = (E) o;</span><br><span class="line">           Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, null);</span><br><span class="line">           if (pred == null)</span><br><span class="line">               first = newNode;</span><br><span class="line">           else</span><br><span class="line">               pred.next = newNode;</span><br><span class="line">           pred = newNode;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if (succ == null) &#123;</span><br><span class="line">           last = pred;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           pred.next = succ;</span><br><span class="line">           succ.prev = pred;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       size += numNew;</span><br><span class="line">       modCount++;</span><br><span class="line">       return true;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="addFirst"><a href="#addFirst" class="headerlink" title="addFirst"></a>addFirst</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 实现的办法是这个私有的，就是在表头加链表</span><br><span class="line"> */</span><br><span class="line">private void linkFirst(E e) &#123;</span><br><span class="line">       final Node&lt;E&gt; f = first;</span><br><span class="line">       final Node&lt;E&gt; newNode = new Node&lt;&gt;(null, e, f);</span><br><span class="line">       first = newNode;</span><br><span class="line">       if (f == null)</span><br><span class="line">           last = newNode;</span><br><span class="line">       else</span><br><span class="line">           f.prev = newNode;</span><br><span class="line">       size++;</span><br><span class="line">       modCount++;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="addLast"><a href="#addLast" class="headerlink" title="addLast"></a>addLast</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 实现的办法是这个私有的，就是在表尾加链表</span><br><span class="line"> */</span><br><span class="line">void linkLast(E e) &#123;</span><br><span class="line">       final Node&lt;E&gt; l = last;</span><br><span class="line">       final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);</span><br><span class="line">       last = newNode;</span><br><span class="line">       if (l == null)</span><br><span class="line">           first = newNode;</span><br><span class="line">       else</span><br><span class="line">           l.next = newNode;</span><br><span class="line">       size++;</span><br><span class="line">       modCount++;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 清除所有链表</span><br><span class="line"> */</span><br><span class="line">     public void clear() &#123;</span><br><span class="line">       for (Node&lt;E&gt; x = first; x != null; ) &#123;</span><br><span class="line">           Node&lt;E&gt; next = x.next;</span><br><span class="line">           x.item = null;</span><br><span class="line">           x.next = null;</span><br><span class="line">           x.prev = null;</span><br><span class="line">           x = next;</span><br><span class="line">       &#125;</span><br><span class="line">       first = last = null;</span><br><span class="line">       size = 0;</span><br><span class="line">       modCount++;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 浅拷贝</span><br><span class="line"> */</span><br><span class="line">   public Object clone() &#123;</span><br><span class="line">       // 就是Object.clone()实现克隆</span><br><span class="line">       LinkedList&lt;E&gt; clone = superClone();</span><br><span class="line">       clone.first = clone.last = null;</span><br><span class="line">       clone.size = 0;</span><br><span class="line">       clone.modCount = 0;</span><br><span class="line"></span><br><span class="line">       for (Node&lt;E&gt; x = first; x != null; x = x.next)</span><br><span class="line">           clone.add(x.item);</span><br><span class="line"></span><br><span class="line">       return clone;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="contains、indexOf、lastIndexOf"><a href="#contains、indexOf、lastIndexOf" class="headerlink" title="contains、indexOf、lastIndexOf"></a>contains、indexOf、lastIndexOf</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 是否包含此元素</span><br><span class="line"> */</span><br><span class="line">   public boolean contains(Object o) &#123;</span><br><span class="line">       return indexOf(o) != -1;</span><br><span class="line">   &#125;</span><br><span class="line">   /**</span><br><span class="line">    * 判断是否存在此元素，存在返回下标，否则返回-1</span><br><span class="line">    */ </span><br><span class="line">   public int indexOf(Object o) &#123;</span><br><span class="line">       int index = 0;</span><br><span class="line">       if (o == null) &#123;</span><br><span class="line">           for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123;</span><br><span class="line">               if (x.item == null)</span><br><span class="line">                   return index;</span><br><span class="line">               index++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123;</span><br><span class="line">               if (o.equals(x.item))</span><br><span class="line">                   return index;</span><br><span class="line">               index++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return -1;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">    /**</span><br><span class="line">    * 从尾部开始循环，判断是否存在此元素，存在返回下标，否则返回-1</span><br><span class="line">    */ </span><br><span class="line">    public int lastIndexOf(Object o) &#123;</span><br><span class="line">       int index = size;</span><br><span class="line">       if (o == null) &#123;</span><br><span class="line">           for (Node&lt;E&gt; x = last; x != null; x = x.prev) &#123;</span><br><span class="line">               index--;</span><br><span class="line">               if (x.item == null)</span><br><span class="line">                   return index;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           for (Node&lt;E&gt; x = last; x != null; x = x.prev) &#123;</span><br><span class="line">               index--;</span><br><span class="line">               if (o.equals(x.item))</span><br><span class="line">                   return index;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return -1;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="get、getFirst、getLast"><a href="#get、getFirst、getLast" class="headerlink" title="get、getFirst、getLast"></a>get、getFirst、getLast</h3><p>这三个get方法都必须保证元素非null的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 根据下标返回元素（）</span><br><span class="line"> */</span><br><span class="line">public E get(int index) &#123;</span><br><span class="line">       checkElementIndex(index);</span><br><span class="line">       return node(index).item;</span><br><span class="line">   &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 返回链表头的元素</span><br><span class="line">     */</span><br><span class="line">    public E getFirst() &#123;</span><br><span class="line">       final Node&lt;E&gt; f = first;</span><br><span class="line">       if (f == null)</span><br><span class="line">           throw new NoSuchElementException();</span><br><span class="line">       return f.item;</span><br><span class="line">   &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 返回链表尾的元素</span><br><span class="line">     */</span><br><span class="line">       public E getLast() &#123;</span><br><span class="line">       final Node&lt;E&gt; l = last;</span><br><span class="line">       if (l == null)</span><br><span class="line">           throw new NoSuchElementException();</span><br><span class="line">       return l.item;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="listIterator"><a href="#listIterator" class="headerlink" title="listIterator"></a>listIterator</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 就是根据下标new一个内部迭代类</span><br><span class="line"> */</span><br><span class="line">  public ListIterator&lt;E&gt; listIterator(int index) &#123;</span><br><span class="line">       checkPositionIndex(index);</span><br><span class="line">       return new ListItr(index);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="offer、offerFirst、offerLast"><a href="#offer、offerFirst、offerLast" class="headerlink" title="offer、offerFirst、offerLast"></a>offer、offerFirst、offerLast</h3><p>这个跟add一样的，只不过返回一个true的结果<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public boolean offer(E e) &#123;</span><br><span class="line">     return add(e);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> public boolean offerFirst(E e) &#123;</span><br><span class="line">     addFirst(e);</span><br><span class="line">     return true;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">   public boolean offerLast(E e) &#123;</span><br><span class="line">     addLast(e);</span><br><span class="line">     return true;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="peek、peekFirst、peekLast"><a href="#peek、peekFirst、peekLast" class="headerlink" title="peek、peekFirst、peekLast"></a>peek、peekFirst、peekLast</h3><p>这三个方法都不用保证元素非null的。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 1.5版本的获取链表头的元素</span><br><span class="line"> */</span><br><span class="line"> public E peek() &#123;</span><br><span class="line">     final Node&lt;E&gt; f = first;</span><br><span class="line">     return (f == null) ? null : f.item;</span><br><span class="line"> &#125;</span><br><span class="line">  /**</span><br><span class="line">   *1.6版本的获取链表头的元素</span><br><span class="line">   */</span><br><span class="line"> public E peekFirst() &#123;</span><br><span class="line">     final Node&lt;E&gt; f = first;</span><br><span class="line">     return (f == null) ? null : f.item;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">   /**</span><br><span class="line">    *获取链表尾的元素</span><br><span class="line">    */</span><br><span class="line"> public E peekLast() &#123;</span><br><span class="line">     final Node&lt;E&gt; l = last;</span><br><span class="line">     return (l == null) ? null : l.item;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="poll、pollFirst、pollLast"><a href="#poll、pollFirst、pollLast" class="headerlink" title="poll、pollFirst、pollLast"></a>poll、pollFirst、pollLast</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">  /**</span><br><span class="line">   * 1.5版本的删除链表头</span><br><span class="line">   */</span><br><span class="line">public E poll() &#123;</span><br><span class="line">     final Node&lt;E&gt; f = first;</span><br><span class="line">     return (f == null) ? null : unlinkFirst(f);</span><br><span class="line"> &#125;</span><br><span class="line">  /**</span><br><span class="line">   * 1.6版本删除链表头</span><br><span class="line">   */</span><br><span class="line"> public E pollFirst() &#123;</span><br><span class="line">     final Node&lt;E&gt; f = first;</span><br><span class="line">     return (f == null) ? null : unlinkFirst(f);</span><br><span class="line"> &#125;</span><br><span class="line">  /**</span><br><span class="line">   * 删除链表尾</span><br><span class="line">   */</span><br><span class="line">  public E pollLast() &#123;</span><br><span class="line">     final Node&lt;E&gt; l = last;</span><br><span class="line">     return (l == null) ? null : unlinkLast(l);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> /**</span><br><span class="line">  * 把指定的链表设置为null，让gc自己去回收</span><br><span class="line">  */</span><br><span class="line">  private E unlinkLast(Node&lt;E&gt; l) &#123;</span><br><span class="line">     // assert l == last &amp;&amp; l != null;</span><br><span class="line">     final E element = l.item;</span><br><span class="line">     final Node&lt;E&gt; prev = l.prev;</span><br><span class="line">     l.item = null;</span><br><span class="line">     l.prev = null; // help GC</span><br><span class="line">     last = prev;</span><br><span class="line">     if (prev == null)</span><br><span class="line">         first = null;</span><br><span class="line">     else</span><br><span class="line">         prev.next = null;</span><br><span class="line">     size--;</span><br><span class="line">     modCount++;</span><br><span class="line">     return element;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="remove、removeFirst、removeLast"><a href="#remove、removeFirst、removeLast" class="headerlink" title="remove、removeFirst、removeLast"></a>remove、removeFirst、removeLast</h3><p>顾名思义，就是删除链表，实现方法都是unlink（必须保证非null）<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> /**</span><br><span class="line">  * 删除指定链表</span><br><span class="line">  */</span><br><span class="line">E unlink(Node&lt;E&gt; x) &#123;</span><br><span class="line">        // assert x != null;</span><br><span class="line">        final E element = x.item;</span><br><span class="line">        final Node&lt;E&gt; next = x.next;</span><br><span class="line">        final Node&lt;E&gt; prev = x.prev;</span><br><span class="line"></span><br><span class="line">        if (prev == null) &#123;</span><br><span class="line">            first = next;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            prev.next = next;</span><br><span class="line">            x.prev = null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (next == null) &#123;</span><br><span class="line">            last = prev;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            next.prev = prev;</span><br><span class="line">            x.next = null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        x.item = null;</span><br><span class="line">        size--;</span><br><span class="line">        modCount++;</span><br><span class="line">        return element;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 根据下标设置对应链表的元素</span><br><span class="line"> */</span><br><span class="line">   public E set(int index, E element) &#123;</span><br><span class="line">       checkElementIndex(index);</span><br><span class="line">       Node&lt;E&gt; x = node(index);</span><br><span class="line">       E oldVal = x.item;</span><br><span class="line">       x.item = element;</span><br><span class="line">       return oldVal;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="toArray"><a href="#toArray" class="headerlink" title="toArray"></a>toArray</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 转换成数组</span><br><span class="line"> */</span><br><span class="line">  public Object[] toArray() &#123;</span><br><span class="line">       Object[] result = new Object[size];</span><br><span class="line">       int i = 0;</span><br><span class="line">       for (Node&lt;E&gt; x = first; x != null; x = x.next)</span><br><span class="line">           result[i++] = x.item;</span><br><span class="line">       return result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　LinkedList 是一个用链表实现的集合，元素有序且可以重复。&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * 实现 List 接口&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *          这个接口是 List 类集合的上层接口，定义了实现该接口的类都必须要实现的一组方法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * 实现 Deque 接口&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *          这是一个双向队列接口，双向队列就是两端都可以进行增加和删除操作。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * 实现 Cloneable 接口&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *          这个类是 java.lang.Cloneable，前面我们讲解深拷贝和浅拷贝的原理时，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *          我们介绍了浅拷贝可以通过调用 Object.clone() 方法来实现，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *          但是调用该方法的对象必须要实现 Cloneable 接口，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *          否则会抛出 CloneNoSupportException异常。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * 实现 Serializable 接口&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *          序列化&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public class LinkedList&amp;lt;E&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;extends AbstractSequentialList&amp;lt;E&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;implements List&amp;lt;E&amp;gt;, Deque&amp;lt;E&amp;gt;, Cloneable, java.io.Serializable&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;h2 id=&quot;成员变量&quot;&gt;&lt;a href=&quot;#成员变量&quot; class=&quot;headerlink&quot; title=&quot;成员变量&quot;&gt;&lt;/a&gt;成员变量&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * 链表的个数，也就是集合的大小吧&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;transient int size = 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * 链表的头&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;transient Node&amp;lt;E&amp;gt; first;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * 链表的尾&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;transient Node&amp;lt;E&amp;gt; last;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt; /**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  * 链表的类&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;private static class Node&amp;lt;E&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     // 存的值&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     E item;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     // 指向下一个节点的引用&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     Node&amp;lt;E&amp;gt; next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     // 指向上一个节点的引用&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     Node&amp;lt;E&amp;gt; prev;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     Node(Node&amp;lt;E&amp;gt; prev, E element, Node&amp;lt;E&amp;gt; next) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         this.item = element;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         this.next = next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         this.prev = prev;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="java1.8源码" scheme="https://little8.top/categories/java1-8%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="little_eight" scheme="https://little8.top/tags/little-eight/"/>
    
  </entry>
  
  <entry>
    <title>java.util.ArrayList类解析</title>
    <link href="https://little8.top/2019/04/11/java.util.ArrayList%E7%B1%BB%E8%A7%A3%E6%9E%90/"/>
    <id>https://little8.top/2019/04/11/java.util.ArrayList类解析/</id>
    <published>2019-04-11T14:19:30.000Z</published>
    <updated>2019-07-23T13:00:40.947Z</updated>
    
    <content type="html"><![CDATA[<p>ArrayList 是一个用数组实现的集合，支持随机访问，元素有序且可以重复。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 实现 List 接口</span><br><span class="line"> *          这个接口是 List 类集合的上层接口，定义了实现该接口的类都必须要实现的一组方法</span><br><span class="line"> * 实现 RandomAccess 接口</span><br><span class="line"> *          这是一个标记接口，一般此标记接口用于 List 实现，</span><br><span class="line"> *          以表明它们支持快速（通常是恒定时间）的随机访问。</span><br><span class="line"> *          该接口的主要目的是允许通用算法改变其行为，</span><br><span class="line"> *          以便在应用于随机或顺序访问列表时提供良好的性能</span><br><span class="line"> * 实现 Cloneable 接口</span><br><span class="line"> *          这个类是 java.lang.Cloneable，前面我们讲解深拷贝和浅拷贝的原理时，</span><br><span class="line"> *          我们介绍了浅拷贝可以通过调用 Object.clone() 方法来实现，</span><br><span class="line"> *          但是调用该方法的对象必须要实现 Cloneable 接口，</span><br><span class="line"> *          否则会抛出 CloneNoSupportException异常。</span><br><span class="line"> * 实现 Serializable 接口</span><br><span class="line"> *          序列化</span><br><span class="line"> */</span><br><span class="line">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;</span><br><span class="line">    implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 默认初始大小.</span><br><span class="line"> */</span><br><span class="line">private static final int DEFAULT_CAPACITY = 10;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 用于空实例的共享空数组实例。</span><br><span class="line"> */</span><br><span class="line">private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 共享空数组实例，用于默认大小的空实例。我们将其与空元素数据区分开来，</span><br><span class="line"> * 以了解添加第一个元素时要加多少量。</span><br><span class="line"> */</span><br><span class="line">private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 存储集合元素的数组缓冲区。集合的容量是这个数组缓冲区的长度。</span><br><span class="line"> * 任何带有elementdata==DEFAULTCAPACITY_EMPTY_ELEMENTDATA的空集合</span><br><span class="line"> * 将在添加第一个元素时扩展为默认容量。</span><br><span class="line"> */</span><br><span class="line">transient Object[] elementData;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 集合大小</span><br><span class="line"> */</span><br><span class="line">private int size;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Constructs an empty list with an initial capacity of ten.(构造初始容量为10的空列表。)</span><br><span class="line"> * 明明说是10，其实看代码只是创建了一个空数组，应该是版本更新忘了改注释了。</span><br><span class="line"> */</span><br><span class="line">public ArrayList() &#123;</span><br><span class="line">    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 构造具有指定初始容量的空列表</span><br><span class="line"> */</span><br><span class="line">public ArrayList(int initialCapacity) &#123;</span><br><span class="line">    if (initialCapacity &gt; 0) &#123;</span><br><span class="line">        this.elementData = new Object[initialCapacity];</span><br><span class="line">    &#125; else if (initialCapacity == 0) &#123;</span><br><span class="line">        this.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 按照集合迭代器返回元素的顺序构造包含指定集合的元素的列表。</span><br><span class="line"> */</span><br><span class="line">public ArrayList(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    if ((size = elementData.length) != 0) &#123;</span><br><span class="line">        // c.toArray might (incorrectly) not return Object[] (see 6260652)</span><br><span class="line">        if (elementData.getClass() != Object[].class)</span><br><span class="line">            elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // replace with empty array.</span><br><span class="line">        this.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h2 id="add"><a href="#add" class="headerlink" title="add"></a>add</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public boolean add(E e) &#123;</span><br><span class="line">     ensureCapacityInternal(size + 1);</span><br><span class="line">     elementData[size++] = e;</span><br><span class="line">     return true;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>看看ensureCapacityInternal方法<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> private void ensureCapacityInternal(int minCapacity) &#123;</span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>再看看calculateCapacity,可以看到当elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA时，也就是这是new ArrayList后第一次加进元素的话，就会返回初始容量10，后面根据这个新建一个10容量的数组<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> private static int calculateCapacity(Object[] elementData, int minCapacity) &#123;</span><br><span class="line">    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        return Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    return minCapacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>ensureExplicitCapacity是干嘛的呢，是确保数组可用，如果容量不够，就要进行扩容了，也就是grow方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private void ensureExplicitCapacity(int minCapacity) &#123;</span><br><span class="line">      modCount++;</span><br><span class="line">      if (minCapacity - elementData.length &gt; 0)</span><br><span class="line">          grow(minCapacity);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>看看grow方法<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> /**</span><br><span class="line">  * 增加容量以确保它至少能容纳最小容量参数指定的元素数。一般是扩容1.5倍</span><br><span class="line">  */</span><br><span class="line">private void grow(int minCapacity) &#123;</span><br><span class="line">     // 现在数组的容量</span><br><span class="line">     int oldCapacity = elementData.length;</span><br><span class="line">     // 扩容1.5倍的容量</span><br><span class="line">     int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</span><br><span class="line">     // 如果1.5倍容量小于minCapacity，那把minC赋值给newC</span><br><span class="line">     if (newCapacity - minCapacity &lt; 0)</span><br><span class="line">         newCapacity = minCapacity;</span><br><span class="line">     // 如果1.5倍容量大于MAX_ARRAY_SIZE（int最大值 - 8）</span><br><span class="line">     if (newCapacity - MAX_ARRAY_SIZE（0x7fffffff - 8） &gt; 0)</span><br><span class="line">         // hugeCapacity是这样的，minC &gt; MAX_ARRAY_SIZE) ?Integer.MAX_VALUE : MAX_ARRAY_SIZE;</span><br><span class="line">         newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">     // 这里用到数组复制的方法，扩容到指定大小</span><br><span class="line">     elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> // 就是清空数组，也就是清空集合</span><br><span class="line">public void clear() &#123;</span><br><span class="line">     modCount++;</span><br><span class="line"></span><br><span class="line">     // clear to let GC do its work</span><br><span class="line">     for (int i = 0; i &lt; size; i++)</span><br><span class="line">         elementData[i] = null;</span><br><span class="line"></span><br><span class="line">     size = 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> // 克隆集合。。</span><br><span class="line"> public Object clone() &#123;</span><br><span class="line">       try &#123;</span><br><span class="line">           ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) super.clone();</span><br><span class="line">           v.elementData = Arrays.copyOf(elementData, size);</span><br><span class="line">           v.modCount = 0;</span><br><span class="line">           return v;</span><br><span class="line">       &#125; catch (CloneNotSupportedException e) &#123;</span><br><span class="line">           // this shouldn&apos;t happen, since we are Cloneable</span><br><span class="line">           throw new InternalError(e);</span><br><span class="line">       &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="contains"><a href="#contains" class="headerlink" title="contains"></a>contains</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public boolean contains(Object o) &#123;</span><br><span class="line">    return indexOf(o) &gt;= 0;</span><br><span class="line">&#125;</span><br><span class="line">//  // 从前面开始遍历，返回第一个与o相等的下标，不存在返回-1</span><br><span class="line">public int indexOf(Object o) &#123;</span><br><span class="line">    if (o == null) &#123;</span><br><span class="line">        for (int i = 0; i &lt; size; i++)</span><br><span class="line">            if (elementData[i]==null)</span><br><span class="line">                return i;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        for (int i = 0; i &lt; size; i++)</span><br><span class="line">            if (o.equals(elementData[i]))</span><br><span class="line">                return i;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 根据下标值获取对应元素</span><br><span class="line">public E get(int index) &#123;</span><br><span class="line">       // 检查是否超过最大下标值</span><br><span class="line">       rangeCheck(index);</span><br><span class="line">       // 就是 elementData[index]</span><br><span class="line">       return elementData(index);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="iterator"><a href="#iterator" class="headerlink" title="iterator"></a>iterator</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 返回的是一个内部类 Itr，Itr这里就不做多解释了，有兴趣可以自己去看。</span><br><span class="line">public Iterator&lt;E&gt; iterator() &#123;</span><br><span class="line">      return new Itr();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="lastIndexOf"><a href="#lastIndexOf" class="headerlink" title="lastIndexOf"></a>lastIndexOf</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 从后面开始遍历，返回第一个与o相等的下标，不存在返回-1</span><br><span class="line"> public int lastIndexOf(Object o) &#123;</span><br><span class="line">       if (o == null) &#123;</span><br><span class="line">           for (int i = size-1; i &gt;= 0; i--)</span><br><span class="line">               if (elementData[i]==null)</span><br><span class="line">                   return i;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           for (int i = size-1; i &gt;= 0; i--)</span><br><span class="line">               if (o.equals(elementData[i]))</span><br><span class="line">                   return i;</span><br><span class="line">       &#125;</span><br><span class="line">       return -1;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 移除指定下标的元素，可以看到是用System.arraycopy来实现对移除元素后数组进行重新组合，让其他元素位置不变</span><br><span class="line">public E remove(int index) &#123;</span><br><span class="line">     rangeCheck(index);</span><br><span class="line"></span><br><span class="line">     modCount++;</span><br><span class="line">     E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">     int numMoved = size - index - 1;</span><br><span class="line">     if (numMoved &gt; 0)</span><br><span class="line">         System.arraycopy(elementData, index+1, elementData, index,</span><br><span class="line">                          numMoved);</span><br><span class="line">     elementData[--size] = null; // clear to let GC do its work</span><br><span class="line"></span><br><span class="line">     return oldValue;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>还有一个根据元素值来移除的，就是遍历数组，找到下标，移除，也是用System.arraycopy来实现</p><h3 id="removeAll"><a href="#removeAll" class="headerlink" title="removeAll"></a>removeAll</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 从此列表中删除指定集合中包含的所有元素。</span><br><span class="line"> public boolean removeAll(Collection&lt;?&gt; c) &#123;</span><br><span class="line">     Objects.requireNonNull(c);</span><br><span class="line">     return batchRemove(c, false);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 核心还是用到了System.arraycopy</span><br><span class="line">private boolean batchRemove(Collection&lt;?&gt; c, boolean complement) &#123;</span><br><span class="line">       final Object[] elementData = this.elementData;</span><br><span class="line">       int r = 0, w = 0;</span><br><span class="line">       boolean modified = false;</span><br><span class="line">       try &#123;</span><br><span class="line">           for (; r &lt; size; r++)</span><br><span class="line">               // complement等于false，也就是c不包含的元素，重新从下标0赋值到elementData</span><br><span class="line">               if (c.contains(elementData[r]) == complement)</span><br><span class="line">                   elementData[w++] = elementData[r];</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           if (r != size) &#123;</span><br><span class="line">               System.arraycopy(elementData, r,</span><br><span class="line">                                elementData, w,</span><br><span class="line">                                size - r);</span><br><span class="line">               w += size - r;</span><br><span class="line">           &#125;</span><br><span class="line">           if (w != size) &#123;</span><br><span class="line">               // clear to let GC do its work</span><br><span class="line">               for (int i = w; i &lt; size; i++)</span><br><span class="line">                   elementData[i] = null;</span><br><span class="line">               modCount += size - w;</span><br><span class="line">               size = w;</span><br><span class="line">               modified = true;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return modified;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 设值。。</span><br><span class="line"> public E set(int index, E element) &#123;</span><br><span class="line">       rangeCheck(index);</span><br><span class="line"></span><br><span class="line">       E oldValue = elementData(index);</span><br><span class="line">       elementData[index] = element;</span><br><span class="line">       return oldValue;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 对elementData进行排序，用Arrays.sort实现</span><br><span class="line">public void sort(Comparator&lt;? super E&gt; c) &#123;</span><br><span class="line">     final int expectedModCount = modCount;</span><br><span class="line">     Arrays.sort((E[]) elementData, 0, size, c);</span><br><span class="line">     if (modCount != expectedModCount) &#123;</span><br><span class="line">         throw new ConcurrentModificationException();</span><br><span class="line">     &#125;</span><br><span class="line">     modCount++;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="subList"><a href="#subList" class="headerlink" title="subList"></a>subList</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 截取指定访问的元素到SubList.,也就是生成新的集合吧</span><br><span class="line">public List&lt;E&gt; subList(int fromIndex, int toIndex) &#123;</span><br><span class="line">       subListRangeCheck(fromIndex, toIndex, size);</span><br><span class="line">       return new SubList(this, 0, fromIndex, toIndex);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="toArray"><a href="#toArray" class="headerlink" title="toArray"></a>toArray</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 转换成size大小的数组。。。</span><br><span class="line">public Object[] toArray() &#123;</span><br><span class="line">      return Arrays.copyOf(elementData, size);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 还可以指定转换的类型</span><br><span class="line">public &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">       if (a.length &lt; size)</span><br><span class="line">           // Make a new array of a&apos;s runtime type, but my contents:</span><br><span class="line">           return (T[]) Arrays.copyOf(elementData, size, a.getClass());</span><br><span class="line">       System.arraycopy(elementData, 0, a, 0, size);</span><br><span class="line">       if (a.length &gt; size)</span><br><span class="line">           a[size] = null;</span><br><span class="line">       return a;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="trimToSize"><a href="#trimToSize" class="headerlink" title="trimToSize"></a>trimToSize</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 把数组转换成size大小的数组</span><br><span class="line"> public void trimToSize() &#123;</span><br><span class="line">      modCount++;</span><br><span class="line">      if (size &lt; elementData.length) &#123;</span><br><span class="line">          elementData = (size == 0)</span><br><span class="line">            ? EMPTY_ELEMENTDATA</span><br><span class="line">            : Arrays.copyOf(elementData, size);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ArrayList 是一个用数组实现的集合，支持随机访问，元素有序且可以重复。&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * 实现 List 接口&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *          这个接口是 List 类集合的上层接口，定义了实现该接口的类都必须要实现的一组方法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * 实现 RandomAccess 接口&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *          这是一个标记接口，一般此标记接口用于 List 实现，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *          以表明它们支持快速（通常是恒定时间）的随机访问。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *          该接口的主要目的是允许通用算法改变其行为，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *          以便在应用于随机或顺序访问列表时提供良好的性能&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * 实现 Cloneable 接口&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *          这个类是 java.lang.Cloneable，前面我们讲解深拷贝和浅拷贝的原理时，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *          我们介绍了浅拷贝可以通过调用 Object.clone() 方法来实现，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *          但是调用该方法的对象必须要实现 Cloneable 接口，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *          否则会抛出 CloneNoSupportException异常。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * 实现 Serializable 接口&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *          序列化&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public class ArrayList&amp;lt;E&amp;gt; extends AbstractList&amp;lt;E&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    implements List&amp;lt;E&amp;gt;, RandomAccess, Cloneable, java.io.Serializable&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;h2 id=&quot;成员变量&quot;&gt;&lt;a href=&quot;#成员变量&quot; class=&quot;headerlink&quot; title=&quot;成员变量&quot;&gt;&lt;/a&gt;成员变量&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * 默认初始大小.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;private static final int DEFAULT_CAPACITY = 10;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * 用于空实例的共享空数组实例。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;private static final Object[] EMPTY_ELEMENTDATA = &amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * 共享空数组实例，用于默认大小的空实例。我们将其与空元素数据区分开来，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * 以了解添加第一个元素时要加多少量。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * 存储集合元素的数组缓冲区。集合的容量是这个数组缓冲区的长度。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * 任何带有elementdata==DEFAULTCAPACITY_EMPTY_ELEMENTDATA的空集合&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * 将在添加第一个元素时扩展为默认容量。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;transient Object[] elementData;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * 集合大小&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;private int size;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="java1.8源码" scheme="https://little8.top/categories/java1-8%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="little_eight" scheme="https://little8.top/tags/little-eight/"/>
    
  </entry>
  
  <entry>
    <title>java.util.Arrays类解析</title>
    <link href="https://little8.top/2019/04/11/java.util.Arrays%E7%B1%BB%E8%A7%A3%E6%9E%90/"/>
    <id>https://little8.top/2019/04/11/java.util.Arrays类解析/</id>
    <published>2019-04-11T14:18:45.000Z</published>
    <updated>2019-07-23T13:00:40.951Z</updated>
    
    <content type="html"><![CDATA[<p>源码的类注释：This class contains various methods for manipulating arrays (such as sorting and searching). This class also contains a static factory that allows arrays to be viewed as lists.<br>可见这就是一个处理数组的类，直接研究含有的方法。</p><h2 id="asList"><a href="#asList" class="headerlink" title="asList"></a>asList</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> /**</span><br><span class="line">  * 就是数组转换成List集合</span><br><span class="line">  */</span><br><span class="line">public static &lt;T&gt; List&lt;T&gt; asList(T... a) &#123;</span><br><span class="line">     return new ArrayList&lt;&gt;(a);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="binarySearch"><a href="#binarySearch" class="headerlink" title="binarySearch"></a>binarySearch</h2><p>源码方法注释：Searches the specified array of longs for the specified value using the binary search algorithm. The array must be sorted<br>就是 采用二进制搜索算法，而且其数组必须是要经过排序的（后面的binarySearch0的使用基础必须是已经排序好的数组），排序刚好可以使用它的sort方法。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 在数组中寻找此元素，返回它的下标</span><br><span class="line"> * 参数可换成其他基本数据类型和Object</span><br><span class="line"> */</span><br><span class="line">public static int binarySearch(long[] a, long key) &#123;</span><br><span class="line">    return binarySearch0(a, 0, a.length, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> /**</span><br><span class="line">  * 遍历的二进制搜索算法</span><br><span class="line">  * @param a 数组</span><br><span class="line">  * @param fromIndex 开始下标</span><br><span class="line">  * @param toIndex 结束下标</span><br><span class="line">  * @param key 寻找的元素</span><br><span class="line">  */</span><br><span class="line"> private static int binarySearch0(long[] a, int fromIndex, int toIndex,</span><br><span class="line">                                 long key) &#123;</span><br><span class="line">    int low = fromIndex;</span><br><span class="line">    int high = toIndex - 1;</span><br><span class="line"></span><br><span class="line">    while (low &lt;= high) &#123;</span><br><span class="line">        // 取中间值</span><br><span class="line">        int mid = (low + high) &gt;&gt;&gt; 1;</span><br><span class="line">        long midVal = a[mid];</span><br><span class="line"></span><br><span class="line">        if (midVal &lt; key)</span><br><span class="line">            low = mid + 1;</span><br><span class="line">        else if (midVal &gt; key)</span><br><span class="line">            high = mid - 1;</span><br><span class="line">        else</span><br><span class="line">            return mid; // key found</span><br><span class="line">    &#125;</span><br><span class="line">    return -(low + 1);  // key not found.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="copyOf"><a href="#copyOf" class="headerlink" title="copyOf"></a>copyOf</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 顾名思义，就是复制指定的数组</span><br><span class="line"> * @param newLength 指定新数组的长度，如果小于复制的数组，则截取只保留到此长度的元素</span><br><span class="line"> * @param newType 默认是复制数组的类型(注意是T[]不是T)，也可以定义成新的类型</span><br><span class="line"> */</span><br><span class="line">public static &lt;T,U&gt; T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType) &#123;</span><br><span class="line">      @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">      T[] copy = ((Object)newType == (Object)Object[].class)</span><br><span class="line">          ? (T[]) new Object[newLength]</span><br><span class="line">          : (T[]) Array.newInstance(newType.getComponentType(), newLength);</span><br><span class="line">      System.arraycopy(original, 0, copy, 0,</span><br><span class="line">                       Math.min(original.length, newLength));</span><br><span class="line">      return copy;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 还提供另一个可指定范围复制数组的方法</span><br><span class="line"> */</span><br><span class="line"> public static &lt;T,U&gt; T[] copyOfRange(U[] original, int from, int to, Class&lt;? extends T[]&gt; newType) &#123;</span><br><span class="line">      int newLength = to - from;</span><br><span class="line">      if (newLength &lt; 0)</span><br><span class="line">          throw new IllegalArgumentException(from + &quot; &gt; &quot; + to);</span><br><span class="line">      @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">      T[] copy = ((Object)newType == (Object)Object[].class)</span><br><span class="line">          ? (T[]) new Object[newLength]</span><br><span class="line">          : (T[]) Array.newInstance(newType.getComponentType(), newLength);</span><br><span class="line">      System.arraycopy(original, from, copy, 0,</span><br><span class="line">                       Math.min(original.length - from, newLength));</span><br><span class="line">      return copy;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>可以看到最终实现的都是System.arraycopy()</p><h2 id="deepEquals"><a href="#deepEquals" class="headerlink" title="deepEquals"></a>deepEquals</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 就是对比两个数组的值（包括类型）是否完全一致</span><br><span class="line"> */</span><br><span class="line">public static boolean deepEquals(Object[] a1, Object[] a2) &#123;</span><br><span class="line">       if (a1 == a2)</span><br><span class="line">           return true;</span><br><span class="line">       if (a1 == null || a2==null)</span><br><span class="line">           return false;</span><br><span class="line">       int length = a1.length;</span><br><span class="line">       if (a2.length != length)</span><br><span class="line">           return false;</span><br><span class="line"></span><br><span class="line">       for (int i = 0; i &lt; length; i++) &#123;</span><br><span class="line">           Object e1 = a1[i];</span><br><span class="line">           Object e2 = a2[i];</span><br><span class="line"></span><br><span class="line">           if (e1 == e2)</span><br><span class="line">               continue;</span><br><span class="line">           if (e1 == null)</span><br><span class="line">               return false;</span><br><span class="line"></span><br><span class="line">           // Figure out whether the two elements are equal</span><br><span class="line">           boolean eq = deepEquals0(e1, e2);</span><br><span class="line"></span><br><span class="line">           if (!eq)</span><br><span class="line">               return false;</span><br><span class="line">       &#125;</span><br><span class="line">       return true;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>###</p><p>源码方法注释：Returns a hash code based on the “deep contents” of the specified array.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 从 result = 1起，然后从第一个元素进行 result = 31 * result + element.HashCode(); 进行循环计算。</span><br><span class="line"> * elementHash ： 就是下一级元素计算出来的。</span><br><span class="line"> * 当element为 引用数据类型数组时，elementHash使用Arrays.deepHashCode(Object a[])计算。</span><br><span class="line"> * 当element为 基本数据类型数组时，elementHash使用Arrays.hashCode(Object a[])计算。</span><br><span class="line"> * 当element为 非数组时，elementHash使用element.hashCode()计算。</span><br><span class="line"> * 很少用过，不理它了。</span><br><span class="line"> */</span><br><span class="line">public static int deepHashCode(Object a[]) &#123;</span><br><span class="line">        if (a == null)</span><br><span class="line">            return 0;</span><br><span class="line"></span><br><span class="line">        int result = 1;</span><br><span class="line"></span><br><span class="line">        for (Object element : a) &#123;</span><br><span class="line">            int elementHash = 0;</span><br><span class="line">            if (element instanceof Object[])</span><br><span class="line">                elementHash = deepHashCode((Object[]) element);</span><br><span class="line">            else if (element instanceof byte[])</span><br><span class="line">                elementHash = hashCode((byte[]) element);</span><br><span class="line">            else if (element instanceof short[])</span><br><span class="line">                elementHash = hashCode((short[]) element);</span><br><span class="line">            else if (element instanceof int[])</span><br><span class="line">                elementHash = hashCode((int[]) element);</span><br><span class="line">            else if (element instanceof long[])</span><br><span class="line">                elementHash = hashCode((long[]) element);</span><br><span class="line">            else if (element instanceof char[])</span><br><span class="line">                elementHash = hashCode((char[]) element);</span><br><span class="line">            else if (element instanceof float[])</span><br><span class="line">                elementHash = hashCode((float[]) element);</span><br><span class="line">            else if (element instanceof double[])</span><br><span class="line">                elementHash = hashCode((double[]) element);</span><br><span class="line">            else if (element instanceof boolean[])</span><br><span class="line">                elementHash = hashCode((boolean[]) element);</span><br><span class="line">            else if (element != null)</span><br><span class="line">                elementHash = element.hashCode();</span><br><span class="line"></span><br><span class="line">            result = 31 * result + elementHash;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="deepToString"><a href="#deepToString" class="headerlink" title="deepToString"></a>deepToString</h2><p>就是把数组转换成“[xx,yy,zz…]”，这样的字符串，可转换多层次嵌套的数组。而toString方法就只能转换一层数组。</p><h2 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 相比于deepEquals()，这个只要求元素的值一样就返回true了</span><br><span class="line"> */</span><br><span class="line">public static boolean equals(short[] a, short a2[]) &#123;</span><br><span class="line">       if (a==a2)</span><br><span class="line">           return true;</span><br><span class="line">       if (a==null || a2==null)</span><br><span class="line">           return false;</span><br><span class="line"></span><br><span class="line">       int length = a.length;</span><br><span class="line">       if (a2.length != length)</span><br><span class="line">           return false;</span><br><span class="line"></span><br><span class="line">       for (int i=0; i&lt;length; i++)</span><br><span class="line">           if (a[i] != a2[i])</span><br><span class="line">               return false;</span><br><span class="line"></span><br><span class="line">       return true;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="fill"><a href="#fill" class="headerlink" title="fill"></a>fill</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 将val值赋给每个元素..</span><br><span class="line"> */</span><br><span class="line">public static void fill(long[] a, long val) &#123;</span><br><span class="line">      for (int i = 0, len = a.length; i &lt; len; i++)</span><br><span class="line">          a[i] = val;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 你还可以指定赋值的范围</span><br><span class="line"> */</span><br><span class="line"> public static void fill(long[] a, int fromIndex, int toIndex, long val) &#123;</span><br><span class="line">     rangeCheck(a.length, fromIndex, toIndex);</span><br><span class="line">     for (int i = fromIndex; i &lt; toIndex; i++)</span><br><span class="line">         a[i] = val;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode"></a>hashCode</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 从 result = 1起，然后从第一个元素进行 result = 31 * result +element.HashCode();进行循环计算。</span><br><span class="line"> */</span><br><span class="line">public static int hashCode(byte a[]) &#123;</span><br><span class="line">    if (a == null)</span><br><span class="line">        return 0;</span><br><span class="line"></span><br><span class="line">    int result = 1;</span><br><span class="line">    for (byte element : a)</span><br><span class="line">        result = 31 * result + element;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="legacyMergeSort"><a href="#legacyMergeSort" class="headerlink" title="legacyMergeSort"></a>legacyMergeSort</h2><p>源码方法注释有这玩意：/*<em> To be removed in a future release. </em>/，那就不看他了</p><h2 id="parallelPrefix、parallelSetAll"><a href="#parallelPrefix、parallelSetAll" class="headerlink" title="parallelPrefix、parallelSetAll"></a>parallelPrefix、parallelSetAll</h2><p>太少用了，忽略不看。</p><h2 id="parallelSort"><a href="#parallelSort" class="headerlink" title="parallelSort"></a>parallelSort</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 就是对数组排序，还提供对指定范围内的方法</span><br><span class="line"> */</span><br><span class="line">public static void parallelSort(long[] a) &#123;</span><br><span class="line">       int n = a.length, p, g;</span><br><span class="line">       if (n &lt;= MIN_ARRAY_SORT_GRAN ||</span><br><span class="line">           (p = ForkJoinPool.getCommonPoolParallelism()) == 1)</span><br><span class="line">           DualPivotQuicksort.sort(a, 0, n - 1, null, 0, 0);</span><br><span class="line">       else</span><br><span class="line">           new ArraysParallelSortHelpers.FJLong.Sorter</span><br><span class="line">               (null, a, new long[n], 0, n, 0,</span><br><span class="line">                ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?</span><br><span class="line">                MIN_ARRAY_SORT_GRAN : g).invoke();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="setAll"><a href="#setAll" class="headerlink" title="setAll"></a>setAll</h2><p>不常用，忽略</p><h2 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h2><p>该方法是用于数组排序，在 Arrays 类中有该方法的一系列重载方法，能对7种基本数据类型，包括 byte,char,double,float,int,long,short 等都能进行排序，还有 Object 类型（实现了Comparable接口），以及比较器 Comparator 。这里我们以 int[ ] 为例看看。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 就是对数组排序，还提供对指定范围内的方法</span><br><span class="line"> */</span><br><span class="line"> public static void sort(int[] a) &#123;</span><br><span class="line">    DualPivotQuicksort.sort(a, 0, a.length - 1, null, 0, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在 Arrays.sort 方法内部调用 DualPivotQuicksort.sort 方法，这个方法的源码很长，分别对于数组的长度进行了各种算法的划分，包括快速排序，插入排序，冒泡排序都有使用。特意翻译了DualPivotQuicksort这个类，有兴趣可以往下看(会逐渐翻译完毕)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br><span class="line">955</span><br><span class="line">956</span><br><span class="line">957</span><br><span class="line">958</span><br><span class="line">959</span><br><span class="line">960</span><br><span class="line">961</span><br><span class="line">962</span><br><span class="line">963</span><br><span class="line">964</span><br><span class="line">965</span><br><span class="line">966</span><br><span class="line">967</span><br><span class="line">968</span><br><span class="line">969</span><br><span class="line">970</span><br><span class="line">971</span><br><span class="line">972</span><br><span class="line">973</span><br><span class="line">974</span><br><span class="line">975</span><br><span class="line">976</span><br><span class="line">977</span><br><span class="line">978</span><br><span class="line">979</span><br><span class="line">980</span><br><span class="line">981</span><br><span class="line">982</span><br><span class="line">983</span><br><span class="line">984</span><br><span class="line">985</span><br><span class="line">986</span><br><span class="line">987</span><br><span class="line">988</span><br><span class="line">989</span><br><span class="line">990</span><br><span class="line">991</span><br><span class="line">992</span><br><span class="line">993</span><br><span class="line">994</span><br><span class="line">995</span><br><span class="line">996</span><br><span class="line">997</span><br><span class="line">998</span><br><span class="line">999</span><br><span class="line">1000</span><br><span class="line">1001</span><br><span class="line">1002</span><br><span class="line">1003</span><br><span class="line">1004</span><br><span class="line">1005</span><br><span class="line">1006</span><br><span class="line">1007</span><br><span class="line">1008</span><br><span class="line">1009</span><br><span class="line">1010</span><br><span class="line">1011</span><br><span class="line">1012</span><br><span class="line">1013</span><br><span class="line">1014</span><br><span class="line">1015</span><br><span class="line">1016</span><br><span class="line">1017</span><br><span class="line">1018</span><br><span class="line">1019</span><br><span class="line">1020</span><br><span class="line">1021</span><br><span class="line">1022</span><br><span class="line">1023</span><br><span class="line">1024</span><br><span class="line">1025</span><br><span class="line">1026</span><br><span class="line">1027</span><br><span class="line">1028</span><br><span class="line">1029</span><br><span class="line">1030</span><br><span class="line">1031</span><br><span class="line">1032</span><br><span class="line">1033</span><br><span class="line">1034</span><br><span class="line">1035</span><br><span class="line">1036</span><br><span class="line">1037</span><br><span class="line">1038</span><br><span class="line">1039</span><br><span class="line">1040</span><br><span class="line">1041</span><br><span class="line">1042</span><br><span class="line">1043</span><br><span class="line">1044</span><br><span class="line">1045</span><br><span class="line">1046</span><br><span class="line">1047</span><br><span class="line">1048</span><br><span class="line">1049</span><br><span class="line">1050</span><br><span class="line">1051</span><br><span class="line">1052</span><br><span class="line">1053</span><br><span class="line">1054</span><br><span class="line">1055</span><br><span class="line">1056</span><br><span class="line">1057</span><br><span class="line">1058</span><br><span class="line">1059</span><br><span class="line">1060</span><br><span class="line">1061</span><br><span class="line">1062</span><br><span class="line">1063</span><br><span class="line">1064</span><br><span class="line">1065</span><br><span class="line">1066</span><br><span class="line">1067</span><br><span class="line">1068</span><br><span class="line">1069</span><br><span class="line">1070</span><br><span class="line">1071</span><br><span class="line">1072</span><br><span class="line">1073</span><br><span class="line">1074</span><br><span class="line">1075</span><br><span class="line">1076</span><br><span class="line">1077</span><br><span class="line">1078</span><br><span class="line">1079</span><br><span class="line">1080</span><br><span class="line">1081</span><br><span class="line">1082</span><br><span class="line">1083</span><br><span class="line">1084</span><br><span class="line">1085</span><br><span class="line">1086</span><br><span class="line">1087</span><br><span class="line">1088</span><br><span class="line">1089</span><br><span class="line">1090</span><br><span class="line">1091</span><br><span class="line">1092</span><br><span class="line">1093</span><br><span class="line">1094</span><br><span class="line">1095</span><br><span class="line">1096</span><br><span class="line">1097</span><br><span class="line">1098</span><br><span class="line">1099</span><br><span class="line">1100</span><br><span class="line">1101</span><br><span class="line">1102</span><br><span class="line">1103</span><br><span class="line">1104</span><br><span class="line">1105</span><br><span class="line">1106</span><br><span class="line">1107</span><br><span class="line">1108</span><br><span class="line">1109</span><br><span class="line">1110</span><br><span class="line">1111</span><br><span class="line">1112</span><br><span class="line">1113</span><br><span class="line">1114</span><br><span class="line">1115</span><br><span class="line">1116</span><br><span class="line">1117</span><br><span class="line">1118</span><br><span class="line">1119</span><br><span class="line">1120</span><br><span class="line">1121</span><br><span class="line">1122</span><br><span class="line">1123</span><br><span class="line">1124</span><br><span class="line">1125</span><br><span class="line">1126</span><br><span class="line">1127</span><br><span class="line">1128</span><br><span class="line">1129</span><br><span class="line">1130</span><br><span class="line">1131</span><br><span class="line">1132</span><br><span class="line">1133</span><br><span class="line">1134</span><br><span class="line">1135</span><br><span class="line">1136</span><br><span class="line">1137</span><br><span class="line">1138</span><br><span class="line">1139</span><br><span class="line">1140</span><br><span class="line">1141</span><br><span class="line">1142</span><br><span class="line">1143</span><br><span class="line">1144</span><br><span class="line">1145</span><br><span class="line">1146</span><br><span class="line">1147</span><br><span class="line">1148</span><br><span class="line">1149</span><br><span class="line">1150</span><br><span class="line">1151</span><br><span class="line">1152</span><br><span class="line">1153</span><br><span class="line">1154</span><br><span class="line">1155</span><br><span class="line">1156</span><br><span class="line">1157</span><br><span class="line">1158</span><br><span class="line">1159</span><br><span class="line">1160</span><br><span class="line">1161</span><br><span class="line">1162</span><br><span class="line">1163</span><br><span class="line">1164</span><br><span class="line">1165</span><br><span class="line">1166</span><br><span class="line">1167</span><br><span class="line">1168</span><br><span class="line">1169</span><br><span class="line">1170</span><br><span class="line">1171</span><br><span class="line">1172</span><br><span class="line">1173</span><br><span class="line">1174</span><br><span class="line">1175</span><br><span class="line">1176</span><br><span class="line">1177</span><br><span class="line">1178</span><br><span class="line">1179</span><br><span class="line">1180</span><br><span class="line">1181</span><br><span class="line">1182</span><br><span class="line">1183</span><br><span class="line">1184</span><br><span class="line">1185</span><br><span class="line">1186</span><br><span class="line">1187</span><br><span class="line">1188</span><br><span class="line">1189</span><br><span class="line">1190</span><br><span class="line">1191</span><br><span class="line">1192</span><br><span class="line">1193</span><br><span class="line">1194</span><br><span class="line">1195</span><br><span class="line">1196</span><br><span class="line">1197</span><br><span class="line">1198</span><br><span class="line">1199</span><br><span class="line">1200</span><br><span class="line">1201</span><br><span class="line">1202</span><br><span class="line">1203</span><br><span class="line">1204</span><br><span class="line">1205</span><br><span class="line">1206</span><br><span class="line">1207</span><br><span class="line">1208</span><br><span class="line">1209</span><br><span class="line">1210</span><br><span class="line">1211</span><br><span class="line">1212</span><br><span class="line">1213</span><br><span class="line">1214</span><br><span class="line">1215</span><br><span class="line">1216</span><br><span class="line">1217</span><br><span class="line">1218</span><br><span class="line">1219</span><br><span class="line">1220</span><br><span class="line">1221</span><br><span class="line">1222</span><br><span class="line">1223</span><br><span class="line">1224</span><br><span class="line">1225</span><br><span class="line">1226</span><br><span class="line">1227</span><br><span class="line">1228</span><br><span class="line">1229</span><br><span class="line">1230</span><br><span class="line">1231</span><br><span class="line">1232</span><br><span class="line">1233</span><br><span class="line">1234</span><br><span class="line">1235</span><br><span class="line">1236</span><br><span class="line">1237</span><br><span class="line">1238</span><br><span class="line">1239</span><br><span class="line">1240</span><br><span class="line">1241</span><br><span class="line">1242</span><br><span class="line">1243</span><br><span class="line">1244</span><br><span class="line">1245</span><br><span class="line">1246</span><br><span class="line">1247</span><br><span class="line">1248</span><br><span class="line">1249</span><br><span class="line">1250</span><br><span class="line">1251</span><br><span class="line">1252</span><br><span class="line">1253</span><br><span class="line">1254</span><br><span class="line">1255</span><br><span class="line">1256</span><br><span class="line">1257</span><br><span class="line">1258</span><br><span class="line">1259</span><br><span class="line">1260</span><br><span class="line">1261</span><br><span class="line">1262</span><br><span class="line">1263</span><br><span class="line">1264</span><br><span class="line">1265</span><br><span class="line">1266</span><br><span class="line">1267</span><br><span class="line">1268</span><br><span class="line">1269</span><br><span class="line">1270</span><br><span class="line">1271</span><br><span class="line">1272</span><br><span class="line">1273</span><br><span class="line">1274</span><br><span class="line">1275</span><br><span class="line">1276</span><br><span class="line">1277</span><br><span class="line">1278</span><br><span class="line">1279</span><br><span class="line">1280</span><br><span class="line">1281</span><br><span class="line">1282</span><br><span class="line">1283</span><br><span class="line">1284</span><br><span class="line">1285</span><br><span class="line">1286</span><br><span class="line">1287</span><br><span class="line">1288</span><br><span class="line">1289</span><br><span class="line">1290</span><br><span class="line">1291</span><br><span class="line">1292</span><br><span class="line">1293</span><br><span class="line">1294</span><br><span class="line">1295</span><br><span class="line">1296</span><br><span class="line">1297</span><br><span class="line">1298</span><br><span class="line">1299</span><br><span class="line">1300</span><br><span class="line">1301</span><br><span class="line">1302</span><br><span class="line">1303</span><br><span class="line">1304</span><br><span class="line">1305</span><br><span class="line">1306</span><br><span class="line">1307</span><br><span class="line">1308</span><br><span class="line">1309</span><br><span class="line">1310</span><br><span class="line">1311</span><br><span class="line">1312</span><br><span class="line">1313</span><br><span class="line">1314</span><br><span class="line">1315</span><br><span class="line">1316</span><br><span class="line">1317</span><br><span class="line">1318</span><br><span class="line">1319</span><br><span class="line">1320</span><br><span class="line">1321</span><br><span class="line">1322</span><br><span class="line">1323</span><br><span class="line">1324</span><br><span class="line">1325</span><br><span class="line">1326</span><br><span class="line">1327</span><br><span class="line">1328</span><br><span class="line">1329</span><br><span class="line">1330</span><br><span class="line">1331</span><br><span class="line">1332</span><br><span class="line">1333</span><br><span class="line">1334</span><br><span class="line">1335</span><br><span class="line">1336</span><br><span class="line">1337</span><br><span class="line">1338</span><br><span class="line">1339</span><br><span class="line">1340</span><br><span class="line">1341</span><br><span class="line">1342</span><br><span class="line">1343</span><br><span class="line">1344</span><br><span class="line">1345</span><br><span class="line">1346</span><br><span class="line">1347</span><br><span class="line">1348</span><br><span class="line">1349</span><br><span class="line">1350</span><br><span class="line">1351</span><br><span class="line">1352</span><br><span class="line">1353</span><br><span class="line">1354</span><br><span class="line">1355</span><br><span class="line">1356</span><br><span class="line">1357</span><br><span class="line">1358</span><br><span class="line">1359</span><br><span class="line">1360</span><br><span class="line">1361</span><br><span class="line">1362</span><br><span class="line">1363</span><br><span class="line">1364</span><br><span class="line">1365</span><br><span class="line">1366</span><br><span class="line">1367</span><br><span class="line">1368</span><br><span class="line">1369</span><br><span class="line">1370</span><br><span class="line">1371</span><br><span class="line">1372</span><br><span class="line">1373</span><br><span class="line">1374</span><br><span class="line">1375</span><br><span class="line">1376</span><br><span class="line">1377</span><br><span class="line">1378</span><br><span class="line">1379</span><br><span class="line">1380</span><br><span class="line">1381</span><br><span class="line">1382</span><br><span class="line">1383</span><br><span class="line">1384</span><br><span class="line">1385</span><br><span class="line">1386</span><br><span class="line">1387</span><br><span class="line">1388</span><br><span class="line">1389</span><br><span class="line">1390</span><br><span class="line">1391</span><br><span class="line">1392</span><br><span class="line">1393</span><br><span class="line">1394</span><br><span class="line">1395</span><br><span class="line">1396</span><br><span class="line">1397</span><br><span class="line">1398</span><br><span class="line">1399</span><br><span class="line">1400</span><br><span class="line">1401</span><br><span class="line">1402</span><br><span class="line">1403</span><br><span class="line">1404</span><br><span class="line">1405</span><br><span class="line">1406</span><br><span class="line">1407</span><br><span class="line">1408</span><br><span class="line">1409</span><br><span class="line">1410</span><br><span class="line">1411</span><br><span class="line">1412</span><br><span class="line">1413</span><br><span class="line">1414</span><br><span class="line">1415</span><br><span class="line">1416</span><br><span class="line">1417</span><br><span class="line">1418</span><br><span class="line">1419</span><br><span class="line">1420</span><br><span class="line">1421</span><br><span class="line">1422</span><br><span class="line">1423</span><br><span class="line">1424</span><br><span class="line">1425</span><br><span class="line">1426</span><br><span class="line">1427</span><br><span class="line">1428</span><br><span class="line">1429</span><br><span class="line">1430</span><br><span class="line">1431</span><br><span class="line">1432</span><br><span class="line">1433</span><br><span class="line">1434</span><br><span class="line">1435</span><br><span class="line">1436</span><br><span class="line">1437</span><br><span class="line">1438</span><br><span class="line">1439</span><br><span class="line">1440</span><br><span class="line">1441</span><br><span class="line">1442</span><br><span class="line">1443</span><br><span class="line">1444</span><br><span class="line">1445</span><br><span class="line">1446</span><br><span class="line">1447</span><br><span class="line">1448</span><br><span class="line">1449</span><br><span class="line">1450</span><br><span class="line">1451</span><br><span class="line">1452</span><br><span class="line">1453</span><br><span class="line">1454</span><br><span class="line">1455</span><br><span class="line">1456</span><br><span class="line">1457</span><br><span class="line">1458</span><br><span class="line">1459</span><br><span class="line">1460</span><br><span class="line">1461</span><br><span class="line">1462</span><br><span class="line">1463</span><br><span class="line">1464</span><br><span class="line">1465</span><br><span class="line">1466</span><br><span class="line">1467</span><br><span class="line">1468</span><br><span class="line">1469</span><br><span class="line">1470</span><br><span class="line">1471</span><br><span class="line">1472</span><br><span class="line">1473</span><br><span class="line">1474</span><br><span class="line">1475</span><br><span class="line">1476</span><br><span class="line">1477</span><br><span class="line">1478</span><br><span class="line">1479</span><br><span class="line">1480</span><br><span class="line">1481</span><br><span class="line">1482</span><br><span class="line">1483</span><br><span class="line">1484</span><br><span class="line">1485</span><br><span class="line">1486</span><br><span class="line">1487</span><br><span class="line">1488</span><br><span class="line">1489</span><br><span class="line">1490</span><br><span class="line">1491</span><br><span class="line">1492</span><br><span class="line">1493</span><br><span class="line">1494</span><br><span class="line">1495</span><br><span class="line">1496</span><br><span class="line">1497</span><br><span class="line">1498</span><br><span class="line">1499</span><br><span class="line">1500</span><br><span class="line">1501</span><br><span class="line">1502</span><br><span class="line">1503</span><br><span class="line">1504</span><br><span class="line">1505</span><br><span class="line">1506</span><br><span class="line">1507</span><br><span class="line">1508</span><br><span class="line">1509</span><br><span class="line">1510</span><br><span class="line">1511</span><br><span class="line">1512</span><br><span class="line">1513</span><br><span class="line">1514</span><br><span class="line">1515</span><br><span class="line">1516</span><br><span class="line">1517</span><br><span class="line">1518</span><br><span class="line">1519</span><br><span class="line">1520</span><br><span class="line">1521</span><br><span class="line">1522</span><br><span class="line">1523</span><br><span class="line">1524</span><br><span class="line">1525</span><br><span class="line">1526</span><br><span class="line">1527</span><br><span class="line">1528</span><br><span class="line">1529</span><br><span class="line">1530</span><br><span class="line">1531</span><br><span class="line">1532</span><br><span class="line">1533</span><br><span class="line">1534</span><br><span class="line">1535</span><br><span class="line">1536</span><br><span class="line">1537</span><br><span class="line">1538</span><br><span class="line">1539</span><br><span class="line">1540</span><br><span class="line">1541</span><br><span class="line">1542</span><br><span class="line">1543</span><br><span class="line">1544</span><br><span class="line">1545</span><br><span class="line">1546</span><br><span class="line">1547</span><br><span class="line">1548</span><br><span class="line">1549</span><br><span class="line">1550</span><br><span class="line">1551</span><br><span class="line">1552</span><br><span class="line">1553</span><br><span class="line">1554</span><br><span class="line">1555</span><br><span class="line">1556</span><br><span class="line">1557</span><br><span class="line">1558</span><br><span class="line">1559</span><br><span class="line">1560</span><br><span class="line">1561</span><br><span class="line">1562</span><br><span class="line">1563</span><br><span class="line">1564</span><br><span class="line">1565</span><br><span class="line">1566</span><br><span class="line">1567</span><br><span class="line">1568</span><br><span class="line">1569</span><br><span class="line">1570</span><br><span class="line">1571</span><br><span class="line">1572</span><br><span class="line">1573</span><br><span class="line">1574</span><br><span class="line">1575</span><br><span class="line">1576</span><br><span class="line">1577</span><br><span class="line">1578</span><br><span class="line">1579</span><br><span class="line">1580</span><br><span class="line">1581</span><br><span class="line">1582</span><br><span class="line">1583</span><br><span class="line">1584</span><br><span class="line">1585</span><br><span class="line">1586</span><br><span class="line">1587</span><br><span class="line">1588</span><br><span class="line">1589</span><br><span class="line">1590</span><br><span class="line">1591</span><br><span class="line">1592</span><br><span class="line">1593</span><br><span class="line">1594</span><br><span class="line">1595</span><br><span class="line">1596</span><br><span class="line">1597</span><br><span class="line">1598</span><br><span class="line">1599</span><br><span class="line">1600</span><br><span class="line">1601</span><br><span class="line">1602</span><br><span class="line">1603</span><br><span class="line">1604</span><br><span class="line">1605</span><br><span class="line">1606</span><br><span class="line">1607</span><br><span class="line">1608</span><br><span class="line">1609</span><br><span class="line">1610</span><br><span class="line">1611</span><br><span class="line">1612</span><br><span class="line">1613</span><br><span class="line">1614</span><br><span class="line">1615</span><br><span class="line">1616</span><br><span class="line">1617</span><br><span class="line">1618</span><br><span class="line">1619</span><br><span class="line">1620</span><br><span class="line">1621</span><br><span class="line">1622</span><br><span class="line">1623</span><br><span class="line">1624</span><br><span class="line">1625</span><br><span class="line">1626</span><br><span class="line">1627</span><br><span class="line">1628</span><br><span class="line">1629</span><br><span class="line">1630</span><br><span class="line">1631</span><br><span class="line">1632</span><br><span class="line">1633</span><br><span class="line">1634</span><br><span class="line">1635</span><br><span class="line">1636</span><br><span class="line">1637</span><br><span class="line">1638</span><br><span class="line">1639</span><br><span class="line">1640</span><br><span class="line">1641</span><br><span class="line">1642</span><br><span class="line">1643</span><br><span class="line">1644</span><br><span class="line">1645</span><br><span class="line">1646</span><br><span class="line">1647</span><br><span class="line">1648</span><br><span class="line">1649</span><br><span class="line">1650</span><br><span class="line">1651</span><br><span class="line">1652</span><br><span class="line">1653</span><br><span class="line">1654</span><br><span class="line">1655</span><br><span class="line">1656</span><br><span class="line">1657</span><br><span class="line">1658</span><br><span class="line">1659</span><br><span class="line">1660</span><br><span class="line">1661</span><br><span class="line">1662</span><br><span class="line">1663</span><br><span class="line">1664</span><br><span class="line">1665</span><br><span class="line">1666</span><br><span class="line">1667</span><br><span class="line">1668</span><br><span class="line">1669</span><br><span class="line">1670</span><br><span class="line">1671</span><br><span class="line">1672</span><br><span class="line">1673</span><br><span class="line">1674</span><br><span class="line">1675</span><br><span class="line">1676</span><br><span class="line">1677</span><br><span class="line">1678</span><br><span class="line">1679</span><br><span class="line">1680</span><br><span class="line">1681</span><br><span class="line">1682</span><br><span class="line">1683</span><br><span class="line">1684</span><br><span class="line">1685</span><br><span class="line">1686</span><br><span class="line">1687</span><br><span class="line">1688</span><br><span class="line">1689</span><br><span class="line">1690</span><br><span class="line">1691</span><br><span class="line">1692</span><br><span class="line">1693</span><br><span class="line">1694</span><br><span class="line">1695</span><br><span class="line">1696</span><br><span class="line">1697</span><br><span class="line">1698</span><br><span class="line">1699</span><br><span class="line">1700</span><br><span class="line">1701</span><br><span class="line">1702</span><br><span class="line">1703</span><br><span class="line">1704</span><br><span class="line">1705</span><br><span class="line">1706</span><br><span class="line">1707</span><br><span class="line">1708</span><br><span class="line">1709</span><br><span class="line">1710</span><br><span class="line">1711</span><br><span class="line">1712</span><br><span class="line">1713</span><br><span class="line">1714</span><br><span class="line">1715</span><br><span class="line">1716</span><br><span class="line">1717</span><br><span class="line">1718</span><br><span class="line">1719</span><br><span class="line">1720</span><br><span class="line">1721</span><br><span class="line">1722</span><br><span class="line">1723</span><br><span class="line">1724</span><br><span class="line">1725</span><br><span class="line">1726</span><br><span class="line">1727</span><br><span class="line">1728</span><br><span class="line">1729</span><br><span class="line">1730</span><br><span class="line">1731</span><br><span class="line">1732</span><br><span class="line">1733</span><br><span class="line">1734</span><br><span class="line">1735</span><br><span class="line">1736</span><br><span class="line">1737</span><br><span class="line">1738</span><br><span class="line">1739</span><br><span class="line">1740</span><br><span class="line">1741</span><br><span class="line">1742</span><br><span class="line">1743</span><br><span class="line">1744</span><br><span class="line">1745</span><br><span class="line">1746</span><br><span class="line">1747</span><br><span class="line">1748</span><br><span class="line">1749</span><br><span class="line">1750</span><br><span class="line">1751</span><br><span class="line">1752</span><br><span class="line">1753</span><br><span class="line">1754</span><br><span class="line">1755</span><br><span class="line">1756</span><br><span class="line">1757</span><br><span class="line">1758</span><br><span class="line">1759</span><br><span class="line">1760</span><br><span class="line">1761</span><br><span class="line">1762</span><br><span class="line">1763</span><br><span class="line">1764</span><br><span class="line">1765</span><br><span class="line">1766</span><br><span class="line">1767</span><br><span class="line">1768</span><br><span class="line">1769</span><br><span class="line">1770</span><br><span class="line">1771</span><br><span class="line">1772</span><br><span class="line">1773</span><br><span class="line">1774</span><br><span class="line">1775</span><br><span class="line">1776</span><br><span class="line">1777</span><br><span class="line">1778</span><br><span class="line">1779</span><br><span class="line">1780</span><br><span class="line">1781</span><br><span class="line">1782</span><br><span class="line">1783</span><br><span class="line">1784</span><br><span class="line">1785</span><br><span class="line">1786</span><br><span class="line">1787</span><br><span class="line">1788</span><br><span class="line">1789</span><br><span class="line">1790</span><br><span class="line">1791</span><br><span class="line">1792</span><br><span class="line">1793</span><br><span class="line">1794</span><br><span class="line">1795</span><br><span class="line">1796</span><br><span class="line">1797</span><br><span class="line">1798</span><br><span class="line">1799</span><br><span class="line">1800</span><br><span class="line">1801</span><br><span class="line">1802</span><br><span class="line">1803</span><br><span class="line">1804</span><br><span class="line">1805</span><br><span class="line">1806</span><br><span class="line">1807</span><br><span class="line">1808</span><br><span class="line">1809</span><br><span class="line">1810</span><br><span class="line">1811</span><br><span class="line">1812</span><br><span class="line">1813</span><br><span class="line">1814</span><br><span class="line">1815</span><br><span class="line">1816</span><br><span class="line">1817</span><br><span class="line">1818</span><br><span class="line">1819</span><br><span class="line">1820</span><br><span class="line">1821</span><br><span class="line">1822</span><br><span class="line">1823</span><br><span class="line">1824</span><br><span class="line">1825</span><br><span class="line">1826</span><br><span class="line">1827</span><br><span class="line">1828</span><br><span class="line">1829</span><br><span class="line">1830</span><br><span class="line">1831</span><br><span class="line">1832</span><br><span class="line">1833</span><br><span class="line">1834</span><br><span class="line">1835</span><br><span class="line">1836</span><br><span class="line">1837</span><br><span class="line">1838</span><br><span class="line">1839</span><br><span class="line">1840</span><br><span class="line">1841</span><br><span class="line">1842</span><br><span class="line">1843</span><br><span class="line">1844</span><br><span class="line">1845</span><br><span class="line">1846</span><br><span class="line">1847</span><br><span class="line">1848</span><br><span class="line">1849</span><br><span class="line">1850</span><br><span class="line">1851</span><br><span class="line">1852</span><br><span class="line">1853</span><br><span class="line">1854</span><br><span class="line">1855</span><br><span class="line">1856</span><br><span class="line">1857</span><br><span class="line">1858</span><br><span class="line">1859</span><br><span class="line">1860</span><br><span class="line">1861</span><br><span class="line">1862</span><br><span class="line">1863</span><br><span class="line">1864</span><br><span class="line">1865</span><br><span class="line">1866</span><br><span class="line">1867</span><br><span class="line">1868</span><br><span class="line">1869</span><br><span class="line">1870</span><br><span class="line">1871</span><br><span class="line">1872</span><br><span class="line">1873</span><br><span class="line">1874</span><br><span class="line">1875</span><br><span class="line">1876</span><br><span class="line">1877</span><br><span class="line">1878</span><br><span class="line">1879</span><br><span class="line">1880</span><br><span class="line">1881</span><br><span class="line">1882</span><br><span class="line">1883</span><br><span class="line">1884</span><br><span class="line">1885</span><br><span class="line">1886</span><br><span class="line">1887</span><br><span class="line">1888</span><br><span class="line">1889</span><br><span class="line">1890</span><br><span class="line">1891</span><br><span class="line">1892</span><br><span class="line">1893</span><br><span class="line">1894</span><br><span class="line">1895</span><br><span class="line">1896</span><br><span class="line">1897</span><br><span class="line">1898</span><br><span class="line">1899</span><br><span class="line">1900</span><br><span class="line">1901</span><br><span class="line">1902</span><br><span class="line">1903</span><br><span class="line">1904</span><br><span class="line">1905</span><br><span class="line">1906</span><br><span class="line">1907</span><br><span class="line">1908</span><br><span class="line">1909</span><br><span class="line">1910</span><br><span class="line">1911</span><br><span class="line">1912</span><br><span class="line">1913</span><br><span class="line">1914</span><br><span class="line">1915</span><br><span class="line">1916</span><br><span class="line">1917</span><br><span class="line">1918</span><br><span class="line">1919</span><br><span class="line">1920</span><br><span class="line">1921</span><br><span class="line">1922</span><br><span class="line">1923</span><br><span class="line">1924</span><br><span class="line">1925</span><br><span class="line">1926</span><br><span class="line">1927</span><br><span class="line">1928</span><br><span class="line">1929</span><br><span class="line">1930</span><br><span class="line">1931</span><br><span class="line">1932</span><br><span class="line">1933</span><br><span class="line">1934</span><br><span class="line">1935</span><br><span class="line">1936</span><br><span class="line">1937</span><br><span class="line">1938</span><br><span class="line">1939</span><br><span class="line">1940</span><br><span class="line">1941</span><br><span class="line">1942</span><br><span class="line">1943</span><br><span class="line">1944</span><br><span class="line">1945</span><br><span class="line">1946</span><br><span class="line">1947</span><br><span class="line">1948</span><br><span class="line">1949</span><br><span class="line">1950</span><br><span class="line">1951</span><br><span class="line">1952</span><br><span class="line">1953</span><br><span class="line">1954</span><br><span class="line">1955</span><br><span class="line">1956</span><br><span class="line">1957</span><br><span class="line">1958</span><br><span class="line">1959</span><br><span class="line">1960</span><br><span class="line">1961</span><br><span class="line">1962</span><br><span class="line">1963</span><br><span class="line">1964</span><br><span class="line">1965</span><br><span class="line">1966</span><br><span class="line">1967</span><br><span class="line">1968</span><br><span class="line">1969</span><br><span class="line">1970</span><br><span class="line">1971</span><br><span class="line">1972</span><br><span class="line">1973</span><br><span class="line">1974</span><br><span class="line">1975</span><br><span class="line">1976</span><br><span class="line">1977</span><br><span class="line">1978</span><br><span class="line">1979</span><br><span class="line">1980</span><br><span class="line">1981</span><br><span class="line">1982</span><br><span class="line">1983</span><br><span class="line">1984</span><br><span class="line">1985</span><br><span class="line">1986</span><br><span class="line">1987</span><br><span class="line">1988</span><br><span class="line">1989</span><br><span class="line">1990</span><br><span class="line">1991</span><br><span class="line">1992</span><br><span class="line">1993</span><br><span class="line">1994</span><br><span class="line">1995</span><br><span class="line">1996</span><br><span class="line">1997</span><br><span class="line">1998</span><br><span class="line">1999</span><br><span class="line">2000</span><br><span class="line">2001</span><br><span class="line">2002</span><br><span class="line">2003</span><br><span class="line">2004</span><br><span class="line">2005</span><br><span class="line">2006</span><br><span class="line">2007</span><br><span class="line">2008</span><br><span class="line">2009</span><br><span class="line">2010</span><br><span class="line">2011</span><br><span class="line">2012</span><br><span class="line">2013</span><br><span class="line">2014</span><br><span class="line">2015</span><br><span class="line">2016</span><br><span class="line">2017</span><br><span class="line">2018</span><br><span class="line">2019</span><br><span class="line">2020</span><br><span class="line">2021</span><br><span class="line">2022</span><br><span class="line">2023</span><br><span class="line">2024</span><br><span class="line">2025</span><br><span class="line">2026</span><br><span class="line">2027</span><br><span class="line">2028</span><br><span class="line">2029</span><br><span class="line">2030</span><br><span class="line">2031</span><br><span class="line">2032</span><br><span class="line">2033</span><br><span class="line">2034</span><br><span class="line">2035</span><br><span class="line">2036</span><br><span class="line">2037</span><br><span class="line">2038</span><br><span class="line">2039</span><br><span class="line">2040</span><br><span class="line">2041</span><br><span class="line">2042</span><br><span class="line">2043</span><br><span class="line">2044</span><br><span class="line">2045</span><br><span class="line">2046</span><br><span class="line">2047</span><br><span class="line">2048</span><br><span class="line">2049</span><br><span class="line">2050</span><br><span class="line">2051</span><br><span class="line">2052</span><br><span class="line">2053</span><br><span class="line">2054</span><br><span class="line">2055</span><br><span class="line">2056</span><br><span class="line">2057</span><br><span class="line">2058</span><br><span class="line">2059</span><br><span class="line">2060</span><br><span class="line">2061</span><br><span class="line">2062</span><br><span class="line">2063</span><br><span class="line">2064</span><br><span class="line">2065</span><br><span class="line">2066</span><br><span class="line">2067</span><br><span class="line">2068</span><br><span class="line">2069</span><br><span class="line">2070</span><br><span class="line">2071</span><br><span class="line">2072</span><br><span class="line">2073</span><br><span class="line">2074</span><br><span class="line">2075</span><br><span class="line">2076</span><br><span class="line">2077</span><br><span class="line">2078</span><br><span class="line">2079</span><br><span class="line">2080</span><br><span class="line">2081</span><br><span class="line">2082</span><br><span class="line">2083</span><br><span class="line">2084</span><br><span class="line">2085</span><br><span class="line">2086</span><br><span class="line">2087</span><br><span class="line">2088</span><br><span class="line">2089</span><br><span class="line">2090</span><br><span class="line">2091</span><br><span class="line">2092</span><br><span class="line">2093</span><br><span class="line">2094</span><br><span class="line">2095</span><br><span class="line">2096</span><br><span class="line">2097</span><br><span class="line">2098</span><br><span class="line">2099</span><br><span class="line">2100</span><br><span class="line">2101</span><br><span class="line">2102</span><br><span class="line">2103</span><br><span class="line">2104</span><br><span class="line">2105</span><br><span class="line">2106</span><br><span class="line">2107</span><br><span class="line">2108</span><br><span class="line">2109</span><br><span class="line">2110</span><br><span class="line">2111</span><br><span class="line">2112</span><br><span class="line">2113</span><br><span class="line">2114</span><br><span class="line">2115</span><br><span class="line">2116</span><br><span class="line">2117</span><br><span class="line">2118</span><br><span class="line">2119</span><br><span class="line">2120</span><br><span class="line">2121</span><br><span class="line">2122</span><br><span class="line">2123</span><br><span class="line">2124</span><br><span class="line">2125</span><br><span class="line">2126</span><br><span class="line">2127</span><br><span class="line">2128</span><br><span class="line">2129</span><br><span class="line">2130</span><br><span class="line">2131</span><br><span class="line">2132</span><br><span class="line">2133</span><br><span class="line">2134</span><br><span class="line">2135</span><br><span class="line">2136</span><br><span class="line">2137</span><br><span class="line">2138</span><br><span class="line">2139</span><br><span class="line">2140</span><br><span class="line">2141</span><br><span class="line">2142</span><br><span class="line">2143</span><br><span class="line">2144</span><br><span class="line">2145</span><br><span class="line">2146</span><br><span class="line">2147</span><br><span class="line">2148</span><br><span class="line">2149</span><br><span class="line">2150</span><br><span class="line">2151</span><br><span class="line">2152</span><br><span class="line">2153</span><br><span class="line">2154</span><br><span class="line">2155</span><br><span class="line">2156</span><br><span class="line">2157</span><br><span class="line">2158</span><br><span class="line">2159</span><br><span class="line">2160</span><br><span class="line">2161</span><br><span class="line">2162</span><br><span class="line">2163</span><br><span class="line">2164</span><br><span class="line">2165</span><br><span class="line">2166</span><br><span class="line">2167</span><br><span class="line">2168</span><br><span class="line">2169</span><br><span class="line">2170</span><br><span class="line">2171</span><br><span class="line">2172</span><br><span class="line">2173</span><br><span class="line">2174</span><br><span class="line">2175</span><br><span class="line">2176</span><br><span class="line">2177</span><br><span class="line">2178</span><br><span class="line">2179</span><br><span class="line">2180</span><br><span class="line">2181</span><br><span class="line">2182</span><br><span class="line">2183</span><br><span class="line">2184</span><br><span class="line">2185</span><br><span class="line">2186</span><br><span class="line">2187</span><br><span class="line">2188</span><br><span class="line">2189</span><br><span class="line">2190</span><br><span class="line">2191</span><br><span class="line">2192</span><br><span class="line">2193</span><br><span class="line">2194</span><br><span class="line">2195</span><br><span class="line">2196</span><br><span class="line">2197</span><br><span class="line">2198</span><br><span class="line">2199</span><br><span class="line">2200</span><br><span class="line">2201</span><br><span class="line">2202</span><br><span class="line">2203</span><br><span class="line">2204</span><br><span class="line">2205</span><br><span class="line">2206</span><br><span class="line">2207</span><br><span class="line">2208</span><br><span class="line">2209</span><br><span class="line">2210</span><br><span class="line">2211</span><br><span class="line">2212</span><br><span class="line">2213</span><br><span class="line">2214</span><br><span class="line">2215</span><br><span class="line">2216</span><br><span class="line">2217</span><br><span class="line">2218</span><br><span class="line">2219</span><br><span class="line">2220</span><br><span class="line">2221</span><br><span class="line">2222</span><br><span class="line">2223</span><br><span class="line">2224</span><br><span class="line">2225</span><br><span class="line">2226</span><br><span class="line">2227</span><br><span class="line">2228</span><br><span class="line">2229</span><br><span class="line">2230</span><br><span class="line">2231</span><br><span class="line">2232</span><br><span class="line">2233</span><br><span class="line">2234</span><br><span class="line">2235</span><br><span class="line">2236</span><br><span class="line">2237</span><br><span class="line">2238</span><br><span class="line">2239</span><br><span class="line">2240</span><br><span class="line">2241</span><br><span class="line">2242</span><br><span class="line">2243</span><br><span class="line">2244</span><br><span class="line">2245</span><br><span class="line">2246</span><br><span class="line">2247</span><br><span class="line">2248</span><br><span class="line">2249</span><br><span class="line">2250</span><br><span class="line">2251</span><br><span class="line">2252</span><br><span class="line">2253</span><br><span class="line">2254</span><br><span class="line">2255</span><br><span class="line">2256</span><br><span class="line">2257</span><br><span class="line">2258</span><br><span class="line">2259</span><br><span class="line">2260</span><br><span class="line">2261</span><br><span class="line">2262</span><br><span class="line">2263</span><br><span class="line">2264</span><br><span class="line">2265</span><br><span class="line">2266</span><br><span class="line">2267</span><br><span class="line">2268</span><br><span class="line">2269</span><br><span class="line">2270</span><br><span class="line">2271</span><br><span class="line">2272</span><br><span class="line">2273</span><br><span class="line">2274</span><br><span class="line">2275</span><br><span class="line">2276</span><br><span class="line">2277</span><br><span class="line">2278</span><br><span class="line">2279</span><br><span class="line">2280</span><br><span class="line">2281</span><br><span class="line">2282</span><br><span class="line">2283</span><br><span class="line">2284</span><br><span class="line">2285</span><br><span class="line">2286</span><br><span class="line">2287</span><br><span class="line">2288</span><br><span class="line">2289</span><br><span class="line">2290</span><br><span class="line">2291</span><br><span class="line">2292</span><br><span class="line">2293</span><br><span class="line">2294</span><br><span class="line">2295</span><br><span class="line">2296</span><br><span class="line">2297</span><br><span class="line">2298</span><br><span class="line">2299</span><br><span class="line">2300</span><br><span class="line">2301</span><br><span class="line">2302</span><br><span class="line">2303</span><br><span class="line">2304</span><br><span class="line">2305</span><br><span class="line">2306</span><br><span class="line">2307</span><br><span class="line">2308</span><br><span class="line">2309</span><br><span class="line">2310</span><br><span class="line">2311</span><br><span class="line">2312</span><br><span class="line">2313</span><br><span class="line">2314</span><br><span class="line">2315</span><br><span class="line">2316</span><br><span class="line">2317</span><br><span class="line">2318</span><br><span class="line">2319</span><br><span class="line">2320</span><br><span class="line">2321</span><br><span class="line">2322</span><br><span class="line">2323</span><br><span class="line">2324</span><br><span class="line">2325</span><br><span class="line">2326</span><br><span class="line">2327</span><br><span class="line">2328</span><br><span class="line">2329</span><br><span class="line">2330</span><br><span class="line">2331</span><br><span class="line">2332</span><br><span class="line">2333</span><br><span class="line">2334</span><br><span class="line">2335</span><br><span class="line">2336</span><br><span class="line">2337</span><br><span class="line">2338</span><br><span class="line">2339</span><br><span class="line">2340</span><br><span class="line">2341</span><br><span class="line">2342</span><br><span class="line">2343</span><br><span class="line">2344</span><br><span class="line">2345</span><br><span class="line">2346</span><br><span class="line">2347</span><br><span class="line">2348</span><br><span class="line">2349</span><br><span class="line">2350</span><br><span class="line">2351</span><br><span class="line">2352</span><br><span class="line">2353</span><br><span class="line">2354</span><br><span class="line">2355</span><br><span class="line">2356</span><br><span class="line">2357</span><br><span class="line">2358</span><br><span class="line">2359</span><br><span class="line">2360</span><br><span class="line">2361</span><br><span class="line">2362</span><br><span class="line">2363</span><br><span class="line">2364</span><br><span class="line">2365</span><br><span class="line">2366</span><br><span class="line">2367</span><br><span class="line">2368</span><br><span class="line">2369</span><br><span class="line">2370</span><br><span class="line">2371</span><br><span class="line">2372</span><br><span class="line">2373</span><br><span class="line">2374</span><br><span class="line">2375</span><br><span class="line">2376</span><br><span class="line">2377</span><br><span class="line">2378</span><br><span class="line">2379</span><br><span class="line">2380</span><br><span class="line">2381</span><br><span class="line">2382</span><br><span class="line">2383</span><br><span class="line">2384</span><br><span class="line">2385</span><br><span class="line">2386</span><br><span class="line">2387</span><br><span class="line">2388</span><br><span class="line">2389</span><br><span class="line">2390</span><br><span class="line">2391</span><br><span class="line">2392</span><br><span class="line">2393</span><br><span class="line">2394</span><br><span class="line">2395</span><br><span class="line">2396</span><br><span class="line">2397</span><br><span class="line">2398</span><br><span class="line">2399</span><br><span class="line">2400</span><br><span class="line">2401</span><br><span class="line">2402</span><br><span class="line">2403</span><br><span class="line">2404</span><br><span class="line">2405</span><br><span class="line">2406</span><br><span class="line">2407</span><br><span class="line">2408</span><br><span class="line">2409</span><br><span class="line">2410</span><br><span class="line">2411</span><br><span class="line">2412</span><br><span class="line">2413</span><br><span class="line">2414</span><br><span class="line">2415</span><br><span class="line">2416</span><br><span class="line">2417</span><br><span class="line">2418</span><br><span class="line">2419</span><br><span class="line">2420</span><br><span class="line">2421</span><br><span class="line">2422</span><br><span class="line">2423</span><br><span class="line">2424</span><br><span class="line">2425</span><br><span class="line">2426</span><br><span class="line">2427</span><br><span class="line">2428</span><br><span class="line">2429</span><br><span class="line">2430</span><br><span class="line">2431</span><br><span class="line">2432</span><br><span class="line">2433</span><br><span class="line">2434</span><br><span class="line">2435</span><br><span class="line">2436</span><br><span class="line">2437</span><br><span class="line">2438</span><br><span class="line">2439</span><br><span class="line">2440</span><br><span class="line">2441</span><br><span class="line">2442</span><br><span class="line">2443</span><br><span class="line">2444</span><br><span class="line">2445</span><br><span class="line">2446</span><br><span class="line">2447</span><br><span class="line">2448</span><br><span class="line">2449</span><br><span class="line">2450</span><br><span class="line">2451</span><br><span class="line">2452</span><br><span class="line">2453</span><br><span class="line">2454</span><br><span class="line">2455</span><br><span class="line">2456</span><br><span class="line">2457</span><br><span class="line">2458</span><br><span class="line">2459</span><br><span class="line">2460</span><br><span class="line">2461</span><br><span class="line">2462</span><br><span class="line">2463</span><br><span class="line">2464</span><br><span class="line">2465</span><br><span class="line">2466</span><br><span class="line">2467</span><br><span class="line">2468</span><br><span class="line">2469</span><br><span class="line">2470</span><br><span class="line">2471</span><br><span class="line">2472</span><br><span class="line">2473</span><br><span class="line">2474</span><br><span class="line">2475</span><br><span class="line">2476</span><br><span class="line">2477</span><br><span class="line">2478</span><br><span class="line">2479</span><br><span class="line">2480</span><br><span class="line">2481</span><br><span class="line">2482</span><br><span class="line">2483</span><br><span class="line">2484</span><br><span class="line">2485</span><br><span class="line">2486</span><br><span class="line">2487</span><br><span class="line">2488</span><br><span class="line">2489</span><br><span class="line">2490</span><br><span class="line">2491</span><br><span class="line">2492</span><br><span class="line">2493</span><br><span class="line">2494</span><br><span class="line">2495</span><br><span class="line">2496</span><br><span class="line">2497</span><br><span class="line">2498</span><br><span class="line">2499</span><br><span class="line">2500</span><br><span class="line">2501</span><br><span class="line">2502</span><br><span class="line">2503</span><br><span class="line">2504</span><br><span class="line">2505</span><br><span class="line">2506</span><br><span class="line">2507</span><br><span class="line">2508</span><br><span class="line">2509</span><br><span class="line">2510</span><br><span class="line">2511</span><br><span class="line">2512</span><br><span class="line">2513</span><br><span class="line">2514</span><br><span class="line">2515</span><br><span class="line">2516</span><br><span class="line">2517</span><br><span class="line">2518</span><br><span class="line">2519</span><br><span class="line">2520</span><br><span class="line">2521</span><br><span class="line">2522</span><br><span class="line">2523</span><br><span class="line">2524</span><br><span class="line">2525</span><br><span class="line">2526</span><br><span class="line">2527</span><br><span class="line">2528</span><br><span class="line">2529</span><br><span class="line">2530</span><br><span class="line">2531</span><br><span class="line">2532</span><br><span class="line">2533</span><br><span class="line">2534</span><br><span class="line">2535</span><br><span class="line">2536</span><br><span class="line">2537</span><br><span class="line">2538</span><br><span class="line">2539</span><br><span class="line">2540</span><br><span class="line">2541</span><br><span class="line">2542</span><br><span class="line">2543</span><br><span class="line">2544</span><br><span class="line">2545</span><br><span class="line">2546</span><br><span class="line">2547</span><br><span class="line">2548</span><br><span class="line">2549</span><br><span class="line">2550</span><br><span class="line">2551</span><br><span class="line">2552</span><br><span class="line">2553</span><br><span class="line">2554</span><br><span class="line">2555</span><br><span class="line">2556</span><br><span class="line">2557</span><br><span class="line">2558</span><br><span class="line">2559</span><br><span class="line">2560</span><br><span class="line">2561</span><br><span class="line">2562</span><br><span class="line">2563</span><br><span class="line">2564</span><br><span class="line">2565</span><br><span class="line">2566</span><br><span class="line">2567</span><br><span class="line">2568</span><br><span class="line">2569</span><br><span class="line">2570</span><br><span class="line">2571</span><br><span class="line">2572</span><br><span class="line">2573</span><br><span class="line">2574</span><br><span class="line">2575</span><br><span class="line">2576</span><br><span class="line">2577</span><br><span class="line">2578</span><br><span class="line">2579</span><br><span class="line">2580</span><br><span class="line">2581</span><br><span class="line">2582</span><br><span class="line">2583</span><br><span class="line">2584</span><br><span class="line">2585</span><br><span class="line">2586</span><br><span class="line">2587</span><br><span class="line">2588</span><br><span class="line">2589</span><br><span class="line">2590</span><br><span class="line">2591</span><br><span class="line">2592</span><br><span class="line">2593</span><br><span class="line">2594</span><br><span class="line">2595</span><br><span class="line">2596</span><br><span class="line">2597</span><br><span class="line">2598</span><br><span class="line">2599</span><br><span class="line">2600</span><br><span class="line">2601</span><br><span class="line">2602</span><br><span class="line">2603</span><br><span class="line">2604</span><br><span class="line">2605</span><br><span class="line">2606</span><br><span class="line">2607</span><br><span class="line">2608</span><br><span class="line">2609</span><br><span class="line">2610</span><br><span class="line">2611</span><br><span class="line">2612</span><br><span class="line">2613</span><br><span class="line">2614</span><br><span class="line">2615</span><br><span class="line">2616</span><br><span class="line">2617</span><br><span class="line">2618</span><br><span class="line">2619</span><br><span class="line">2620</span><br><span class="line">2621</span><br><span class="line">2622</span><br><span class="line">2623</span><br><span class="line">2624</span><br><span class="line">2625</span><br><span class="line">2626</span><br><span class="line">2627</span><br><span class="line">2628</span><br><span class="line">2629</span><br><span class="line">2630</span><br><span class="line">2631</span><br><span class="line">2632</span><br><span class="line">2633</span><br><span class="line">2634</span><br><span class="line">2635</span><br><span class="line">2636</span><br><span class="line">2637</span><br><span class="line">2638</span><br><span class="line">2639</span><br><span class="line">2640</span><br><span class="line">2641</span><br><span class="line">2642</span><br><span class="line">2643</span><br><span class="line">2644</span><br><span class="line">2645</span><br><span class="line">2646</span><br><span class="line">2647</span><br><span class="line">2648</span><br><span class="line">2649</span><br><span class="line">2650</span><br><span class="line">2651</span><br><span class="line">2652</span><br><span class="line">2653</span><br><span class="line">2654</span><br><span class="line">2655</span><br><span class="line">2656</span><br><span class="line">2657</span><br><span class="line">2658</span><br><span class="line">2659</span><br><span class="line">2660</span><br><span class="line">2661</span><br><span class="line">2662</span><br><span class="line">2663</span><br><span class="line">2664</span><br><span class="line">2665</span><br><span class="line">2666</span><br><span class="line">2667</span><br><span class="line">2668</span><br><span class="line">2669</span><br><span class="line">2670</span><br><span class="line">2671</span><br><span class="line">2672</span><br><span class="line">2673</span><br><span class="line">2674</span><br><span class="line">2675</span><br><span class="line">2676</span><br><span class="line">2677</span><br><span class="line">2678</span><br><span class="line">2679</span><br><span class="line">2680</span><br><span class="line">2681</span><br><span class="line">2682</span><br><span class="line">2683</span><br><span class="line">2684</span><br><span class="line">2685</span><br><span class="line">2686</span><br><span class="line">2687</span><br><span class="line">2688</span><br><span class="line">2689</span><br><span class="line">2690</span><br><span class="line">2691</span><br><span class="line">2692</span><br><span class="line">2693</span><br><span class="line">2694</span><br><span class="line">2695</span><br><span class="line">2696</span><br><span class="line">2697</span><br><span class="line">2698</span><br><span class="line">2699</span><br><span class="line">2700</span><br><span class="line">2701</span><br><span class="line">2702</span><br><span class="line">2703</span><br><span class="line">2704</span><br><span class="line">2705</span><br><span class="line">2706</span><br><span class="line">2707</span><br><span class="line">2708</span><br><span class="line">2709</span><br><span class="line">2710</span><br><span class="line">2711</span><br><span class="line">2712</span><br><span class="line">2713</span><br><span class="line">2714</span><br><span class="line">2715</span><br><span class="line">2716</span><br><span class="line">2717</span><br><span class="line">2718</span><br><span class="line">2719</span><br><span class="line">2720</span><br><span class="line">2721</span><br><span class="line">2722</span><br><span class="line">2723</span><br><span class="line">2724</span><br><span class="line">2725</span><br><span class="line">2726</span><br><span class="line">2727</span><br><span class="line">2728</span><br><span class="line">2729</span><br><span class="line">2730</span><br><span class="line">2731</span><br><span class="line">2732</span><br><span class="line">2733</span><br><span class="line">2734</span><br><span class="line">2735</span><br><span class="line">2736</span><br><span class="line">2737</span><br><span class="line">2738</span><br><span class="line">2739</span><br><span class="line">2740</span><br><span class="line">2741</span><br><span class="line">2742</span><br><span class="line">2743</span><br><span class="line">2744</span><br><span class="line">2745</span><br><span class="line">2746</span><br><span class="line">2747</span><br><span class="line">2748</span><br><span class="line">2749</span><br><span class="line">2750</span><br><span class="line">2751</span><br><span class="line">2752</span><br><span class="line">2753</span><br><span class="line">2754</span><br><span class="line">2755</span><br><span class="line">2756</span><br><span class="line">2757</span><br><span class="line">2758</span><br><span class="line">2759</span><br><span class="line">2760</span><br><span class="line">2761</span><br><span class="line">2762</span><br><span class="line">2763</span><br><span class="line">2764</span><br><span class="line">2765</span><br><span class="line">2766</span><br><span class="line">2767</span><br><span class="line">2768</span><br><span class="line">2769</span><br><span class="line">2770</span><br><span class="line">2771</span><br><span class="line">2772</span><br><span class="line">2773</span><br><span class="line">2774</span><br><span class="line">2775</span><br><span class="line">2776</span><br><span class="line">2777</span><br><span class="line">2778</span><br><span class="line">2779</span><br><span class="line">2780</span><br><span class="line">2781</span><br><span class="line">2782</span><br><span class="line">2783</span><br><span class="line">2784</span><br><span class="line">2785</span><br><span class="line">2786</span><br><span class="line">2787</span><br><span class="line">2788</span><br><span class="line">2789</span><br><span class="line">2790</span><br><span class="line">2791</span><br><span class="line">2792</span><br><span class="line">2793</span><br><span class="line">2794</span><br><span class="line">2795</span><br><span class="line">2796</span><br><span class="line">2797</span><br><span class="line">2798</span><br><span class="line">2799</span><br><span class="line">2800</span><br><span class="line">2801</span><br><span class="line">2802</span><br><span class="line">2803</span><br><span class="line">2804</span><br><span class="line">2805</span><br><span class="line">2806</span><br><span class="line">2807</span><br><span class="line">2808</span><br><span class="line">2809</span><br><span class="line">2810</span><br><span class="line">2811</span><br><span class="line">2812</span><br><span class="line">2813</span><br><span class="line">2814</span><br><span class="line">2815</span><br><span class="line">2816</span><br><span class="line">2817</span><br><span class="line">2818</span><br><span class="line">2819</span><br><span class="line">2820</span><br><span class="line">2821</span><br><span class="line">2822</span><br><span class="line">2823</span><br><span class="line">2824</span><br><span class="line">2825</span><br><span class="line">2826</span><br><span class="line">2827</span><br><span class="line">2828</span><br><span class="line">2829</span><br><span class="line">2830</span><br><span class="line">2831</span><br><span class="line">2832</span><br><span class="line">2833</span><br><span class="line">2834</span><br><span class="line">2835</span><br><span class="line">2836</span><br><span class="line">2837</span><br><span class="line">2838</span><br><span class="line">2839</span><br><span class="line">2840</span><br><span class="line">2841</span><br><span class="line">2842</span><br><span class="line">2843</span><br><span class="line">2844</span><br><span class="line">2845</span><br><span class="line">2846</span><br><span class="line">2847</span><br><span class="line">2848</span><br><span class="line">2849</span><br><span class="line">2850</span><br><span class="line">2851</span><br><span class="line">2852</span><br><span class="line">2853</span><br><span class="line">2854</span><br><span class="line">2855</span><br><span class="line">2856</span><br><span class="line">2857</span><br><span class="line">2858</span><br><span class="line">2859</span><br><span class="line">2860</span><br><span class="line">2861</span><br><span class="line">2862</span><br><span class="line">2863</span><br><span class="line">2864</span><br><span class="line">2865</span><br><span class="line">2866</span><br><span class="line">2867</span><br><span class="line">2868</span><br><span class="line">2869</span><br><span class="line">2870</span><br><span class="line">2871</span><br><span class="line">2872</span><br><span class="line">2873</span><br><span class="line">2874</span><br><span class="line">2875</span><br><span class="line">2876</span><br><span class="line">2877</span><br><span class="line">2878</span><br><span class="line">2879</span><br><span class="line">2880</span><br><span class="line">2881</span><br><span class="line">2882</span><br><span class="line">2883</span><br><span class="line">2884</span><br><span class="line">2885</span><br><span class="line">2886</span><br><span class="line">2887</span><br><span class="line">2888</span><br><span class="line">2889</span><br><span class="line">2890</span><br><span class="line">2891</span><br><span class="line">2892</span><br><span class="line">2893</span><br><span class="line">2894</span><br><span class="line">2895</span><br><span class="line">2896</span><br><span class="line">2897</span><br><span class="line">2898</span><br><span class="line">2899</span><br><span class="line">2900</span><br><span class="line">2901</span><br><span class="line">2902</span><br><span class="line">2903</span><br><span class="line">2904</span><br><span class="line">2905</span><br><span class="line">2906</span><br><span class="line">2907</span><br><span class="line">2908</span><br><span class="line">2909</span><br><span class="line">2910</span><br><span class="line">2911</span><br><span class="line">2912</span><br><span class="line">2913</span><br><span class="line">2914</span><br><span class="line">2915</span><br><span class="line">2916</span><br><span class="line">2917</span><br><span class="line">2918</span><br><span class="line">2919</span><br><span class="line">2920</span><br><span class="line">2921</span><br><span class="line">2922</span><br><span class="line">2923</span><br><span class="line">2924</span><br><span class="line">2925</span><br><span class="line">2926</span><br><span class="line">2927</span><br><span class="line">2928</span><br><span class="line">2929</span><br><span class="line">2930</span><br><span class="line">2931</span><br><span class="line">2932</span><br><span class="line">2933</span><br><span class="line">2934</span><br><span class="line">2935</span><br><span class="line">2936</span><br><span class="line">2937</span><br><span class="line">2938</span><br><span class="line">2939</span><br><span class="line">2940</span><br><span class="line">2941</span><br><span class="line">2942</span><br><span class="line">2943</span><br><span class="line">2944</span><br><span class="line">2945</span><br><span class="line">2946</span><br><span class="line">2947</span><br><span class="line">2948</span><br><span class="line">2949</span><br><span class="line">2950</span><br><span class="line">2951</span><br><span class="line">2952</span><br><span class="line">2953</span><br><span class="line">2954</span><br><span class="line">2955</span><br><span class="line">2956</span><br><span class="line">2957</span><br><span class="line">2958</span><br><span class="line">2959</span><br><span class="line">2960</span><br><span class="line">2961</span><br><span class="line">2962</span><br><span class="line">2963</span><br><span class="line">2964</span><br><span class="line">2965</span><br><span class="line">2966</span><br><span class="line">2967</span><br><span class="line">2968</span><br><span class="line">2969</span><br><span class="line">2970</span><br><span class="line">2971</span><br><span class="line">2972</span><br><span class="line">2973</span><br><span class="line">2974</span><br><span class="line">2975</span><br><span class="line">2976</span><br><span class="line">2977</span><br><span class="line">2978</span><br><span class="line">2979</span><br><span class="line">2980</span><br><span class="line">2981</span><br><span class="line">2982</span><br><span class="line">2983</span><br><span class="line">2984</span><br><span class="line">2985</span><br><span class="line">2986</span><br><span class="line">2987</span><br><span class="line">2988</span><br><span class="line">2989</span><br><span class="line">2990</span><br><span class="line">2991</span><br><span class="line">2992</span><br><span class="line">2993</span><br><span class="line">2994</span><br><span class="line">2995</span><br><span class="line">2996</span><br><span class="line">2997</span><br><span class="line">2998</span><br><span class="line">2999</span><br><span class="line">3000</span><br><span class="line">3001</span><br><span class="line">3002</span><br><span class="line">3003</span><br><span class="line">3004</span><br><span class="line">3005</span><br><span class="line">3006</span><br><span class="line">3007</span><br><span class="line">3008</span><br><span class="line">3009</span><br><span class="line">3010</span><br><span class="line">3011</span><br><span class="line">3012</span><br><span class="line">3013</span><br><span class="line">3014</span><br><span class="line">3015</span><br><span class="line">3016</span><br><span class="line">3017</span><br><span class="line">3018</span><br><span class="line">3019</span><br><span class="line">3020</span><br><span class="line">3021</span><br><span class="line">3022</span><br><span class="line">3023</span><br><span class="line">3024</span><br><span class="line">3025</span><br><span class="line">3026</span><br><span class="line">3027</span><br><span class="line">3028</span><br><span class="line">3029</span><br><span class="line">3030</span><br><span class="line">3031</span><br><span class="line">3032</span><br><span class="line">3033</span><br><span class="line">3034</span><br><span class="line">3035</span><br><span class="line">3036</span><br><span class="line">3037</span><br><span class="line">3038</span><br><span class="line">3039</span><br><span class="line">3040</span><br><span class="line">3041</span><br><span class="line">3042</span><br><span class="line">3043</span><br><span class="line">3044</span><br><span class="line">3045</span><br><span class="line">3046</span><br><span class="line">3047</span><br><span class="line">3048</span><br><span class="line">3049</span><br><span class="line">3050</span><br><span class="line">3051</span><br><span class="line">3052</span><br><span class="line">3053</span><br><span class="line">3054</span><br><span class="line">3055</span><br><span class="line">3056</span><br><span class="line">3057</span><br><span class="line">3058</span><br><span class="line">3059</span><br><span class="line">3060</span><br><span class="line">3061</span><br><span class="line">3062</span><br><span class="line">3063</span><br><span class="line">3064</span><br><span class="line">3065</span><br><span class="line">3066</span><br><span class="line">3067</span><br><span class="line">3068</span><br><span class="line">3069</span><br><span class="line">3070</span><br><span class="line">3071</span><br><span class="line">3072</span><br><span class="line">3073</span><br><span class="line">3074</span><br><span class="line">3075</span><br><span class="line">3076</span><br><span class="line">3077</span><br><span class="line">3078</span><br><span class="line">3079</span><br><span class="line">3080</span><br><span class="line">3081</span><br><span class="line">3082</span><br><span class="line">3083</span><br><span class="line">3084</span><br><span class="line">3085</span><br><span class="line">3086</span><br><span class="line">3087</span><br><span class="line">3088</span><br><span class="line">3089</span><br><span class="line">3090</span><br><span class="line">3091</span><br><span class="line">3092</span><br><span class="line">3093</span><br><span class="line">3094</span><br><span class="line">3095</span><br><span class="line">3096</span><br><span class="line">3097</span><br><span class="line">3098</span><br><span class="line">3099</span><br><span class="line">3100</span><br><span class="line">3101</span><br><span class="line">3102</span><br><span class="line">3103</span><br><span class="line">3104</span><br><span class="line">3105</span><br><span class="line">3106</span><br><span class="line">3107</span><br><span class="line">3108</span><br><span class="line">3109</span><br><span class="line">3110</span><br><span class="line">3111</span><br><span class="line">3112</span><br><span class="line">3113</span><br><span class="line">3114</span><br><span class="line">3115</span><br><span class="line">3116</span><br><span class="line">3117</span><br><span class="line">3118</span><br><span class="line">3119</span><br><span class="line">3120</span><br><span class="line">3121</span><br><span class="line">3122</span><br><span class="line">3123</span><br><span class="line">3124</span><br><span class="line">3125</span><br><span class="line">3126</span><br><span class="line">3127</span><br><span class="line">3128</span><br><span class="line">3129</span><br><span class="line">3130</span><br><span class="line">3131</span><br><span class="line">3132</span><br><span class="line">3133</span><br><span class="line">3134</span><br><span class="line">3135</span><br><span class="line">3136</span><br><span class="line">3137</span><br><span class="line">3138</span><br><span class="line">3139</span><br><span class="line">3140</span><br><span class="line">3141</span><br><span class="line">3142</span><br><span class="line">3143</span><br><span class="line">3144</span><br><span class="line">3145</span><br><span class="line">3146</span><br><span class="line">3147</span><br><span class="line">3148</span><br><span class="line">3149</span><br><span class="line">3150</span><br><span class="line">3151</span><br><span class="line">3152</span><br><span class="line">3153</span><br><span class="line">3154</span><br><span class="line">3155</span><br><span class="line">3156</span><br><span class="line">3157</span><br><span class="line">3158</span><br><span class="line">3159</span><br><span class="line">3160</span><br><span class="line">3161</span><br><span class="line">3162</span><br><span class="line">3163</span><br><span class="line">3164</span><br><span class="line">3165</span><br><span class="line">3166</span><br><span class="line">3167</span><br><span class="line">3168</span><br><span class="line">3169</span><br><span class="line">3170</span><br><span class="line">3171</span><br><span class="line">3172</span><br><span class="line">3173</span><br><span class="line">3174</span><br><span class="line">3175</span><br><span class="line">3176</span><br><span class="line">3177</span><br><span class="line">3178</span><br><span class="line">3179</span><br><span class="line">3180</span><br><span class="line">3181</span><br><span class="line">3182</span><br><span class="line">3183</span><br><span class="line">3184</span><br><span class="line">3185</span><br><span class="line">3186</span><br><span class="line">3187</span><br><span class="line">3188</span><br><span class="line">3189</span><br><span class="line">3190</span><br><span class="line">3191</span><br><span class="line">3192</span><br><span class="line">3193</span><br><span class="line">3194</span><br><span class="line">3195</span><br><span class="line">3196</span><br><span class="line">3197</span><br><span class="line">3198</span><br><span class="line">3199</span><br><span class="line">3200</span><br><span class="line">3201</span><br><span class="line">3202</span><br><span class="line">3203</span><br><span class="line">3204</span><br><span class="line">3205</span><br><span class="line">3206</span><br><span class="line">3207</span><br><span class="line">3208</span><br><span class="line">3209</span><br><span class="line">3210</span><br><span class="line">3211</span><br><span class="line">3212</span><br><span class="line">3213</span><br><span class="line">3214</span><br><span class="line">3215</span><br><span class="line">3216</span><br><span class="line">3217</span><br><span class="line">3218</span><br><span class="line">3219</span><br><span class="line">3220</span><br><span class="line">3221</span><br><span class="line">3222</span><br><span class="line">3223</span><br><span class="line">3224</span><br><span class="line">3225</span><br><span class="line">3226</span><br><span class="line">3227</span><br><span class="line">3228</span><br><span class="line">3229</span><br><span class="line">3230</span><br><span class="line">3231</span><br><span class="line">3232</span><br><span class="line">3233</span><br><span class="line">3234</span><br><span class="line">3235</span><br><span class="line">3236</span><br><span class="line">3237</span><br><span class="line">3238</span><br><span class="line">3239</span><br><span class="line">3240</span><br></pre></td><td class="code"><pre><span class="line">final class DualPivotQuicksort &#123;</span><br><span class="line">       private DualPivotQuicksort() &#123;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       /**</span><br><span class="line">        * 合并排序中的最大运行次数</span><br><span class="line">        */</span><br><span class="line">       private static final int MAX_RUN_COUNT = 67;</span><br><span class="line"></span><br><span class="line">       /**</span><br><span class="line">        * 合并排序中运行的最大长度。</span><br><span class="line">        */</span><br><span class="line">       private static final int MAX_RUN_LENGTH = 33;</span><br><span class="line"></span><br><span class="line">       /**</span><br><span class="line">        * 如果要排序的数组的长度小于此值常量，快速排序优先用于合并排序。</span><br><span class="line">        */</span><br><span class="line">       private static final int QUICKSORT_THRESHOLD = 286;</span><br><span class="line"></span><br><span class="line">       /**</span><br><span class="line">        * 如果要排序的数组的长度小于此常量，则插入排序优先于快速排序。</span><br><span class="line">        */</span><br><span class="line">       private static final int INSERTION_SORT_THRESHOLD = 47;</span><br><span class="line"></span><br><span class="line">       /**</span><br><span class="line">        * 如果要排序的字节数组的长度大于此常量，则使用计数排序优先于插入排序。</span><br><span class="line">        */</span><br><span class="line">       private static final int COUNTING_SORT_THRESHOLD_FOR_BYTE = 29;</span><br><span class="line"></span><br><span class="line">       /**</span><br><span class="line">        * 如果要排序的短数组或字符数组的长度大于此常量，则计数排序优先于快速排序。</span><br><span class="line">        */</span><br><span class="line">       private static final int COUNTING_SORT_THRESHOLD_FOR_SHORT_OR_CHAR = 3200;</span><br><span class="line"></span><br><span class="line">       /**</span><br><span class="line">        * 如果可以合并，请使用给定的工作区数组切片对数组的指定范围进行排序</span><br><span class="line">        *</span><br><span class="line">        * @param a        要排序的数组</span><br><span class="line">        * @param left     排序开始位置</span><br><span class="line">        * @param right    排序结束位置</span><br><span class="line">        * @param work     工作区数组（切片）</span><br><span class="line">        * @param workBase 工作阵列中可用空间的原点</span><br><span class="line">        * @param workLen  工作阵列的可用大小</span><br><span class="line">        */</span><br><span class="line">        static void sort(int[] a, int left, int right,</span><br><span class="line">                        int[] work, int workBase, int workLen) &#123;</span><br><span class="line">           // 在小数组上使用快速排序</span><br><span class="line">           if (right - left &lt; QUICKSORT_THRESHOLD) &#123;</span><br><span class="line">               sort(a, left, right, true);</span><br><span class="line">               return;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       /*</span><br><span class="line">        * 索引运行[i]是第i次运行的开始（升序或降序）。</span><br><span class="line">        */</span><br><span class="line">           int[] run = new int[MAX_RUN_COUNT + 1];</span><br><span class="line">           int count = 0;</span><br><span class="line">           run[0] = left;</span><br><span class="line"></span><br><span class="line">           // 检查数组是否接近排序</span><br><span class="line">           for (int k = left; k &lt; right; run[count] = k) &#123;</span><br><span class="line">               if (a[k] &lt; a[k + 1]) &#123; //</span><br><span class="line">                   while (++k &lt;= right &amp;&amp; a[k - 1] &lt;= a[k]) ;</span><br><span class="line">               &#125; else if (a[k] &gt; a[k + 1]) &#123; // descending</span><br><span class="line">                   while (++k &lt;= right &amp;&amp; a[k - 1] &gt;= a[k]) ;</span><br><span class="line">                   for (int lo = run[count] - 1, hi = k; ++lo &lt; --hi; ) &#123;</span><br><span class="line">                       int t = a[lo];</span><br><span class="line">                       a[lo] = a[hi];</span><br><span class="line">                       a[hi] = t;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">                   for (int m = MAX_RUN_LENGTH; ++k &lt;= right &amp;&amp; a[k - 1] == a[k]; ) &#123;</span><br><span class="line">                       if (--m == 0) &#123;</span><br><span class="line">                           sort(a, left, right, true);</span><br><span class="line">                           return;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">           /*</span><br><span class="line">            * 数组不是高度结构化的，请使用快速排序而不是合并排序。</span><br><span class="line">            */</span><br><span class="line">               if (++count == MAX_RUN_COUNT) &#123;</span><br><span class="line">                   sort(a, left, right, true);</span><br><span class="line">                   return;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // 检查特殊情况</span><br><span class="line">           // 实施说明：变量“right”增加1。</span><br><span class="line">           if (run[count] == right++) &#123; // 上次运行包含一个元素</span><br><span class="line">               run[++count] = right;</span><br><span class="line">           &#125; else if (count == 1) &#123; // 数组已排序</span><br><span class="line">               return;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // 确定合并的替换基</span><br><span class="line">           byte odd = 0;</span><br><span class="line">           for (int n = 1; (n &lt;&lt;= 1) &lt; count; odd ^= 1) ;</span><br><span class="line"></span><br><span class="line">           // 使用或创建用于合并的临时数组B</span><br><span class="line">           int[] b;                 // 临时数组；替换为 a</span><br><span class="line">           int ao, bo;              // 从“左”开始的数组偏移量</span><br><span class="line">           int blen = right - left; // B所需空间</span><br><span class="line">           if (work == null || workLen &lt; blen || workBase + blen &gt; work.length) &#123;</span><br><span class="line">               work = new int[blen];</span><br><span class="line">               workBase = 0;</span><br><span class="line">           &#125;</span><br><span class="line">           if (odd == 0) &#123;</span><br><span class="line">               System.arraycopy(a, left, work, workBase, blen);</span><br><span class="line">               b = a;</span><br><span class="line">               bo = 0;</span><br><span class="line">               a = work;</span><br><span class="line">               ao = workBase - left;</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               b = work;</span><br><span class="line">               ao = 0;</span><br><span class="line">               bo = workBase - left;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // 合并</span><br><span class="line">           for (int last; count &gt; 1; count = last) &#123;</span><br><span class="line">               for (int k = (last = 0) + 2; k &lt;= count; k += 2) &#123;</span><br><span class="line">                   int hi = run[k], mi = run[k - 1];</span><br><span class="line">                   for (int i = run[k - 2], p = i, q = mi; i &lt; hi; ++i) &#123;</span><br><span class="line">                       if (q &gt;= hi || p &lt; mi &amp;&amp; a[p + ao] &lt;= a[q + ao]) &#123;</span><br><span class="line">                           b[i + bo] = a[p++ + ao];</span><br><span class="line">                       &#125; else &#123;</span><br><span class="line">                           b[i + bo] = a[q++ + ao];</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">                   run[++last] = hi;</span><br><span class="line">               &#125;</span><br><span class="line">               if ((count &amp; 1) != 0) &#123;</span><br><span class="line">                   for (int i = right, lo = run[count - 1]; --i &gt;= lo;</span><br><span class="line">                        b[i + bo] = a[i + ao]</span><br><span class="line">                           )</span><br><span class="line">                       ;</span><br><span class="line">                   run[++last] = right;</span><br><span class="line">               &#125;</span><br><span class="line">               int[] t = a;</span><br><span class="line">               a = b;</span><br><span class="line">               b = t;</span><br><span class="line">               int o = ao;</span><br><span class="line">               ao = bo;</span><br><span class="line">               bo = o;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       /**</span><br><span class="line">        * 快速排序</span><br><span class="line">        *</span><br><span class="line">        * @param leftmost 指示此部分是否在范围内最左边</span><br><span class="line">        */</span><br><span class="line">       private static void sort(int[] a, int left, int right, boolean leftmost) &#123;</span><br><span class="line">           int length = right - left + 1;</span><br><span class="line"></span><br><span class="line">           // 在小数组上使用插入排序</span><br><span class="line">           if (length &lt; INSERTION_SORT_THRESHOLD) &#123;</span><br><span class="line">               if (leftmost) &#123;</span><br><span class="line">               /*</span><br><span class="line">                * 传统的（不带sentinel）插入排序，针对服务器虚拟机进行了优化，用于最左边的部分。</span><br><span class="line">                */</span><br><span class="line">                   for (int i = left, j = i; i &lt; right; j = ++i) &#123;</span><br><span class="line">                       int ai = a[i + 1];</span><br><span class="line">                       while (ai &lt; a[j]) &#123;</span><br><span class="line">                           a[j + 1] = a[j];</span><br><span class="line">                           if (j-- == left) &#123;</span><br><span class="line">                               break;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                       a[j + 1] = ai;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">               /*</span><br><span class="line">                * 跳过最长的升序。</span><br><span class="line">                */</span><br><span class="line">                   do &#123;</span><br><span class="line">                       if (left &gt;= right) &#123;</span><br><span class="line">                           return;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125; while (a[++left] &gt;= a[left - 1]);</span><br><span class="line"></span><br><span class="line">               /*</span><br><span class="line">                * 相邻部分的每一个元素都扮演着哨兵的角色，</span><br><span class="line">                * 因此这允许我们避免在每次迭代中进行左范围检查。</span><br><span class="line">                * 此外，我们使用了更优化的算法，即对插入排序，</span><br><span class="line">                * 这比传统的插入排序实现更快（在快速排序的上下文中）。</span><br><span class="line">                */</span><br><span class="line">                   for (int k = left; ++left &lt;= right; k = ++left) &#123;</span><br><span class="line">                       int a1 = a[k], a2 = a[left];</span><br><span class="line"></span><br><span class="line">                       if (a1 &lt; a2) &#123;</span><br><span class="line">                           a2 = a1;</span><br><span class="line">                           a1 = a[left];</span><br><span class="line">                       &#125;</span><br><span class="line">                       while (a1 &lt; a[--k]) &#123;</span><br><span class="line">                           a[k + 2] = a[k];</span><br><span class="line">                       &#125;</span><br><span class="line">                       a[++k + 1] = a1;</span><br><span class="line"></span><br><span class="line">                       while (a2 &lt; a[--k]) &#123;</span><br><span class="line">                           a[k + 1] = a[k];</span><br><span class="line">                       &#125;</span><br><span class="line">                       a[k + 1] = a2;</span><br><span class="line">                   &#125;</span><br><span class="line">                   int last = a[right];</span><br><span class="line"></span><br><span class="line">                   while (last &lt; a[--right]) &#123;</span><br><span class="line">                       a[right + 1] = a[right];</span><br><span class="line">                   &#125;</span><br><span class="line">                   a[right + 1] = last;</span><br><span class="line">               &#125;</span><br><span class="line">               return;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // 长度的廉价近似值/7</span><br><span class="line">           int seventh = (length &gt;&gt; 3) + (length &gt;&gt; 6) + 1;</span><br><span class="line"></span><br><span class="line">       /*</span><br><span class="line">        * 在范围内的中心元素周围（包括中心元素）对五个等距元素进行排序。</span><br><span class="line">        * 这些元素将用于如下所述的轴选择。</span><br><span class="line">        * 选择这些元素的间距是根据经验确定的，可以很好地处理各种输入。</span><br><span class="line">        */</span><br><span class="line">           int e3 = (left + right) &gt;&gt;&gt; 1; // The midpoint</span><br><span class="line">           int e2 = e3 - seventh;</span><br><span class="line">           int e1 = e2 - seventh;</span><br><span class="line">           int e4 = e3 + seventh;</span><br><span class="line">           int e5 = e4 + seventh;</span><br><span class="line"></span><br><span class="line">           // 使用插入排序对这些元素排序</span><br><span class="line">           if (a[e2] &lt; a[e1]) &#123;</span><br><span class="line">               int t = a[e2];</span><br><span class="line">               a[e2] = a[e1];</span><br><span class="line">               a[e1] = t;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           if (a[e3] &lt; a[e2]) &#123;</span><br><span class="line">               int t = a[e3];</span><br><span class="line">               a[e3] = a[e2];</span><br><span class="line">               a[e2] = t;</span><br><span class="line">               if (t &lt; a[e1]) &#123;</span><br><span class="line">                   a[e2] = a[e1];</span><br><span class="line">                   a[e1] = t;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           if (a[e4] &lt; a[e3]) &#123;</span><br><span class="line">               int t = a[e4];</span><br><span class="line">               a[e4] = a[e3];</span><br><span class="line">               a[e3] = t;</span><br><span class="line">               if (t &lt; a[e2]) &#123;</span><br><span class="line">                   a[e3] = a[e2];</span><br><span class="line">                   a[e2] = t;</span><br><span class="line">                   if (t &lt; a[e1]) &#123;</span><br><span class="line">                       a[e2] = a[e1];</span><br><span class="line">                       a[e1] = t;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           if (a[e5] &lt; a[e4]) &#123;</span><br><span class="line">               int t = a[e5];</span><br><span class="line">               a[e5] = a[e4];</span><br><span class="line">               a[e4] = t;</span><br><span class="line">               if (t &lt; a[e3]) &#123;</span><br><span class="line">                   a[e4] = a[e3];</span><br><span class="line">                   a[e3] = t;</span><br><span class="line">                   if (t &lt; a[e2]) &#123;</span><br><span class="line">                       a[e3] = a[e2];</span><br><span class="line">                       a[e2] = t;</span><br><span class="line">                       if (t &lt; a[e1]) &#123;</span><br><span class="line">                           a[e2] = a[e1];</span><br><span class="line">                           a[e1] = t;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // 指针</span><br><span class="line">           int less = left;  // 中心部分第一个元素的索引</span><br><span class="line">           int great = right; // 右部分第一个元素前的索引</span><br><span class="line"></span><br><span class="line">           if (a[e1] != a[e2] &amp;&amp; a[e2] != a[e3] &amp;&amp; a[e3] != a[e4] &amp;&amp; a[e4] != a[e5]) &#123;</span><br><span class="line">           /*</span><br><span class="line">            * 使用五个已排序元素中的第二个和第四个元素作为轴心。</span><br><span class="line">            * 这些值是数组第一和第二个词组的廉价近似值。注意，Pivot1&lt;=Pivot2。</span><br><span class="line">            */</span><br><span class="line">               int pivot1 = a[e2];</span><br><span class="line">               int pivot2 = a[e4];</span><br><span class="line"></span><br><span class="line">           /*</span><br><span class="line">            * 要排序的第一个和最后一个元素将移动到以前由枢轴占用的位置。</span><br><span class="line">            * 当分区完成时，数据透视被交换回它们的最终位置，并从随后的排序中排除。</span><br><span class="line">            */</span><br><span class="line">               a[e2] = a[left];</span><br><span class="line">               a[e4] = a[right];</span><br><span class="line"></span><br><span class="line">           /*</span><br><span class="line">            * 跳过小于或大于透视值的元素。</span><br><span class="line">            */</span><br><span class="line">               while (a[++less] &lt; pivot1) ;</span><br><span class="line">               while (a[--great] &gt; pivot2) ;</span><br><span class="line"></span><br><span class="line">           /*</span><br><span class="line">            * 划分:</span><br><span class="line">            *</span><br><span class="line">            *   左边部分           中间部分                   右边部分</span><br><span class="line">            * +--------------------------------------------------------------+</span><br><span class="line">            * |  &lt; pivot1  |  pivot1 &lt;= &amp;&amp; &lt;= pivot2  |    ?    |  &gt; pivot2  |</span><br><span class="line">            * +--------------------------------------------------------------+</span><br><span class="line">            *               ^                          ^       ^</span><br><span class="line">            *               |                          |       |</span><br><span class="line">            *              less                        k     great</span><br><span class="line">            *</span><br><span class="line">            * 不变式:</span><br><span class="line">            *</span><br><span class="line">            *              all in (左边, less)   &lt; pivot1</span><br><span class="line">            *    pivot1 &lt;= all in [less, k)     &lt;= pivot2</span><br><span class="line">            *              all in (great, 右边) &gt; pivot2</span><br><span class="line">            *</span><br><span class="line">            * Pointer k is the first index of ?-part.</span><br><span class="line">            */</span><br><span class="line">               outer:</span><br><span class="line">               for (int k = less - 1; ++k &lt;= great; ) &#123;</span><br><span class="line">                   int ak = a[k];</span><br><span class="line">                   if (ak &lt; pivot1) &#123; // 移动 a[k] 到左边</span><br><span class="line">                       a[k] = a[less];</span><br><span class="line">                   /*</span><br><span class="line">                    * 由于性能问题，这里和我们使用下面的 &quot;a[i] = b; i++;&quot; 而不是&quot;a[i++] = b;&quot;</span><br><span class="line">                    */</span><br><span class="line">                       a[less] = ak;</span><br><span class="line">                       ++less;</span><br><span class="line">                   &#125; else if (ak &gt; pivot2) &#123; // 移动 a[k] to 到右边</span><br><span class="line">                       while (a[great] &gt; pivot2) &#123;</span><br><span class="line">                           if (great-- == k) &#123;</span><br><span class="line">                               break outer;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                       if (a[great] &lt; pivot1) &#123; // a[great] &lt;= pivot2</span><br><span class="line">                           a[k] = a[less];</span><br><span class="line">                           a[less] = a[great];</span><br><span class="line">                           ++less;</span><br><span class="line">                       &#125; else &#123; // pivot1 &lt;= a[great] &lt;= pivot2</span><br><span class="line">                           a[k] = a[great];</span><br><span class="line">                       &#125;</span><br><span class="line">                   /*</span><br><span class="line">                    * 由于性能问题，这里和我们使用下面的 &quot;a[i] = b; i--;&quot;  而不是&quot;a[i--] = b;&quot;</span><br><span class="line">                    */</span><br><span class="line">                       a[great] = ak;</span><br><span class="line">                       --great;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               // 将pivots调到最终位置</span><br><span class="line">               a[left] = a[less - 1];</span><br><span class="line">               a[less - 1] = pivot1;</span><br><span class="line">               a[right] = a[great + 1];</span><br><span class="line">               a[great + 1] = pivot2;</span><br><span class="line"></span><br><span class="line">               // 以递归方式对左右部分排序，不包括已知的数据透视</span><br><span class="line">               sort(a, left, less - 2, leftmost);</span><br><span class="line">               sort(a, great + 2, right, false);</span><br><span class="line"></span><br><span class="line">           /*</span><br><span class="line">            * 如果中心部分太大（包括数组的4/7以上），请将内部轴值交换到末端。</span><br><span class="line">            */</span><br><span class="line">               if (less &lt; e1 &amp;&amp; e5 &lt; great) &#123;</span><br><span class="line">               /*</span><br><span class="line">                * 跳过与透视值相等的元素。</span><br><span class="line">                */</span><br><span class="line">                   while (a[less] == pivot1) &#123;</span><br><span class="line">                       ++less;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   while (a[great] == pivot2) &#123;</span><br><span class="line">                       --great;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">               /*</span><br><span class="line">                * 划分:</span><br><span class="line">                *</span><br><span class="line">                *   左边部分           中间部分                   右边部分</span><br><span class="line">                * +----------------------------------------------------------+</span><br><span class="line">                * | == pivot1 |  pivot1 &lt; &amp;&amp; &lt; pivot2  |    ?    | == pivot2 |</span><br><span class="line">                * +----------------------------------------------------------+</span><br><span class="line">                *              ^                        ^       ^</span><br><span class="line">                *              |                        |       |</span><br><span class="line">                *             less                      k     great</span><br><span class="line">                *</span><br><span class="line">                * 不变式:</span><br><span class="line">                *</span><br><span class="line">                *              all in (*,  less) == pivot1</span><br><span class="line">                *     pivot1 &lt; all in [less,  k)  &lt; pivot2</span><br><span class="line">                *              all in (great, *) == pivot2</span><br><span class="line">                *</span><br><span class="line">                * Pointer k is the first index of ?-part.</span><br><span class="line">                */</span><br><span class="line">                   outer:</span><br><span class="line">                   for (int k = less - 1; ++k &lt;= great; ) &#123;</span><br><span class="line">                       int ak = a[k];</span><br><span class="line">                       if (ak == pivot1) &#123; // 移动 a[k] 到左边</span><br><span class="line">                           a[k] = a[less];</span><br><span class="line">                           a[less] = ak;</span><br><span class="line">                           ++less;</span><br><span class="line">                       &#125; else if (ak == pivot2) &#123; // 移动 a[k] 到右边</span><br><span class="line">                           while (a[great] == pivot2) &#123;</span><br><span class="line">                               if (great-- == k) &#123;</span><br><span class="line">                                   break outer;</span><br><span class="line">                               &#125;</span><br><span class="line">                           &#125;</span><br><span class="line">                           if (a[great] == pivot1) &#123; // a[great] &lt; pivot2</span><br><span class="line">                               a[k] = a[less];</span><br><span class="line">                           /*</span><br><span class="line">                            * 即使[great]等于Pivot1，如果[great]和Pivot1是不同符号的浮点零，</span><br><span class="line">                            * 则赋值a[less]=Pivot1可能不正确。</span><br><span class="line">                            * 因此，在浮动和双重排序方法中，</span><br><span class="line">                            * 我们必须使用更精确的赋值a[less]=a[great]。</span><br><span class="line">                            */</span><br><span class="line">                               a[less] = pivot1;</span><br><span class="line">                               ++less;</span><br><span class="line">                           &#125; else &#123; // pivot1 &lt; a[great] &lt; pivot2</span><br><span class="line">                               a[k] = a[great];</span><br><span class="line">                           &#125;</span><br><span class="line">                           a[great] = ak;</span><br><span class="line">                           --great;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               // 递归排序中心部分</span><br><span class="line">               sort(a, less, great, false);</span><br><span class="line"></span><br><span class="line">           &#125; else &#123; // Partitioning with one pivot</span><br><span class="line">           /*</span><br><span class="line">            * Use the third of the five sorted elements as pivot.</span><br><span class="line">            * This value is inexpensive approximation of the median.</span><br><span class="line">            */</span><br><span class="line">               int pivot = a[e3];</span><br><span class="line"></span><br><span class="line">           /*</span><br><span class="line">            * Partitioning degenerates to the traditional 3-way</span><br><span class="line">            * (or &quot;Dutch National Flag&quot;) schema:</span><br><span class="line">            *</span><br><span class="line">            *   left part    center part              right part</span><br><span class="line">            * +-------------------------------------------------+</span><br><span class="line">            * |  &lt; pivot  |   == pivot   |     ?    |  &gt; pivot  |</span><br><span class="line">            * +-------------------------------------------------+</span><br><span class="line">            *              ^              ^        ^</span><br><span class="line">            *              |              |        |</span><br><span class="line">            *             less            k      great</span><br><span class="line">            *</span><br><span class="line">            * Invariants:</span><br><span class="line">            *</span><br><span class="line">            *   all in (left, less)   &lt; pivot</span><br><span class="line">            *   all in [less, k)     == pivot</span><br><span class="line">            *   all in (great, right) &gt; pivot</span><br><span class="line">            *</span><br><span class="line">            * Pointer k is the first index of ?-part.</span><br><span class="line">            */</span><br><span class="line">               for (int k = less; k &lt;= great; ++k) &#123;</span><br><span class="line">                   if (a[k] == pivot) &#123;</span><br><span class="line">                       continue;</span><br><span class="line">                   &#125;</span><br><span class="line">                   int ak = a[k];</span><br><span class="line">                   if (ak &lt; pivot) &#123; // Move a[k] to left part</span><br><span class="line">                       a[k] = a[less];</span><br><span class="line">                       a[less] = ak;</span><br><span class="line">                       ++less;</span><br><span class="line">                   &#125; else &#123; // a[k] &gt; pivot - Move a[k] to right part</span><br><span class="line">                       while (a[great] &gt; pivot) &#123;</span><br><span class="line">                           --great;</span><br><span class="line">                       &#125;</span><br><span class="line">                       if (a[great] &lt; pivot) &#123; // a[great] &lt;= pivot</span><br><span class="line">                           a[k] = a[less];</span><br><span class="line">                           a[less] = a[great];</span><br><span class="line">                           ++less;</span><br><span class="line">                       &#125; else &#123; // a[great] == pivot</span><br><span class="line">                       /*</span><br><span class="line">                        * Even though a[great] equals to pivot, the</span><br><span class="line">                        * assignment a[k] = pivot may be incorrect,</span><br><span class="line">                        * if a[great] and pivot are floating-point</span><br><span class="line">                        * zeros of different signs. Therefore in float</span><br><span class="line">                        * and double sorting methods we have to use</span><br><span class="line">                        * more accurate assignment a[k] = a[great].</span><br><span class="line">                        */</span><br><span class="line">                           a[k] = pivot;</span><br><span class="line">                       &#125;</span><br><span class="line">                       a[great] = ak;</span><br><span class="line">                       --great;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">           /*</span><br><span class="line">            * Sort left and right parts recursively.</span><br><span class="line">            * All elements from center part are equal</span><br><span class="line">            * and, therefore, already sorted.</span><br><span class="line">            */</span><br><span class="line">               sort(a, left, less - 1, leftmost);</span><br><span class="line">               sort(a, great + 1, right, false);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       /**</span><br><span class="line">        * Sorts the specified range of the array using the given</span><br><span class="line">        * workspace array slice if possible for merging</span><br><span class="line">        *</span><br><span class="line">        * @param a        the array to be sorted</span><br><span class="line">        * @param left     the index of the first element, inclusive, to be sorted</span><br><span class="line">        * @param right    the index of the last element, inclusive, to be sorted</span><br><span class="line">        * @param work     a workspace array (slice)</span><br><span class="line">        * @param workBase origin of usable space in work array</span><br><span class="line">        * @param workLen  usable size of work array</span><br><span class="line">        */</span><br><span class="line">       static void sort(long[] a, int left, int right,</span><br><span class="line">                        long[] work, int workBase, int workLen) &#123;</span><br><span class="line">           // Use Quicksort on small arrays</span><br><span class="line">           if (right - left &lt; QUICKSORT_THRESHOLD) &#123;</span><br><span class="line">               sort(a, left, right, true);</span><br><span class="line">               return;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       /*</span><br><span class="line">        * Index run[i] is the start of i-th run</span><br><span class="line">        * (ascending or descending sequence).</span><br><span class="line">        */</span><br><span class="line">           int[] run = new int[MAX_RUN_COUNT + 1];</span><br><span class="line">           int count = 0;</span><br><span class="line">           run[0] = left;</span><br><span class="line"></span><br><span class="line">           // Check if the array is nearly sorted</span><br><span class="line">           for (int k = left; k &lt; right; run[count] = k) &#123;</span><br><span class="line">               if (a[k] &lt; a[k + 1]) &#123; // ascending</span><br><span class="line">                   while (++k &lt;= right &amp;&amp; a[k - 1] &lt;= a[k]) ;</span><br><span class="line">               &#125; else if (a[k] &gt; a[k + 1]) &#123; // descending</span><br><span class="line">                   while (++k &lt;= right &amp;&amp; a[k - 1] &gt;= a[k]) ;</span><br><span class="line">                   for (int lo = run[count] - 1, hi = k; ++lo &lt; --hi; ) &#123;</span><br><span class="line">                       long t = a[lo];</span><br><span class="line">                       a[lo] = a[hi];</span><br><span class="line">                       a[hi] = t;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; else &#123; // equal</span><br><span class="line">                   for (int m = MAX_RUN_LENGTH; ++k &lt;= right &amp;&amp; a[k - 1] == a[k]; ) &#123;</span><br><span class="line">                       if (--m == 0) &#123;</span><br><span class="line">                           sort(a, left, right, true);</span><br><span class="line">                           return;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">           /*</span><br><span class="line">            * The array is not highly structured,</span><br><span class="line">            * use Quicksort instead of merge sort.</span><br><span class="line">            */</span><br><span class="line">               if (++count == MAX_RUN_COUNT) &#123;</span><br><span class="line">                   sort(a, left, right, true);</span><br><span class="line">                   return;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // Check special cases</span><br><span class="line">           // Implementation note: variable &quot;right&quot; is increased by 1.</span><br><span class="line">           if (run[count] == right++) &#123; // The last run contains one element</span><br><span class="line">               run[++count] = right;</span><br><span class="line">           &#125; else if (count == 1) &#123; // The array is already sorted</span><br><span class="line">               return;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // Determine alternation base for merge</span><br><span class="line">           byte odd = 0;</span><br><span class="line">           for (int n = 1; (n &lt;&lt;= 1) &lt; count; odd ^= 1) ;</span><br><span class="line"></span><br><span class="line">           // Use or create temporary array b for merging</span><br><span class="line">           long[] b;                 // temp array; alternates with a</span><br><span class="line">           int ao, bo;              // array offsets from &apos;left&apos;</span><br><span class="line">           int blen = right - left; // space needed for b</span><br><span class="line">           if (work == null || workLen &lt; blen || workBase + blen &gt; work.length) &#123;</span><br><span class="line">               work = new long[blen];</span><br><span class="line">               workBase = 0;</span><br><span class="line">           &#125;</span><br><span class="line">           if (odd == 0) &#123;</span><br><span class="line">               System.arraycopy(a, left, work, workBase, blen);</span><br><span class="line">               b = a;</span><br><span class="line">               bo = 0;</span><br><span class="line">               a = work;</span><br><span class="line">               ao = workBase - left;</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               b = work;</span><br><span class="line">               ao = 0;</span><br><span class="line">               bo = workBase - left;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // Merging</span><br><span class="line">           for (int last; count &gt; 1; count = last) &#123;</span><br><span class="line">               for (int k = (last = 0) + 2; k &lt;= count; k += 2) &#123;</span><br><span class="line">                   int hi = run[k], mi = run[k - 1];</span><br><span class="line">                   for (int i = run[k - 2], p = i, q = mi; i &lt; hi; ++i) &#123;</span><br><span class="line">                       if (q &gt;= hi || p &lt; mi &amp;&amp; a[p + ao] &lt;= a[q + ao]) &#123;</span><br><span class="line">                           b[i + bo] = a[p++ + ao];</span><br><span class="line">                       &#125; else &#123;</span><br><span class="line">                           b[i + bo] = a[q++ + ao];</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">                   run[++last] = hi;</span><br><span class="line">               &#125;</span><br><span class="line">               if ((count &amp; 1) != 0) &#123;</span><br><span class="line">                   for (int i = right, lo = run[count - 1]; --i &gt;= lo;</span><br><span class="line">                        b[i + bo] = a[i + ao]</span><br><span class="line">                           )</span><br><span class="line">                       ;</span><br><span class="line">                   run[++last] = right;</span><br><span class="line">               &#125;</span><br><span class="line">               long[] t = a;</span><br><span class="line">               a = b;</span><br><span class="line">               b = t;</span><br><span class="line">               int o = ao;</span><br><span class="line">               ao = bo;</span><br><span class="line">               bo = o;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       /**</span><br><span class="line">        * Sorts the specified range of the array by Dual-Pivot Quicksort.</span><br><span class="line">        *</span><br><span class="line">        * @param a        the array to be sorted</span><br><span class="line">        * @param left     the index of the first element, inclusive, to be sorted</span><br><span class="line">        * @param right    the index of the last element, inclusive, to be sorted</span><br><span class="line">        * @param leftmost indicates if this part is the leftmost in the range</span><br><span class="line">        */</span><br><span class="line">       private static void sort(long[] a, int left, int right, boolean leftmost) &#123;</span><br><span class="line">           int length = right - left + 1;</span><br><span class="line"></span><br><span class="line">           // Use insertion sort on tiny arrays</span><br><span class="line">           if (length &lt; INSERTION_SORT_THRESHOLD) &#123;</span><br><span class="line">               if (leftmost) &#123;</span><br><span class="line">               /*</span><br><span class="line">                * Traditional (without sentinel) insertion sort,</span><br><span class="line">                * optimized for server VM, is used in case of</span><br><span class="line">                * the leftmost part.</span><br><span class="line">                */</span><br><span class="line">                   for (int i = left, j = i; i &lt; right; j = ++i) &#123;</span><br><span class="line">                       long ai = a[i + 1];</span><br><span class="line">                       while (ai &lt; a[j]) &#123;</span><br><span class="line">                           a[j + 1] = a[j];</span><br><span class="line">                           if (j-- == left) &#123;</span><br><span class="line">                               break;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                       a[j + 1] = ai;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">               /*</span><br><span class="line">                * Skip the longest ascending sequence.</span><br><span class="line">                */</span><br><span class="line">                   do &#123;</span><br><span class="line">                       if (left &gt;= right) &#123;</span><br><span class="line">                           return;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125; while (a[++left] &gt;= a[left - 1]);</span><br><span class="line"></span><br><span class="line">               /*</span><br><span class="line">                * Every element from adjoining part plays the role</span><br><span class="line">                * of sentinel, therefore this allows us to avoid the</span><br><span class="line">                * left range check on each iteration. Moreover, we use</span><br><span class="line">                * the more optimized algorithm, so called pair insertion</span><br><span class="line">                * sort, which is faster (in the context of Quicksort)</span><br><span class="line">                * than traditional implementation of insertion sort.</span><br><span class="line">                */</span><br><span class="line">                   for (int k = left; ++left &lt;= right; k = ++left) &#123;</span><br><span class="line">                       long a1 = a[k], a2 = a[left];</span><br><span class="line"></span><br><span class="line">                       if (a1 &lt; a2) &#123;</span><br><span class="line">                           a2 = a1;</span><br><span class="line">                           a1 = a[left];</span><br><span class="line">                       &#125;</span><br><span class="line">                       while (a1 &lt; a[--k]) &#123;</span><br><span class="line">                           a[k + 2] = a[k];</span><br><span class="line">                       &#125;</span><br><span class="line">                       a[++k + 1] = a1;</span><br><span class="line"></span><br><span class="line">                       while (a2 &lt; a[--k]) &#123;</span><br><span class="line">                           a[k + 1] = a[k];</span><br><span class="line">                       &#125;</span><br><span class="line">                       a[k + 1] = a2;</span><br><span class="line">                   &#125;</span><br><span class="line">                   long last = a[right];</span><br><span class="line"></span><br><span class="line">                   while (last &lt; a[--right]) &#123;</span><br><span class="line">                       a[right + 1] = a[right];</span><br><span class="line">                   &#125;</span><br><span class="line">                   a[right + 1] = last;</span><br><span class="line">               &#125;</span><br><span class="line">               return;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // Inexpensive approximation of length / 7</span><br><span class="line">           int seventh = (length &gt;&gt; 3) + (length &gt;&gt; 6) + 1;</span><br><span class="line"></span><br><span class="line">       /*</span><br><span class="line">        * Sort five evenly spaced elements around (and including) the</span><br><span class="line">        * center element in the range. These elements will be used for</span><br><span class="line">        * pivot selection as described below. The choice for spacing</span><br><span class="line">        * these elements was empirically determined to work well on</span><br><span class="line">        * a wide variety of inputs.</span><br><span class="line">        */</span><br><span class="line">           int e3 = (left + right) &gt;&gt;&gt; 1; // The midpoint</span><br><span class="line">           int e2 = e3 - seventh;</span><br><span class="line">           int e1 = e2 - seventh;</span><br><span class="line">           int e4 = e3 + seventh;</span><br><span class="line">           int e5 = e4 + seventh;</span><br><span class="line"></span><br><span class="line">           // Sort these elements using insertion sort</span><br><span class="line">           if (a[e2] &lt; a[e1]) &#123;</span><br><span class="line">               long t = a[e2];</span><br><span class="line">               a[e2] = a[e1];</span><br><span class="line">               a[e1] = t;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           if (a[e3] &lt; a[e2]) &#123;</span><br><span class="line">               long t = a[e3];</span><br><span class="line">               a[e3] = a[e2];</span><br><span class="line">               a[e2] = t;</span><br><span class="line">               if (t &lt; a[e1]) &#123;</span><br><span class="line">                   a[e2] = a[e1];</span><br><span class="line">                   a[e1] = t;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           if (a[e4] &lt; a[e3]) &#123;</span><br><span class="line">               long t = a[e4];</span><br><span class="line">               a[e4] = a[e3];</span><br><span class="line">               a[e3] = t;</span><br><span class="line">               if (t &lt; a[e2]) &#123;</span><br><span class="line">                   a[e3] = a[e2];</span><br><span class="line">                   a[e2] = t;</span><br><span class="line">                   if (t &lt; a[e1]) &#123;</span><br><span class="line">                       a[e2] = a[e1];</span><br><span class="line">                       a[e1] = t;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           if (a[e5] &lt; a[e4]) &#123;</span><br><span class="line">               long t = a[e5];</span><br><span class="line">               a[e5] = a[e4];</span><br><span class="line">               a[e4] = t;</span><br><span class="line">               if (t &lt; a[e3]) &#123;</span><br><span class="line">                   a[e4] = a[e3];</span><br><span class="line">                   a[e3] = t;</span><br><span class="line">                   if (t &lt; a[e2]) &#123;</span><br><span class="line">                       a[e3] = a[e2];</span><br><span class="line">                       a[e2] = t;</span><br><span class="line">                       if (t &lt; a[e1]) &#123;</span><br><span class="line">                           a[e2] = a[e1];</span><br><span class="line">                           a[e1] = t;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // Pointers</span><br><span class="line">           int less = left;  // The index of the first element of center part</span><br><span class="line">           int great = right; // The index before the first element of right part</span><br><span class="line"></span><br><span class="line">           if (a[e1] != a[e2] &amp;&amp; a[e2] != a[e3] &amp;&amp; a[e3] != a[e4] &amp;&amp; a[e4] != a[e5]) &#123;</span><br><span class="line">           /*</span><br><span class="line">            * Use the second and fourth of the five sorted elements as pivots.</span><br><span class="line">            * These values are inexpensive approximations of the first and</span><br><span class="line">            * second terciles of the array. Note that pivot1 &lt;= pivot2.</span><br><span class="line">            */</span><br><span class="line">               long pivot1 = a[e2];</span><br><span class="line">               long pivot2 = a[e4];</span><br><span class="line"></span><br><span class="line">           /*</span><br><span class="line">            * The first and the last elements to be sorted are moved to the</span><br><span class="line">            * locations formerly occupied by the pivots. When partitioning</span><br><span class="line">            * is complete, the pivots are swapped back into their final</span><br><span class="line">            * positions, and excluded from subsequent sorting.</span><br><span class="line">            */</span><br><span class="line">               a[e2] = a[left];</span><br><span class="line">               a[e4] = a[right];</span><br><span class="line"></span><br><span class="line">           /*</span><br><span class="line">            * Skip elements, which are less or greater than pivot values.</span><br><span class="line">            */</span><br><span class="line">               while (a[++less] &lt; pivot1) ;</span><br><span class="line">               while (a[--great] &gt; pivot2) ;</span><br><span class="line"></span><br><span class="line">           /*</span><br><span class="line">            * Partitioning:</span><br><span class="line">            *</span><br><span class="line">            *   left part           center part                   right part</span><br><span class="line">            * +--------------------------------------------------------------+</span><br><span class="line">            * |  &lt; pivot1  |  pivot1 &lt;= &amp;&amp; &lt;= pivot2  |    ?    |  &gt; pivot2  |</span><br><span class="line">            * +--------------------------------------------------------------+</span><br><span class="line">            *               ^                          ^       ^</span><br><span class="line">            *               |                          |       |</span><br><span class="line">            *              less                        k     great</span><br><span class="line">            *</span><br><span class="line">            * Invariants:</span><br><span class="line">            *</span><br><span class="line">            *              all in (left, less)   &lt; pivot1</span><br><span class="line">            *    pivot1 &lt;= all in [less, k)     &lt;= pivot2</span><br><span class="line">            *              all in (great, right) &gt; pivot2</span><br><span class="line">            *</span><br><span class="line">            * Pointer k is the first index of ?-part.</span><br><span class="line">            */</span><br><span class="line">               outer:</span><br><span class="line">               for (int k = less - 1; ++k &lt;= great; ) &#123;</span><br><span class="line">                   long ak = a[k];</span><br><span class="line">                   if (ak &lt; pivot1) &#123; // Move a[k] to left part</span><br><span class="line">                       a[k] = a[less];</span><br><span class="line">                   /*</span><br><span class="line">                    * Here and below we use &quot;a[i] = b; i++;&quot; instead</span><br><span class="line">                    * of &quot;a[i++] = b;&quot; due to performance issue.</span><br><span class="line">                    */</span><br><span class="line">                       a[less] = ak;</span><br><span class="line">                       ++less;</span><br><span class="line">                   &#125; else if (ak &gt; pivot2) &#123; // Move a[k] to right part</span><br><span class="line">                       while (a[great] &gt; pivot2) &#123;</span><br><span class="line">                           if (great-- == k) &#123;</span><br><span class="line">                               break outer;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                       if (a[great] &lt; pivot1) &#123; // a[great] &lt;= pivot2</span><br><span class="line">                           a[k] = a[less];</span><br><span class="line">                           a[less] = a[great];</span><br><span class="line">                           ++less;</span><br><span class="line">                       &#125; else &#123; // pivot1 &lt;= a[great] &lt;= pivot2</span><br><span class="line">                           a[k] = a[great];</span><br><span class="line">                       &#125;</span><br><span class="line">                   /*</span><br><span class="line">                    * Here and below we use &quot;a[i] = b; i--;&quot; instead</span><br><span class="line">                    * of &quot;a[i--] = b;&quot; due to performance issue.</span><br><span class="line">                    */</span><br><span class="line">                       a[great] = ak;</span><br><span class="line">                       --great;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               // Swap pivots into their final positions</span><br><span class="line">               a[left] = a[less - 1];</span><br><span class="line">               a[less - 1] = pivot1;</span><br><span class="line">               a[right] = a[great + 1];</span><br><span class="line">               a[great + 1] = pivot2;</span><br><span class="line"></span><br><span class="line">               // Sort left and right parts recursively, excluding known pivots</span><br><span class="line">               sort(a, left, less - 2, leftmost);</span><br><span class="line">               sort(a, great + 2, right, false);</span><br><span class="line"></span><br><span class="line">           /*</span><br><span class="line">            * If center part is too large (comprises &gt; 4/7 of the array),</span><br><span class="line">            * swap internal pivot values to ends.</span><br><span class="line">            */</span><br><span class="line">               if (less &lt; e1 &amp;&amp; e5 &lt; great) &#123;</span><br><span class="line">               /*</span><br><span class="line">                * Skip elements, which are equal to pivot values.</span><br><span class="line">                */</span><br><span class="line">                   while (a[less] == pivot1) &#123;</span><br><span class="line">                       ++less;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   while (a[great] == pivot2) &#123;</span><br><span class="line">                       --great;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">               /*</span><br><span class="line">                * Partitioning:</span><br><span class="line">                *</span><br><span class="line">                *   left part         center part                  right part</span><br><span class="line">                * +----------------------------------------------------------+</span><br><span class="line">                * | == pivot1 |  pivot1 &lt; &amp;&amp; &lt; pivot2  |    ?    | == pivot2 |</span><br><span class="line">                * +----------------------------------------------------------+</span><br><span class="line">                *              ^                        ^       ^</span><br><span class="line">                *              |                        |       |</span><br><span class="line">                *             less                      k     great</span><br><span class="line">                *</span><br><span class="line">                * Invariants:</span><br><span class="line">                *</span><br><span class="line">                *              all in (*,  less) == pivot1</span><br><span class="line">                *     pivot1 &lt; all in [less,  k)  &lt; pivot2</span><br><span class="line">                *              all in (great, *) == pivot2</span><br><span class="line">                *</span><br><span class="line">                * Pointer k is the first index of ?-part.</span><br><span class="line">                */</span><br><span class="line">                   outer:</span><br><span class="line">                   for (int k = less - 1; ++k &lt;= great; ) &#123;</span><br><span class="line">                       long ak = a[k];</span><br><span class="line">                       if (ak == pivot1) &#123; // Move a[k] to left part</span><br><span class="line">                           a[k] = a[less];</span><br><span class="line">                           a[less] = ak;</span><br><span class="line">                           ++less;</span><br><span class="line">                       &#125; else if (ak == pivot2) &#123; // Move a[k] to right part</span><br><span class="line">                           while (a[great] == pivot2) &#123;</span><br><span class="line">                               if (great-- == k) &#123;</span><br><span class="line">                                   break outer;</span><br><span class="line">                               &#125;</span><br><span class="line">                           &#125;</span><br><span class="line">                           if (a[great] == pivot1) &#123; // a[great] &lt; pivot2</span><br><span class="line">                               a[k] = a[less];</span><br><span class="line">                           /*</span><br><span class="line">                            * Even though a[great] equals to pivot1, the</span><br><span class="line">                            * assignment a[less] = pivot1 may be incorrect,</span><br><span class="line">                            * if a[great] and pivot1 are floating-point zeros</span><br><span class="line">                            * of different signs. Therefore in float and</span><br><span class="line">                            * double sorting methods we have to use more</span><br><span class="line">                            * accurate assignment a[less] = a[great].</span><br><span class="line">                            */</span><br><span class="line">                               a[less] = pivot1;</span><br><span class="line">                               ++less;</span><br><span class="line">                           &#125; else &#123; // pivot1 &lt; a[great] &lt; pivot2</span><br><span class="line">                               a[k] = a[great];</span><br><span class="line">                           &#125;</span><br><span class="line">                           a[great] = ak;</span><br><span class="line">                           --great;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               // Sort center part recursively</span><br><span class="line">               sort(a, less, great, false);</span><br><span class="line"></span><br><span class="line">           &#125; else &#123; // Partitioning with one pivot</span><br><span class="line">           /*</span><br><span class="line">            * Use the third of the five sorted elements as pivot.</span><br><span class="line">            * This value is inexpensive approximation of the median.</span><br><span class="line">            */</span><br><span class="line">               long pivot = a[e3];</span><br><span class="line"></span><br><span class="line">           /*</span><br><span class="line">            * Partitioning degenerates to the traditional 3-way</span><br><span class="line">            * (or &quot;Dutch National Flag&quot;) schema:</span><br><span class="line">            *</span><br><span class="line">            *   left part    center part              right part</span><br><span class="line">            * +-------------------------------------------------+</span><br><span class="line">            * |  &lt; pivot  |   == pivot   |     ?    |  &gt; pivot  |</span><br><span class="line">            * +-------------------------------------------------+</span><br><span class="line">            *              ^              ^        ^</span><br><span class="line">            *              |              |        |</span><br><span class="line">            *             less            k      great</span><br><span class="line">            *</span><br><span class="line">            * Invariants:</span><br><span class="line">            *</span><br><span class="line">            *   all in (left, less)   &lt; pivot</span><br><span class="line">            *   all in [less, k)     == pivot</span><br><span class="line">            *   all in (great, right) &gt; pivot</span><br><span class="line">            *</span><br><span class="line">            * Pointer k is the first index of ?-part.</span><br><span class="line">            */</span><br><span class="line">               for (int k = less; k &lt;= great; ++k) &#123;</span><br><span class="line">                   if (a[k] == pivot) &#123;</span><br><span class="line">                       continue;</span><br><span class="line">                   &#125;</span><br><span class="line">                   long ak = a[k];</span><br><span class="line">                   if (ak &lt; pivot) &#123; // Move a[k] to left part</span><br><span class="line">                       a[k] = a[less];</span><br><span class="line">                       a[less] = ak;</span><br><span class="line">                       ++less;</span><br><span class="line">                   &#125; else &#123; // a[k] &gt; pivot - Move a[k] to right part</span><br><span class="line">                       while (a[great] &gt; pivot) &#123;</span><br><span class="line">                           --great;</span><br><span class="line">                       &#125;</span><br><span class="line">                       if (a[great] &lt; pivot) &#123; // a[great] &lt;= pivot</span><br><span class="line">                           a[k] = a[less];</span><br><span class="line">                           a[less] = a[great];</span><br><span class="line">                           ++less;</span><br><span class="line">                       &#125; else &#123; // a[great] == pivot</span><br><span class="line">                       /*</span><br><span class="line">                        * Even though a[great] equals to pivot, the</span><br><span class="line">                        * assignment a[k] = pivot may be incorrect,</span><br><span class="line">                        * if a[great] and pivot are floating-point</span><br><span class="line">                        * zeros of different signs. Therefore in float</span><br><span class="line">                        * and double sorting methods we have to use</span><br><span class="line">                        * more accurate assignment a[k] = a[great].</span><br><span class="line">                        */</span><br><span class="line">                           a[k] = pivot;</span><br><span class="line">                       &#125;</span><br><span class="line">                       a[great] = ak;</span><br><span class="line">                       --great;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">           /*</span><br><span class="line">            * Sort left and right parts recursively.</span><br><span class="line">            * All elements from center part are equal</span><br><span class="line">            * and, therefore, already sorted.</span><br><span class="line">            */</span><br><span class="line">               sort(a, left, less - 1, leftmost);</span><br><span class="line">               sort(a, great + 1, right, false);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       /**</span><br><span class="line">        * Sorts the specified range of the array using the given</span><br><span class="line">        * workspace array slice if possible for merging</span><br><span class="line">        *</span><br><span class="line">        * @param a        the array to be sorted</span><br><span class="line">        * @param left     the index of the first element, inclusive, to be sorted</span><br><span class="line">        * @param right    the index of the last element, inclusive, to be sorted</span><br><span class="line">        * @param work     a workspace array (slice)</span><br><span class="line">        * @param workBase origin of usable space in work array</span><br><span class="line">        * @param workLen  usable size of work array</span><br><span class="line">        */</span><br><span class="line">       static void sort(short[] a, int left, int right,</span><br><span class="line">                        short[] work, int workBase, int workLen) &#123;</span><br><span class="line">           // Use counting sort on large arrays</span><br><span class="line">           if (right - left &gt; COUNTING_SORT_THRESHOLD_FOR_SHORT_OR_CHAR) &#123;</span><br><span class="line">               int[] count = new int[NUM_SHORT_VALUES];</span><br><span class="line"></span><br><span class="line">               for (int i = left - 1; ++i &lt;= right;</span><br><span class="line">                    count[a[i] - Short.MIN_VALUE]++</span><br><span class="line">                       )</span><br><span class="line">                   ;</span><br><span class="line">               for (int i = NUM_SHORT_VALUES, k = right + 1; k &gt; left; ) &#123;</span><br><span class="line">                   while (count[--i] == 0) ;</span><br><span class="line">                   short value = (short) (i + Short.MIN_VALUE);</span><br><span class="line">                   int s = count[i];</span><br><span class="line"></span><br><span class="line">                   do &#123;</span><br><span class="line">                       a[--k] = value;</span><br><span class="line">                   &#125; while (--s &gt; 0);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; else &#123; // Use Dual-Pivot Quicksort on small arrays</span><br><span class="line">               doSort(a, left, right, work, workBase, workLen);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       /**</span><br><span class="line">        * The number of distinct short values.</span><br><span class="line">        */</span><br><span class="line">       private static final int NUM_SHORT_VALUES = 1 &lt;&lt; 16;</span><br><span class="line"></span><br><span class="line">       /**</span><br><span class="line">        * Sorts the specified range of the array.</span><br><span class="line">        *</span><br><span class="line">        * @param a        the array to be sorted</span><br><span class="line">        * @param left     the index of the first element, inclusive, to be sorted</span><br><span class="line">        * @param right    the index of the last element, inclusive, to be sorted</span><br><span class="line">        * @param work     a workspace array (slice)</span><br><span class="line">        * @param workBase origin of usable space in work array</span><br><span class="line">        * @param workLen  usable size of work array</span><br><span class="line">        */</span><br><span class="line">       private static void doSort(short[] a, int left, int right,</span><br><span class="line">                                  short[] work, int workBase, int workLen) &#123;</span><br><span class="line">           // Use Quicksort on small arrays</span><br><span class="line">           if (right - left &lt; QUICKSORT_THRESHOLD) &#123;</span><br><span class="line">               sort(a, left, right, true);</span><br><span class="line">               return;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       /*</span><br><span class="line">        * Index run[i] is the start of i-th run</span><br><span class="line">        * (ascending or descending sequence).</span><br><span class="line">        */</span><br><span class="line">           int[] run = new int[MAX_RUN_COUNT + 1];</span><br><span class="line">           int count = 0;</span><br><span class="line">           run[0] = left;</span><br><span class="line"></span><br><span class="line">           // Check if the array is nearly sorted</span><br><span class="line">           for (int k = left; k &lt; right; run[count] = k) &#123;</span><br><span class="line">               if (a[k] &lt; a[k + 1]) &#123; // ascending</span><br><span class="line">                   while (++k &lt;= right &amp;&amp; a[k - 1] &lt;= a[k]) ;</span><br><span class="line">               &#125; else if (a[k] &gt; a[k + 1]) &#123; // descending</span><br><span class="line">                   while (++k &lt;= right &amp;&amp; a[k - 1] &gt;= a[k]) ;</span><br><span class="line">                   for (int lo = run[count] - 1, hi = k; ++lo &lt; --hi; ) &#123;</span><br><span class="line">                       short t = a[lo];</span><br><span class="line">                       a[lo] = a[hi];</span><br><span class="line">                       a[hi] = t;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; else &#123; // equal</span><br><span class="line">                   for (int m = MAX_RUN_LENGTH; ++k &lt;= right &amp;&amp; a[k - 1] == a[k]; ) &#123;</span><br><span class="line">                       if (--m == 0) &#123;</span><br><span class="line">                           sort(a, left, right, true);</span><br><span class="line">                           return;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">           /*</span><br><span class="line">            * The array is not highly structured,</span><br><span class="line">            * use Quicksort instead of merge sort.</span><br><span class="line">            */</span><br><span class="line">               if (++count == MAX_RUN_COUNT) &#123;</span><br><span class="line">                   sort(a, left, right, true);</span><br><span class="line">                   return;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // Check special cases</span><br><span class="line">           // Implementation note: variable &quot;right&quot; is increased by 1.</span><br><span class="line">           if (run[count] == right++) &#123; // The last run contains one element</span><br><span class="line">               run[++count] = right;</span><br><span class="line">           &#125; else if (count == 1) &#123; // The array is already sorted</span><br><span class="line">               return;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // Determine alternation base for merge</span><br><span class="line">           byte odd = 0;</span><br><span class="line">           for (int n = 1; (n &lt;&lt;= 1) &lt; count; odd ^= 1) ;</span><br><span class="line"></span><br><span class="line">           // Use or create temporary array b for merging</span><br><span class="line">           short[] b;                 // temp array; alternates with a</span><br><span class="line">           int ao, bo;              // array offsets from &apos;left&apos;</span><br><span class="line">           int blen = right - left; // space needed for b</span><br><span class="line">           if (work == null || workLen &lt; blen || workBase + blen &gt; work.length) &#123;</span><br><span class="line">               work = new short[blen];</span><br><span class="line">               workBase = 0;</span><br><span class="line">           &#125;</span><br><span class="line">           if (odd == 0) &#123;</span><br><span class="line">               System.arraycopy(a, left, work, workBase, blen);</span><br><span class="line">               b = a;</span><br><span class="line">               bo = 0;</span><br><span class="line">               a = work;</span><br><span class="line">               ao = workBase - left;</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               b = work;</span><br><span class="line">               ao = 0;</span><br><span class="line">               bo = workBase - left;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // Merging</span><br><span class="line">           for (int last; count &gt; 1; count = last) &#123;</span><br><span class="line">               for (int k = (last = 0) + 2; k &lt;= count; k += 2) &#123;</span><br><span class="line">                   int hi = run[k], mi = run[k - 1];</span><br><span class="line">                   for (int i = run[k - 2], p = i, q = mi; i &lt; hi; ++i) &#123;</span><br><span class="line">                       if (q &gt;= hi || p &lt; mi &amp;&amp; a[p + ao] &lt;= a[q + ao]) &#123;</span><br><span class="line">                           b[i + bo] = a[p++ + ao];</span><br><span class="line">                       &#125; else &#123;</span><br><span class="line">                           b[i + bo] = a[q++ + ao];</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">                   run[++last] = hi;</span><br><span class="line">               &#125;</span><br><span class="line">               if ((count &amp; 1) != 0) &#123;</span><br><span class="line">                   for (int i = right, lo = run[count - 1]; --i &gt;= lo;</span><br><span class="line">                        b[i + bo] = a[i + ao]</span><br><span class="line">                           )</span><br><span class="line">                       ;</span><br><span class="line">                   run[++last] = right;</span><br><span class="line">               &#125;</span><br><span class="line">               short[] t = a;</span><br><span class="line">               a = b;</span><br><span class="line">               b = t;</span><br><span class="line">               int o = ao;</span><br><span class="line">               ao = bo;</span><br><span class="line">               bo = o;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       /**</span><br><span class="line">        * Sorts the specified range of the array by Dual-Pivot Quicksort.</span><br><span class="line">        *</span><br><span class="line">        * @param a        the array to be sorted</span><br><span class="line">        * @param left     the index of the first element, inclusive, to be sorted</span><br><span class="line">        * @param right    the index of the last element, inclusive, to be sorted</span><br><span class="line">        * @param leftmost indicates if this part is the leftmost in the range</span><br><span class="line">        */</span><br><span class="line">       private static void sort(short[] a, int left, int right, boolean leftmost) &#123;</span><br><span class="line">           int length = right - left + 1;</span><br><span class="line"></span><br><span class="line">           // Use insertion sort on tiny arrays</span><br><span class="line">           if (length &lt; INSERTION_SORT_THRESHOLD) &#123;</span><br><span class="line">               if (leftmost) &#123;</span><br><span class="line">               /*</span><br><span class="line">                * Traditional (without sentinel) insertion sort,</span><br><span class="line">                * optimized for server VM, is used in case of</span><br><span class="line">                * the leftmost part.</span><br><span class="line">                */</span><br><span class="line">                   for (int i = left, j = i; i &lt; right; j = ++i) &#123;</span><br><span class="line">                       short ai = a[i + 1];</span><br><span class="line">                       while (ai &lt; a[j]) &#123;</span><br><span class="line">                           a[j + 1] = a[j];</span><br><span class="line">                           if (j-- == left) &#123;</span><br><span class="line">                               break;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                       a[j + 1] = ai;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">               /*</span><br><span class="line">                * Skip the longest ascending sequence.</span><br><span class="line">                */</span><br><span class="line">                   do &#123;</span><br><span class="line">                       if (left &gt;= right) &#123;</span><br><span class="line">                           return;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125; while (a[++left] &gt;= a[left - 1]);</span><br><span class="line"></span><br><span class="line">               /*</span><br><span class="line">                * Every element from adjoining part plays the role</span><br><span class="line">                * of sentinel, therefore this allows us to avoid the</span><br><span class="line">                * left range check on each iteration. Moreover, we use</span><br><span class="line">                * the more optimized algorithm, so called pair insertion</span><br><span class="line">                * sort, which is faster (in the context of Quicksort)</span><br><span class="line">                * than traditional implementation of insertion sort.</span><br><span class="line">                */</span><br><span class="line">                   for (int k = left; ++left &lt;= right; k = ++left) &#123;</span><br><span class="line">                       short a1 = a[k], a2 = a[left];</span><br><span class="line"></span><br><span class="line">                       if (a1 &lt; a2) &#123;</span><br><span class="line">                           a2 = a1;</span><br><span class="line">                           a1 = a[left];</span><br><span class="line">                       &#125;</span><br><span class="line">                       while (a1 &lt; a[--k]) &#123;</span><br><span class="line">                           a[k + 2] = a[k];</span><br><span class="line">                       &#125;</span><br><span class="line">                       a[++k + 1] = a1;</span><br><span class="line"></span><br><span class="line">                       while (a2 &lt; a[--k]) &#123;</span><br><span class="line">                           a[k + 1] = a[k];</span><br><span class="line">                       &#125;</span><br><span class="line">                       a[k + 1] = a2;</span><br><span class="line">                   &#125;</span><br><span class="line">                   short last = a[right];</span><br><span class="line"></span><br><span class="line">                   while (last &lt; a[--right]) &#123;</span><br><span class="line">                       a[right + 1] = a[right];</span><br><span class="line">                   &#125;</span><br><span class="line">                   a[right + 1] = last;</span><br><span class="line">               &#125;</span><br><span class="line">               return;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // Inexpensive approximation of length / 7</span><br><span class="line">           int seventh = (length &gt;&gt; 3) + (length &gt;&gt; 6) + 1;</span><br><span class="line"></span><br><span class="line">       /*</span><br><span class="line">        * Sort five evenly spaced elements around (and including) the</span><br><span class="line">        * center element in the range. These elements will be used for</span><br><span class="line">        * pivot selection as described below. The choice for spacing</span><br><span class="line">        * these elements was empirically determined to work well on</span><br><span class="line">        * a wide variety of inputs.</span><br><span class="line">        */</span><br><span class="line">           int e3 = (left + right) &gt;&gt;&gt; 1; // The midpoint</span><br><span class="line">           int e2 = e3 - seventh;</span><br><span class="line">           int e1 = e2 - seventh;</span><br><span class="line">           int e4 = e3 + seventh;</span><br><span class="line">           int e5 = e4 + seventh;</span><br><span class="line"></span><br><span class="line">           // Sort these elements using insertion sort</span><br><span class="line">           if (a[e2] &lt; a[e1]) &#123;</span><br><span class="line">               short t = a[e2];</span><br><span class="line">               a[e2] = a[e1];</span><br><span class="line">               a[e1] = t;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           if (a[e3] &lt; a[e2]) &#123;</span><br><span class="line">               short t = a[e3];</span><br><span class="line">               a[e3] = a[e2];</span><br><span class="line">               a[e2] = t;</span><br><span class="line">               if (t &lt; a[e1]) &#123;</span><br><span class="line">                   a[e2] = a[e1];</span><br><span class="line">                   a[e1] = t;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           if (a[e4] &lt; a[e3]) &#123;</span><br><span class="line">               short t = a[e4];</span><br><span class="line">               a[e4] = a[e3];</span><br><span class="line">               a[e3] = t;</span><br><span class="line">               if (t &lt; a[e2]) &#123;</span><br><span class="line">                   a[e3] = a[e2];</span><br><span class="line">                   a[e2] = t;</span><br><span class="line">                   if (t &lt; a[e1]) &#123;</span><br><span class="line">                       a[e2] = a[e1];</span><br><span class="line">                       a[e1] = t;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           if (a[e5] &lt; a[e4]) &#123;</span><br><span class="line">               short t = a[e5];</span><br><span class="line">               a[e5] = a[e4];</span><br><span class="line">               a[e4] = t;</span><br><span class="line">               if (t &lt; a[e3]) &#123;</span><br><span class="line">                   a[e4] = a[e3];</span><br><span class="line">                   a[e3] = t;</span><br><span class="line">                   if (t &lt; a[e2]) &#123;</span><br><span class="line">                       a[e3] = a[e2];</span><br><span class="line">                       a[e2] = t;</span><br><span class="line">                       if (t &lt; a[e1]) &#123;</span><br><span class="line">                           a[e2] = a[e1];</span><br><span class="line">                           a[e1] = t;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // Pointers</span><br><span class="line">           int less = left;  // The index of the first element of center part</span><br><span class="line">           int great = right; // The index before the first element of right part</span><br><span class="line"></span><br><span class="line">           if (a[e1] != a[e2] &amp;&amp; a[e2] != a[e3] &amp;&amp; a[e3] != a[e4] &amp;&amp; a[e4] != a[e5]) &#123;</span><br><span class="line">           /*</span><br><span class="line">            * Use the second and fourth of the five sorted elements as pivots.</span><br><span class="line">            * These values are inexpensive approximations of the first and</span><br><span class="line">            * second terciles of the array. Note that pivot1 &lt;= pivot2.</span><br><span class="line">            */</span><br><span class="line">               short pivot1 = a[e2];</span><br><span class="line">               short pivot2 = a[e4];</span><br><span class="line"></span><br><span class="line">           /*</span><br><span class="line">            * The first and the last elements to be sorted are moved to the</span><br><span class="line">            * locations formerly occupied by the pivots. When partitioning</span><br><span class="line">            * is complete, the pivots are swapped back into their final</span><br><span class="line">            * positions, and excluded from subsequent sorting.</span><br><span class="line">            */</span><br><span class="line">               a[e2] = a[left];</span><br><span class="line">               a[e4] = a[right];</span><br><span class="line"></span><br><span class="line">           /*</span><br><span class="line">            * Skip elements, which are less or greater than pivot values.</span><br><span class="line">            */</span><br><span class="line">               while (a[++less] &lt; pivot1) ;</span><br><span class="line">               while (a[--great] &gt; pivot2) ;</span><br><span class="line"></span><br><span class="line">           /*</span><br><span class="line">            * Partitioning:</span><br><span class="line">            *</span><br><span class="line">            *   left part           center part                   right part</span><br><span class="line">            * +--------------------------------------------------------------+</span><br><span class="line">            * |  &lt; pivot1  |  pivot1 &lt;= &amp;&amp; &lt;= pivot2  |    ?    |  &gt; pivot2  |</span><br><span class="line">            * +--------------------------------------------------------------+</span><br><span class="line">            *               ^                          ^       ^</span><br><span class="line">            *               |                          |       |</span><br><span class="line">            *              less                        k     great</span><br><span class="line">            *</span><br><span class="line">            * Invariants:</span><br><span class="line">            *</span><br><span class="line">            *              all in (left, less)   &lt; pivot1</span><br><span class="line">            *    pivot1 &lt;= all in [less, k)     &lt;= pivot2</span><br><span class="line">            *              all in (great, right) &gt; pivot2</span><br><span class="line">            *</span><br><span class="line">            * Pointer k is the first index of ?-part.</span><br><span class="line">            */</span><br><span class="line">               outer:</span><br><span class="line">               for (int k = less - 1; ++k &lt;= great; ) &#123;</span><br><span class="line">                   short ak = a[k];</span><br><span class="line">                   if (ak &lt; pivot1) &#123; // Move a[k] to left part</span><br><span class="line">                       a[k] = a[less];</span><br><span class="line">                   /*</span><br><span class="line">                    * Here and below we use &quot;a[i] = b; i++;&quot; instead</span><br><span class="line">                    * of &quot;a[i++] = b;&quot; due to performance issue.</span><br><span class="line">                    */</span><br><span class="line">                       a[less] = ak;</span><br><span class="line">                       ++less;</span><br><span class="line">                   &#125; else if (ak &gt; pivot2) &#123; // Move a[k] to right part</span><br><span class="line">                       while (a[great] &gt; pivot2) &#123;</span><br><span class="line">                           if (great-- == k) &#123;</span><br><span class="line">                               break outer;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                       if (a[great] &lt; pivot1) &#123; // a[great] &lt;= pivot2</span><br><span class="line">                           a[k] = a[less];</span><br><span class="line">                           a[less] = a[great];</span><br><span class="line">                           ++less;</span><br><span class="line">                       &#125; else &#123; // pivot1 &lt;= a[great] &lt;= pivot2</span><br><span class="line">                           a[k] = a[great];</span><br><span class="line">                       &#125;</span><br><span class="line">                   /*</span><br><span class="line">                    * Here and below we use &quot;a[i] = b; i--;&quot; instead</span><br><span class="line">                    * of &quot;a[i--] = b;&quot; due to performance issue.</span><br><span class="line">                    */</span><br><span class="line">                       a[great] = ak;</span><br><span class="line">                       --great;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               // Swap pivots into their final positions</span><br><span class="line">               a[left] = a[less - 1];</span><br><span class="line">               a[less - 1] = pivot1;</span><br><span class="line">               a[right] = a[great + 1];</span><br><span class="line">               a[great + 1] = pivot2;</span><br><span class="line"></span><br><span class="line">               // Sort left and right parts recursively, excluding known pivots</span><br><span class="line">               sort(a, left, less - 2, leftmost);</span><br><span class="line">               sort(a, great + 2, right, false);</span><br><span class="line"></span><br><span class="line">           /*</span><br><span class="line">            * If center part is too large (comprises &gt; 4/7 of the array),</span><br><span class="line">            * swap internal pivot values to ends.</span><br><span class="line">            */</span><br><span class="line">               if (less &lt; e1 &amp;&amp; e5 &lt; great) &#123;</span><br><span class="line">               /*</span><br><span class="line">                * Skip elements, which are equal to pivot values.</span><br><span class="line">                */</span><br><span class="line">                   while (a[less] == pivot1) &#123;</span><br><span class="line">                       ++less;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   while (a[great] == pivot2) &#123;</span><br><span class="line">                       --great;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">               /*</span><br><span class="line">                * Partitioning:</span><br><span class="line">                *</span><br><span class="line">                *   left part         center part                  right part</span><br><span class="line">                * +----------------------------------------------------------+</span><br><span class="line">                * | == pivot1 |  pivot1 &lt; &amp;&amp; &lt; pivot2  |    ?    | == pivot2 |</span><br><span class="line">                * +----------------------------------------------------------+</span><br><span class="line">                *              ^                        ^       ^</span><br><span class="line">                *              |                        |       |</span><br><span class="line">                *             less                      k     great</span><br><span class="line">                *</span><br><span class="line">                * Invariants:</span><br><span class="line">                *</span><br><span class="line">                *              all in (*,  less) == pivot1</span><br><span class="line">                *     pivot1 &lt; all in [less,  k)  &lt; pivot2</span><br><span class="line">                *              all in (great, *) == pivot2</span><br><span class="line">                *</span><br><span class="line">                * Pointer k is the first index of ?-part.</span><br><span class="line">                */</span><br><span class="line">                   outer:</span><br><span class="line">                   for (int k = less - 1; ++k &lt;= great; ) &#123;</span><br><span class="line">                       short ak = a[k];</span><br><span class="line">                       if (ak == pivot1) &#123; // Move a[k] to left part</span><br><span class="line">                           a[k] = a[less];</span><br><span class="line">                           a[less] = ak;</span><br><span class="line">                           ++less;</span><br><span class="line">                       &#125; else if (ak == pivot2) &#123; // Move a[k] to right part</span><br><span class="line">                           while (a[great] == pivot2) &#123;</span><br><span class="line">                               if (great-- == k) &#123;</span><br><span class="line">                                   break outer;</span><br><span class="line">                               &#125;</span><br><span class="line">                           &#125;</span><br><span class="line">                           if (a[great] == pivot1) &#123; // a[great] &lt; pivot2</span><br><span class="line">                               a[k] = a[less];</span><br><span class="line">                           /*</span><br><span class="line">                            * Even though a[great] equals to pivot1, the</span><br><span class="line">                            * assignment a[less] = pivot1 may be incorrect,</span><br><span class="line">                            * if a[great] and pivot1 are floating-point zeros</span><br><span class="line">                            * of different signs. Therefore in float and</span><br><span class="line">                            * double sorting methods we have to use more</span><br><span class="line">                            * accurate assignment a[less] = a[great].</span><br><span class="line">                            */</span><br><span class="line">                               a[less] = pivot1;</span><br><span class="line">                               ++less;</span><br><span class="line">                           &#125; else &#123; // pivot1 &lt; a[great] &lt; pivot2</span><br><span class="line">                               a[k] = a[great];</span><br><span class="line">                           &#125;</span><br><span class="line">                           a[great] = ak;</span><br><span class="line">                           --great;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               // Sort center part recursively</span><br><span class="line">               sort(a, less, great, false);</span><br><span class="line"></span><br><span class="line">           &#125; else &#123; // Partitioning with one pivot</span><br><span class="line">           /*</span><br><span class="line">            * Use the third of the five sorted elements as pivot.</span><br><span class="line">            * This value is inexpensive approximation of the median.</span><br><span class="line">            */</span><br><span class="line">               short pivot = a[e3];</span><br><span class="line"></span><br><span class="line">           /*</span><br><span class="line">            * Partitioning degenerates to the traditional 3-way</span><br><span class="line">            * (or &quot;Dutch National Flag&quot;) schema:</span><br><span class="line">            *</span><br><span class="line">            *   left part    center part              right part</span><br><span class="line">            * +-------------------------------------------------+</span><br><span class="line">            * |  &lt; pivot  |   == pivot   |     ?    |  &gt; pivot  |</span><br><span class="line">            * +-------------------------------------------------+</span><br><span class="line">            *              ^              ^        ^</span><br><span class="line">            *              |              |        |</span><br><span class="line">            *             less            k      great</span><br><span class="line">            *</span><br><span class="line">            * Invariants:</span><br><span class="line">            *</span><br><span class="line">            *   all in (left, less)   &lt; pivot</span><br><span class="line">            *   all in [less, k)     == pivot</span><br><span class="line">            *   all in (great, right) &gt; pivot</span><br><span class="line">            *</span><br><span class="line">            * Pointer k is the first index of ?-part.</span><br><span class="line">            */</span><br><span class="line">               for (int k = less; k &lt;= great; ++k) &#123;</span><br><span class="line">                   if (a[k] == pivot) &#123;</span><br><span class="line">                       continue;</span><br><span class="line">                   &#125;</span><br><span class="line">                   short ak = a[k];</span><br><span class="line">                   if (ak &lt; pivot) &#123; // Move a[k] to left part</span><br><span class="line">                       a[k] = a[less];</span><br><span class="line">                       a[less] = ak;</span><br><span class="line">                       ++less;</span><br><span class="line">                   &#125; else &#123; // a[k] &gt; pivot - Move a[k] to right part</span><br><span class="line">                       while (a[great] &gt; pivot) &#123;</span><br><span class="line">                           --great;</span><br><span class="line">                       &#125;</span><br><span class="line">                       if (a[great] &lt; pivot) &#123; // a[great] &lt;= pivot</span><br><span class="line">                           a[k] = a[less];</span><br><span class="line">                           a[less] = a[great];</span><br><span class="line">                           ++less;</span><br><span class="line">                       &#125; else &#123; // a[great] == pivot</span><br><span class="line">                       /*</span><br><span class="line">                        * Even though a[great] equals to pivot, the</span><br><span class="line">                        * assignment a[k] = pivot may be incorrect,</span><br><span class="line">                        * if a[great] and pivot are floating-point</span><br><span class="line">                        * zeros of different signs. Therefore in float</span><br><span class="line">                        * and double sorting methods we have to use</span><br><span class="line">                        * more accurate assignment a[k] = a[great].</span><br><span class="line">                        */</span><br><span class="line">                           a[k] = pivot;</span><br><span class="line">                       &#125;</span><br><span class="line">                       a[great] = ak;</span><br><span class="line">                       --great;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">           /*</span><br><span class="line">            * Sort left and right parts recursively.</span><br><span class="line">            * All elements from center part are equal</span><br><span class="line">            * and, therefore, already sorted.</span><br><span class="line">            */</span><br><span class="line">               sort(a, left, less - 1, leftmost);</span><br><span class="line">               sort(a, great + 1, right, false);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       /**</span><br><span class="line">        * Sorts the specified range of the array using the given</span><br><span class="line">        * workspace array slice if possible for merging</span><br><span class="line">        *</span><br><span class="line">        * @param a        the array to be sorted</span><br><span class="line">        * @param left     the index of the first element, inclusive, to be sorted</span><br><span class="line">        * @param right    the index of the last element, inclusive, to be sorted</span><br><span class="line">        * @param work     a workspace array (slice)</span><br><span class="line">        * @param workBase origin of usable space in work array</span><br><span class="line">        * @param workLen  usable size of work array</span><br><span class="line">        */</span><br><span class="line">       static void sort(char[] a, int left, int right,</span><br><span class="line">                        char[] work, int workBase, int workLen) &#123;</span><br><span class="line">           // Use counting sort on large arrays</span><br><span class="line">           if (right - left &gt; COUNTING_SORT_THRESHOLD_FOR_SHORT_OR_CHAR) &#123;</span><br><span class="line">               int[] count = new int[NUM_CHAR_VALUES];</span><br><span class="line"></span><br><span class="line">               for (int i = left - 1; ++i &lt;= right;</span><br><span class="line">                    count[a[i]]++</span><br><span class="line">                       )</span><br><span class="line">                   ;</span><br><span class="line">               for (int i = NUM_CHAR_VALUES, k = right + 1; k &gt; left; ) &#123;</span><br><span class="line">                   while (count[--i] == 0) ;</span><br><span class="line">                   char value = (char) i;</span><br><span class="line">                   int s = count[i];</span><br><span class="line"></span><br><span class="line">                   do &#123;</span><br><span class="line">                       a[--k] = value;</span><br><span class="line">                   &#125; while (--s &gt; 0);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; else &#123; // Use Dual-Pivot Quicksort on small arrays</span><br><span class="line">               doSort(a, left, right, work, workBase, workLen);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       /**</span><br><span class="line">        * The number of distinct char values.</span><br><span class="line">        */</span><br><span class="line">       private static final int NUM_CHAR_VALUES = 1 &lt;&lt; 16;</span><br><span class="line"></span><br><span class="line">       /**</span><br><span class="line">        * Sorts the specified range of the array.</span><br><span class="line">        *</span><br><span class="line">        * @param a        the array to be sorted</span><br><span class="line">        * @param left     the index of the first element, inclusive, to be sorted</span><br><span class="line">        * @param right    the index of the last element, inclusive, to be sorted</span><br><span class="line">        * @param work     a workspace array (slice)</span><br><span class="line">        * @param workBase origin of usable space in work array</span><br><span class="line">        * @param workLen  usable size of work array</span><br><span class="line">        */</span><br><span class="line">       private static void doSort(char[] a, int left, int right,</span><br><span class="line">                                  char[] work, int workBase, int workLen) &#123;</span><br><span class="line">           // Use Quicksort on small arrays</span><br><span class="line">           if (right - left &lt; QUICKSORT_THRESHOLD) &#123;</span><br><span class="line">               sort(a, left, right, true);</span><br><span class="line">               return;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       /*</span><br><span class="line">        * Index run[i] is the start of i-th run</span><br><span class="line">        * (ascending or descending sequence).</span><br><span class="line">        */</span><br><span class="line">           int[] run = new int[MAX_RUN_COUNT + 1];</span><br><span class="line">           int count = 0;</span><br><span class="line">           run[0] = left;</span><br><span class="line"></span><br><span class="line">           // Check if the array is nearly sorted</span><br><span class="line">           for (int k = left; k &lt; right; run[count] = k) &#123;</span><br><span class="line">               if (a[k] &lt; a[k + 1]) &#123; // ascending</span><br><span class="line">                   while (++k &lt;= right &amp;&amp; a[k - 1] &lt;= a[k]) ;</span><br><span class="line">               &#125; else if (a[k] &gt; a[k + 1]) &#123; // descending</span><br><span class="line">                   while (++k &lt;= right &amp;&amp; a[k - 1] &gt;= a[k]) ;</span><br><span class="line">                   for (int lo = run[count] - 1, hi = k; ++lo &lt; --hi; ) &#123;</span><br><span class="line">                       char t = a[lo];</span><br><span class="line">                       a[lo] = a[hi];</span><br><span class="line">                       a[hi] = t;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; else &#123; // equal</span><br><span class="line">                   for (int m = MAX_RUN_LENGTH; ++k &lt;= right &amp;&amp; a[k - 1] == a[k]; ) &#123;</span><br><span class="line">                       if (--m == 0) &#123;</span><br><span class="line">                           sort(a, left, right, true);</span><br><span class="line">                           return;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">           /*</span><br><span class="line">            * The array is not highly structured,</span><br><span class="line">            * use Quicksort instead of merge sort.</span><br><span class="line">            */</span><br><span class="line">               if (++count == MAX_RUN_COUNT) &#123;</span><br><span class="line">                   sort(a, left, right, true);</span><br><span class="line">                   return;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // Check special cases</span><br><span class="line">           // Implementation note: variable &quot;right&quot; is increased by 1.</span><br><span class="line">           if (run[count] == right++) &#123; // The last run contains one element</span><br><span class="line">               run[++count] = right;</span><br><span class="line">           &#125; else if (count == 1) &#123; // The array is already sorted</span><br><span class="line">               return;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // Determine alternation base for merge</span><br><span class="line">           byte odd = 0;</span><br><span class="line">           for (int n = 1; (n &lt;&lt;= 1) &lt; count; odd ^= 1) ;</span><br><span class="line"></span><br><span class="line">           // Use or create temporary array b for merging</span><br><span class="line">           char[] b;                 // temp array; alternates with a</span><br><span class="line">           int ao, bo;              // array offsets from &apos;left&apos;</span><br><span class="line">           int blen = right - left; // space needed for b</span><br><span class="line">           if (work == null || workLen &lt; blen || workBase + blen &gt; work.length) &#123;</span><br><span class="line">               work = new char[blen];</span><br><span class="line">               workBase = 0;</span><br><span class="line">           &#125;</span><br><span class="line">           if (odd == 0) &#123;</span><br><span class="line">               System.arraycopy(a, left, work, workBase, blen);</span><br><span class="line">               b = a;</span><br><span class="line">               bo = 0;</span><br><span class="line">               a = work;</span><br><span class="line">               ao = workBase - left;</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               b = work;</span><br><span class="line">               ao = 0;</span><br><span class="line">               bo = workBase - left;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // Merging</span><br><span class="line">           for (int last; count &gt; 1; count = last) &#123;</span><br><span class="line">               for (int k = (last = 0) + 2; k &lt;= count; k += 2) &#123;</span><br><span class="line">                   int hi = run[k], mi = run[k - 1];</span><br><span class="line">                   for (int i = run[k - 2], p = i, q = mi; i &lt; hi; ++i) &#123;</span><br><span class="line">                       if (q &gt;= hi || p &lt; mi &amp;&amp; a[p + ao] &lt;= a[q + ao]) &#123;</span><br><span class="line">                           b[i + bo] = a[p++ + ao];</span><br><span class="line">                       &#125; else &#123;</span><br><span class="line">                           b[i + bo] = a[q++ + ao];</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">                   run[++last] = hi;</span><br><span class="line">               &#125;</span><br><span class="line">               if ((count &amp; 1) != 0) &#123;</span><br><span class="line">                   for (int i = right, lo = run[count - 1]; --i &gt;= lo;</span><br><span class="line">                        b[i + bo] = a[i + ao]</span><br><span class="line">                           )</span><br><span class="line">                       ;</span><br><span class="line">                   run[++last] = right;</span><br><span class="line">               &#125;</span><br><span class="line">               char[] t = a;</span><br><span class="line">               a = b;</span><br><span class="line">               b = t;</span><br><span class="line">               int o = ao;</span><br><span class="line">               ao = bo;</span><br><span class="line">               bo = o;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       /**</span><br><span class="line">        * Sorts the specified range of the array by Dual-Pivot Quicksort.</span><br><span class="line">        *</span><br><span class="line">        * @param a        the array to be sorted</span><br><span class="line">        * @param left     the index of the first element, inclusive, to be sorted</span><br><span class="line">        * @param right    the index of the last element, inclusive, to be sorted</span><br><span class="line">        * @param leftmost indicates if this part is the leftmost in the range</span><br><span class="line">        */</span><br><span class="line">       private static void sort(char[] a, int left, int right, boolean leftmost) &#123;</span><br><span class="line">           int length = right - left + 1;</span><br><span class="line"></span><br><span class="line">           // Use insertion sort on tiny arrays</span><br><span class="line">           if (length &lt; INSERTION_SORT_THRESHOLD) &#123;</span><br><span class="line">               if (leftmost) &#123;</span><br><span class="line">               /*</span><br><span class="line">                * Traditional (without sentinel) insertion sort,</span><br><span class="line">                * optimized for server VM, is used in case of</span><br><span class="line">                * the leftmost part.</span><br><span class="line">                */</span><br><span class="line">                   for (int i = left, j = i; i &lt; right; j = ++i) &#123;</span><br><span class="line">                       char ai = a[i + 1];</span><br><span class="line">                       while (ai &lt; a[j]) &#123;</span><br><span class="line">                           a[j + 1] = a[j];</span><br><span class="line">                           if (j-- == left) &#123;</span><br><span class="line">                               break;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                       a[j + 1] = ai;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">               /*</span><br><span class="line">                * Skip the longest ascending sequence.</span><br><span class="line">                */</span><br><span class="line">                   do &#123;</span><br><span class="line">                       if (left &gt;= right) &#123;</span><br><span class="line">                           return;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125; while (a[++left] &gt;= a[left - 1]);</span><br><span class="line"></span><br><span class="line">               /*</span><br><span class="line">                * Every element from adjoining part plays the role</span><br><span class="line">                * of sentinel, therefore this allows us to avoid the</span><br><span class="line">                * left range check on each iteration. Moreover, we use</span><br><span class="line">                * the more optimized algorithm, so called pair insertion</span><br><span class="line">                * sort, which is faster (in the context of Quicksort)</span><br><span class="line">                * than traditional implementation of insertion sort.</span><br><span class="line">                */</span><br><span class="line">                   for (int k = left; ++left &lt;= right; k = ++left) &#123;</span><br><span class="line">                       char a1 = a[k], a2 = a[left];</span><br><span class="line"></span><br><span class="line">                       if (a1 &lt; a2) &#123;</span><br><span class="line">                           a2 = a1;</span><br><span class="line">                           a1 = a[left];</span><br><span class="line">                       &#125;</span><br><span class="line">                       while (a1 &lt; a[--k]) &#123;</span><br><span class="line">                           a[k + 2] = a[k];</span><br><span class="line">                       &#125;</span><br><span class="line">                       a[++k + 1] = a1;</span><br><span class="line"></span><br><span class="line">                       while (a2 &lt; a[--k]) &#123;</span><br><span class="line">                           a[k + 1] = a[k];</span><br><span class="line">                       &#125;</span><br><span class="line">                       a[k + 1] = a2;</span><br><span class="line">                   &#125;</span><br><span class="line">                   char last = a[right];</span><br><span class="line"></span><br><span class="line">                   while (last &lt; a[--right]) &#123;</span><br><span class="line">                       a[right + 1] = a[right];</span><br><span class="line">                   &#125;</span><br><span class="line">                   a[right + 1] = last;</span><br><span class="line">               &#125;</span><br><span class="line">               return;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // Inexpensive approximation of length / 7</span><br><span class="line">           int seventh = (length &gt;&gt; 3) + (length &gt;&gt; 6) + 1;</span><br><span class="line"></span><br><span class="line">       /*</span><br><span class="line">        * Sort five evenly spaced elements around (and including) the</span><br><span class="line">        * center element in the range. These elements will be used for</span><br><span class="line">        * pivot selection as described below. The choice for spacing</span><br><span class="line">        * these elements was empirically determined to work well on</span><br><span class="line">        * a wide variety of inputs.</span><br><span class="line">        */</span><br><span class="line">           int e3 = (left + right) &gt;&gt;&gt; 1; // The midpoint</span><br><span class="line">           int e2 = e3 - seventh;</span><br><span class="line">           int e1 = e2 - seventh;</span><br><span class="line">           int e4 = e3 + seventh;</span><br><span class="line">           int e5 = e4 + seventh;</span><br><span class="line"></span><br><span class="line">           // Sort these elements using insertion sort</span><br><span class="line">           if (a[e2] &lt; a[e1]) &#123;</span><br><span class="line">               char t = a[e2];</span><br><span class="line">               a[e2] = a[e1];</span><br><span class="line">               a[e1] = t;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           if (a[e3] &lt; a[e2]) &#123;</span><br><span class="line">               char t = a[e3];</span><br><span class="line">               a[e3] = a[e2];</span><br><span class="line">               a[e2] = t;</span><br><span class="line">               if (t &lt; a[e1]) &#123;</span><br><span class="line">                   a[e2] = a[e1];</span><br><span class="line">                   a[e1] = t;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           if (a[e4] &lt; a[e3]) &#123;</span><br><span class="line">               char t = a[e4];</span><br><span class="line">               a[e4] = a[e3];</span><br><span class="line">               a[e3] = t;</span><br><span class="line">               if (t &lt; a[e2]) &#123;</span><br><span class="line">                   a[e3] = a[e2];</span><br><span class="line">                   a[e2] = t;</span><br><span class="line">                   if (t &lt; a[e1]) &#123;</span><br><span class="line">                       a[e2] = a[e1];</span><br><span class="line">                       a[e1] = t;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           if (a[e5] &lt; a[e4]) &#123;</span><br><span class="line">               char t = a[e5];</span><br><span class="line">               a[e5] = a[e4];</span><br><span class="line">               a[e4] = t;</span><br><span class="line">               if (t &lt; a[e3]) &#123;</span><br><span class="line">                   a[e4] = a[e3];</span><br><span class="line">                   a[e3] = t;</span><br><span class="line">                   if (t &lt; a[e2]) &#123;</span><br><span class="line">                       a[e3] = a[e2];</span><br><span class="line">                       a[e2] = t;</span><br><span class="line">                       if (t &lt; a[e1]) &#123;</span><br><span class="line">                           a[e2] = a[e1];</span><br><span class="line">                           a[e1] = t;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // Pointers</span><br><span class="line">           int less = left;  // The index of the first element of center part</span><br><span class="line">           int great = right; // The index before the first element of right part</span><br><span class="line"></span><br><span class="line">           if (a[e1] != a[e2] &amp;&amp; a[e2] != a[e3] &amp;&amp; a[e3] != a[e4] &amp;&amp; a[e4] != a[e5]) &#123;</span><br><span class="line">           /*</span><br><span class="line">            * Use the second and fourth of the five sorted elements as pivots.</span><br><span class="line">            * These values are inexpensive approximations of the first and</span><br><span class="line">            * second terciles of the array. Note that pivot1 &lt;= pivot2.</span><br><span class="line">            */</span><br><span class="line">               char pivot1 = a[e2];</span><br><span class="line">               char pivot2 = a[e4];</span><br><span class="line"></span><br><span class="line">           /*</span><br><span class="line">            * The first and the last elements to be sorted are moved to the</span><br><span class="line">            * locations formerly occupied by the pivots. When partitioning</span><br><span class="line">            * is complete, the pivots are swapped back into their final</span><br><span class="line">            * positions, and excluded from subsequent sorting.</span><br><span class="line">            */</span><br><span class="line">               a[e2] = a[left];</span><br><span class="line">               a[e4] = a[right];</span><br><span class="line"></span><br><span class="line">           /*</span><br><span class="line">            * Skip elements, which are less or greater than pivot values.</span><br><span class="line">            */</span><br><span class="line">               while (a[++less] &lt; pivot1) ;</span><br><span class="line">               while (a[--great] &gt; pivot2) ;</span><br><span class="line"></span><br><span class="line">           /*</span><br><span class="line">            * Partitioning:</span><br><span class="line">            *</span><br><span class="line">            *   left part           center part                   right part</span><br><span class="line">            * +--------------------------------------------------------------+</span><br><span class="line">            * |  &lt; pivot1  |  pivot1 &lt;= &amp;&amp; &lt;= pivot2  |    ?    |  &gt; pivot2  |</span><br><span class="line">            * +--------------------------------------------------------------+</span><br><span class="line">            *               ^                          ^       ^</span><br><span class="line">            *               |                          |       |</span><br><span class="line">            *              less                        k     great</span><br><span class="line">            *</span><br><span class="line">            * Invariants:</span><br><span class="line">            *</span><br><span class="line">            *              all in (left, less)   &lt; pivot1</span><br><span class="line">            *    pivot1 &lt;= all in [less, k)     &lt;= pivot2</span><br><span class="line">            *              all in (great, right) &gt; pivot2</span><br><span class="line">            *</span><br><span class="line">            * Pointer k is the first index of ?-part.</span><br><span class="line">            */</span><br><span class="line">               outer:</span><br><span class="line">               for (int k = less - 1; ++k &lt;= great; ) &#123;</span><br><span class="line">                   char ak = a[k];</span><br><span class="line">                   if (ak &lt; pivot1) &#123; // Move a[k] to left part</span><br><span class="line">                       a[k] = a[less];</span><br><span class="line">                   /*</span><br><span class="line">                    * Here and below we use &quot;a[i] = b; i++;&quot; instead</span><br><span class="line">                    * of &quot;a[i++] = b;&quot; due to performance issue.</span><br><span class="line">                    */</span><br><span class="line">                       a[less] = ak;</span><br><span class="line">                       ++less;</span><br><span class="line">                   &#125; else if (ak &gt; pivot2) &#123; // Move a[k] to right part</span><br><span class="line">                       while (a[great] &gt; pivot2) &#123;</span><br><span class="line">                           if (great-- == k) &#123;</span><br><span class="line">                               break outer;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                       if (a[great] &lt; pivot1) &#123; // a[great] &lt;= pivot2</span><br><span class="line">                           a[k] = a[less];</span><br><span class="line">                           a[less] = a[great];</span><br><span class="line">                           ++less;</span><br><span class="line">                       &#125; else &#123; // pivot1 &lt;= a[great] &lt;= pivot2</span><br><span class="line">                           a[k] = a[great];</span><br><span class="line">                       &#125;</span><br><span class="line">                   /*</span><br><span class="line">                    * Here and below we use &quot;a[i] = b; i--;&quot; instead</span><br><span class="line">                    * of &quot;a[i--] = b;&quot; due to performance issue.</span><br><span class="line">                    */</span><br><span class="line">                       a[great] = ak;</span><br><span class="line">                       --great;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               // Swap pivots into their final positions</span><br><span class="line">               a[left] = a[less - 1];</span><br><span class="line">               a[less - 1] = pivot1;</span><br><span class="line">               a[right] = a[great + 1];</span><br><span class="line">               a[great + 1] = pivot2;</span><br><span class="line"></span><br><span class="line">               // Sort left and right parts recursively, excluding known pivots</span><br><span class="line">               sort(a, left, less - 2, leftmost);</span><br><span class="line">               sort(a, great + 2, right, false);</span><br><span class="line"></span><br><span class="line">           /*</span><br><span class="line">            * If center part is too large (comprises &gt; 4/7 of the array),</span><br><span class="line">            * swap internal pivot values to ends.</span><br><span class="line">            */</span><br><span class="line">               if (less &lt; e1 &amp;&amp; e5 &lt; great) &#123;</span><br><span class="line">               /*</span><br><span class="line">                * Skip elements, which are equal to pivot values.</span><br><span class="line">                */</span><br><span class="line">                   while (a[less] == pivot1) &#123;</span><br><span class="line">                       ++less;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   while (a[great] == pivot2) &#123;</span><br><span class="line">                       --great;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">               /*</span><br><span class="line">                * Partitioning:</span><br><span class="line">                *</span><br><span class="line">                *   left part         center part                  right part</span><br><span class="line">                * +----------------------------------------------------------+</span><br><span class="line">                * | == pivot1 |  pivot1 &lt; &amp;&amp; &lt; pivot2  |    ?    | == pivot2 |</span><br><span class="line">                * +----------------------------------------------------------+</span><br><span class="line">                *              ^                        ^       ^</span><br><span class="line">                *              |                        |       |</span><br><span class="line">                *             less                      k     great</span><br><span class="line">                *</span><br><span class="line">                * Invariants:</span><br><span class="line">                *</span><br><span class="line">                *              all in (*,  less) == pivot1</span><br><span class="line">                *     pivot1 &lt; all in [less,  k)  &lt; pivot2</span><br><span class="line">                *              all in (great, *) == pivot2</span><br><span class="line">                *</span><br><span class="line">                * Pointer k is the first index of ?-part.</span><br><span class="line">                */</span><br><span class="line">                   outer:</span><br><span class="line">                   for (int k = less - 1; ++k &lt;= great; ) &#123;</span><br><span class="line">                       char ak = a[k];</span><br><span class="line">                       if (ak == pivot1) &#123; // Move a[k] to left part</span><br><span class="line">                           a[k] = a[less];</span><br><span class="line">                           a[less] = ak;</span><br><span class="line">                           ++less;</span><br><span class="line">                       &#125; else if (ak == pivot2) &#123; // Move a[k] to right part</span><br><span class="line">                           while (a[great] == pivot2) &#123;</span><br><span class="line">                               if (great-- == k) &#123;</span><br><span class="line">                                   break outer;</span><br><span class="line">                               &#125;</span><br><span class="line">                           &#125;</span><br><span class="line">                           if (a[great] == pivot1) &#123; // a[great] &lt; pivot2</span><br><span class="line">                               a[k] = a[less];</span><br><span class="line">                           /*</span><br><span class="line">                            * Even though a[great] equals to pivot1, the</span><br><span class="line">                            * assignment a[less] = pivot1 may be incorrect,</span><br><span class="line">                            * if a[great] and pivot1 are floating-point zeros</span><br><span class="line">                            * of different signs. Therefore in float and</span><br><span class="line">                            * double sorting methods we have to use more</span><br><span class="line">                            * accurate assignment a[less] = a[great].</span><br><span class="line">                            */</span><br><span class="line">                               a[less] = pivot1;</span><br><span class="line">                               ++less;</span><br><span class="line">                           &#125; else &#123; // pivot1 &lt; a[great] &lt; pivot2</span><br><span class="line">                               a[k] = a[great];</span><br><span class="line">                           &#125;</span><br><span class="line">                           a[great] = ak;</span><br><span class="line">                           --great;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               // Sort center part recursively</span><br><span class="line">               sort(a, less, great, false);</span><br><span class="line"></span><br><span class="line">           &#125; else &#123; // Partitioning with one pivot</span><br><span class="line">           /*</span><br><span class="line">            * Use the third of the five sorted elements as pivot.</span><br><span class="line">            * This value is inexpensive approximation of the median.</span><br><span class="line">            */</span><br><span class="line">               char pivot = a[e3];</span><br><span class="line"></span><br><span class="line">           /*</span><br><span class="line">            * Partitioning degenerates to the traditional 3-way</span><br><span class="line">            * (or &quot;Dutch National Flag&quot;) schema:</span><br><span class="line">            *</span><br><span class="line">            *   left part    center part              right part</span><br><span class="line">            * +-------------------------------------------------+</span><br><span class="line">            * |  &lt; pivot  |   == pivot   |     ?    |  &gt; pivot  |</span><br><span class="line">            * +-------------------------------------------------+</span><br><span class="line">            *              ^              ^        ^</span><br><span class="line">            *              |              |        |</span><br><span class="line">            *             less            k      great</span><br><span class="line">            *</span><br><span class="line">            * Invariants:</span><br><span class="line">            *</span><br><span class="line">            *   all in (left, less)   &lt; pivot</span><br><span class="line">            *   all in [less, k)     == pivot</span><br><span class="line">            *   all in (great, right) &gt; pivot</span><br><span class="line">            *</span><br><span class="line">            * Pointer k is the first index of ?-part.</span><br><span class="line">            */</span><br><span class="line">               for (int k = less; k &lt;= great; ++k) &#123;</span><br><span class="line">                   if (a[k] == pivot) &#123;</span><br><span class="line">                       continue;</span><br><span class="line">                   &#125;</span><br><span class="line">                   char ak = a[k];</span><br><span class="line">                   if (ak &lt; pivot) &#123; // Move a[k] to left part</span><br><span class="line">                       a[k] = a[less];</span><br><span class="line">                       a[less] = ak;</span><br><span class="line">                       ++less;</span><br><span class="line">                   &#125; else &#123; // a[k] &gt; pivot - Move a[k] to right part</span><br><span class="line">                       while (a[great] &gt; pivot) &#123;</span><br><span class="line">                           --great;</span><br><span class="line">                       &#125;</span><br><span class="line">                       if (a[great] &lt; pivot) &#123; // a[great] &lt;= pivot</span><br><span class="line">                           a[k] = a[less];</span><br><span class="line">                           a[less] = a[great];</span><br><span class="line">                           ++less;</span><br><span class="line">                       &#125; else &#123; // a[great] == pivot</span><br><span class="line">                       /*</span><br><span class="line">                        * Even though a[great] equals to pivot, the</span><br><span class="line">                        * assignment a[k] = pivot may be incorrect,</span><br><span class="line">                        * if a[great] and pivot are floating-point</span><br><span class="line">                        * zeros of different signs. Therefore in float</span><br><span class="line">                        * and double sorting methods we have to use</span><br><span class="line">                        * more accurate assignment a[k] = a[great].</span><br><span class="line">                        */</span><br><span class="line">                           a[k] = pivot;</span><br><span class="line">                       &#125;</span><br><span class="line">                       a[great] = ak;</span><br><span class="line">                       --great;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">           /*</span><br><span class="line">            * Sort left and right parts recursively.</span><br><span class="line">            * All elements from center part are equal</span><br><span class="line">            * and, therefore, already sorted.</span><br><span class="line">            */</span><br><span class="line">               sort(a, left, less - 1, leftmost);</span><br><span class="line">               sort(a, great + 1, right, false);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       /**</span><br><span class="line">        * The number of distinct byte values.</span><br><span class="line">        */</span><br><span class="line">       private static final int NUM_BYTE_VALUES = 1 &lt;&lt; 8;</span><br><span class="line"></span><br><span class="line">       /**</span><br><span class="line">        * Sorts the specified range of the array.</span><br><span class="line">        *</span><br><span class="line">        * @param a     the array to be sorted</span><br><span class="line">        * @param left  the index of the first element, inclusive, to be sorted</span><br><span class="line">        * @param right the index of the last element, inclusive, to be sorted</span><br><span class="line">        */</span><br><span class="line">       static void sort(byte[] a, int left, int right) &#123;</span><br><span class="line">           // Use counting sort on large arrays</span><br><span class="line">           if (right - left &gt; COUNTING_SORT_THRESHOLD_FOR_BYTE) &#123;</span><br><span class="line">               int[] count = new int[NUM_BYTE_VALUES];</span><br><span class="line"></span><br><span class="line">               for (int i = left - 1; ++i &lt;= right;</span><br><span class="line">                    count[a[i] - Byte.MIN_VALUE]++</span><br><span class="line">                       )</span><br><span class="line">                   ;</span><br><span class="line">               for (int i = NUM_BYTE_VALUES, k = right + 1; k &gt; left; ) &#123;</span><br><span class="line">                   while (count[--i] == 0) ;</span><br><span class="line">                   byte value = (byte) (i + Byte.MIN_VALUE);</span><br><span class="line">                   int s = count[i];</span><br><span class="line"></span><br><span class="line">                   do &#123;</span><br><span class="line">                       a[--k] = value;</span><br><span class="line">                   &#125; while (--s &gt; 0);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; else &#123; // Use insertion sort on small arrays</span><br><span class="line">               for (int i = left, j = i; i &lt; right; j = ++i) &#123;</span><br><span class="line">                   byte ai = a[i + 1];</span><br><span class="line">                   while (ai &lt; a[j]) &#123;</span><br><span class="line">                       a[j + 1] = a[j];</span><br><span class="line">                       if (j-- == left) &#123;</span><br><span class="line">                           break;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">                   a[j + 1] = ai;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       /**</span><br><span class="line">        * Sorts the specified range of the array using the given</span><br><span class="line">        * workspace array slice if possible for merging</span><br><span class="line">        *</span><br><span class="line">        * @param a        the array to be sorted</span><br><span class="line">        * @param left     the index of the first element, inclusive, to be sorted</span><br><span class="line">        * @param right    the index of the last element, inclusive, to be sorted</span><br><span class="line">        * @param work     a workspace array (slice)</span><br><span class="line">        * @param workBase origin of usable space in work array</span><br><span class="line">        * @param workLen  usable size of work array</span><br><span class="line">        */</span><br><span class="line">       static void sort(float[] a, int left, int right,</span><br><span class="line">                        float[] work, int workBase, int workLen) &#123;</span><br><span class="line">       /*</span><br><span class="line">        * Phase 1: Move NaNs to the end of the array.</span><br><span class="line">        */</span><br><span class="line">           while (left &lt;= right &amp;&amp; Float.isNaN(a[right])) &#123;</span><br><span class="line">               --right;</span><br><span class="line">           &#125;</span><br><span class="line">           for (int k = right; --k &gt;= left; ) &#123;</span><br><span class="line">               float ak = a[k];</span><br><span class="line">               if (ak != ak) &#123; // a[k] is NaN</span><br><span class="line">                   a[k] = a[right];</span><br><span class="line">                   a[right] = ak;</span><br><span class="line">                   --right;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       /*</span><br><span class="line">        * Phase 2: Sort everything except NaNs (which are already in place).</span><br><span class="line">        */</span><br><span class="line">           doSort(a, left, right, work, workBase, workLen);</span><br><span class="line"></span><br><span class="line">       /*</span><br><span class="line">        * Phase 3: Place negative zeros before positive zeros.</span><br><span class="line">        */</span><br><span class="line">           int hi = right;</span><br><span class="line"></span><br><span class="line">       /*</span><br><span class="line">        * Find the first zero, or first positive, or last negative element.</span><br><span class="line">        */</span><br><span class="line">           while (left &lt; hi) &#123;</span><br><span class="line">               int middle = (left + hi) &gt;&gt;&gt; 1;</span><br><span class="line">               float middleValue = a[middle];</span><br><span class="line"></span><br><span class="line">               if (middleValue &lt; 0.0f) &#123;</span><br><span class="line">                   left = middle + 1;</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">                   hi = middle;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       /*</span><br><span class="line">        * Skip the last negative value (if any) or all leading negative zeros.</span><br><span class="line">        */</span><br><span class="line">           while (left &lt;= right &amp;&amp; Float.floatToRawIntBits(a[left]) &lt; 0) &#123;</span><br><span class="line">               ++left;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       /*</span><br><span class="line">        * Move negative zeros to the beginning of the sub-range.</span><br><span class="line">        *</span><br><span class="line">        * Partitioning:</span><br><span class="line">        *</span><br><span class="line">        * +----------------------------------------------------+</span><br><span class="line">        * |   &lt; 0.0   |   -0.0   |   0.0   |   ?  ( &gt;= 0.0 )   |</span><br><span class="line">        * +----------------------------------------------------+</span><br><span class="line">        *              ^          ^         ^</span><br><span class="line">        *              |          |         |</span><br><span class="line">        *             left        p         k</span><br><span class="line">        *</span><br><span class="line">        * Invariants:</span><br><span class="line">        *</span><br><span class="line">        *   all in (*,  left)  &lt;  0.0</span><br><span class="line">        *   all in [left,  p) == -0.0</span><br><span class="line">        *   all in [p,     k) ==  0.0</span><br><span class="line">        *   all in [k, right] &gt;=  0.0</span><br><span class="line">        *</span><br><span class="line">        * Pointer k is the first index of ?-part.</span><br><span class="line">        */</span><br><span class="line">           for (int k = left, p = left - 1; ++k &lt;= right; ) &#123;</span><br><span class="line">               float ak = a[k];</span><br><span class="line">               if (ak != 0.0f) &#123;</span><br><span class="line">                   break;</span><br><span class="line">               &#125;</span><br><span class="line">               if (Float.floatToRawIntBits(ak) &lt; 0) &#123; // ak is -0.0f</span><br><span class="line">                   a[k] = 0.0f;</span><br><span class="line">                   a[++p] = -0.0f;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       /**</span><br><span class="line">        * Sorts the specified range of the array.</span><br><span class="line">        *</span><br><span class="line">        * @param a        the array to be sorted</span><br><span class="line">        * @param left     the index of the first element, inclusive, to be sorted</span><br><span class="line">        * @param right    the index of the last element, inclusive, to be sorted</span><br><span class="line">        * @param work     a workspace array (slice)</span><br><span class="line">        * @param workBase origin of usable space in work array</span><br><span class="line">        * @param workLen  usable size of work array</span><br><span class="line">        */</span><br><span class="line">       private static void doSort(float[] a, int left, int right,</span><br><span class="line">                                  float[] work, int workBase, int workLen) &#123;</span><br><span class="line">           // Use Quicksort on small arrays</span><br><span class="line">           if (right - left &lt; QUICKSORT_THRESHOLD) &#123;</span><br><span class="line">               sort(a, left, right, true);</span><br><span class="line">               return;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       /*</span><br><span class="line">        * Index run[i] is the start of i-th run</span><br><span class="line">        * (ascending or descending sequence).</span><br><span class="line">        */</span><br><span class="line">           int[] run = new int[MAX_RUN_COUNT + 1];</span><br><span class="line">           int count = 0;</span><br><span class="line">           run[0] = left;</span><br><span class="line"></span><br><span class="line">           // Check if the array is nearly sorted</span><br><span class="line">           for (int k = left; k &lt; right; run[count] = k) &#123;</span><br><span class="line">               if (a[k] &lt; a[k + 1]) &#123; // ascending</span><br><span class="line">                   while (++k &lt;= right &amp;&amp; a[k - 1] &lt;= a[k]) ;</span><br><span class="line">               &#125; else if (a[k] &gt; a[k + 1]) &#123; // descending</span><br><span class="line">                   while (++k &lt;= right &amp;&amp; a[k - 1] &gt;= a[k]) ;</span><br><span class="line">                   for (int lo = run[count] - 1, hi = k; ++lo &lt; --hi; ) &#123;</span><br><span class="line">                       float t = a[lo];</span><br><span class="line">                       a[lo] = a[hi];</span><br><span class="line">                       a[hi] = t;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; else &#123; // equal</span><br><span class="line">                   for (int m = MAX_RUN_LENGTH; ++k &lt;= right &amp;&amp; a[k - 1] == a[k]; ) &#123;</span><br><span class="line">                       if (--m == 0) &#123;</span><br><span class="line">                           sort(a, left, right, true);</span><br><span class="line">                           return;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">           /*</span><br><span class="line">            * The array is not highly structured,</span><br><span class="line">            * use Quicksort instead of merge sort.</span><br><span class="line">            */</span><br><span class="line">               if (++count == MAX_RUN_COUNT) &#123;</span><br><span class="line">                   sort(a, left, right, true);</span><br><span class="line">                   return;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // Check special cases</span><br><span class="line">           // Implementation note: variable &quot;right&quot; is increased by 1.</span><br><span class="line">           if (run[count] == right++) &#123; // The last run contains one element</span><br><span class="line">               run[++count] = right;</span><br><span class="line">           &#125; else if (count == 1) &#123; // The array is already sorted</span><br><span class="line">               return;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // Determine alternation base for merge</span><br><span class="line">           byte odd = 0;</span><br><span class="line">           for (int n = 1; (n &lt;&lt;= 1) &lt; count; odd ^= 1) ;</span><br><span class="line"></span><br><span class="line">           // Use or create temporary array b for merging</span><br><span class="line">           float[] b;                 // temp array; alternates with a</span><br><span class="line">           int ao, bo;              // array offsets from &apos;left&apos;</span><br><span class="line">           int blen = right - left; // space needed for b</span><br><span class="line">           if (work == null || workLen &lt; blen || workBase + blen &gt; work.length) &#123;</span><br><span class="line">               work = new float[blen];</span><br><span class="line">               workBase = 0;</span><br><span class="line">           &#125;</span><br><span class="line">           if (odd == 0) &#123;</span><br><span class="line">               System.arraycopy(a, left, work, workBase, blen);</span><br><span class="line">               b = a;</span><br><span class="line">               bo = 0;</span><br><span class="line">               a = work;</span><br><span class="line">               ao = workBase - left;</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               b = work;</span><br><span class="line">               ao = 0;</span><br><span class="line">               bo = workBase - left;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // Merging</span><br><span class="line">           for (int last; count &gt; 1; count = last) &#123;</span><br><span class="line">               for (int k = (last = 0) + 2; k &lt;= count; k += 2) &#123;</span><br><span class="line">                   int hi = run[k], mi = run[k - 1];</span><br><span class="line">                   for (int i = run[k - 2], p = i, q = mi; i &lt; hi; ++i) &#123;</span><br><span class="line">                       if (q &gt;= hi || p &lt; mi &amp;&amp; a[p + ao] &lt;= a[q + ao]) &#123;</span><br><span class="line">                           b[i + bo] = a[p++ + ao];</span><br><span class="line">                       &#125; else &#123;</span><br><span class="line">                           b[i + bo] = a[q++ + ao];</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">                   run[++last] = hi;</span><br><span class="line">               &#125;</span><br><span class="line">               if ((count &amp; 1) != 0) &#123;</span><br><span class="line">                   for (int i = right, lo = run[count - 1]; --i &gt;= lo;</span><br><span class="line">                        b[i + bo] = a[i + ao]</span><br><span class="line">                           )</span><br><span class="line">                       ;</span><br><span class="line">                   run[++last] = right;</span><br><span class="line">               &#125;</span><br><span class="line">               float[] t = a;</span><br><span class="line">               a = b;</span><br><span class="line">               b = t;</span><br><span class="line">               int o = ao;</span><br><span class="line">               ao = bo;</span><br><span class="line">               bo = o;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       /**</span><br><span class="line">        * Sorts the specified range of the array by Dual-Pivot Quicksort.</span><br><span class="line">        *</span><br><span class="line">        * @param a        the array to be sorted</span><br><span class="line">        * @param left     the index of the first element, inclusive, to be sorted</span><br><span class="line">        * @param right    the index of the last element, inclusive, to be sorted</span><br><span class="line">        * @param leftmost indicates if this part is the leftmost in the range</span><br><span class="line">        */</span><br><span class="line">       private static void sort(float[] a, int left, int right, boolean leftmost) &#123;</span><br><span class="line">           int length = right - left + 1;</span><br><span class="line"></span><br><span class="line">           // Use insertion sort on tiny arrays</span><br><span class="line">           if (length &lt; INSERTION_SORT_THRESHOLD) &#123;</span><br><span class="line">               if (leftmost) &#123;</span><br><span class="line">               /*</span><br><span class="line">                * Traditional (without sentinel) insertion sort,</span><br><span class="line">                * optimized for server VM, is used in case of</span><br><span class="line">                * the leftmost part.</span><br><span class="line">                */</span><br><span class="line">                   for (int i = left, j = i; i &lt; right; j = ++i) &#123;</span><br><span class="line">                       float ai = a[i + 1];</span><br><span class="line">                       while (ai &lt; a[j]) &#123;</span><br><span class="line">                           a[j + 1] = a[j];</span><br><span class="line">                           if (j-- == left) &#123;</span><br><span class="line">                               break;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                       a[j + 1] = ai;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">               /*</span><br><span class="line">                * Skip the longest ascending sequence.</span><br><span class="line">                */</span><br><span class="line">                   do &#123;</span><br><span class="line">                       if (left &gt;= right) &#123;</span><br><span class="line">                           return;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125; while (a[++left] &gt;= a[left - 1]);</span><br><span class="line"></span><br><span class="line">               /*</span><br><span class="line">                * Every element from adjoining part plays the role</span><br><span class="line">                * of sentinel, therefore this allows us to avoid the</span><br><span class="line">                * left range check on each iteration. Moreover, we use</span><br><span class="line">                * the more optimized algorithm, so called pair insertion</span><br><span class="line">                * sort, which is faster (in the context of Quicksort)</span><br><span class="line">                * than traditional implementation of insertion sort.</span><br><span class="line">                */</span><br><span class="line">                   for (int k = left; ++left &lt;= right; k = ++left) &#123;</span><br><span class="line">                       float a1 = a[k], a2 = a[left];</span><br><span class="line"></span><br><span class="line">                       if (a1 &lt; a2) &#123;</span><br><span class="line">                           a2 = a1;</span><br><span class="line">                           a1 = a[left];</span><br><span class="line">                       &#125;</span><br><span class="line">                       while (a1 &lt; a[--k]) &#123;</span><br><span class="line">                           a[k + 2] = a[k];</span><br><span class="line">                       &#125;</span><br><span class="line">                       a[++k + 1] = a1;</span><br><span class="line"></span><br><span class="line">                       while (a2 &lt; a[--k]) &#123;</span><br><span class="line">                           a[k + 1] = a[k];</span><br><span class="line">                       &#125;</span><br><span class="line">                       a[k + 1] = a2;</span><br><span class="line">                   &#125;</span><br><span class="line">                   float last = a[right];</span><br><span class="line"></span><br><span class="line">                   while (last &lt; a[--right]) &#123;</span><br><span class="line">                       a[right + 1] = a[right];</span><br><span class="line">                   &#125;</span><br><span class="line">                   a[right + 1] = last;</span><br><span class="line">               &#125;</span><br><span class="line">               return;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // Inexpensive approximation of length / 7</span><br><span class="line">           int seventh = (length &gt;&gt; 3) + (length &gt;&gt; 6) + 1;</span><br><span class="line"></span><br><span class="line">       /*</span><br><span class="line">        * Sort five evenly spaced elements around (and including) the</span><br><span class="line">        * center element in the range. These elements will be used for</span><br><span class="line">        * pivot selection as described below. The choice for spacing</span><br><span class="line">        * these elements was empirically determined to work well on</span><br><span class="line">        * a wide variety of inputs.</span><br><span class="line">        */</span><br><span class="line">           int e3 = (left + right) &gt;&gt;&gt; 1; // The midpoint</span><br><span class="line">           int e2 = e3 - seventh;</span><br><span class="line">           int e1 = e2 - seventh;</span><br><span class="line">           int e4 = e3 + seventh;</span><br><span class="line">           int e5 = e4 + seventh;</span><br><span class="line"></span><br><span class="line">           // Sort these elements using insertion sort</span><br><span class="line">           if (a[e2] &lt; a[e1]) &#123;</span><br><span class="line">               float t = a[e2];</span><br><span class="line">               a[e2] = a[e1];</span><br><span class="line">               a[e1] = t;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           if (a[e3] &lt; a[e2]) &#123;</span><br><span class="line">               float t = a[e3];</span><br><span class="line">               a[e3] = a[e2];</span><br><span class="line">               a[e2] = t;</span><br><span class="line">               if (t &lt; a[e1]) &#123;</span><br><span class="line">                   a[e2] = a[e1];</span><br><span class="line">                   a[e1] = t;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           if (a[e4] &lt; a[e3]) &#123;</span><br><span class="line">               float t = a[e4];</span><br><span class="line">               a[e4] = a[e3];</span><br><span class="line">               a[e3] = t;</span><br><span class="line">               if (t &lt; a[e2]) &#123;</span><br><span class="line">                   a[e3] = a[e2];</span><br><span class="line">                   a[e2] = t;</span><br><span class="line">                   if (t &lt; a[e1]) &#123;</span><br><span class="line">                       a[e2] = a[e1];</span><br><span class="line">                       a[e1] = t;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           if (a[e5] &lt; a[e4]) &#123;</span><br><span class="line">               float t = a[e5];</span><br><span class="line">               a[e5] = a[e4];</span><br><span class="line">               a[e4] = t;</span><br><span class="line">               if (t &lt; a[e3]) &#123;</span><br><span class="line">                   a[e4] = a[e3];</span><br><span class="line">                   a[e3] = t;</span><br><span class="line">                   if (t &lt; a[e2]) &#123;</span><br><span class="line">                       a[e3] = a[e2];</span><br><span class="line">                       a[e2] = t;</span><br><span class="line">                       if (t &lt; a[e1]) &#123;</span><br><span class="line">                           a[e2] = a[e1];</span><br><span class="line">                           a[e1] = t;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // Pointers</span><br><span class="line">           int less = left;  // The index of the first element of center part</span><br><span class="line">           int great = right; // The index before the first element of right part</span><br><span class="line"></span><br><span class="line">           if (a[e1] != a[e2] &amp;&amp; a[e2] != a[e3] &amp;&amp; a[e3] != a[e4] &amp;&amp; a[e4] != a[e5]) &#123;</span><br><span class="line">           /*</span><br><span class="line">            * Use the second and fourth of the five sorted elements as pivots.</span><br><span class="line">            * These values are inexpensive approximations of the first and</span><br><span class="line">            * second terciles of the array. Note that pivot1 &lt;= pivot2.</span><br><span class="line">            */</span><br><span class="line">               float pivot1 = a[e2];</span><br><span class="line">               float pivot2 = a[e4];</span><br><span class="line"></span><br><span class="line">           /*</span><br><span class="line">            * The first and the last elements to be sorted are moved to the</span><br><span class="line">            * locations formerly occupied by the pivots. When partitioning</span><br><span class="line">            * is complete, the pivots are swapped back into their final</span><br><span class="line">            * positions, and excluded from subsequent sorting.</span><br><span class="line">            */</span><br><span class="line">               a[e2] = a[left];</span><br><span class="line">               a[e4] = a[right];</span><br><span class="line"></span><br><span class="line">           /*</span><br><span class="line">            * Skip elements, which are less or greater than pivot values.</span><br><span class="line">            */</span><br><span class="line">               while (a[++less] &lt; pivot1) ;</span><br><span class="line">               while (a[--great] &gt; pivot2) ;</span><br><span class="line"></span><br><span class="line">           /*</span><br><span class="line">            * Partitioning:</span><br><span class="line">            *</span><br><span class="line">            *   left part           center part                   right part</span><br><span class="line">            * +--------------------------------------------------------------+</span><br><span class="line">            * |  &lt; pivot1  |  pivot1 &lt;= &amp;&amp; &lt;= pivot2  |    ?    |  &gt; pivot2  |</span><br><span class="line">            * +--------------------------------------------------------------+</span><br><span class="line">            *               ^                          ^       ^</span><br><span class="line">            *               |                          |       |</span><br><span class="line">            *              less                        k     great</span><br><span class="line">            *</span><br><span class="line">            * Invariants:</span><br><span class="line">            *</span><br><span class="line">            *              all in (left, less)   &lt; pivot1</span><br><span class="line">            *    pivot1 &lt;= all in [less, k)     &lt;= pivot2</span><br><span class="line">            *              all in (great, right) &gt; pivot2</span><br><span class="line">            *</span><br><span class="line">            * Pointer k is the first index of ?-part.</span><br><span class="line">            */</span><br><span class="line">               outer:</span><br><span class="line">               for (int k = less - 1; ++k &lt;= great; ) &#123;</span><br><span class="line">                   float ak = a[k];</span><br><span class="line">                   if (ak &lt; pivot1) &#123; // Move a[k] to left part</span><br><span class="line">                       a[k] = a[less];</span><br><span class="line">                   /*</span><br><span class="line">                    * Here and below we use &quot;a[i] = b; i++;&quot; instead</span><br><span class="line">                    * of &quot;a[i++] = b;&quot; due to performance issue.</span><br><span class="line">                    */</span><br><span class="line">                       a[less] = ak;</span><br><span class="line">                       ++less;</span><br><span class="line">                   &#125; else if (ak &gt; pivot2) &#123; // Move a[k] to right part</span><br><span class="line">                       while (a[great] &gt; pivot2) &#123;</span><br><span class="line">                           if (great-- == k) &#123;</span><br><span class="line">                               break outer;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                       if (a[great] &lt; pivot1) &#123; // a[great] &lt;= pivot2</span><br><span class="line">                           a[k] = a[less];</span><br><span class="line">                           a[less] = a[great];</span><br><span class="line">                           ++less;</span><br><span class="line">                       &#125; else &#123; // pivot1 &lt;= a[great] &lt;= pivot2</span><br><span class="line">                           a[k] = a[great];</span><br><span class="line">                       &#125;</span><br><span class="line">                   /*</span><br><span class="line">                    * Here and below we use &quot;a[i] = b; i--;&quot; instead</span><br><span class="line">                    * of &quot;a[i--] = b;&quot; due to performance issue.</span><br><span class="line">                    */</span><br><span class="line">                       a[great] = ak;</span><br><span class="line">                       --great;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               // Swap pivots into their final positions</span><br><span class="line">               a[left] = a[less - 1];</span><br><span class="line">               a[less - 1] = pivot1;</span><br><span class="line">               a[right] = a[great + 1];</span><br><span class="line">               a[great + 1] = pivot2;</span><br><span class="line"></span><br><span class="line">               // Sort left and right parts recursively, excluding known pivots</span><br><span class="line">               sort(a, left, less - 2, leftmost);</span><br><span class="line">               sort(a, great + 2, right, false);</span><br><span class="line"></span><br><span class="line">           /*</span><br><span class="line">            * If center part is too large (comprises &gt; 4/7 of the array),</span><br><span class="line">            * swap internal pivot values to ends.</span><br><span class="line">            */</span><br><span class="line">               if (less &lt; e1 &amp;&amp; e5 &lt; great) &#123;</span><br><span class="line">               /*</span><br><span class="line">                * Skip elements, which are equal to pivot values.</span><br><span class="line">                */</span><br><span class="line">                   while (a[less] == pivot1) &#123;</span><br><span class="line">                       ++less;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   while (a[great] == pivot2) &#123;</span><br><span class="line">                       --great;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">               /*</span><br><span class="line">                * Partitioning:</span><br><span class="line">                *</span><br><span class="line">                *   left part         center part                  right part</span><br><span class="line">                * +----------------------------------------------------------+</span><br><span class="line">                * | == pivot1 |  pivot1 &lt; &amp;&amp; &lt; pivot2  |    ?    | == pivot2 |</span><br><span class="line">                * +----------------------------------------------------------+</span><br><span class="line">                *              ^                        ^       ^</span><br><span class="line">                *              |                        |       |</span><br><span class="line">                *             less                      k     great</span><br><span class="line">                *</span><br><span class="line">                * Invariants:</span><br><span class="line">                *</span><br><span class="line">                *              all in (*,  less) == pivot1</span><br><span class="line">                *     pivot1 &lt; all in [less,  k)  &lt; pivot2</span><br><span class="line">                *              all in (great, *) == pivot2</span><br><span class="line">                *</span><br><span class="line">                * Pointer k is the first index of ?-part.</span><br><span class="line">                */</span><br><span class="line">                   outer:</span><br><span class="line">                   for (int k = less - 1; ++k &lt;= great; ) &#123;</span><br><span class="line">                       float ak = a[k];</span><br><span class="line">                       if (ak == pivot1) &#123; // Move a[k] to left part</span><br><span class="line">                           a[k] = a[less];</span><br><span class="line">                           a[less] = ak;</span><br><span class="line">                           ++less;</span><br><span class="line">                       &#125; else if (ak == pivot2) &#123; // Move a[k] to right part</span><br><span class="line">                           while (a[great] == pivot2) &#123;</span><br><span class="line">                               if (great-- == k) &#123;</span><br><span class="line">                                   break outer;</span><br><span class="line">                               &#125;</span><br><span class="line">                           &#125;</span><br><span class="line">                           if (a[great] == pivot1) &#123; // a[great] &lt; pivot2</span><br><span class="line">                               a[k] = a[less];</span><br><span class="line">                           /*</span><br><span class="line">                            * Even though a[great] equals to pivot1, the</span><br><span class="line">                            * assignment a[less] = pivot1 may be incorrect,</span><br><span class="line">                            * if a[great] and pivot1 are floating-point zeros</span><br><span class="line">                            * of different signs. Therefore in float and</span><br><span class="line">                            * double sorting methods we have to use more</span><br><span class="line">                            * accurate assignment a[less] = a[great].</span><br><span class="line">                            */</span><br><span class="line">                               a[less] = a[great];</span><br><span class="line">                               ++less;</span><br><span class="line">                           &#125; else &#123; // pivot1 &lt; a[great] &lt; pivot2</span><br><span class="line">                               a[k] = a[great];</span><br><span class="line">                           &#125;</span><br><span class="line">                           a[great] = ak;</span><br><span class="line">                           --great;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               // Sort center part recursively</span><br><span class="line">               sort(a, less, great, false);</span><br><span class="line"></span><br><span class="line">           &#125; else &#123; // Partitioning with one pivot</span><br><span class="line">           /*</span><br><span class="line">            * Use the third of the five sorted elements as pivot.</span><br><span class="line">            * This value is inexpensive approximation of the median.</span><br><span class="line">            */</span><br><span class="line">               float pivot = a[e3];</span><br><span class="line"></span><br><span class="line">           /*</span><br><span class="line">            * Partitioning degenerates to the traditional 3-way</span><br><span class="line">            * (or &quot;Dutch National Flag&quot;) schema:</span><br><span class="line">            *</span><br><span class="line">            *   left part    center part              right part</span><br><span class="line">            * +-------------------------------------------------+</span><br><span class="line">            * |  &lt; pivot  |   == pivot   |     ?    |  &gt; pivot  |</span><br><span class="line">            * +-------------------------------------------------+</span><br><span class="line">            *              ^              ^        ^</span><br><span class="line">            *              |              |        |</span><br><span class="line">            *             less            k      great</span><br><span class="line">            *</span><br><span class="line">            * Invariants:</span><br><span class="line">            *</span><br><span class="line">            *   all in (left, less)   &lt; pivot</span><br><span class="line">            *   all in [less, k)     == pivot</span><br><span class="line">            *   all in (great, right) &gt; pivot</span><br><span class="line">            *</span><br><span class="line">            * Pointer k is the first index of ?-part.</span><br><span class="line">            */</span><br><span class="line">               for (int k = less; k &lt;= great; ++k) &#123;</span><br><span class="line">                   if (a[k] == pivot) &#123;</span><br><span class="line">                       continue;</span><br><span class="line">                   &#125;</span><br><span class="line">                   float ak = a[k];</span><br><span class="line">                   if (ak &lt; pivot) &#123; // Move a[k] to left part</span><br><span class="line">                       a[k] = a[less];</span><br><span class="line">                       a[less] = ak;</span><br><span class="line">                       ++less;</span><br><span class="line">                   &#125; else &#123; // a[k] &gt; pivot - Move a[k] to right part</span><br><span class="line">                       while (a[great] &gt; pivot) &#123;</span><br><span class="line">                           --great;</span><br><span class="line">                       &#125;</span><br><span class="line">                       if (a[great] &lt; pivot) &#123; // a[great] &lt;= pivot</span><br><span class="line">                           a[k] = a[less];</span><br><span class="line">                           a[less] = a[great];</span><br><span class="line">                           ++less;</span><br><span class="line">                       &#125; else &#123; // a[great] == pivot</span><br><span class="line">                       /*</span><br><span class="line">                        * Even though a[great] equals to pivot, the</span><br><span class="line">                        * assignment a[k] = pivot may be incorrect,</span><br><span class="line">                        * if a[great] and pivot are floating-point</span><br><span class="line">                        * zeros of different signs. Therefore in float</span><br><span class="line">                        * and double sorting methods we have to use</span><br><span class="line">                        * more accurate assignment a[k] = a[great].</span><br><span class="line">                        */</span><br><span class="line">                           a[k] = a[great];</span><br><span class="line">                       &#125;</span><br><span class="line">                       a[great] = ak;</span><br><span class="line">                       --great;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">           /*</span><br><span class="line">            * Sort left and right parts recursively.</span><br><span class="line">            * All elements from center part are equal</span><br><span class="line">            * and, therefore, already sorted.</span><br><span class="line">            */</span><br><span class="line">               sort(a, left, less - 1, leftmost);</span><br><span class="line">               sort(a, great + 1, right, false);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       /**</span><br><span class="line">        * Sorts the specified range of the array using the given</span><br><span class="line">        * workspace array slice if possible for merging</span><br><span class="line">        *</span><br><span class="line">        * @param a        the array to be sorted</span><br><span class="line">        * @param left     the index of the first element, inclusive, to be sorted</span><br><span class="line">        * @param right    the index of the last element, inclusive, to be sorted</span><br><span class="line">        * @param work     a workspace array (slice)</span><br><span class="line">        * @param workBase origin of usable space in work array</span><br><span class="line">        * @param workLen  usable size of work array</span><br><span class="line">        */</span><br><span class="line">       static void sort(double[] a, int left, int right,</span><br><span class="line">                        double[] work, int workBase, int workLen) &#123;</span><br><span class="line">       /*</span><br><span class="line">        * Phase 1: Move NaNs to the end of the array.</span><br><span class="line">        */</span><br><span class="line">           while (left &lt;= right &amp;&amp; Double.isNaN(a[right])) &#123;</span><br><span class="line">               --right;</span><br><span class="line">           &#125;</span><br><span class="line">           for (int k = right; --k &gt;= left; ) &#123;</span><br><span class="line">               double ak = a[k];</span><br><span class="line">               if (ak != ak) &#123; // a[k] is NaN</span><br><span class="line">                   a[k] = a[right];</span><br><span class="line">                   a[right] = ak;</span><br><span class="line">                   --right;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       /*</span><br><span class="line">        * Phase 2: Sort everything except NaNs (which are already in place).</span><br><span class="line">        */</span><br><span class="line">           doSort(a, left, right, work, workBase, workLen);</span><br><span class="line"></span><br><span class="line">       /*</span><br><span class="line">        * Phase 3: Place negative zeros before positive zeros.</span><br><span class="line">        */</span><br><span class="line">           int hi = right;</span><br><span class="line"></span><br><span class="line">       /*</span><br><span class="line">        * Find the first zero, or first positive, or last negative element.</span><br><span class="line">        */</span><br><span class="line">           while (left &lt; hi) &#123;</span><br><span class="line">               int middle = (left + hi) &gt;&gt;&gt; 1;</span><br><span class="line">               double middleValue = a[middle];</span><br><span class="line"></span><br><span class="line">               if (middleValue &lt; 0.0d) &#123;</span><br><span class="line">                   left = middle + 1;</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">                   hi = middle;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       /*</span><br><span class="line">        * Skip the last negative value (if any) or all leading negative zeros.</span><br><span class="line">        */</span><br><span class="line">           while (left &lt;= right &amp;&amp; Double.doubleToRawLongBits(a[left]) &lt; 0) &#123;</span><br><span class="line">               ++left;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       /*</span><br><span class="line">        * Move negative zeros to the beginning of the sub-range.</span><br><span class="line">        *</span><br><span class="line">        * Partitioning:</span><br><span class="line">        *</span><br><span class="line">        * +----------------------------------------------------+</span><br><span class="line">        * |   &lt; 0.0   |   -0.0   |   0.0   |   ?  ( &gt;= 0.0 )   |</span><br><span class="line">        * +----------------------------------------------------+</span><br><span class="line">        *              ^          ^         ^</span><br><span class="line">        *              |          |         |</span><br><span class="line">        *             left        p         k</span><br><span class="line">        *</span><br><span class="line">        * Invariants:</span><br><span class="line">        *</span><br><span class="line">        *   all in (*,  left)  &lt;  0.0</span><br><span class="line">        *   all in [left,  p) == -0.0</span><br><span class="line">        *   all in [p,     k) ==  0.0</span><br><span class="line">        *   all in [k, right] &gt;=  0.0</span><br><span class="line">        *</span><br><span class="line">        * Pointer k is the first index of ?-part.</span><br><span class="line">        */</span><br><span class="line">           for (int k = left, p = left - 1; ++k &lt;= right; ) &#123;</span><br><span class="line">               double ak = a[k];</span><br><span class="line">               if (ak != 0.0d) &#123;</span><br><span class="line">                   break;</span><br><span class="line">               &#125;</span><br><span class="line">               if (Double.doubleToRawLongBits(ak) &lt; 0) &#123; // ak is -0.0d</span><br><span class="line">                   a[k] = 0.0d;</span><br><span class="line">                   a[++p] = -0.0d;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       /**</span><br><span class="line">        * Sorts the specified range of the array.</span><br><span class="line">        *</span><br><span class="line">        * @param a        the array to be sorted</span><br><span class="line">        * @param left     the index of the first element, inclusive, to be sorted</span><br><span class="line">        * @param right    the index of the last element, inclusive, to be sorted</span><br><span class="line">        * @param work     a workspace array (slice)</span><br><span class="line">        * @param workBase origin of usable space in work array</span><br><span class="line">        * @param workLen  usable size of work array</span><br><span class="line">        */</span><br><span class="line">       private static void doSort(double[] a, int left, int right,</span><br><span class="line">                                  double[] work, int workBase, int workLen) &#123;</span><br><span class="line">           // Use Quicksort on small arrays</span><br><span class="line">           if (right - left &lt; QUICKSORT_THRESHOLD) &#123;</span><br><span class="line">               sort(a, left, right, true);</span><br><span class="line">               return;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       /*</span><br><span class="line">        * Index run[i] is the start of i-th run</span><br><span class="line">        * (ascending or descending sequence).</span><br><span class="line">        */</span><br><span class="line">           int[] run = new int[MAX_RUN_COUNT + 1];</span><br><span class="line">           int count = 0;</span><br><span class="line">           run[0] = left;</span><br><span class="line"></span><br><span class="line">           // Check if the array is nearly sorted</span><br><span class="line">           for (int k = left; k &lt; right; run[count] = k) &#123;</span><br><span class="line">               if (a[k] &lt; a[k + 1]) &#123; // ascending</span><br><span class="line">                   while (++k &lt;= right &amp;&amp; a[k - 1] &lt;= a[k]) ;</span><br><span class="line">               &#125; else if (a[k] &gt; a[k + 1]) &#123; // descending</span><br><span class="line">                   while (++k &lt;= right &amp;&amp; a[k - 1] &gt;= a[k]) ;</span><br><span class="line">                   for (int lo = run[count] - 1, hi = k; ++lo &lt; --hi; ) &#123;</span><br><span class="line">                       double t = a[lo];</span><br><span class="line">                       a[lo] = a[hi];</span><br><span class="line">                       a[hi] = t;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; else &#123; // equal</span><br><span class="line">                   for (int m = MAX_RUN_LENGTH; ++k &lt;= right &amp;&amp; a[k - 1] == a[k]; ) &#123;</span><br><span class="line">                       if (--m == 0) &#123;</span><br><span class="line">                           sort(a, left, right, true);</span><br><span class="line">                           return;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">           /*</span><br><span class="line">            * The array is not highly structured,</span><br><span class="line">            * use Quicksort instead of merge sort.</span><br><span class="line">            */</span><br><span class="line">               if (++count == MAX_RUN_COUNT) &#123;</span><br><span class="line">                   sort(a, left, right, true);</span><br><span class="line">                   return;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // Check special cases</span><br><span class="line">           // Implementation note: variable &quot;right&quot; is increased by 1.</span><br><span class="line">           if (run[count] == right++) &#123; // The last run contains one element</span><br><span class="line">               run[++count] = right;</span><br><span class="line">           &#125; else if (count == 1) &#123; // The array is already sorted</span><br><span class="line">               return;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // Determine alternation base for merge</span><br><span class="line">           byte odd = 0;</span><br><span class="line">           for (int n = 1; (n &lt;&lt;= 1) &lt; count; odd ^= 1) ;</span><br><span class="line"></span><br><span class="line">           // Use or create temporary array b for merging</span><br><span class="line">           double[] b;                 // temp array; alternates with a</span><br><span class="line">           int ao, bo;              // array offsets from &apos;left&apos;</span><br><span class="line">           int blen = right - left; // space needed for b</span><br><span class="line">           if (work == null || workLen &lt; blen || workBase + blen &gt; work.length) &#123;</span><br><span class="line">               work = new double[blen];</span><br><span class="line">               workBase = 0;</span><br><span class="line">           &#125;</span><br><span class="line">           if (odd == 0) &#123;</span><br><span class="line">               System.arraycopy(a, left, work, workBase, blen);</span><br><span class="line">               b = a;</span><br><span class="line">               bo = 0;</span><br><span class="line">               a = work;</span><br><span class="line">               ao = workBase - left;</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               b = work;</span><br><span class="line">               ao = 0;</span><br><span class="line">               bo = workBase - left;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // Merging</span><br><span class="line">           for (int last; count &gt; 1; count = last) &#123;</span><br><span class="line">               for (int k = (last = 0) + 2; k &lt;= count; k += 2) &#123;</span><br><span class="line">                   int hi = run[k], mi = run[k - 1];</span><br><span class="line">                   for (int i = run[k - 2], p = i, q = mi; i &lt; hi; ++i) &#123;</span><br><span class="line">                       if (q &gt;= hi || p &lt; mi &amp;&amp; a[p + ao] &lt;= a[q + ao]) &#123;</span><br><span class="line">                           b[i + bo] = a[p++ + ao];</span><br><span class="line">                       &#125; else &#123;</span><br><span class="line">                           b[i + bo] = a[q++ + ao];</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">                   run[++last] = hi;</span><br><span class="line">               &#125;</span><br><span class="line">               if ((count &amp; 1) != 0) &#123;</span><br><span class="line">                   for (int i = right, lo = run[count - 1]; --i &gt;= lo;</span><br><span class="line">                        b[i + bo] = a[i + ao]</span><br><span class="line">                           )</span><br><span class="line">                       ;</span><br><span class="line">                   run[++last] = right;</span><br><span class="line">               &#125;</span><br><span class="line">               double[] t = a;</span><br><span class="line">               a = b;</span><br><span class="line">               b = t;</span><br><span class="line">               int o = ao;</span><br><span class="line">               ao = bo;</span><br><span class="line">               bo = o;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       /**</span><br><span class="line">        * Sorts the specified range of the array by Dual-Pivot Quicksort.</span><br><span class="line">        *</span><br><span class="line">        * @param a        the array to be sorted</span><br><span class="line">        * @param left     the index of the first element, inclusive, to be sorted</span><br><span class="line">        * @param right    the index of the last element, inclusive, to be sorted</span><br><span class="line">        * @param leftmost indicates if this part is the leftmost in the range</span><br><span class="line">        */</span><br><span class="line">       private static void sort(double[] a, int left, int right, boolean leftmost) &#123;</span><br><span class="line">           int length = right - left + 1;</span><br><span class="line"></span><br><span class="line">           // Use insertion sort on tiny arrays</span><br><span class="line">           if (length &lt; INSERTION_SORT_THRESHOLD) &#123;</span><br><span class="line">               if (leftmost) &#123;</span><br><span class="line">               /*</span><br><span class="line">                * Traditional (without sentinel) insertion sort,</span><br><span class="line">                * optimized for server VM, is used in case of</span><br><span class="line">                * the leftmost part.</span><br><span class="line">                */</span><br><span class="line">                   for (int i = left, j = i; i &lt; right; j = ++i) &#123;</span><br><span class="line">                       double ai = a[i + 1];</span><br><span class="line">                       while (ai &lt; a[j]) &#123;</span><br><span class="line">                           a[j + 1] = a[j];</span><br><span class="line">                           if (j-- == left) &#123;</span><br><span class="line">                               break;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                       a[j + 1] = ai;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">               /*</span><br><span class="line">                * Skip the longest ascending sequence.</span><br><span class="line">                */</span><br><span class="line">                   do &#123;</span><br><span class="line">                       if (left &gt;= right) &#123;</span><br><span class="line">                           return;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125; while (a[++left] &gt;= a[left - 1]);</span><br><span class="line"></span><br><span class="line">               /*</span><br><span class="line">                * Every element from adjoining part plays the role</span><br><span class="line">                * of sentinel, therefore this allows us to avoid the</span><br><span class="line">                * left range check on each iteration. Moreover, we use</span><br><span class="line">                * the more optimized algorithm, so called pair insertion</span><br><span class="line">                * sort, which is faster (in the context of Quicksort)</span><br><span class="line">                * than traditional implementation of insertion sort.</span><br><span class="line">                */</span><br><span class="line">                   for (int k = left; ++left &lt;= right; k = ++left) &#123;</span><br><span class="line">                       double a1 = a[k], a2 = a[left];</span><br><span class="line"></span><br><span class="line">                       if (a1 &lt; a2) &#123;</span><br><span class="line">                           a2 = a1;</span><br><span class="line">                           a1 = a[left];</span><br><span class="line">                       &#125;</span><br><span class="line">                       while (a1 &lt; a[--k]) &#123;</span><br><span class="line">                           a[k + 2] = a[k];</span><br><span class="line">                       &#125;</span><br><span class="line">                       a[++k + 1] = a1;</span><br><span class="line"></span><br><span class="line">                       while (a2 &lt; a[--k]) &#123;</span><br><span class="line">                           a[k + 1] = a[k];</span><br><span class="line">                       &#125;</span><br><span class="line">                       a[k + 1] = a2;</span><br><span class="line">                   &#125;</span><br><span class="line">                   double last = a[right];</span><br><span class="line"></span><br><span class="line">                   while (last &lt; a[--right]) &#123;</span><br><span class="line">                       a[right + 1] = a[right];</span><br><span class="line">                   &#125;</span><br><span class="line">                   a[right + 1] = last;</span><br><span class="line">               &#125;</span><br><span class="line">               return;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // Inexpensive approximation of length / 7</span><br><span class="line">           int seventh = (length &gt;&gt; 3) + (length &gt;&gt; 6) + 1;</span><br><span class="line"></span><br><span class="line">       /*</span><br><span class="line">        * Sort five evenly spaced elements around (and including) the</span><br><span class="line">        * center element in the range. These elements will be used for</span><br><span class="line">        * pivot selection as described below. The choice for spacing</span><br><span class="line">        * these elements was empirically determined to work well on</span><br><span class="line">        * a wide variety of inputs.</span><br><span class="line">        */</span><br><span class="line">           int e3 = (left + right) &gt;&gt;&gt; 1; // The midpoint</span><br><span class="line">           int e2 = e3 - seventh;</span><br><span class="line">           int e1 = e2 - seventh;</span><br><span class="line">           int e4 = e3 + seventh;</span><br><span class="line">           int e5 = e4 + seventh;</span><br><span class="line"></span><br><span class="line">           // Sort these elements using insertion sort</span><br><span class="line">           if (a[e2] &lt; a[e1]) &#123;</span><br><span class="line">               double t = a[e2];</span><br><span class="line">               a[e2] = a[e1];</span><br><span class="line">               a[e1] = t;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           if (a[e3] &lt; a[e2]) &#123;</span><br><span class="line">               double t = a[e3];</span><br><span class="line">               a[e3] = a[e2];</span><br><span class="line">               a[e2] = t;</span><br><span class="line">               if (t &lt; a[e1]) &#123;</span><br><span class="line">                   a[e2] = a[e1];</span><br><span class="line">                   a[e1] = t;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           if (a[e4] &lt; a[e3]) &#123;</span><br><span class="line">               double t = a[e4];</span><br><span class="line">               a[e4] = a[e3];</span><br><span class="line">               a[e3] = t;</span><br><span class="line">               if (t &lt; a[e2]) &#123;</span><br><span class="line">                   a[e3] = a[e2];</span><br><span class="line">                   a[e2] = t;</span><br><span class="line">                   if (t &lt; a[e1]) &#123;</span><br><span class="line">                       a[e2] = a[e1];</span><br><span class="line">                       a[e1] = t;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           if (a[e5] &lt; a[e4]) &#123;</span><br><span class="line">               double t = a[e5];</span><br><span class="line">               a[e5] = a[e4];</span><br><span class="line">               a[e4] = t;</span><br><span class="line">               if (t &lt; a[e3]) &#123;</span><br><span class="line">                   a[e4] = a[e3];</span><br><span class="line">                   a[e3] = t;</span><br><span class="line">                   if (t &lt; a[e2]) &#123;</span><br><span class="line">                       a[e3] = a[e2];</span><br><span class="line">                       a[e2] = t;</span><br><span class="line">                       if (t &lt; a[e1]) &#123;</span><br><span class="line">                           a[e2] = a[e1];</span><br><span class="line">                           a[e1] = t;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // Pointers</span><br><span class="line">           int less = left;  // The index of the first element of center part</span><br><span class="line">           int great = right; // The index before the first element of right part</span><br><span class="line"></span><br><span class="line">           if (a[e1] != a[e2] &amp;&amp; a[e2] != a[e3] &amp;&amp; a[e3] != a[e4] &amp;&amp; a[e4] != a[e5]) &#123;</span><br><span class="line">           /*</span><br><span class="line">            * Use the second and fourth of the five sorted elements as pivots.</span><br><span class="line">            * These values are inexpensive approximations of the first and</span><br><span class="line">            * second terciles of the array. Note that pivot1 &lt;= pivot2.</span><br><span class="line">            */</span><br><span class="line">               double pivot1 = a[e2];</span><br><span class="line">               double pivot2 = a[e4];</span><br><span class="line"></span><br><span class="line">           /*</span><br><span class="line">            * The first and the last elements to be sorted are moved to the</span><br><span class="line">            * locations formerly occupied by the pivots. When partitioning</span><br><span class="line">            * is complete, the pivots are swapped back into their final</span><br><span class="line">            * positions, and excluded from subsequent sorting.</span><br><span class="line">            */</span><br><span class="line">               a[e2] = a[left];</span><br><span class="line">               a[e4] = a[right];</span><br><span class="line"></span><br><span class="line">           /*</span><br><span class="line">            * Skip elements, which are less or greater than pivot values.</span><br><span class="line">            */</span><br><span class="line">               while (a[++less] &lt; pivot1) ;</span><br><span class="line">               while (a[--great] &gt; pivot2) ;</span><br><span class="line"></span><br><span class="line">           /*</span><br><span class="line">            * Partitioning:</span><br><span class="line">            *</span><br><span class="line">            *   left part           center part                   right part</span><br><span class="line">            * +--------------------------------------------------------------+</span><br><span class="line">            * |  &lt; pivot1  |  pivot1 &lt;= &amp;&amp; &lt;= pivot2  |    ?    |  &gt; pivot2  |</span><br><span class="line">            * +--------------------------------------------------------------+</span><br><span class="line">            *               ^                          ^       ^</span><br><span class="line">            *               |                          |       |</span><br><span class="line">            *              less                        k     great</span><br><span class="line">            *</span><br><span class="line">            * Invariants:</span><br><span class="line">            *</span><br><span class="line">            *              all in (left, less)   &lt; pivot1</span><br><span class="line">            *    pivot1 &lt;= all in [less, k)     &lt;= pivot2</span><br><span class="line">            *              all in (great, right) &gt; pivot2</span><br><span class="line">            *</span><br><span class="line">            * Pointer k is the first index of ?-part.</span><br><span class="line">            */</span><br><span class="line">               outer:</span><br><span class="line">               for (int k = less - 1; ++k &lt;= great; ) &#123;</span><br><span class="line">                   double ak = a[k];</span><br><span class="line">                   if (ak &lt; pivot1) &#123; // Move a[k] to left part</span><br><span class="line">                       a[k] = a[less];</span><br><span class="line">                   /*</span><br><span class="line">                    * Here and below we use &quot;a[i] = b; i++;&quot; instead</span><br><span class="line">                    * of &quot;a[i++] = b;&quot; due to performance issue.</span><br><span class="line">                    */</span><br><span class="line">                       a[less] = ak;</span><br><span class="line">                       ++less;</span><br><span class="line">                   &#125; else if (ak &gt; pivot2) &#123; // Move a[k] to right part</span><br><span class="line">                       while (a[great] &gt; pivot2) &#123;</span><br><span class="line">                           if (great-- == k) &#123;</span><br><span class="line">                               break outer;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                       if (a[great] &lt; pivot1) &#123; // a[great] &lt;= pivot2</span><br><span class="line">                           a[k] = a[less];</span><br><span class="line">                           a[less] = a[great];</span><br><span class="line">                           ++less;</span><br><span class="line">                       &#125; else &#123; // pivot1 &lt;= a[great] &lt;= pivot2</span><br><span class="line">                           a[k] = a[great];</span><br><span class="line">                       &#125;</span><br><span class="line">                   /*</span><br><span class="line">                    * Here and below we use &quot;a[i] = b; i--;&quot; instead</span><br><span class="line">                    * of &quot;a[i--] = b;&quot; due to performance issue.</span><br><span class="line">                    */</span><br><span class="line">                       a[great] = ak;</span><br><span class="line">                       --great;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               // Swap pivots into their final positions</span><br><span class="line">               a[left] = a[less - 1];</span><br><span class="line">               a[less - 1] = pivot1;</span><br><span class="line">               a[right] = a[great + 1];</span><br><span class="line">               a[great + 1] = pivot2;</span><br><span class="line"></span><br><span class="line">               // Sort left and right parts recursively, excluding known pivots</span><br><span class="line">               sort(a, left, less - 2, leftmost);</span><br><span class="line">               sort(a, great + 2, right, false);</span><br><span class="line"></span><br><span class="line">           /*</span><br><span class="line">            * If center part is too large (comprises &gt; 4/7 of the array),</span><br><span class="line">            * swap internal pivot values to ends.</span><br><span class="line">            */</span><br><span class="line">               if (less &lt; e1 &amp;&amp; e5 &lt; great) &#123;</span><br><span class="line">               /*</span><br><span class="line">                * Skip elements, which are equal to pivot values.</span><br><span class="line">                */</span><br><span class="line">                   while (a[less] == pivot1) &#123;</span><br><span class="line">                       ++less;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   while (a[great] == pivot2) &#123;</span><br><span class="line">                       --great;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">               /*</span><br><span class="line">                * Partitioning:</span><br><span class="line">                *</span><br><span class="line">                *   left part         center part                  right part</span><br><span class="line">                * +----------------------------------------------------------+</span><br><span class="line">                * | == pivot1 |  pivot1 &lt; &amp;&amp; &lt; pivot2  |    ?    | == pivot2 |</span><br><span class="line">                * +----------------------------------------------------------+</span><br><span class="line">                *              ^                        ^       ^</span><br><span class="line">                *              |                        |       |</span><br><span class="line">                *             less                      k     great</span><br><span class="line">                *</span><br><span class="line">                * Invariants:</span><br><span class="line">                *</span><br><span class="line">                *              all in (*,  less) == pivot1</span><br><span class="line">                *     pivot1 &lt; all in [less,  k)  &lt; pivot2</span><br><span class="line">                *              all in (great, *) == pivot2</span><br><span class="line">                *</span><br><span class="line">                * Pointer k is the first index of ?-part.</span><br><span class="line">                */</span><br><span class="line">                   outer:</span><br><span class="line">                   for (int k = less - 1; ++k &lt;= great; ) &#123;</span><br><span class="line">                       double ak = a[k];</span><br><span class="line">                       if (ak == pivot1) &#123; // Move a[k] to left part</span><br><span class="line">                           a[k] = a[less];</span><br><span class="line">                           a[less] = ak;</span><br><span class="line">                           ++less;</span><br><span class="line">                       &#125; else if (ak == pivot2) &#123; // Move a[k] to right part</span><br><span class="line">                           while (a[great] == pivot2) &#123;</span><br><span class="line">                               if (great-- == k) &#123;</span><br><span class="line">                                   break outer;</span><br><span class="line">                               &#125;</span><br><span class="line">                           &#125;</span><br><span class="line">                           if (a[great] == pivot1) &#123; // a[great] &lt; pivot2</span><br><span class="line">                               a[k] = a[less];</span><br><span class="line">                           /*</span><br><span class="line">                            * Even though a[great] equals to pivot1, the</span><br><span class="line">                            * assignment a[less] = pivot1 may be incorrect,</span><br><span class="line">                            * if a[great] and pivot1 are floating-point zeros</span><br><span class="line">                            * of different signs. Therefore in float and</span><br><span class="line">                            * double sorting methods we have to use more</span><br><span class="line">                            * accurate assignment a[less] = a[great].</span><br><span class="line">                            */</span><br><span class="line">                               a[less] = a[great];</span><br><span class="line">                               ++less;</span><br><span class="line">                           &#125; else &#123; // pivot1 &lt; a[great] &lt; pivot2</span><br><span class="line">                               a[k] = a[great];</span><br><span class="line">                           &#125;</span><br><span class="line">                           a[great] = ak;</span><br><span class="line">                           --great;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               // Sort center part recursively</span><br><span class="line">               sort(a, less, great, false);</span><br><span class="line"></span><br><span class="line">           &#125; else &#123; // Partitioning with one pivot</span><br><span class="line">           /*</span><br><span class="line">            * Use the third of the five sorted elements as pivot.</span><br><span class="line">            * This value is inexpensive approximation of the median.</span><br><span class="line">            */</span><br><span class="line">               double pivot = a[e3];</span><br><span class="line"></span><br><span class="line">           /*</span><br><span class="line">            * Partitioning degenerates to the traditional 3-way</span><br><span class="line">            * (or &quot;Dutch National Flag&quot;) schema:</span><br><span class="line">            *</span><br><span class="line">            *   left part    center part              right part</span><br><span class="line">            * +-------------------------------------------------+</span><br><span class="line">            * |  &lt; pivot  |   == pivot   |     ?    |  &gt; pivot  |</span><br><span class="line">            * +-------------------------------------------------+</span><br><span class="line">            *              ^              ^        ^</span><br><span class="line">            *              |              |        |</span><br><span class="line">            *             less            k      great</span><br><span class="line">            *</span><br><span class="line">            * Invariants:</span><br><span class="line">            *</span><br><span class="line">            *   all in (left, less)   &lt; pivot</span><br><span class="line">            *   all in [less, k)     == pivot</span><br><span class="line">            *   all in (great, right) &gt; pivot</span><br><span class="line">            *</span><br><span class="line">            * Pointer k is the first index of ?-part.</span><br><span class="line">            */</span><br><span class="line">               for (int k = less; k &lt;= great; ++k) &#123;</span><br><span class="line">                   if (a[k] == pivot) &#123;</span><br><span class="line">                       continue;</span><br><span class="line">                   &#125;</span><br><span class="line">                   double ak = a[k];</span><br><span class="line">                   if (ak &lt; pivot) &#123; // Move a[k] to left part</span><br><span class="line">                       a[k] = a[less];</span><br><span class="line">                       a[less] = ak;</span><br><span class="line">                       ++less;</span><br><span class="line">                   &#125; else &#123; // a[k] &gt; pivot - Move a[k] to right part</span><br><span class="line">                       while (a[great] &gt; pivot) &#123;</span><br><span class="line">                           --great;</span><br><span class="line">                       &#125;</span><br><span class="line">                       if (a[great] &lt; pivot) &#123; // a[great] &lt;= pivot</span><br><span class="line">                           a[k] = a[less];</span><br><span class="line">                           a[less] = a[great];</span><br><span class="line">                           ++less;</span><br><span class="line">                       &#125; else &#123; // a[great] == pivot</span><br><span class="line">                       /*</span><br><span class="line">                        * Even though a[great] equals to pivot, the</span><br><span class="line">                        * assignment a[k] = pivot may be incorrect,</span><br><span class="line">                        * if a[great] and pivot are floating-point</span><br><span class="line">                        * zeros of different signs. Therefore in float</span><br><span class="line">                        * and double sorting methods we have to use</span><br><span class="line">                        * more accurate assignment a[k] = a[great].</span><br><span class="line">                        */</span><br><span class="line">                           a[k] = a[great];</span><br><span class="line">                       &#125;</span><br><span class="line">                       a[great] = ak;</span><br><span class="line">                       --great;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">           /*</span><br><span class="line">            * Sort left and right parts recursively.</span><br><span class="line">            * All elements from center part are equal</span><br><span class="line">            * and, therefore, already sorted.</span><br><span class="line">            */</span><br><span class="line">               sort(a, left, less - 1, leftmost);</span><br><span class="line">               sort(a, great + 1, right, false);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;源码的类注释：This class contains various methods for manipulating arrays (such as sorting and searching). This class also contains a static factory that allows arrays to be viewed as lists.&lt;br&gt;可见这就是一个处理数组的类，直接研究含有的方法。&lt;/p&gt;&lt;h2 id=&quot;asList&quot;&gt;&lt;a href=&quot;#asList&quot; class=&quot;headerlink&quot; title=&quot;asList&quot;&gt;&lt;/a&gt;asList&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt; /**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  * 就是数组转换成List集合&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public static &amp;lt;T&amp;gt; List&amp;lt;T&amp;gt; asList(T... a) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     return new ArrayList&amp;lt;&amp;gt;(a);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="java1.8源码" scheme="https://little8.top/categories/java1-8%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="little_eight" scheme="https://little8.top/tags/little-eight/"/>
    
  </entry>
  
  <entry>
    <title>Dockerfile命令</title>
    <link href="https://little8.top/2019/03/12/Dockerfile%E5%91%BD%E4%BB%A4/"/>
    <id>https://little8.top/2019/03/12/Dockerfile命令/</id>
    <published>2019-03-12T14:18:42.000Z</published>
    <updated>2019-07-23T13:00:40.947Z</updated>
    
    <content type="html"><![CDATA[<h2 id="FROM指令"><a href="#FROM指令" class="headerlink" title="FROM指令"></a>FROM指令</h2><p>脚本的第1行是FROM指令。通过FROM指令，docker编译程序能够知道在哪个基础镜像执行来进行编译。所有的Dockerfile都必须以FROM指令开始。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM devops-reg.io/public/openjdk:8</span><br></pre></td></tr></table></figure><h2 id="MAINTAINER指令"><a href="#MAINTAINER指令" class="headerlink" title="MAINTAINER指令"></a>MAINTAINER指令</h2><p>第二条指令MAINTAINER，用来标明这个镜像的维护者信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#MAINTAINER xxxx@qq.com</span><br></pre></td></tr></table></figure><h2 id="RUN指令"><a href="#RUN指令" class="headerlink" title="RUN指令"></a>RUN指令</h2><p>接下来是RUN指令。这条指令用来在docker的编译环境中运行指定命令。上面这条指令会在编译环境运行/bin/sh -c “apt-get update &amp;&amp; apt-get -y install …”。RUN指令还有另外一种格式：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN [&quot;程序名&quot;, &quot;参数1&quot;, &quot;参数2&quot;]</span><br></pre></td></tr></table></figure><p></p><a id="more"></a><p>这种格式运行程序，可以免除运行/bin/sh的消耗。这种格式使用Json格式将程序名与所需参数组成一个字符串数组，所以如果参数中有引号等特殊字符，需要进行转义。</p><h2 id="ENV指令"><a href="#ENV指令" class="headerlink" title="ENV指令"></a>ENV指令</h2><p>ENV指令用来指定在执行docker run命令运行镜像时，自动设置的环境变量。这些环境变量可以通过docker run命令的–evn参数来进行修改。</p><h2 id="COPY指令和ADD指令"><a href="#COPY指令和ADD指令" class="headerlink" title="COPY指令和ADD指令"></a>COPY指令和ADD指令</h2><p>COPY指令用来将本地（Dockerfile所在位置）的文件或文件夹复制到编译环境的指定路径下。上面的例子里，boot2docker的Dockerfile希望将与Dockerfile同一目录下的kernel_config文件复制到编译环境的/linux-kernal/.config。Dockerfile还提供了另外一个类似的指令：ADD。在复制文件方面ADD指令和COPY指令的格式和效果是完全一样的。这两个指令的区别主要由两点：</p><ul><li>ADD指令可以从一个URL地址下载内容复制到容器的文件系统中</li><li>ADD指令会将压缩打包格式的文件解开后复制到指定位置，而COPY指令只做复制操作</li></ul><h2 id="CMD指令"><a href="#CMD指令" class="headerlink" title="CMD指令"></a>CMD指令</h2><p>这是整个Dockerfile脚本的最后一条指令。当Dockerfile已经完成了所有环境的安装与配置，通过CMD指令来指示docker run命令运行镜像时要执行的命令。上面的例子里，在完成所有工作后，boot2docker的编译脚本将编译结果输出到本地环境下。</p><h3 id="其他指令"><a href="#其他指令" class="headerlink" title="其他指令"></a>其他指令</h3><h3 id="EXPOSE指令"><a href="#EXPOSE指令" class="headerlink" title="EXPOSE指令"></a>EXPOSE指令</h3><p>EXPOSE &lt;端口&gt; [&lt;端口&gt;…]指令用于标明，这个镜像中的应用将会侦听某个端口，并且希望能将这个端口映射到主机的网络界面上。但是，为了安全，docker run命令如果没有带上响应的端口映射参数，docker并不会将端口映射出了。</p><h3 id="ENTRYPOINT指令"><a href="#ENTRYPOINT指令" class="headerlink" title="ENTRYPOINT指令"></a>ENTRYPOINT指令</h3><p>ENTRYPOINT指令和前面介绍过的CMD一样，用于标明一个镜像作为容器运行时，最后要执行的程序或命令。这两个指令有相同之处，也有区别。通过两个指令的配合使用可以配置出不同的效果。</p><p>ENTRYPOINT指令有两种格式，CMD指令有三种格式：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ENTRYPOINT [&quot;程序名&quot;, &quot;参数1&quot;, &quot;参数2&quot;]</span><br><span class="line">ENTRYPOINT 命令 参数1 参数2</span><br><span class="line"></span><br><span class="line">CMD [&quot;程序名&quot;, &quot;参数1&quot;, &quot;参数2&quot;]</span><br><span class="line">CMD 命令 参数1 参数2</span><br><span class="line">CMD 参数1 参数2</span><br></pre></td></tr></table></figure><p></p><p>ENTRYPOINT是容器运行程序的入口。也就是说，在docker run命令中指定的命令都将作为参数提供给ENTRYPOINT指定的程序。同样，上面列举的CMD指令格式的后面两种格式也将作为参数提供给ENTRYPOINT指定的程序。</p><p>默认的ENTRYPOINT是/bin/sh -c。你可以根据实际需要任意设置。但是如果在一个Dockerfile中出现了多个ENTRYPOINT指令，那么，只有最后一个ENTRYPOINT指令是起效的。</p><p>一种常用的设置是将命令与必要参数设置到ENTRYPOINT中，而运行时只提供其他选项。例如：你有一个MySQL的客户端程序运行在容器中，而客户端所需要的主机地址、用户名和密码你不希望每次都输入，你就可以将ENTRYPOINT设置成：ENTRYPOINT mysql -u &lt;用户名&gt; -p &lt;密码&gt; -h &lt;主机名&gt;。而你运行时，只需要指定数据库名。</p><h3 id="VOLUME指令"><a href="#VOLUME指令" class="headerlink" title="VOLUME指令"></a>VOLUME指令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VOLUME [&quot;路径&quot;]</span><br></pre></td></tr></table></figure><p>VOLUME指令用于在容器内创建一个或多个卷。而更多的时候，是在执行docker run时指定要创建的卷以及本地路径来进行映射。关于这个用法将在后面的章节学习到。</p><h3 id="USER指令"><a href="#USER指令" class="headerlink" title="USER指令"></a>USER指令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USER 用户名或用户ID</span><br></pre></td></tr></table></figure><p>USER指令用于容器内运行RUN指令或CMD指令的用户。例如，在构建一个nginx镜像时，你希望最后运行nginx的用户为nginx，就可以在CMD [“nginx”]之前将用户设置为nginx。</p><p>如果在运行docker run命令时设置了-u 用户名参数，那么将覆盖USER指令设置的用户。</p><h3 id="WORKDIR指令"><a href="#WORKDIR指令" class="headerlink" title="WORKDIR指令"></a>WORKDIR指令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WORKDIR 路径</span><br></pre></td></tr></table></figure><p>WORKDIR指令用于设置执行RUN指令、CMD指令和ENTRYPOINT指令执行时的工作目录。在Dockerfile中可以多次设置WORKDIR，在每次设置之后的命令将使用新的路径。</p><h3 id="ONBUILD指令"><a href="#ONBUILD指令" class="headerlink" title="ONBUILD指令"></a>ONBUILD指令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ONBUILD 指令</span><br></pre></td></tr></table></figure><p>ONBUILD指令用于设置一些指令，当本镜像作为基础镜像被其他Dockerfile用FROM指令引用时，在所有其他指令执行之前先执行这些指令。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;FROM指令&quot;&gt;&lt;a href=&quot;#FROM指令&quot; class=&quot;headerlink&quot; title=&quot;FROM指令&quot;&gt;&lt;/a&gt;FROM指令&lt;/h2&gt;&lt;p&gt;脚本的第1行是FROM指令。通过FROM指令，docker编译程序能够知道在哪个基础镜像执行来进行编译。所有的Dockerfile都必须以FROM指令开始。&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;FROM devops-reg.io/public/openjdk:8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;h2 id=&quot;MAINTAINER指令&quot;&gt;&lt;a href=&quot;#MAINTAINER指令&quot; class=&quot;headerlink&quot; title=&quot;MAINTAINER指令&quot;&gt;&lt;/a&gt;MAINTAINER指令&lt;/h2&gt;&lt;p&gt;第二条指令MAINTAINER，用来标明这个镜像的维护者信息。&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#MAINTAINER xxxx@qq.com&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;h2 id=&quot;RUN指令&quot;&gt;&lt;a href=&quot;#RUN指令&quot; class=&quot;headerlink&quot; title=&quot;RUN指令&quot;&gt;&lt;/a&gt;RUN指令&lt;/h2&gt;&lt;p&gt;接下来是RUN指令。这条指令用来在docker的编译环境中运行指定命令。上面这条指令会在编译环境运行/bin/sh -c “apt-get update &amp;amp;&amp;amp; apt-get -y install …”。RUN指令还有另外一种格式：&lt;br&gt;&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;RUN [&amp;quot;程序名&amp;quot;, &amp;quot;参数1&amp;quot;, &amp;quot;参数2&amp;quot;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="杂类" scheme="https://little8.top/categories/%E6%9D%82%E7%B1%BB/"/>
    
    
      <category term="little_eight" scheme="https://little8.top/tags/little-eight/"/>
    
  </entry>
  
  <entry>
    <title>Docker简单介绍</title>
    <link href="https://little8.top/2019/02/27/Docker%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/"/>
    <id>https://little8.top/2019/02/27/Docker简单介绍/</id>
    <published>2019-02-27T13:38:05.000Z</published>
    <updated>2019-07-23T13:00:40.947Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><ul><li>镜像（ Image ）</li><li>容器（ Container ）</li><li>仓库（ Repository ）</li></ul><h2 id="Docker镜像"><a href="#Docker镜像" class="headerlink" title="Docker镜像"></a>Docker镜像</h2><p>Docker 镜像（Image），就相当于是一个 root 文件系统，它除了提供容器运行时所需的程序、库、资<br>源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p><h3 id="分层存储"><a href="#分层存储" class="headerlink" title="分层存储"></a>分层存储</h3><p>因为镜像体积庞大，就将其设计成分层存储的架构，所以严格来说镜像由一组文件系统组成。<br>镜像构建时，会一层层构建，前一层是后一层的基础。。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。</p><h2 id="Docker-容器"><a href="#Docker-容器" class="headerlink" title="Docker 容器"></a>Docker 容器</h2><p>容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p><h2 id="Docker仓库"><a href="#Docker仓库" class="headerlink" title="Docker仓库"></a>Docker仓库</h2><p>镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker仓库就是这样的服务。<br>一个 Docker Registry 中可以包含多个仓库（ Repository ）；每个仓库可以包含多个标签（ Tag ）；每个标签对应一个镜像。<br>通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 &lt;仓库名&gt;:&lt;标签&gt; 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签。<br>以 Ubuntu 镜像 为例， ubuntu 是仓库的名字，其内包含有不同的版本标签，如， 16.04 , 18.04。我们可以通过 ubuntu:14.04，或者ubuntu:18.04来具体指定所需哪个版本的镜像。如果忽略了标签，比如 ubuntu ，那将视为ubuntu:latest 。</p><h3 id="私有-Docker仓库"><a href="#私有-Docker仓库" class="headerlink" title="私有 Docker仓库"></a>私有 Docker仓库</h3><p>除了使用公开服务外，用户还可以在本地搭建私有Docker仓库。Docker官方提供了Docker仓库镜像，可以直接使用做为私有 Registry 服务。</p><h2 id="使用-Docker-镜像"><a href="#使用-Docker-镜像" class="headerlink" title="使用 Docker 镜像"></a>使用 Docker 镜像</h2><h3 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h3><p>从 Docker 镜像仓库获取镜像的命令是 docker pull 。其命令格式为：</p><blockquote><p>docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]</p></blockquote><ul><li>Docker 镜像仓库地址：地址的格式一般是 &lt;域名/IP&gt;[:端口号] 。默认地址是 Docker Hub。</li><li>仓库名：如之前所说，这里的仓库名是两段式名称，即&lt;用户名&gt;/&lt;软件名&gt;。对于DockerHub，如果不给出用户名，则默认为 library ，也就是官方镜像。<br>比如<a id="more"></a><blockquote><p>$ docker pull ubuntu:18.04<br>18.04: Pulling from library/ubuntu<br>bf5d46315322: Pull complete<br>9f13e0ac480c: Pull complete<br>e8988b5b3097: Pull complete<br>40af181810e7: Pull complete<br>e6f7c7e5c03e: Pull complete<br>Digest: sha256:147913621d9cdea08853f6ba9116c2e27a3ceffecf3b49298<br>3ae97c3d643fbbe<br>Status: Downloaded newer image for ubuntu:18.04</p></blockquote></li></ul><p>上面的命令中没有给出 Docker 镜像仓库地址，因此将会从 Docker Hub 获取镜像。而镜像名称是 ubuntu:18.04 ，因此将会获取官方镜像 library/ubuntu仓库中标签为 18.04 的镜像。</p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>有了镜像后，我们就能够以这个镜像为基础启动并运行一个容器。以上面的<br>ubuntu:18.04 为例，如果我们打算启动里面的 bash 并且进行交互式操作的<br>话，可以执行下面的命令。</p><blockquote><p>$ docker run -it –rm \<br>ubuntu:18.04 \<br>bash<br>root@e7009c6ce357:/# cat /etc/os-release<br>NAME=”Ubuntu”<br>VERSION=”18.04.1 LTS (Bionic Beaver)”<br>ID=ubuntu<br>ID_LIKE=debian<br>PRETTY_NAME=”Ubuntu 18.04.1 LTS”<br>VERSION_ID=”18.04”<br>HOME_URL=”<a href="https://www.ubuntu.com/&quot;" target="_blank" rel="noopener">https://www.ubuntu.com/&quot;</a><br>SUPPORT_URL=”<a href="https://help.ubuntu.com/&quot;" target="_blank" rel="noopener">https://help.ubuntu.com/&quot;</a><br>BUG_REPORT_URL=”<a href="https://bugs.launchpad.net/ubuntu/&quot;" target="_blank" rel="noopener">https://bugs.launchpad.net/ubuntu/&quot;</a><br>PRIVACY_POLICY_URL=”<a href="https://www.ubuntu.com/legal/terms-and-polic" target="_blank" rel="noopener">https://www.ubuntu.com/legal/terms-and-polic</a><br>ies/privacy-policy”<br>VERSION_CODENAME=bionic<br>UBUNTU_CODENAME=bionic</p></blockquote><ul><li>docker run 就是运行容器的命令</li><li>-it ：这是两个参数，一个是 -i ：交互式操作，一个是 -t 终端。我们<br>这里打算进入 bash 执行一些命令并查看返回结果，因此我们需要交互式终<br>端。</li><li>–rm ：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需<br>求，退出的容器并不会立即删除，除非手动 docker rm 。我们这里只是随便<br>执行个命令，看看结果，不需要排障和保留结果，因此使用 –rm 可以避免<br>浪费空间。</li><li>ubuntu:18.04 ：这是指用 ubuntu:18.04 镜像为基础来启动容器。</li><li>bash ：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的<br>是 bash 。</li></ul><h3 id="列出镜像"><a href="#列出镜像" class="headerlink" title="列出镜像"></a>列出镜像</h3><p>要想列出已经下载下来的镜像，可以使用 docker image ls 命令。</p><blockquote><p>$ docker image ls<br>REPOSITORY TAG IMAGE ID CRE<br>ATED SIZE<br>redis latest 5f515359c7f8 5 d<br>ays ago 183 MB<br>nginx latest 05a60462f8ba 5 d<br>ays ago 181 MB<br>mongo 3.2 fe9198c04d62 5 d<br>ays ago 342 MB</p></blockquote><p><none><none>00285df0df87 5 d<br>ays ago 342 MB<br>ubuntu 18.04 f753707788c5 4 w<br>eeks ago 127 MB<br>ubuntu latest f753707788c5 4 w<br>eeks ago 127 MB</none></none></p><p>列表包含了 仓库名 、 标签 、 镜像 ID 、 创建时间 以及 所占用的空间 。</p><h3 id="删除本地镜像"><a href="#删除本地镜像" class="headerlink" title="删除本地镜像"></a>删除本地镜像</h3><p>如果要删除本地的镜像，可以使用 docker image rm 命令</p><h2 id="使用-Dockerfile-定制镜像"><a href="#使用-Dockerfile-定制镜像" class="headerlink" title="使用 Dockerfile 定制镜像"></a>使用 Dockerfile 定制镜像</h2><p>Dockerfile 是一个文本文件，其内包含了一条条的指令(Instruction)，每一条指令<br>构建一层，因此每一条指令的内容，就是描述该层应当如何构建。</p><p>看一个Dockerfile文件<br></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM nginx</span><br><span class="line">RUN echo '<span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, Docker!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>' &gt; /usr/share/nginx/html/index</span><br><span class="line">.html</span><br></pre></td></tr></table></figure><p></p><h3 id="FROM-指定基础镜像"><a href="#FROM-指定基础镜像" class="headerlink" title="FROM 指定基础镜像"></a>FROM 指定基础镜像</h3><p>所谓定制镜像，那一定是以一个镜像为基础，在其上进行定制。就像我们之前运行<br>了一个 nginx 镜像的容器，再进行修改一样，基础镜像是必须指定的。而<br>FROM 就是指定基础镜像，因此一个 Dockerfile 中 FROM 是必备的指令，并<br>且必须是第一条指令。</p><h3 id="RUN-执行命令"><a href="#RUN-执行命令" class="headerlink" title="RUN 执行命令"></a>RUN 执行命令</h3><p>RUN 指令是用来执行命令行命令的。由于命令行的强大能力， RUN 指令在定制<br>镜像时是最常用的指令之一。其格式有两种：</p><ul><li><p>shell 格式： RUN &lt;命令&gt; ，就像直接在命令行中输入的命令一样。刚才写的<br>Dockerfile 中的 RUN 指令就是这种格式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RUN echo &apos;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&apos; &gt; /usr/share/nginx/html/index</span><br><span class="line">.html</span><br></pre></td></tr></table></figure></li><li><p>exec 格式： RUN [“可执行文件”, “参数1”, “参数2”] ，这更像是函数调用中<br>的格式。</p></li></ul><p>Dockerfile 支持 Shell 类的行尾添加 \ 的<br>命令换行方式，以及行首 # 进行注释的格式。良好的格式，比如换行、缩进、注<br>释等，会让维护、排障更为容易，这是一个比较好的习惯。</p><h3 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h3><p>在 Dockerfile 文件所在目录执行：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t nginx:v3 .</span><br><span class="line">Sending build context to Docker daemon 2.048 kB</span><br><span class="line">Step 1 : FROM nginx</span><br><span class="line">---&gt; e43d811ce2f4</span><br><span class="line">Step 2 : RUN echo &apos;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&apos; &gt; /usr/share/nginx/h</span><br><span class="line">tml/index.html</span><br><span class="line">---&gt; Running in 9cdc27646c7b</span><br><span class="line">---&gt; 44aa4490ce2c</span><br><span class="line">Removing intermediate container 9cdc27646c7b</span><br><span class="line">Successfully built 44aa4490ce2c</span><br></pre></td></tr></table></figure><p></p><p>这里我们使用了 docker build 命令进行镜像构建。其格式为：</p><blockquote><p>docker build [选项] &lt;上下文路径/URL/-&gt;</p></blockquote><p>在这里我们指定了最终镜像的名称 -t nginx:v3 ，构建成功后，我们可以像之前<br>运行 nginx:v2 那样来运行这个镜像，其结果会和 nginx:v2 一样。</p><p>更多Dockerfile命令可参考官方文档：<a href="https://docs.docker.com/engine/reference/builder/" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/builder/</a></p><h2 id="docker使用"><a href="#docker使用" class="headerlink" title="docker使用"></a>docker使用</h2><h3 id="docker安装"><a href="#docker安装" class="headerlink" title="docker安装"></a>docker安装</h3><ul><li><p>使用 sudo 或 root 权限登录 Centos，确保 yum 包更新到最新。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum update</span><br></pre></td></tr></table></figure></li><li><p>执行 Docker 安装脚本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl -fsSL https://get.docker.com -o get-docker.sh</span><br><span class="line">$ sudo sh get-docker.sh</span><br></pre></td></tr></table></figure></li><li><p>启动 Docker 进程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start docker</span><br></pre></td></tr></table></figure></li></ul><p>后期可能会出现这样的错误信息：</p><blockquote><p>Got permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Get http://%2Fvar%2Frun%2Fdocker.sock/v1.39/images/json: dial unix /var/run/docker.sock: connect: permission denied</p></blockquote><p>原因：</p><blockquote><p>docker守护进程启动的时候，会默认赋予名字为docker的用户组读写Unix socket的权限，因此只要创建docker用户组，并将当前用户加入到docker用户组中，那么当前用户就有权限访问Unix socket了，进而也就可以执行docker相关命令。</p></blockquote><p>解决方案</p><blockquote><p>.#添加docker用户组<br>sudo groupadd docker</p></blockquote><p>#添加将登陆用户加入到docker用户组中<br>sudo gpasswd -a $USER docker</p><p>#将登陆用户加入到docker更新用户组中<br>newgrp docker #更新用户组<br>docker ps</p><p>#测试docker命令是否可以使用sudo正常使用</p><h2 id="Kubernetes（太多，后期再补充吧）"><a href="#Kubernetes（太多，后期再补充吧）" class="headerlink" title="Kubernetes（太多，后期再补充吧）"></a>Kubernetes（太多，后期再补充吧）</h2><p>Kubernetes，因为首尾字母中间有8个字符，所以被简写成 K8s。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Docker&quot;&gt;&lt;a href=&quot;#Docker&quot; class=&quot;headerlink&quot; title=&quot;Docker&quot;&gt;&lt;/a&gt;Docker&lt;/h1&gt;&lt;ul&gt;&lt;li&gt;镜像（ Image ）&lt;/li&gt;&lt;li&gt;容器（ Container ）&lt;/li&gt;&lt;li&gt;仓库（ Repository ）&lt;/li&gt;&lt;/ul&gt;&lt;h2 id=&quot;Docker镜像&quot;&gt;&lt;a href=&quot;#Docker镜像&quot; class=&quot;headerlink&quot; title=&quot;Docker镜像&quot;&gt;&lt;/a&gt;Docker镜像&lt;/h2&gt;&lt;p&gt;Docker 镜像（Image），就相当于是一个 root 文件系统，它除了提供容器运行时所需的程序、库、资&lt;br&gt;源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。&lt;/p&gt;&lt;h3 id=&quot;分层存储&quot;&gt;&lt;a href=&quot;#分层存储&quot; class=&quot;headerlink&quot; title=&quot;分层存储&quot;&gt;&lt;/a&gt;分层存储&lt;/h3&gt;&lt;p&gt;因为镜像体积庞大，就将其设计成分层存储的架构，所以严格来说镜像由一组文件系统组成。&lt;br&gt;镜像构建时，会一层层构建，前一层是后一层的基础。。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。&lt;/p&gt;&lt;h2 id=&quot;Docker-容器&quot;&gt;&lt;a href=&quot;#Docker-容器&quot; class=&quot;headerlink&quot; title=&quot;Docker 容器&quot;&gt;&lt;/a&gt;Docker 容器&lt;/h2&gt;&lt;p&gt;容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。&lt;/p&gt;&lt;h2 id=&quot;Docker仓库&quot;&gt;&lt;a href=&quot;#Docker仓库&quot; class=&quot;headerlink&quot; title=&quot;Docker仓库&quot;&gt;&lt;/a&gt;Docker仓库&lt;/h2&gt;&lt;p&gt;镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker仓库就是这样的服务。&lt;br&gt;一个 Docker Registry 中可以包含多个仓库（ Repository ）；每个仓库可以包含多个标签（ Tag ）；每个标签对应一个镜像。&lt;br&gt;通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 &amp;lt;仓库名&amp;gt;:&amp;lt;标签&amp;gt; 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签。&lt;br&gt;以 Ubuntu 镜像 为例， ubuntu 是仓库的名字，其内包含有不同的版本标签，如， 16.04 , 18.04。我们可以通过 ubuntu:14.04，或者ubuntu:18.04来具体指定所需哪个版本的镜像。如果忽略了标签，比如 ubuntu ，那将视为ubuntu:latest 。&lt;/p&gt;&lt;h3 id=&quot;私有-Docker仓库&quot;&gt;&lt;a href=&quot;#私有-Docker仓库&quot; class=&quot;headerlink&quot; title=&quot;私有 Docker仓库&quot;&gt;&lt;/a&gt;私有 Docker仓库&lt;/h3&gt;&lt;p&gt;除了使用公开服务外，用户还可以在本地搭建私有Docker仓库。Docker官方提供了Docker仓库镜像，可以直接使用做为私有 Registry 服务。&lt;/p&gt;&lt;h2 id=&quot;使用-Docker-镜像&quot;&gt;&lt;a href=&quot;#使用-Docker-镜像&quot; class=&quot;headerlink&quot; title=&quot;使用 Docker 镜像&quot;&gt;&lt;/a&gt;使用 Docker 镜像&lt;/h2&gt;&lt;h3 id=&quot;获取镜像&quot;&gt;&lt;a href=&quot;#获取镜像&quot; class=&quot;headerlink&quot; title=&quot;获取镜像&quot;&gt;&lt;/a&gt;获取镜像&lt;/h3&gt;&lt;p&gt;从 Docker 镜像仓库获取镜像的命令是 docker pull 。其命令格式为：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]&lt;/p&gt;&lt;/blockquote&gt;&lt;ul&gt;&lt;li&gt;Docker 镜像仓库地址：地址的格式一般是 &amp;lt;域名/IP&amp;gt;[:端口号] 。默认地址是 Docker Hub。&lt;/li&gt;&lt;li&gt;仓库名：如之前所说，这里的仓库名是两段式名称，即&amp;lt;用户名&amp;gt;/&amp;lt;软件名&amp;gt;。对于DockerHub，如果不给出用户名，则默认为 library ，也就是官方镜像。&lt;br&gt;比如
    
    </summary>
    
    
      <category term="杂类" scheme="https://little8.top/categories/%E6%9D%82%E7%B1%BB/"/>
    
    
      <category term="little_eight" scheme="https://little8.top/tags/little-eight/"/>
    
  </entry>
  
  <entry>
    <title>使用Nacos实现服务注册与发现</title>
    <link href="https://little8.top/2019/02/15/%E4%BD%BF%E7%94%A8Nacos%E5%AE%9E%E7%8E%B0%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0/"/>
    <id>https://little8.top/2019/02/15/使用Nacos实现服务注册与发现/</id>
    <published>2019-02-15T08:24:55.000Z</published>
    <updated>2019-07-23T13:00:40.951Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用Nacos实现服务注册与发现"><a href="#使用Nacos实现服务注册与发现" class="headerlink" title="使用Nacos实现服务注册与发现"></a>使用Nacos实现服务注册与发现</h1><h2 id="什么是-Nacos"><a href="#什么是-Nacos" class="headerlink" title="什么是 Nacos"></a>什么是 Nacos</h2><p>官网解释：<br>Nacos 致力于帮助您发现、配置和管理微服务。Nacos 提供了一组简单易用的特性集，帮助您快速实现动态服务发现、服务配置、服务元数据及流量管理。</p><p>Nacos 帮助您更敏捷和容易地构建、交付和管理微服务平台。 Nacos 是构建以“服务”为中心的现代应用架构 (例如微服务范式、云原生范式) 的服务基础设施。</p><p>个人解释：<br>微服务管理平台</p><h2 id="Nacos优缺点"><a href="#Nacos优缺点" class="headerlink" title="Nacos优缺点"></a>Nacos优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>开箱即用，适用于dubbo，spring cloud</li><li>AP模型，数据最终一致性</li><li>注册中心，配置中心二合一，提供控制台管理</li><li>纯国产，久经双十一考验</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>刚刚开源不久，社区热度不够，依然存在bug<blockquote><p>优缺点4比1，肯定选它呀，</p></blockquote></li></ul><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><h3 id="下载Nacos"><a href="#下载Nacos" class="headerlink" title="下载Nacos"></a>下载Nacos</h3><p><a href="ttps://github.com/alibaba/nacos/releases" target="_blank" rel="noopener">下载地址(本文版本：0.8.0)</a></p><p>下载完成之后，解压。根据不同平台，执行不同命令。本人windows，直接点击bin包下的startup.cmd</p><p>启动完成之后，访问：<a href="http://127.0.0.1:8848/nacos/，默认账号密码均为nacos，进入Nacos的服务管理页面，如下图" target="_blank" rel="noopener">http://127.0.0.1:8848/nacos/，默认账号密码均为nacos，进入Nacos的服务管理页面，如下图</a><br><img src="https://raw.githubusercontent.com/little-eight-china/image/master/bdbk/nacos/1.jpg?raw=true" alt="图片1"></p><h3 id="创建服务提供和消费者"><a href="#创建服务提供和消费者" class="headerlink" title="创建服务提供和消费者"></a>创建服务提供和消费者</h3><h4 id="项目架构"><a href="#项目架构" class="headerlink" title="项目架构"></a>项目架构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">└─springboot-nacos</span><br><span class="line">    └─nacos-server</span><br><span class="line">        └─pom.xml</span><br><span class="line">    └─nacos-client</span><br><span class="line">        └─pom.xml</span><br><span class="line">    └─pom.xml</span><br></pre></td></tr></table></figure><ul><li>创建一个名为springboot-nacos的springboot项目，然后项目里只留pom.xml文件，其余全部删除。pom.xml的依赖如下</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;0.2.1.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br><span class="line">&lt;/dependencyManagement&gt;</span><br></pre></td></tr></table></figure><blockquote><p>注意，版本兼容性官方说明：版本 0.2.x.RELEASE 对应的是 Spring Boot 2.0.x 版本，版本 0.1.x.RELEASE 对应的是 Spring Boot 1.x 版本，所以要看清楚自己的springboot是什么版本，如果是2.1.x,会有未知的bug(比如服务注册不上)，本人使用2.0.6</p></blockquote><ul><li><p>在父项目中new一个module，名为nacos-server作为服务提供者，由于依赖可全继承父层，所以pom.xml可删除其它，只留 parent</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">&lt;parent&gt;</span><br><span class="line">&lt;groupId&gt;bdbk&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;springboot-nacos&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.0.0&lt;/version&gt;</span><br><span class="line">&lt;/parent&gt;</span><br><span class="line">&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">&lt;artifactId&gt;nacos-server&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.0.0&lt;/version&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure></li><li><p>配置好application.yml</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8080</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: nacos-server #服务名</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      discovery:</span><br><span class="line">        server-addr: 127.0.0.1:8848 #nacos地址</span><br></pre></td></tr></table></figure><ul><li><p>在启动类里写内部接口服务提供类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 开启Spring Cloud的服务注册与发现</span><br><span class="line">@EnableDiscoveryClient</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class NacosServerApplication &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">SpringApplication.run(NacosServerApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 开放服务接口</span><br><span class="line">@RestController</span><br><span class="line">static class ServerController &#123;</span><br><span class="line">@GetMapping(&quot;/&quot;)</span><br><span class="line">public String hello() &#123;</span><br><span class="line">return &quot;hello clien&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>启动，如果控制台日志看到如下说明注册成功 即可在nacos的管理界面看到我们的服务注册了上去，你可以点击详情查看服务的具体信息。此时还可以改下端口开2个服务，后面做负载均衡的测试<br><img src="https://raw.githubusercontent.com/little-eight-china/image/master/bdbk/nacos/2.jpg?raw=true" alt="图片2"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">o.s.c.a.n.registry.NacosServiceRegistry  : nacos registry, nacos-client 192.168.96.122:8090 register finished</span><br></pre></td></tr></table></figure></li><li><p>同理创建nacos-client作为服务消费者，配置好application.yml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8090</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: nacos-client</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      discovery:</span><br><span class="line">        server-addr: 127.0.0.1:8848</span><br></pre></td></tr></table></figure></li><li><p>在启动类里写内部接口服务消费类</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 开启Spring Cloud的服务注册与发现</span><br><span class="line">@EnableDiscoveryClient</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class NacosClientApplication &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">SpringApplication.run(NacosClientApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 调用服务接口</span><br><span class="line">@RestController</span><br><span class="line">static class ClientController &#123;</span><br><span class="line">@Autowired</span><br><span class="line">private LoadBalancerClient loadBalancerClient;</span><br><span class="line">@GetMapping(&quot;/&quot;)</span><br><span class="line">public String test() &#123;</span><br><span class="line">// 负载均衡接口选取服务提供节点实现接口调用</span><br><span class="line">ServiceInstance serviceInstance = loadBalancerClient.choose(&quot;nacos-server&quot;);</span><br><span class="line">RestTemplate restTemplate = new RestTemplate();</span><br><span class="line">String result = restTemplate.getForObject(serviceInstance.getUri().toString(), String.class);</span><br><span class="line">return &quot;端口号为 : &quot; + serviceInstance.getPort() + &quot;, 返回结果 : &quot; + result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>启动，注册成功后，访问localhost:8090,可以看到结果显示在2个端口不断切换，说明不同请求真正实际调用的服务提供者实例是不同的，也就是说，通过LoadBalancerClient接口在获取服务实例的时候，已经实现了对服务提供方实例的负载均衡。</li></ul><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://nacos.io/zh-cn/docs/quick-start-spring-cloud.html" target="_blank" rel="noopener">Nacos官方文档</a></p><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><p><a href="https://github.com/little-eight-china/springboot-project/tree/master/springboot-nacos" target="_blank" rel="noopener">springboot-nacos</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;使用Nacos实现服务注册与发现&quot;&gt;&lt;a href=&quot;#使用Nacos实现服务注册与发现&quot; class=&quot;headerlink&quot; title=&quot;使用Nacos实现服务注册与发现&quot;&gt;&lt;/a&gt;使用Nacos实现服务注册与发现&lt;/h1&gt;&lt;h2 id=&quot;什么是-Nacos
      
    
    </summary>
    
    
      <category term="springboot" scheme="https://little8.top/categories/springboot/"/>
    
    
      <category term="little_eight" scheme="https://little8.top/tags/little-eight/"/>
    
  </entry>
  
  <entry>
    <title>十大基础排序算法</title>
    <link href="https://little8.top/2019/01/30/%E5%8D%81%E5%A4%A7%E5%9F%BA%E7%A1%80%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>https://little8.top/2019/01/30/十大基础排序算法/</id>
    <published>2019-01-30T08:20:12.000Z</published>
    <updated>2019-07-23T13:00:40.951Z</updated>
    
    <content type="html"><![CDATA[<h2 id="十大基础排序算法"><a href="#十大基础排序算法" class="headerlink" title="十大基础排序算法"></a>十大基础排序算法</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><ul><li><p>基本思路<br>对n个数进行排序，每次都是由前一个数跟后一个数比较，每循环一轮， 就可以将最大的数移到数组的最后， 总共循环n-1轮，完成对数组排序。</p></li><li><p>动图演示</p></li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/1/17/1685c01b1a3ac5e8?imageslim" alt="这里写图片描述"></p><ul><li>编码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> len = arr.length;</span><br><span class="line"><span class="comment">// i控制循环次数，长度为len的数组只需要循环len-1次，i的起始值为0所以i&lt;len-1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line"><span class="comment">// 如果前一个数比后一个数大，则交换位置将大的数往后放。</span></span><br><span class="line"><span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line"><span class="keyword">int</span> temp = arr[j + <span class="number">1</span>];</span><br><span class="line">arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">arr[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><a id="more"></a><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><ul><li><p>基本思路<br>选择排序可以说是冒泡排序的改良版,通过循环对比，记录最小的数字下标与目标互换 这样相对于冒泡排序来说，比较的次数并没有改变，但是数据交换的次数大大减少。</p></li><li><p>动图演示</p></li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/1/17/1685c01b2349fb70?imageslim" alt="这里写图片描述"></p><ul><li>编码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> len = arr.length;</span><br><span class="line"><span class="comment">// 用来保存每次比较后较小数的下标</span></span><br><span class="line"><span class="keyword">int</span> minIndex;</span><br><span class="line"><span class="comment">// i控制循环次数，长度为len的数组只需要循环len-1次，i的起始值为0所以i&lt;len-1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">minIndex = i;</span><br><span class="line"><span class="comment">//j控制比较次数，因为每次循环结束之后最小的数都已经放在了最前面，</span></span><br><span class="line"><span class="comment">//所以下一次循环的时候就可以跳过这个数，所以j的初始值为i+1而不需要每次循环都从0开始，并且j&lt;len即可</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line"><span class="comment">// 每比较一次都需要将较小数的下标记录下来</span></span><br><span class="line"><span class="keyword">if</span> (arr[minIndex] &gt; arr[j]) &#123;</span><br><span class="line">minIndex = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当完成一次循环时，就需要将本次循环选取的最小数移动到本次循环开始的位置。</span></span><br><span class="line"><span class="keyword">if</span> (minIndex != i) &#123;</span><br><span class="line"><span class="keyword">int</span> temp = arr[i];</span><br><span class="line">arr[i] = arr[minIndex];</span><br><span class="line">arr[minIndex] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><ul><li><p>基本思路<br>首先就默认数组中的第一个数的位置是正确的，即已经排序。然后取下一个数，与已经排序的数按从后向前的顺序依次比较， 如果该数比当前位置排好序的数小，则将排好序的数的位置向后移一位。 重复上一步骤，直到找到合适的位置。找到位置后就结束比较的循环，将该数放到相应的位置。</p></li><li><p>动图演示</p></li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/1/17/1685c01b284a6b98?imageslim" alt="这里写图片描述"></p><ul><li>编码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> len = arr.length;</span><br><span class="line"><span class="comment">// target用来记录即将要排序的那个数的值即目标值</span></span><br><span class="line"><span class="keyword">int</span> target;</span><br><span class="line"><span class="comment">// index用来记录要交换的那个值的下标</span></span><br><span class="line"><span class="keyword">int</span> index;</span><br><span class="line"><span class="comment">// i控制循环次数，因为已经默认第一个数的位置是正确的，所以i的起始值为1，i&lt;len，循环len-1次</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">target = arr[i];</span><br><span class="line">index = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line"><span class="comment">// 如果前一个数大于target，则设值成后一个数，并记录前一个数下标</span></span><br><span class="line"><span class="keyword">if</span> (target &lt; arr[j - <span class="number">1</span>]) &#123;</span><br><span class="line">arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">index = j - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 更目标数的位置。</span></span><br><span class="line">arr[index] = target;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><ul><li><p>基本思路<br>希尔排序也称为”缩小增量排序”，原理是先将需要排的数组分成多个子序列，这样每个子序列的元素个数就很少，再分别对每个对子序列进行插入排序。在该数组基本有序后 再进行一次直接插入排序就能完成对整个数组的排序。所以，要采用跳跃分割的策略。这里引入“增量”的概念，将相距某个增量的记录两两组合成一个子序列，然后对每个子序列进行直接插入排序， 这样得到的结果才会使基本有序（即小的在前边，大的在后边，不大不小的在中间）。希尔排序就是 直接插入排序的升级版。</p></li><li><p>动图演示</p></li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/1/17/1685c01b7d4cfe55?imageslim" alt="这里写图片描述"></p><ul><li>编码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="comment">// 数组的长度</span></span><br><span class="line"><span class="keyword">int</span> len = arr.length;</span><br><span class="line"><span class="comment">// 初始的增量为数组长度的一半</span></span><br><span class="line"><span class="keyword">int</span> k = len / <span class="number">2</span>;</span><br><span class="line"><span class="comment">// while循环控制按增量的值来划不同分子序列，每完成一次增量就减少为原来的一半</span></span><br><span class="line"><span class="comment">// 增量的最小值为1，即最后一次对整个数组做直接插入排序</span></span><br><span class="line"><span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// 里边其实就是升级版的直接插入排序了，是对每一个子序列进行直接插入排序，</span></span><br><span class="line"><span class="comment">// 所以直接将直接插入排序中的‘1’变为‘k’就可以了。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; len; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> j = i;</span><br><span class="line"><span class="keyword">int</span> target = arr[i];</span><br><span class="line"><span class="keyword">while</span> (j &gt;= k &amp;&amp; target &lt; arr[j - k]) &#123;</span><br><span class="line">arr[j] = arr[j - k];</span><br><span class="line">j -= k;</span><br><span class="line">&#125;</span><br><span class="line">arr[j] = target;</span><br><span class="line">&#125;</span><br><span class="line">k /= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><ul><li><p>基本思路<br>总体概括就是从上到下递归拆分，然后从下到上逐步合并。</p></li><li><p>动图演示</p></li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/1/17/1685c01b7f84849b?imageslim" alt="这里写图片描述"></p><ul><li>编码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归拆分</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr   待拆分数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> left  待拆分数组最小下标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> right 待拆分数组最大下标</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 中间下标</span></span><br><span class="line"><span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line"><span class="comment">// 递归拆分左边</span></span><br><span class="line">mergeSort(arr, left, mid);</span><br><span class="line"><span class="comment">// 递归拆分右边</span></span><br><span class="line">mergeSort(arr, mid + <span class="number">1</span>, right);</span><br><span class="line"><span class="comment">// 合并左右</span></span><br><span class="line">sort(arr, left, mid, right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 合并两个有序子序列</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr   待合并数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> left  待合并数组最小下标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mid   待合并数组中间下标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> right 待合并数组最大下标</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 临时数组，用来保存每次合并年之后的结果</span></span><br><span class="line"><span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[right - left + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> i = left;</span><br><span class="line"><span class="keyword">int</span> j = mid + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 临时数组的初始下标</span></span><br><span class="line"><span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 这个while循环能够初步筛选出待合并的了两个子序列中的较小数</span></span><br><span class="line"><span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr[i] &lt;= arr[j]) &#123;</span><br><span class="line">temp[k++] = arr[i++];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">temp[k++] = arr[j++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将左边序列中剩余的数放入临时数组</span></span><br><span class="line"><span class="keyword">while</span> (i &lt;= mid) &#123;</span><br><span class="line">temp[k++] = arr[i++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将右边序列中剩余的数放入临时数组</span></span><br><span class="line"><span class="keyword">while</span> (j &lt;= right) &#123;</span><br><span class="line">temp[k++] = arr[j++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将临时数组中的元素位置对应到真真实的数组中</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>; m &lt; temp.length; m++) &#123;</span><br><span class="line">arr[m + left] = temp[m];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><ul><li><p>基本思路<br>快速排序也采用了分治的策略，这里引入了‘基准数’的概念。</p><ul><li>找一个基准数（一般将待排序的数组的第一个数作为基准数）</li><li>对数组进行分区，将小于等于基准数的全部放在左边，大于基准数的全部放在右边。</li><li>重复1，2步骤，分别对左右两个子分区进行分区，一直到各分区只有一个数为止。</li></ul></li><li><p>动图演示</p></li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/1/17/1685c01b83823cd8?imageslim" alt="这里写图片描述"></p><ul><li>编码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分区过程</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr   待分区数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> left  待分区数组最小下标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> right 待分区数组最大下标</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line"><span class="keyword">int</span> temp = qSort(arr, left, right);</span><br><span class="line">quickSort(arr, left, temp - <span class="number">1</span>);</span><br><span class="line">quickSort(arr, temp + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 排序过程</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr   待排序数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> left  待排序数组最小下标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> right 待排序数组最大下标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 排好序之后基准数的位置下标，方便下次的分区</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">qSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 定义基准数，默认为数组的第一个元素</span></span><br><span class="line"><span class="keyword">int</span> temp = arr[left];</span><br><span class="line"><span class="comment">// 循环执行的条件</span></span><br><span class="line"><span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line"><span class="comment">// 因为默认的基准数是在最左边，所以首先从右边开始比较进入while循环的判断条件</span></span><br><span class="line"><span class="comment">// 如果当前arr[right]比基准数大，则直接将右指针左移一位，当然还要保证left&lt;right</span></span><br><span class="line"><span class="keyword">while</span> (left &lt; right &amp;&amp; arr[right] &gt; temp) &#123;</span><br><span class="line">right--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 跳出循环说明当前的arr[right]比基准数要小，那么直接将当前数移动到基准数所在的位置，并且左指针向右移一位（left++）</span></span><br><span class="line"><span class="comment">// 这时当前数（arr[right]）所在的位置空出，需要从左边找一个比基准数大的数来填充。</span></span><br><span class="line"><span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">arr[left++] = arr[right];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 下面的步骤是为了在左边找到比基准数大的数填充到right的位置。</span></span><br><span class="line"><span class="comment">// 因为现在需要填充的位置在右边，所以左边的指针移动，如果arr[left]小于或者等于基准数，则直接将左指针右移一位</span></span><br><span class="line"><span class="keyword">while</span> (left &lt; right &amp;&amp; arr[left] &lt;= temp) &#123;</span><br><span class="line">left++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 跳出上一个循环说明当前的arr[left]的值大于基准数，需要将该值填充到右边空出的位置，然后当前位置空出。</span></span><br><span class="line"><span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">arr[right--] = arr[left];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当循环结束说明左指针和右指针已经相遇。并且相遇的位置是一个空出的位置，</span></span><br><span class="line"><span class="comment">// 这时候将基准数填入该位置，并返回该位置的下标，为分区做准备。</span></span><br><span class="line">arr[left] = temp;</span><br><span class="line"><span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><ul><li><p>基本思路<br>堆是一种特殊的完全二叉树，分为大顶堆和小顶堆。大顶堆：每个结点的值都大于它的左右子结点的值，升序排序用大顶堆。小顶堆：每个结点的值都小于它的左右子结点的值，降序排序用小顶堆。<br>所以，需要先将待排序数组构造成大顶堆的格式，这时候该堆的顶结点就是最大的数，将其与堆的最后一个结点的元素交换。再将剩余的树重新调整成堆，再次首节点与尾结点交换，重复执行直到只剩下最后一个结点完成排序。</p></li><li><p>动图演示</p></li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/1/17/1685c01bbe480b52?imageslim" alt="这里写图片描述"></p><ul><li>编码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> len = arr.length;</span><br><span class="line"><span class="comment">// 初始化大顶堆（从最后一个非叶节点开始，从左到右，由下到上）</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = len / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">adjustHeap(arr, i, len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将顶节点和最后一个节点互换位置，再将剩下的堆进行调整</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = len - <span class="number">1</span>; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">swap(arr, <span class="number">0</span>, j);</span><br><span class="line">adjustHeap(arr, <span class="number">0</span>, j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 整理树让其变成堆</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr 待整理的数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i   开始的结点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> j   数组的长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">adjustHeap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 定义一个变量保存开始的结点</span></span><br><span class="line"><span class="keyword">int</span> temp = arr[i];</span><br><span class="line"><span class="comment">// k就是该结点的左子结点下标</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">2</span> * i + <span class="number">1</span>; k &lt; j; k = <span class="number">2</span> * k + <span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">// 比较左右两个子结点的大小，k始终记录两者中较大值的下标</span></span><br><span class="line"><span class="keyword">if</span> (k + <span class="number">1</span> &lt; j &amp;&amp; arr[k] &lt; arr[k + <span class="number">1</span>]) &#123;</span><br><span class="line">k++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 经子结点中的较大值和当前的结点比较，比较结果的较大值放在当前结点位置</span></span><br><span class="line"><span class="keyword">if</span> (arr[k] &gt; temp) &#123;</span><br><span class="line">arr[i] = arr[k];</span><br><span class="line">i = k;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 说明已经是大顶堆</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">arr[i] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 交换数据</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr  待整理的数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> num1 开始的结点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> num2 交换的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp = arr[num1];</span><br><span class="line">arr[num1] = arr[num2];</span><br><span class="line">arr[num2] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><ul><li><p>基本思路<br>就是将待排序数据拆分成多个关键字进行排序，也就是说，基数排序的实质是多关键字排序。多关键字排序的思路是将待排数据里德排序关键字拆分成多个排序关键字；第1个排序关键字，第2个排序关键字，第3个排序关键字……然后，根据子关键字对待排序数据进行排序。</p></li><li><p>动图演示</p></li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/1/17/1685c01bd10a5893?imageslim" alt="这里写图片描述"></p><ul><li>编码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> radix, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 缓存数组  </span></span><br><span class="line"><span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line"><span class="comment">// buckets用于记录待排序元素的信息  </span></span><br><span class="line"><span class="comment">// buckets数组定义了max-min个桶  </span></span><br><span class="line"><span class="keyword">int</span>[] buckets = <span class="keyword">new</span> <span class="keyword">int</span>[radix];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, rate = <span class="number">1</span>; i &lt; d; i++) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重置count数组，开始统计下一个关键字  </span></span><br><span class="line">java.util.Arrays.fill(buckets, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 将data中的元素完全复制到tmp数组中  </span></span><br><span class="line">System.arraycopy(arr, <span class="number">0</span>, tmp, <span class="number">0</span>, arr.length);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算每个待排序数据的子关键字  </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line"><span class="keyword">int</span> subKey = (tmp[j] / rate) % radix;</span><br><span class="line">buckets[subKey]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; radix; j++) &#123;</span><br><span class="line">buckets[j] = buckets[j] + buckets[j - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按子关键字对指定的数据进行排序  </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> m = arr.length - <span class="number">1</span>; m &gt;= <span class="number">0</span>; m--) &#123;</span><br><span class="line"><span class="keyword">int</span> subKey = (tmp[m] / rate) % radix;</span><br><span class="line">arr[--buckets[subKey]] = tmp[m];</span><br><span class="line">&#125;</span><br><span class="line">rate *= radix;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><ul><li><p>基本思路<br>计数排序采用了一种全新的思路，不再是通过比较来排序，而是将待排序数组中的最大值+1作为一个临时数组的长度，然后用临时数组记录待排序数组中每个元素出现的次数。最后再遍历临时数组，因为是升序，所以从前到后遍历，将临时数组中值&gt;0的数的下标循环取出，依次放入待排序数组中，即可完成排序。计数排序的效率很高，但是实在牺牲内存的前提下，并且有着限制，那就是待排序数组的值必须 限制在一个确定的范围。</p></li><li><p>动图演示</p></li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/1/17/1685c01bbf2b9faf?imageslim" alt="这里写图片描述"></p><ul><li>编码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> len = arr.length;</span><br><span class="line"><span class="comment">// 保存待排序数组中的最大值，目的是确定临时数组的长度（必须）</span></span><br><span class="line"><span class="keyword">int</span> maxNum = arr[<span class="number">0</span>];</span><br><span class="line"><span class="comment">// 保存待排序数组中的最小值，目的是确定最终遍历临时数组时下标的初始值（非必需，只是这样可以加快速度，减少循环次数）</span></span><br><span class="line"><span class="keyword">int</span> minNum = arr[<span class="number">0</span>];</span><br><span class="line"><span class="comment">// for循环就是为了找到待排序数组的最大值和最小值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">maxNum = maxNum &gt; arr[i] ? maxNum : arr[i];</span><br><span class="line">minNum = minNum &lt; arr[i] ? minNum : arr[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建一个临时数组</span></span><br><span class="line"><span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[maxNum + <span class="number">1</span>];</span><br><span class="line"><span class="comment">// for循环是为了记录待排序数组中每个元素出现的次数，并将该次数保存到临时数组中</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> anArr : arr) &#123;</span><br><span class="line">temp[anArr]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// k=0用来记录待排序数组的下标</span></span><br><span class="line"><span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 遍历临时数组，重新为待排序数组赋值。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = minNum; i &lt; temp.length; i++) &#123;</span><br><span class="line"><span class="keyword">while</span> (temp[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">arr[k++] = i;</span><br><span class="line">temp[i]--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><ul><li><p>基本思路<br>桶排序其实就是计数排序的强化版，需要利用一个映射函数首先定义有限个数个桶，然后将待排序数组内的元素按照函数映射的关系分别放入不同的桶里边，现在不同的桶里边的数据已经做了区分，比如A桶里的数要么全部大于B桶，要么全部小于B桶里的数。但是A，B桶各自里边的数还是乱序的。所以要借助其他排序方式（快速，插入，归并）分别对每一个元素个数大于一的桶里边的数据进行排序。最后再将桶里边的元素按照顺序依次放入待排序数组中即可。</p></li><li><p>动图演示<br>无。。。。。</p></li><li><p>编码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> len = arr.length;</span><br><span class="line"><span class="comment">// 定义桶的个数，这里k的值要视情况而定，这里我们假设待排序数组里的数都是[0,100)之间的。</span></span><br><span class="line"><span class="keyword">int</span> k = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 用嵌套集合来模拟桶，外层集合表示桶，内层集合表示桶里边装的元素。</span></span><br><span class="line">java.util.List&lt;java.util.List&lt;Integer&gt;&gt; bucket = <span class="keyword">new</span> java.util.ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">// for循环初始化外层集合即初始化桶</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">bucket.add(<span class="keyword">new</span> java.util.ArrayList&lt;&gt;());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 循环是为了将待排序数组中的元素通过映射函数分别放入不同的桶里边</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> anArr : arr) &#123;</span><br><span class="line">bucket.get(anArr / <span class="number">10</span>).add(anArr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这个循环是为了将所有的元素个数大于1的桶里边的数据进行排序。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (bucket.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">// 因为这里是用集合来模拟的桶所以用java写好的对集合排序的方法。</span></span><br><span class="line"><span class="comment">// 其实应该自己写一个方法来排序的。</span></span><br><span class="line">java.util.Collections.sort(bucket.get(i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将排好序的数重新放入待排序数组中</span></span><br><span class="line"><span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (java.util.List&lt;Integer&gt; list : bucket) &#123;</span><br><span class="line"><span class="keyword">if</span> (list.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (Integer a : list) &#123;</span><br><span class="line">arr[m++] = a;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;十大基础排序算法&quot;&gt;&lt;a href=&quot;#十大基础排序算法&quot; class=&quot;headerlink&quot; title=&quot;十大基础排序算法&quot;&gt;&lt;/a&gt;十大基础排序算法&lt;/h2&gt;&lt;h3 id=&quot;冒泡排序&quot;&gt;&lt;a href=&quot;#冒泡排序&quot; class=&quot;headerlink&quot; title=&quot;冒泡排序&quot;&gt;&lt;/a&gt;冒泡排序&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;基本思路&lt;br&gt;对n个数进行排序，每次都是由前一个数跟后一个数比较，每循环一轮， 就可以将最大的数移到数组的最后， 总共循环n-1轮，完成对数组排序。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;动图演示&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/1/17/1685c01b1a3ac5e8?imageslim&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;编码&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;sort&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[] arr)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (arr == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; len = arr.length;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;comment&quot;&gt;// i控制循环次数，长度为len的数组只需要循环len-1次，i的起始值为0所以i&amp;lt;len-1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; len - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; j &amp;lt; len - i - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; j++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				&lt;span class=&quot;comment&quot;&gt;// 如果前一个数比后一个数大，则交换位置将大的数往后放。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (arr[j] &amp;gt; arr[j + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;					&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; temp = arr[j + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;					arr[j + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] = arr[j];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;					arr[j] = temp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
      <category term="杂类" scheme="https://little8.top/categories/%E6%9D%82%E7%B1%BB/"/>
    
    
      <category term="little_eight" scheme="https://little8.top/tags/little-eight/"/>
    
  </entry>
  
  <entry>
    <title>Linux命令大全</title>
    <link href="https://little8.top/2018/12/28/Linux%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"/>
    <id>https://little8.top/2018/12/28/Linux命令大全/</id>
    <published>2018-12-28T11:33:41.000Z</published>
    <updated>2019-07-23T13:00:40.947Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux命令大全"><a href="#Linux命令大全" class="headerlink" title="Linux命令大全"></a>Linux命令大全</h1><h2 id="linux-系统管理命令"><a href="#linux-系统管理命令" class="headerlink" title="linux 系统管理命令"></a>linux 系统管理命令</h2><h3 id="adduser"><a href="#adduser" class="headerlink" title="adduser"></a>adduser</h3><p><strong>功能说明</strong>：新增用户帐号。<br><strong>语 法</strong>：adduser<br><strong>补充说明</strong>：在 Slackware 中，adduser 指令是个 script 程序，利用交谈的方式取得<br>输入的用户帐号资料，然后再交由真正建立帐号的 useradd 指令建立新用户，如<br>此可方便管理员建立用户帐号。在 Red Hat Linux 中，adduser 指令则是 useradd<br>指令的符号连接，两者实际上是同一个指令。</p><h3 id="chfn-change-finger-information"><a href="#chfn-change-finger-information" class="headerlink" title="chfn(change finger information)"></a>chfn(change finger information)</h3><p><strong>功能说明</strong>：改变 finger 指令显示的信息。<br><strong>语 法</strong>：chfn [-f &lt;真实姓名&gt;][-h &lt;家中电话&gt;][-o &lt;办公地址&gt;][-p &lt;办公电话&gt;][-uv][帐号名称]<br><strong>补充说明</strong>：chfn 指令可用来更改执行 finger 指令时所显示的信息，这些信息都存<br>放在/etc 目录里的 asswd 文件里。若不指定任何参数，则 chfn 指令会进入问答式<br>界面。<br><strong>参 数</strong>：</p><ul><li>-f&lt;真实姓名&gt;或–full-name&lt;真实姓名&gt; 设置真实姓名。</li><li>-h&lt;家中电话&gt;或–home-phone&lt;家中电话&gt; 设置家中的电话号码。</li><li>-o&lt;办公地址&gt;或–office&lt;办公地址&gt; 设置办公室的地址。</li><li>-p&lt;办公电话&gt;或–office-phone&lt;办公电话&gt; 设置办公室的电话号码。</li><li>-u 或–help 在线帮助。</li><li><p>-v 或-version 显示版本信息。</p><h3 id="chsh-change-shell"><a href="#chsh-change-shell" class="headerlink" title="chsh(change shell)"></a>chsh(change shell)</h3><p><strong>功能说明</strong>：更换登入系统时使用的 shell。<br><strong>语 法</strong>：chsh [-luv][-s<shell 名称>][用户名称]<br><strong>补充说明</strong>：每位用户在登入系统时，都会拥有预设的 shell 环境，这个指令可更<br>改其预设值。若不指定任何参数与用户名称，则 chsh 会以应答的方式进行设置。<br><strong>参 数</strong>：</shell></p></li><li><p>-s<shell 名称>或–shell<shell 名称>更改系统预设的 shell 环境。</shell></shell></p></li><li>-l 或–list-shells 列出目前系统可用的 shell 清单。</li><li>-u 或–help 在线帮助。</li><li>-v 或-version 显示版本信息。</li></ul><a id="more"></a><h3 id="date"><a href="#date" class="headerlink" title="date"></a>date</h3><p><strong>功能说明</strong>：显示或设置系统时间与日期。</p><p><strong>语 法</strong>：<br>date [-d &lt; 字符串&gt;][-u][+%H%I%K%l%M%P%r%s%S%T%X%Z%a%A%b%B%c%d%D%j%m%U<br>%w%x%y%Y%n%t] 或 date [-s &lt; 字符串&gt;][-u][MMDDhhmmCCYYss] 或 date [–help][–version]</p><p><strong>补充说明</strong>：第一种语法可用来显示系统日期或时间，以%为开头的参数为格式参<br>数，可指定日期或时间的显示格式。第二种语法可用来设置系统日期与时间。只<br>有管理员才有设置日期与时间的权限。若不加任何参数，data 会显示目前的日期<br>与时间。</p><p><strong>参 数</strong>：</p><ul><li>%H 小时(以 00-23 来表示)。</li><li>%I 小时(以 01-12 来表示)。</li><li>%K 小时(以 0-23 来表示)。</li><li>%l 小时(以 0-12 来表示)。</li><li>%M 分钟(以 00-59 来表示)。</li><li>%P AM 或 PM。</li><li>%r 时间(含时分秒，小时以 12 小时 AM/PM 来表示)。</li><li>%s 总秒数。起算时间为 1970-01-01 00:00:00 UTC。</li><li>%S 秒(以本地的惯用法来表示)。</li><li>%T 时间(含时分秒，小时以 24小时制来表示)。</li><li>%X 时间(以本地的惯用法来表示)。</li><li>%Z 市区。</li><li>%a 星期的缩写。</li><li>%A 星期的完整名称。</li><li>%b 月份英文名的缩写。</li><li>%B 月份的完整英文名称。</li><li>%c 日期与时间。只输入 date 指令也会显示同样的结果。</li><li>%d 日期(以 01-31 来表示)。</li><li>%D 日期(含年月日)。</li><li>%j 该年中的第几天。</li><li>%m 月份(以 01-12 来表示)。</li><li>%U 该年中的周数。</li><li>%w 该周的天数，0 代表周日，1 代表周一，异词类推。</li><li>%x 日期(以本地的惯用法来表示)。</li><li>%y 年份(以 00-99 来表示)。</li><li>%Y 年份(以四位数来表示)。</li><li>%n 在显示时，插入新的一行。</li><li>%t 在显示时，插入 tab。</li><li>MM 月份(必要)。</li><li>DD 日期(必要)。</li><li>hh 小时(必要)。</li><li>mm 分钟(必要)。</li><li>CC 年份的前两位数(选择性)。</li><li>YY 年份的后两位数(选择性)。</li><li>ss 秒(选择性)。</li><li>-d&lt;字符串&gt; 显示字符串所指的日期与时间。字符串前后必须加上双引号。</li><li>-s&lt;字符串&gt; 根据字符串来设置日期与时间。字符串前后必须加上双引号。</li><li>-u 显示 GMT。</li><li>–help 在线帮助。</li><li>–version 显示版本信息。</li><li><h3 id="exit"><a href="#exit" class="headerlink" title="exit"></a>exit</h3><strong>功能说明</strong>：退出目前的 shell。</li></ul><p><strong>语 法</strong>：exit [状态值]<br><strong>补充说明</strong>：执行 exit 可使 shell 以指定的状态值退出。若不设置状态值参数，则<br>shell 以预设值退出。状态值 0 代表执行成功，其他值代表执行失败。exit 也可用<br>在 script，离开正在执行的 script，回到 shell。</p><h3 id="finger"><a href="#finger" class="headerlink" title="finger"></a>finger</h3><p><strong>功能说明</strong>：查找并显示用户信息。<br><strong>语 法</strong>：finger [-lmsp][帐号名称…]<br><strong>补充说明</strong>：finger 指令会去查找，并显示指定帐号的用户相关信息，<br>包括本地与远端主机的用户皆可，帐号名称没有大小写的差别。单独<br>执行 finger 指令，它会显示本地主机现在所有的用户的登陆信息，包<br>括帐号名称，真实姓名，登入终端机，闲置时间，登入时间以及地址<br>和电话。<br><strong>参 数</strong>：</p><ul><li>-l 列出该用户的帐号名称，真实姓名，用户专属目录，登入所用<br>的 Shell，登入时间，转信地址，电子邮件状态，还有计划文件和方<br>案文件内容。</li><li>-m 排除查找用户的真实姓名。</li><li>-s 列出该用户的帐号名称，真实姓名，登入终端机，闲置时间，<br>登入时间以及地址和电话。</li><li>-p 列出该用户的帐号名称，真实姓名，用户专属目录，登入所用<br>的 Shell，登入时间，转信地址，电子邮件状态，但不显示该用户的<br>计划文件和方案文件内容。</li></ul><h3 id="free"><a href="#free" class="headerlink" title="free"></a>free</h3><p><strong>功能说明</strong>：显示内存状态。<br><strong>语 法</strong>： free [-bkmotV][-s &lt;间隔秒数&gt;]<br><strong>补充说明</strong>：free 指令会显示内存的使用情况，包括实体内存，虚拟的交换文件内<br>存，共享内存区段，以及系统核心使用的缓冲区等。<br><strong>参 数</strong>：</p><ul><li>-b 以 Byte 为单位显示内存使用情况。</li><li>-k 以 KB 为单位显示内存使用情况。</li><li>-m 以 MB 为单位显示内存使用情况。</li><li>-o 不显示缓冲区调节列。</li><li>-s&lt;间隔秒数&gt; 持续观察内存使用状况。</li><li>-t 显示内存总和列。</li><li>-V 显示版本信息。</li></ul><h3 id="gitps-gnu-interactive-tools-process-status"><a href="#gitps-gnu-interactive-tools-process-status" class="headerlink" title="gitps(gnu interactive tools process status)"></a>gitps(gnu interactive tools process status)</h3><p><strong>功能说明</strong>：报告程序状况。<br><strong>语 法</strong>：gitps [acefgjlnrsSTuvwxX][p &lt;程序识别码&gt;][t &lt;终端机编号&gt;][U &lt;帐号<br>名称&gt;]<br><strong>补充说明</strong>：gitps 是用来报告并管理程序执行的指令，基本上它就是通过 ps 指令<br>来报告，管理程序，也能通过 gitps 指令随时中断，删除不必要的程序。因为 gitps<br>指令会去执行 ps 指令，所以其参数和 ps 指令相当类似。<br><strong>参 数</strong>：</p><ul><li>a 显示 现行终端机下的所有程序，包括其他用户的程序。</li><li>c 列出程序时，显示每个程序真正的指令名称，而不包含路径，参数或是常</li><li>驻服务的标示．</li><li>e 列出程序时，显示每个程序所使用的环境变量。</li><li>f 用 ASCII 字符显示树状结构，表达程序间的相互关系。</li><li>g 显示现行终端机下的所有程序，包括群组领导者的程序。</li><li>j 采用工作控制的格式来显示程序状况。</li><li>l 采用纤细的格式来显示程序状况。</li><li>n 以数字来表示 USER 和 WCHAN 栏位。</li><li>p&lt;程序识别码&gt; 指定程序识别码，并列出该程序的状况。</li><li>r 只列出现行终端机正在执行中的程序。</li><li>s 采用程序信号的格式显示程序状况。</li><li>S 列出程序时，包括已中断的子程序信息。</li><li>t&lt;终端机机标号&gt; 指定终端机编号，并列出属于该终端机的程序的状况。</li><li>T 显示现行终端机下的所有程序。</li><li>u 以用户为主的格式来显示程序状况。</li><li>U&lt;帐号名称&gt; 列出属于该用户的程序的状况。</li><li>v 采用虚拟内存的格式显示程序状况。</li><li>w 采用宽阔的格式来显示程序状况。</li><li>x 显示所有程序，不以终端机来区分。</li><li>X 采用旧试的 Linux i386 登陆格式显示程序状况。</li></ul><h3 id="groupdel-group-delete"><a href="#groupdel-group-delete" class="headerlink" title="groupdel(group delete)"></a>groupdel(group delete)</h3><p><strong>功能说明</strong>：删除群组。<br><strong>语 法</strong>：groupdel [群组名称]<br><strong>补充说明</strong>：需要从系统上删除群组时，可用 groupdel 指令来完成这项工作。倘若<br>该群组中仍包括某些用户，则必须先删除这些用户后，方能删除群组。</p><h3 id="groupmod-group-modify"><a href="#groupmod-group-modify" class="headerlink" title="groupmod(group modify)"></a>groupmod(group modify)</h3><p><strong>功能说明</strong>：更改群组识别码或名称。<br><strong>语 法</strong>：<code>groupmod [-g &lt;群组识别码&gt; &lt;-o&gt; ][-n &lt;新群组名称&gt;][群组名称]</code><br><strong>补充说明</strong>：需要更改群组的识别码或名称时，可用 groupmod 指令来完成这项工作。<br><strong>参 数</strong>：</p><ul><li>-g &lt;群组识别码&gt; 设置欲使用的群组识别码。</li><li>-o 重复使用群组识别码。</li><li>-n &lt;新群组名称&gt; 设置欲使用的群组名称。</li></ul><h3 id="id"><a href="#id" class="headerlink" title="id"></a>id</h3><p><strong>功能说明</strong>：显示用户的 ID，以及所属群组的 ID。<br><strong>语 法</strong>：id [-gGnru][–help][–version][用户名称]<br><strong>补充说明</strong>：id 会显示用户以及所属群组的实际与有效 ID。若两个 ID 相同，则仅<br>显示实际 ID。若仅指定用户名称，则显示目前用户的 ID。<br><strong>参 数</strong>：</p><ul><li>-g 或–group 显示用户所属群组的 ID。</li><li>-G 或–groups 显示用户所属附加群组的 ID。</li><li>-n 或–name 显示用户，所属群组或附加群组的名称。</li><li>-r 或–real 显示实际 ID。</li><li>-u 或–user 显示用户 ID。</li><li>-help 显示帮助。</li><li>-version 显示版本信息。</li></ul><h3 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h3><p><strong>功能说明</strong>：删除执行中的程序或工作。<br><strong>语 法</strong>：kill [-s &lt;信息名称或编号&gt;][程序] 或 kill [-l &lt;信息编号&gt;]<br><strong>补充说明</strong>：kill 可将指定的信息送至程序。预设的信息为 SIGTERM(15)，可将指<br>定程序终止。若仍无法终止该程序，可使用 SIGKILL(9)信息尝试强制删除程序。<br>程序或工作的编号可利用 ps 指令或 jobs 指令查看。<br><strong>参 数</strong>：</p><ul><li>-l &lt;信息编号&gt; 若不加&lt;信息编号&gt;选项，则-l 参数会列出全部的信息名称。</li><li>-s &lt;信息名称或编号&gt; 指定要送出的信息。<br>[程序] [程序]可以是程序的 PID 或是 PGID，也可以是工作编号。</li></ul><h3 id="ps-process-status"><a href="#ps-process-status" class="headerlink" title="ps(process status)"></a>ps(process status)</h3><p><strong>功能说明</strong>：报告程序状况。<br><strong>语 法</strong>：ps [-aAcdefHjlmNVwy][acefghLnrsSTuvxX][-C &lt;指令名称&gt;][-g &lt;群组<br>名称&gt;][-G &lt;群组识别码&gt;][-p &lt;程序识别码&gt;][p &lt;程序识别码&gt;][-s &lt;阶段作业&gt;][-t &lt;终端机编号&gt;][t &lt;终端机编号&gt;][-u &lt;用户识别码&gt;][-U &lt;用户识别码&gt;][U &lt;<br>用户名称&gt;][-&lt;程序识别码&gt;][–cols &lt;每列字符数&gt;][–columns &lt;每列字符数&gt;][–cumulative][–deselect][–forest][–headers][–help][–info][–lines &lt; 显示列数&gt;][–no-headers][–group &lt;群组名称&gt;][-Group &lt;群组识别码&gt;][–pid &lt;程序识别码&gt;][–rows &lt;显示列数&gt;][–sid &lt;阶段作业&gt;][–tty &lt;终端机编号&gt;][–user &lt;用户名称&gt;][–User &lt;用户识别码&gt;][–version][–width &lt;每列字符数&gt;]<br><strong>补充说明</strong>：ps 是用来报告程序执行状况的指令，您可以搭配 kill 指令随时中断，<br>删除不必要的程序。<br><strong>参 数</strong>：</p><ul><li>-a 显示所有终端机下执行的程序，除了阶段作业领导者之外。</li><li>a 显示现行终端机下的所有程序，包括其他用户的程序。</li><li>-A 显示所有程序。</li><li>-c 显示 CLS 和 PRI 栏位。</li><li>c 列出程序时，显示每个程序真正的指令名称，而不包含路径，参数或常驻<br>服务的标示。</li><li>-C&lt;指令名称&gt; 指定执行指令的名称，并列出该指令的程序的状况。</li><li>-d 显示所有程序，但不包括阶段作业领导者的程序。</li><li>-e 此参数的效果和指定”A”参数相同。</li><li>e 列出程序时，显示每个程序所使用的环境变量。</li><li>-f 显示 UID,PPIP,C 与 STIME 栏位。</li><li>f 用 ASCII 字符显示树状结构，表达程序间的相互关系。</li><li>-g&lt;群组名称&gt; 此参数的效果和指定”-G”参数相同，当亦能使用阶段作业领导<br>者的名称来指定。</li><li>g 显示现行终端机下的所有程序，包括群组领导者的程序。</li><li>-G&lt;群组识别码&gt; 列出属于该群组的程序的状况，也可使用群组名称来指<br>定。</li><li>h 不显示标题列。</li><li>-H 显示树状结构，表示程序间的相互关系。</li><li>-j 或 j 采用工作控制的格式显示程序状况。</li><li>-l 或 l 采用详细的格式来显示程序状况。</li><li>L 列出栏位的相关信息。</li><li>-m 或 m 显示所有的执行绪。</li><li>n 以数字来表示 USER 和 WCHAN 栏位。</li><li>-N 显示所有的程序，除了执行 ps 指令终端机下的程序之外。</li><li>-p&lt;程序识别码&gt; 指定程序识别码，并列出该程序的状况。</li><li>p&lt;程序识别码&gt; 此参数的效果和指定”-p”参数相同，只在列表格式方面稍有<br>差异。</li><li>r 只列出现行终端机正在执行中的程序。</li><li>-s&lt;阶段作业&gt; 指定阶段作业的程序识别码，并列出隶属该阶段作业的程序的<br>状况。</li><li>s 采用程序信号的格式显示程序状况。</li><li>S 列出程序时，包括已中断的子程序资料。</li><li>-t&lt;终端机编号&gt; 指定终端机编号，并列出属于该终端机的程序的状况。</li><li>t&lt;终端机编号&gt; 此参数的效果和指定”-t”参数相同，只在列表格式方面稍有差<br>异。</li><li>-T 显示现行终端机下的所有程序。</li><li>-u&lt;用户识别码&gt; 此参数的效果和指定”-U”参数相同。</li><li>u 以用户为主的格式来显示程序状况。</li><li>-U&lt;用户识别码&gt; 列出属于该用户的程序的状况，也可使用用户名称来指<br>定。</li><li>U&lt;用户名称&gt; 列出属于该用户的程序的状况。</li><li>v 采用虚拟内存的格式显示程序状况。</li><li>-V 或 V 显示版本信息。</li><li>-w 或 w 采用宽阔的格式来显示程序状况。</li><li>x 显示所有程序，不以终端机来区分。</li><li>X 采用旧式的 Linux i386 登陆格式显示程序状况。</li><li>-y 配合参数”-l”使用时，不显示 F(flag)栏位，并以 RSS 栏位取代 ADDR 栏<br>位 。</li><li>-&lt;程序识别码&gt; 此参数的效果和指定”p”参数相同。</li><li>–cols&lt;每列字符数&gt; 设置每列的最大字符数。</li><li>–columns&lt;每列字符数&gt; 此参数的效果和指定”–cols”参数相同。<br>13</li><li>–cumulative 此参数的效果和指定”S”参数相同。</li><li>–deselect 此参数的效果和指定”-N”参数相同。</li><li>–forest 此参数的效果和指定”f”参数相同。</li><li>–headers 重复显示标题列。</li><li>–help 在线帮助。</li><li>–info 显示排错信息。</li><li>–lines&lt;显示列数&gt; 设置显示画面的列数。</li><li>–no-headers 此参数的效果和指定”h”参数相同，只在列表格式方面稍有差<br>异。</li><li>–group&lt;群组名称&gt; 此参数的效果和指定”-G”参数相同。</li><li>–Group&lt;群组识别码&gt; 此参数的效果和指定”-G”参数相同。</li><li>–pid&lt;程序识别码&gt; 此参数的效果和指定”-p”参数相同。</li><li>–rows&lt;显示列数&gt; 此参数的效果和指定”–lines”参数相同。</li><li>–sid&lt;阶段作业&gt; 此参数的效果和指定”-s”参数相同。</li><li>–tty&lt;终端机编号&gt; 此参数的效果和指定”-t”参数相同。</li><li>–user&lt;用户名称&gt; 此参数的效果和指定”-U”参数相同。</li><li>–User&lt;用户识别码&gt; 此参数的效果和指定”-U”参数相同。</li><li>–version 此参数的效果和指定”-V”参数相同。</li><li>–widty&lt;每列字符数&gt; 此参数的效果和指定”-cols”参数相同。</li></ul><h3 id="pstree-process-status-tree"><a href="#pstree-process-status-tree" class="headerlink" title="pstree(process status tree)"></a>pstree(process status tree)</h3><p><strong>功能说明</strong>：以树状图显示程序。<br><strong>语 法</strong>：pstree [-acGhlnpuUV][-H &lt;程序识别码&gt;][&lt;程序识别码&gt;/&lt;用户名称&gt;]<br><strong>补充说明</strong>：pstree 指令用 ASCII 字符显示树状结构，清楚地表达程序间的相互关<br>系。如果不指定程序识别码或用户名称，则会把系统启动时的第一个程序视为基<br>层，并显示之后的所有程序。若指定用户名称，便会以隶属该用户的第一个程序<br>当作基层，然后显示该用户的所有程序。<br><strong>参 数</strong>：</p><ul><li>-a 显示每个程序的完整指令，包含路径，参数或是常驻服务的标示。</li><li>-c 不使用精简标示法。</li><li>-G 使用 VT100 终端机的列绘图字符。</li><li>-h 列出树状图时，特别标明现在执行的程序。</li><li>-H&lt;程序识别码&gt; 此参数的效果和指定”-h”参数类似，但特别标明指定的程<br>序。</li><li>-l 采用长列格式显示树状图。</li><li>-n 用程序识别码排序。预设是以程序名称来排序。</li><li>-p 显示程序识别码。</li><li>-u 显示用户名称。</li><li>-U 使用 UTF-8 列绘图字符。</li><li>-V 显示版本信息。</li></ul><h3 id="su-super-user"><a href="#su-super-user" class="headerlink" title="su(super user)"></a>su(super user)</h3><p><strong>功能说明</strong>：变更用户身份。<br><strong>语 法</strong>：su [-flmp][–help][–version][-][-c &lt;指令&gt;][-s<shell>][用户帐号]<br><strong>补充说明</strong>：su 可让用户暂时变更登入的身份。变更时须输入所要变更的用户帐<br>号与密码。<br><strong>参 数</strong>：</shell></p><ul><li>-c&lt;指令&gt;或–command=&lt;指令&gt; 执行完指定的指令后，即恢复原来的身份。</li><li>-f 或–fast 适用于 csh 与 tsch，使 shell 不用去读取启动文件。</li><li>-.-l 或 –login 改变身份时，也同时变更工作目录，以及HOME,SHELL,USER,LOGNAME。此外，也会变更 PATH 变量。</li><li>-m,-p 或–preserve-environment 变更身份时，不要变更环境变量。</li><li>-s<shell>或–shell=<shell>指定要执行的 shell。</shell></shell></li><li>–help 显示帮助。</li><li>–version 显示版本信息。<br>[用户帐号] 指定要变更的用户。若不指定此参数，则预设变更为 root。</li></ul><h3 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h3><p><strong>功能说明：以其他身份来执行指令。</strong><br><strong>语 法</strong>：sudo [-bhHpV][-s<shell>][-u &lt;用户&gt;][指令] 或 sudo [-klv]<br><strong>补充说明</strong>：sudo 可让用户以其他的身份来执行指定的指令，预设的身份为 root。<br>在/etc/sudoers 中设置了可执行 sudo 指令的用户。若其未经授权的用户企图使用<br>sudo，则会发出警告的邮件给管理员。用户使用 sudo 时，必须先输入密码，之<br>后有 5 分钟的有效期限，超过期限则必须重新输入密码。<br><strong>参 数</strong>：</shell></p><ul><li>-b 在后台执行指令。</li><li>-h 显示帮助。</li><li>-H 将 HOME 环境变量设为新身份的 HOME 环境变量。</li><li>-k 结束密码的有效期限，也就是下次再执行 sudo 时便需要输入密码。</li><li>-l 列出目前用户可执行与无法执行的指令。</li><li>-p 改变询问密码的提示符号。</li><li>-s<shell>执行指定的 shell。</shell></li><li>-u&lt;用户&gt; 以指定的用户作为新的身份。若不加上此参数，则预设以 root 作<br>为新的身份。</li><li>-v 延长密码有效期限 5 分钟。</li><li>-V 显示版本信息。</li></ul><h3 id="uname"><a href="#uname" class="headerlink" title="uname"></a>uname</h3><p><strong>功能说明</strong>：显示系统信息。<br><strong>语 法</strong>：uname [-amnrsv][–help][–version]<br><strong>补充说明</strong>：uname 可显示电脑以及操作系统的相关信息。<br><strong>参 数</strong>：</p><ul><li>-a 或–all 显示全部的信息。</li><li>-m 或–machine 显示电脑类型。</li><li>-n 或-nodename 显示在网络上的主机名称。</li><li>-r 或–release 显示操作系统的发行编号。</li><li>-s 或–sysname 显示操作系统名称。</li><li>-v 显示操作系统的版本。</li><li>–help 显示帮助。</li><li><p>–version 显示版本信息。<br>###　useradd<br><strong>功能说明</strong>：建立用户帐号。<br><strong>语 法</strong>：useradd [-mMnr][-c &lt;备注&gt;][-d &lt;登入目录&gt;][-e &lt;有效期限&gt;][-f &lt;缓冲<br>天 数 &gt;][-g &lt; 群 组 &gt;][-G &lt; 群 组 &gt;][-s<shell>][-u<uid>][ 用户帐<br>号] 或 useradd -D [-b][-e &lt; 有效期限&gt;][-f &lt; 缓冲天数&gt;][-g &lt; 群组&gt;][-G &lt; 群组&gt;][-s<shell>]<br><strong>补充说明</strong>：useradd 可用来建立用户帐号。帐号建好之后，再用 passwd 设定帐号<br>的密码．而可用 userdel 删除帐号。使用 useradd 指令所建立的帐号，实际上是保<br>存在/etc/passwd 文本文件中。<br><strong>参 数</strong>：</shell></uid></shell></p></li><li><p>-c&lt;备注&gt; 加上备注文字。备注文字会保存在 passwd 的备注栏位中。</p></li><li>-d&lt;登入目录&gt; 指定用户登入时的启始目录。</li><li>-D 变更预设值．</li><li>-e&lt;有效期限&gt; 指定帐号的有效期限。</li><li>-f&lt;缓冲天数&gt; 指定在密码过期后多少天即关闭该帐号。</li><li>-g&lt;群组&gt; 指定用户所属的群组。</li><li>-G&lt;群组&gt; 指定用户所属的附加群组。</li><li>-m 自动建立用户的登入目录。</li><li>-M 不要自动建立用户的登入目录。</li><li>-n 取消建立以用户名称为名的群组．</li><li>-r 建立系统帐号。</li><li>-s<shell>指定用户登入后所使用的 shell。</shell></li><li>-u<uid>指定用户 ID。</uid></li></ul><h3 id="who"><a href="#who" class="headerlink" title="who"></a>who</h3><p><strong>功能说明</strong>：显示目前登入系统的用户信息。<br><strong>语 法</strong>：who [-Himqsw][–help][–version][am i][记录文件]<br><strong>补充说明</strong>：执行这项指令可得知目前有那些用户登入系统，单独执行 who 指令<br>会列出登入帐号，使用的 终端机，登入时间以及从何处登入或正在使用哪个 X<br>显示器。<br><strong>参 数</strong>：</p><ul><li>-H 或–heading 显示各栏位的标题信息列。</li><li>-i 或-u 或–idle 显示闲置时间，若该用户在前一分钟之内有进行任何动作，<br>将标示成”.”号，如果该用户已超过 24小时没有任何动作，则标示出”old”字符串。</li><li>-m 此参数的效果和指定”am i”字符串相同。</li><li>-q 或–count 只显示登入系统的帐号名称和总人数。</li><li>-s 此参数将忽略不予处理，仅负责解决 who 指令其他版本的兼容性问题。</li><li>-w 或-T 或–mesg 或–message 或–writable 显示用户的信息状态栏。</li><li>–help 在线帮助。</li><li>–version 显示版本信息。</li></ul><h2 id="linux-系统设置命令"><a href="#linux-系统设置命令" class="headerlink" title="linux 系统设置命令"></a>linux 系统设置命令</h2><h3 id="crontab"><a href="#crontab" class="headerlink" title="crontab"></a>crontab</h3><p><strong>功能说明</strong>：设置计时器。<br><strong>语 法</strong>：crontab [-u &lt;用户名称&gt;][配置文件] 或 crontab [-u &lt;用户名称&gt;][-elr]<br><strong>补充说明</strong>：cron 是一个常驻服务，它提供计时器的功能，让用户在特定的时间得<br>以执行预设的指令或程序。只要用户会编辑计时器的配置文件，就可以使用计时<br>器的功能。其配置文件格式如下：<br>Minute Hour Day Month DayOFWeek Command<br><strong>参 数</strong>：</p><ul><li>-e 编辑该用户的计时器设置。</li><li>-l 列出该用户的计时器设置。</li><li>-r 删除该用户的计时器设置。</li><li>-u&lt;用户名称&gt; 指定要设定计时器的用户名称。</li></ul><h3 id="dircolors"><a href="#dircolors" class="headerlink" title="dircolors"></a>dircolors</h3><p><strong>功能说明</strong>：设置 ls 指令在显示目录或文件时所用的色彩。<br><strong>语 法</strong>：dircolors [色彩配置文件] 或 dircolors [-bcp][–help][–version]<br><strong>补充说明</strong>：dircolors 可根据[色彩配置文件]来设置 LS_COLORS 环境变量或是显<br>示设置 LS_COLORS 环境变量的 shell 指令。<br><strong>参 数</strong>：</p><ul><li>-b 或–sh 或–bourne-shell 显示在 Boume shell 中，将 LS_COLORS 设为目前<br>预设置的 shell 指令。</li><li>-c 或–csh 或–c-shell 显示在 C shell 中，将 LS_COLORS 设为目前预设置的<br>shell 指令。</li><li>-p 或–print-database 显示预设置</li><li>-help 显示帮助。</li><li>-version 显示版本信息。</li></ul><h3 id="rpm-redhat-package-manager"><a href="#rpm-redhat-package-manager" class="headerlink" title="rpm(redhat package manager)"></a>rpm(redhat package manager)</h3><p><strong>功能说明</strong>：管理套件。<br><strong>补充说明</strong>：rmp 原本是 Red Hat Linux 发行版专门用来管理 Linux 各项套件的程<br>序，由于它遵循 GPL 规则且功能强大方便，因而广受欢迎。逐渐受到其他发行<br>版的采用。RPM 套件管理方式的出现，让 Linux 易于安装，升级，间接提升了<br>Linux 的适用度。<br><strong>参 数</strong>：省略。</p><h2 id="linux-文档编辑命令"><a href="#linux-文档编辑命令" class="headerlink" title="linux 文档编辑命令"></a>linux 文档编辑命令</h2><h3 id="comm-common"><a href="#comm-common" class="headerlink" title="comm(common)"></a>comm(common)</h3><p><strong>功能说明</strong>：比较两个已排过序的文件。<br><strong>语 法</strong>：comm [-123][–help][–version][第 1 个文件][第 2 个文件]<br><strong>补充说明</strong>：这项指令会一列列地比较两个已排序文件的差异，并将其结果显示出<br>来，如果没有指定任何参数，则会把结果分成 3 行显示：第 1 行仅是在第 1 个文<br>件中出现过的列，第 2 行是仅在第 2 个文件中出现过的列，第 3 行则是在第 1<br>与第 2 个文件里都出现过的列。若给予的文件名称为”-“，则 comm 指令会从标<br>准输入设备读取数据。<br><strong>参 数</strong>：</p><ul><li>-1 不显示只在第 1 个文件里出现过的列。</li><li>-2 不显示只在第 2 个文件里出现过的列。</li><li>-3 不显示只在第 1 和第 2 个文件里出现过的列。</li><li>–help 在线帮助。</li><li>–version 显示版本信息。</li></ul><h3 id="egrep"><a href="#egrep" class="headerlink" title="egrep"></a>egrep</h3><p><strong>功能说明</strong>：在文件内查找指定的字符串。egrep 执行效果如 grep -E，使用的语法<br>及参数可参照 grep 指令，与 grep 不同点在于解读字符串的方法，egrep 是用<br>extended regular expression 语法来解读，而 grep 则用 basic regular expression 语法，extended regular expression 比 basic regular expression 有更完整的表达规范。</p><h3 id="fgrep-fixed-regexp"><a href="#fgrep-fixed-regexp" class="headerlink" title="fgrep(fixed regexp)"></a>fgrep(fixed regexp)</h3><p><strong>功能说明</strong>：查找文件里符合条件的字符串。<br><strong>语 法</strong>：fgrep [范本样式][文件或目录…]<br><strong>补充说明</strong>：本指令相当于执行 grep 指令加上参数”-F”，详见 grep 指令说明。</p><h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><p><strong>功能说明</strong>：查找文件里符合条件的字符串。<br><strong>语 法</strong>：grep [-abcEFGhHilLnqrsvVwxy][-A&lt;显示列数&gt;][-B&lt;显示列数&gt;][-C&lt;<br>显示列数&gt;][-d&lt;进行动作&gt;][-e&lt;范本样式&gt;][-f&lt;范本文件&gt;][–help][范本样式][文件<br>或目录…]<br><strong>补充说明</strong>：grep 指令用于查找内容包含指定的范本样式的文件，如果发现某文件<br>的内容符合所指定的范本样式，预设 grep 指令会把含有范本样式的那一列显示<br>出来。若不指定任何文件名称，或是所给予的文件名为“-”，则 grep 指令会从标<br>准输入设备读取数据。<br><strong>参 数</strong>：</p><ul><li>-a 或–text 不要忽略二进制的数据。</li><li>-A&lt;显示列数&gt;或–after-context=&lt;显示列数&gt; 除了显示符合范本样式的那一列<br>之外，并显示该列之后的内容。</li><li>-b 或–byte-offset 在显示符合范本样式的那一列之前，标示出该列第一个字符<br>的位编号。</li><li>-B&lt;显示列数&gt;或–before-context=&lt;显示列数&gt; 除了显示符合范本样式的那一列<br>之外，并显示该列之前的内容。</li><li>-c 或–count 计算符合范本样式的列数。</li><li>-C&lt;显示列数&gt;或–context=&lt;显示列数&gt;或-&lt;显示列数&gt; 除了显示符合范本样式<br>的那一列之外，并显示该列之前后的内容。</li><li>-d&lt;进行动作&gt;或–directories=&lt;进行动作&gt; 当指定要查找的是目录而非文件时，<br>必须使用这项参数，否则 grep 指令将回报信息并停止动作。</li><li>-e&lt;范本样式&gt;或–regexp=&lt;范本样式&gt; 指定字符串做为查找文件内容的范本样<br>式。</li><li>-E 或–extended-regexp 将范本样式为延伸的普通表示法来使用。</li><li>-f&lt;范本文件&gt;或–file=&lt;范本文件&gt; 指定范本文件，其内容含有一个或多个范本<br>样式，让 grep 查找符合范本条件的文件内容，格式为每列一个范本样式。</li><li>-F 或–fixed-regexp 将范本样式视为固定字符串的列表。</li><li>-G 或–basic-regexp 将范本样式视为普通的表示法来使用。</li><li>-h 或–no-filename 在显示符合范本样式的那一列之前，不标示该列所属的文件<br>名称。</li><li>-H 或–with-filename 在显示符合范本样式的那一列之前，表示该列所属的文件<br>名称。</li><li>-i 或–ignore-case 忽略字符大小写的差别。<br>56</li><li>-l 或–file-with-matches 列出文件内容符合指定的范本样式的文件名称。</li><li>-L 或–files-without-match 列出文件内容不符合指定的范本样式的文件名称。</li><li>-n 或–line-number 在显示符合范本样式的那一列之前，标示出该列的列数编<br>号。</li><li>-q 或–quiet 或–silent 不显示任何信息。</li><li>-r 或–recursive 此参数的效果和指定“-d recurse”参数相同。</li><li>-s 或–no-messages 不显示错误信息。</li><li>-v 或–revert-match 反转查找。</li><li>-V 或–version 显示版本信息。</li><li>-w 或–word-regexp 只显示全字符合的列。</li><li>-x 或–line-regexp 只显示全列符合的列。</li><li>-y 此参数的效果和指定“-i”参数相同。</li><li>–help 在线帮助。</li></ul><h3 id="look"><a href="#look" class="headerlink" title="look"></a>look</h3><p><strong>功能说明</strong>：查询单字。<br><strong>语 法</strong>：look [-adf][-t&lt;字尾字符串&gt;][字首字符串][字典文件]<br><strong>补充说明</strong>：look 指令用于英文单字的查询。您仅需给予它欲查询的字首字符串，<br>它会显示所有开头字符串符合该条件的单字。<br><strong>参 数</strong>：</p><ul><li>-a 使用另一个字典文件 web2，该文件也位于/usr/dict 目录下。</li><li>-d 只对比英文字母和数字，其余一慨忽略不予比对。</li><li>-f 忽略字符大小写差别。</li><li>-t&lt;字尾字符串&gt; 设置字尾字符串。</li></ul><h3 id="wc-word-count"><a href="#wc-word-count" class="headerlink" title="wc(word count)"></a>wc(word count)</h3><p><strong>功能说明</strong>：计算字数。<br><strong>语 法</strong>：wc [-clw][–help][–version][文件…]<br><strong>补充说明</strong>：利用 wc 指令我们可以计算文件的 Byte 数、字数、或是列数，若不指<br>定文件名称、或是所给予的文件名为“-”，则 wc 指令会从标准输入设备读取数据。<br><strong>参 数</strong>：</p><ul><li>-c 或–bytes 或–chars 只显示 Bytes 数。</li><li>-l 或–lines 只显示列数。</li><li>-w 或–words 只显示字数。</li><li>–help 在线帮助。</li><li>–version 显示版本信息。</li></ul><h2 id="linux-压缩备份命令"><a href="#linux-压缩备份命令" class="headerlink" title="linux 压缩备份命令"></a>linux 压缩备份命令</h2><h3 id="gunzip-gnu-unzip"><a href="#gunzip-gnu-unzip" class="headerlink" title="gunzip(gnu unzip)"></a>gunzip(gnu unzip)</h3><p><strong>功能说明</strong>：解压文件。<br><strong>语 法</strong>： gunzip [-acfhlLnNqrtvV][-s &lt; 压缩字尾字符串 &gt;][ 文<br>件…] 或 gunzip [-acfhlLnNqrtvV][-s &lt;压缩字尾字符串&gt;][目录]<br><strong>补充说明</strong>：gunzip 是个使用广泛的解压缩程序，它用于解开被 gzip 压缩过的文件，这些<br>压缩文件预设最后的扩展名为”.gz”。事实上 gunzip 就是 gzip 的硬连接，因此不论是压缩<br>或解压缩，都可通过 gzip 指令单独完成。<br><strong>参 数</strong>：</p><ul><li>-a 或–ascii 使用 ASCII 文字模式。</li><li>-c 或–stdout 或–to-stdout 把解压后的文件输出到标准输出设备。</li><li>-f 或-force 强行解开压缩文件，不理会文件名称或硬连接是否存在以及该文件是否为<br>符号连接。</li><li>-h 或–help 在线帮助。</li><li>-l 或–list 列出压缩文件的相关信息。</li><li>-L 或–license 显示版本与版权信息。</li><li>-n 或–no-name 解压缩时，若压缩文件内含有远来的文件名称及时间戳记，则将其忽<br>略不予处理。</li><li>-N 或–name 解压缩时，若压缩文件内含有原来的文件名称及时间戳记，则将其回存到<br>解开的文件上。</li><li>-q 或–quiet 不显示警告信息。</li><li>-r 或–recursive 递归处理，将指定目录下的所有文件及子目录一并处理。</li><li>-S&lt;压缩字尾字符串&gt;或–suffix&lt;压缩字尾字符串&gt; 更改压缩字尾字符串。</li><li>-t 或–test 测试压缩文件是否正确无误。</li><li>-v 或–verbose 显示指令执行过程。</li><li>-V 或–version 显示版本信息。</li></ul><h3 id="gzexe-gzip-executable"><a href="#gzexe-gzip-executable" class="headerlink" title="gzexe(gzip executable)"></a>gzexe(gzip executable)</h3><p><strong>功能说明</strong>：压缩执行文件。<br><strong>语 法</strong>：gzexe [-d][执行文件…]<br><strong>补充说明</strong>：gzexe 是用来压缩执行文件的程序。当您去执行被压缩过的执行文件时，该文件会自动解压然后继续执行，和使用一般的执行文件相同。<br><strong>参 数</strong>：</p><ul><li>-d 解开压缩文件。</li></ul><h3 id="gzip-gnu-zip"><a href="#gzip-gnu-zip" class="headerlink" title="gzip(gnu zip)"></a>gzip(gnu zip)</h3><p><strong>功能说明</strong>：压缩文件。<br><strong>语 法</strong>： gzip [-acdfhlLnNqrtvV][-S &lt; 压缩字尾字符串 &gt;][-&lt; 压缩效率&gt;][–best/fast][文件…] 或 gzip [-acdfhlLnNqrtvV][-S &lt;压缩字尾字符串&gt;][-&lt;压缩效率&gt;][–best/fast][目录]<br><strong>补充说明</strong>：gzip 是个使用广泛的压缩程序，文件经它压缩过后，其名称后面会多出”.gz”的扩展名。<br><strong>参 数</strong>：</p><ul><li>-a 或–ascii 使用 ASCII 文字模式。</li><li>-c 或–stdout 或–to-stdout 把压缩后的文件输出到标准输出设备，不去更动原始文件。</li><li>-d 或–decompress 或—-uncompress 解开压缩文件。</li><li>-f 或–force 强行压缩文件。不理会文件名称或硬连接是否存在以及该文件是否为符号<br>连接。</li><li>-h 或–help 在线帮助。</li><li>-l 或–list 列出压缩文件的相关信息。</li><li>-L 或–license 显示版本与版权信息。</li><li>-n 或–no-name 压缩文件时，不保存原来的文件名称及时间戳记。</li><li>-N 或–name 压缩文件时，保存原来的文件名称及时间戳记。</li><li>-q 或–quiet 不显示警告信息。</li><li>-r 或–recursive 递归处理，将指定目录下的所有文件及子目录一并处理。</li><li>-S&lt;压缩字尾字符串&gt;或—-suffix&lt;压缩字尾字符串&gt; 更改压缩字尾字符串。</li><li>-t 或–test 测试压缩文件是否正确无误。</li><li>-v 或–verbose 显示指令执行过程。</li><li>-V 或–version 显示版本信息。</li><li>-&lt;压缩效率&gt; 压缩效率是一个介于 1－9 的数值，预设值为”6”，指定愈大的数值，压<br>缩效率就会愈高。</li><li>–best 此参数的效果和指定”-9”参数相同。</li><li>–fast 此参数的效果和指定”-1”参数相同。</li></ul><h3 id="tar-tape-archive"><a href="#tar-tape-archive" class="headerlink" title="tar(tape archive)"></a>tar(tape archive)</h3><p><strong>功能说明</strong>：备份文件。<br><strong>语 法</strong>：tar [-ABcdgGhiklmMoOpPrRsStuUvwWxzZ][-b &lt;区块数目&gt;][-C &lt;目的目<br>录&gt;][-f &lt;备份文件&gt;][-F &lt;Script文件&gt;][-K &lt;文件&gt;][-L &lt;媒体容量&gt;][-N &lt;日期时间&gt;][-T &lt; 范本文件 &gt;][-V &lt; 卷册名称 &gt;][-X &lt; 范本文件 &gt;][-&lt; 设备编号 &gt;&lt; 存储密度&gt;][–after-date=&lt; 日期时间 &gt;][–atime-preserve][–backuup=&lt; 备份方式&gt;][–checkpoint][–concatenate][–confirmation][–delete][–exclude=&lt; 范本样式&gt;][–force-local][–group=&lt; 群组名称&gt;][–help][–ignore-failed-read][–new-volume-script=&lt;Script文件&gt;][–newer-mtime][–no-recursion][–null][–numeric-owner][–owner=&lt; 用户名称&gt;][–posix][–erve][–preserve-order][–preserve-permissions][–record-size=&lt;区块数目&gt;][–recursive-unlink][–remove-files][–rsh-command=&lt; 执行指令&gt;][–same-owner][–suffix=&lt;备份字尾字符串&gt;][–totals][–use-compress-program=&lt;执行指令&gt;][–version][–volno-file=&lt;编号文件&gt;][文件或目录…]<br><strong>补充说明</strong>：tar 是用来建立，还原备份文件的工具程序，它可以加入，解开备份文件内的文件。<br><strong>参数</strong>：</p><ul><li>-A 或–catenate 新增温暖件到已存在的备份文件。</li><li>-b&lt;区块数目&gt;或–blocking-factor=&lt;区块数目&gt; 设置每笔记录的区块数目，每个区块大小为 12Bytes。</li><li>-B 或–read-full-records 读取数据时重设区块大小。</li><li>-c 或–create 建立新的备份文件。</li><li>-C&lt;目的目录&gt;或–directory=&lt;目的目录&gt; 切换到指定的目录。</li><li>-d 或–diff 或–compare 对比备份文件内和文件系统上的文件的差异。</li><li>-f&lt;备份文件&gt;或–file=&lt;备份文件&gt; 指定备份文件。</li><li>-F&lt;Script文件&gt;或–info-script=&lt;Script文件&gt; 每次更换磁带时，就执行指定的 Script文件。</li><li><ul><li>-g 或–listed-incremental 处理 GNU 格式的大量备份。</li></ul></li><li>-G 或–incremental 处理旧的 GNU 格式的大量备份。</li><li>-h 或–dereference 不建立符号连接，直接复制该连接所指向的原始文件。</li><li>-i 或–ignore-zeros 忽略备份文件中的 0 Byte 区块，也就是 EOF。</li><li>-k 或–keep-old-files 解开备份文件时，不覆盖已有的文件。</li><li>-K&lt;文件&gt;或–starting-file=&lt;文件&gt; 从指定的文件开始还原。</li><li>-l 或–one-file-system 复制的文件或目录存放的文件系统，必须与 tar 指令执行时所处的<br>文件系统相同，否则不予复制。</li><li>-L&lt;媒体容量&gt;或-tape-length=&lt;媒体容量&gt; 设置存放每体的容量，单位以 1024 Bytes<br>计算。</li><li>-m 或–modification-time 还原文件时，不变更文件的更改时间。</li><li>-M 或–multi-volume 在建立，还原备份文件或列出其中的内容时，采用多卷册模式。</li><li>-N&lt;日期格式&gt;或–newer=&lt;日期时间&gt; 只将较指定日期更新的文件保存到备份文件里。</li><li>-o 或–old-archive 或–portability 将资料写入备份文件时使用 V7 格式。</li><li>-O 或–stdout 把从备份文件里还原的文件输出到标准输出设备。</li><li>-p 或–same-permissions 用原来的文件权限还原文件。</li><li>-P 或–absolute-names 文件名使用绝对名称，不移除文件名称前的”/“号。</li><li>-r 或–append 新增文件到已存在的备份文件的结尾部分。</li><li>-R 或–block-number 列出每个信息在备份文件中的区块编号。</li><li>-s 或–same-order 还原文件的顺序和备份文件内的存放顺序相同。</li><li>-S 或–sparse 倘若一个文件内含大量的连续 0 字节，则将此文件存成稀疏文件。</li><li>-t 或–list 列出备份文件的内容。</li><li>-T&lt;范本文件&gt;或–files-from=&lt;范本文件&gt;指定范本文件，其内含有一个或多个范本样<br>式，让 tar 解开或建立符合设置条件的文件。</li><li>-u 或–update 仅置换较备份文件内的文件更新的文件。</li><li>-U 或–unlink-first 解开压缩文件还原文件之前，先解除文件的连接。</li><li>-v 或–verbose 显示指令执行过程。</li><li>-V&lt;卷册名称&gt;或–label=&lt;卷册名称&gt; 建立使用指定的卷册名称的备份文件。</li><li>-w 或–interactive 遭遇问题时先询问用户。</li><li>-W 或–verify 写入备份文件后，确认文件正确无误。</li><li>-x 或–extract 或–get 从备份文件中还原文件。</li><li>-X&lt;范本文件&gt;或–exclude-from=&lt;范本文件&gt; 指定范本文件，其内含有一个或多个范本样式，让 ar 排除符合设置条件的文件。</li><li>-z 或–gzip 或–ungzip 通过 gzip 指令处理备份文件。</li><li>-Z 或–compress 或–uncompress 通过 compress 指令处理备份文件。</li><li>-&lt;设备编号&gt;&lt;存储密度&gt; 设置备份用的外围设备编号及存放数据的密度。</li><li>–after-date=&lt;日期时间&gt; 此参数的效果和指定”-N”参数相同。</li><li>–atime-preserve 不变更文件的存取时间。</li><li>–backup=&lt;备份方式&gt;或–backup 移除文件前先进行备份。</li><li>–checkpoint 读取备份文件时列出目录名称。</li><li>–concatenate 此参数的效果和指定”-A”参数相同。</li><li>–confirmation 此参数的效果和指定”-w”参数相同。</li><li>–delete 从备份文件中删除指定的文件。</li><li>–exclude=&lt;范本样式&gt; 排除符合范本样式的问家。</li><li>–group=&lt;群组名称&gt; 把加入设备文件中的文件的所属群组设成指定的群组。</li><li>–help 在线帮助。</li><li>–ignore-failed-read 忽略数据读取错误，不中断程序的执行。</li><li>–new-volume-script=&lt;Script文件&gt; 此参数的效果和指定”-F”参数相同。</li><li>–newer-mtime 只保存更改过的文件。</li><li>–no-recursion 不做递归处理，也就是指定目录下的所有文件及子目录不予处理。</li><li>–null 从 null 设备读取文件名称。</li><li>–numeric-owner 以用户识别码及群组识别码取代用户名称和群组名称。</li><li>–owner=&lt;用户名称&gt; 把加入备份文件中的文件的拥有者设成指定的用户。</li><li>–posix 将数据写入备份文件时使用 POSIX 格式。</li><li>–preserve 此参数的效果和指定”-ps”参数相同。</li><li>–preserve-order 此参数的效果和指定”-A”参数相同。</li><li>–preserve-permissions 此参数的效果和指定”-p”参数相同。</li><li>–record-size=&lt;区块数目&gt; 此参数的效果和指定”-b”参数相同。</li><li>–recursive-unlink　解开压缩文件还原目录之前，先解除整个目录下所有文件的连接。</li><li>–remove-files 文件加入备份文件后，就将其删除。</li><li>–rsh-command=&lt;执行指令&gt; 设置要在远端主机上执行的指令，以取代 rsh 指令。</li><li>–same-owner 尝试以相同的文件拥有者还原问家你。</li><li>–suffix=&lt;备份字尾字符串&gt; 移除文件前先行备份。</li><li>–totals 备份文件建立后，列出文件大小。</li><li>–use-compress-program=&lt;执行指令&gt; 通过指定的指令处理备份文件。</li><li>–version 显示版本信息。</li><li>–volno-file=&lt;编号文件&gt; 使用指定文件内的编号取代预设的卷册编号。</li></ul><h3 id="unarj"><a href="#unarj" class="headerlink" title="unarj"></a>unarj</h3><p><strong>功能说明</strong>：解压缩.arj 文件。<br><strong>语 法</strong>：unarj [eltx][.arj 压缩文件]<br><strong>补充说明</strong>：unarj 为.arj 压缩文件的压缩程序。<br><strong>参 数</strong>：</p><ul><li>e 解压缩.arj 文件。</li><li>l 显示压缩文件内所包含的文件。</li><li>t 检查压缩文件是否正确。</li><li>x 解压缩时保留原有的路径。</li></ul><h3 id="unzip"><a href="#unzip" class="headerlink" title="unzip"></a>unzip</h3><p><strong>功能说明</strong>：解压缩 zip 文件<br><strong>语 法</strong>：unzip [-cflptuvz][-agCjLMnoqsVX][-P &lt;密码&gt;][.zip 文件][文件][-d &lt;目录&gt;][-x &lt;文件&gt;] 或 unzip [-Z]<br><strong>补充说明</strong>：unzip 为.zip 压缩文件的解压缩程序。<br><strong>参 数</strong>：</p><ul><li>-c 将解压缩的结果显示到屏幕上，并对字符做适当的转换。</li><li>-f 更新现有的文件。</li><li>-l 显示压缩文件内所包含的文件。</li><li>-p 与-c 参数类似，会将解压缩的结果显示到屏幕上，但不会执行任何的转换。</li><li>-t 检查压缩文件是否正确。</li><li>-u 与-f 参数类似，但是除了更新现有的文件外，也会将压缩文件中的其他文件解压缩到目录中。</li><li>-v 执行是时显示详细的信息。</li><li>-z 仅显示压缩文件的备注文字。</li><li>-a 对文本文件进行必要的字符转换。</li><li>-b 不要对文本文件进行字符转换。</li><li>-C 压缩文件中的文件名称区分大小写。</li><li>-j 不处理压缩文件中原有的目录路径。</li><li>-L 将压缩文件中的全部文件名改为小写。</li><li>-M 将输出结果送到 more 程序处理。</li><li>-n 解压缩时不要覆盖原有的文件。</li><li>-o 不必先询问用户，unzip 执行后覆盖原有文件。</li><li>-P&lt;密码&gt; 使用 zip 的密码选项。</li><li>-q 执行时不显示任何信息。</li><li>-s 将文件名中的空白字符转换为底线字符。</li><li>-V 保留 VMS 的文件版本信息。</li><li>-X 解压缩时同时回存文件原来的 UID/GID。<br>[.zip 文件] 指定.zip 压缩文件。<br>[文件] 指定要处理.zip 压缩文件中的哪些文件。</li><li>-d&lt;目录&gt; 指定文件解压缩后所要存储的目录。</li><li>-x&lt;文件&gt; 指定不要处理.zip 压缩文件中的哪些文件。</li><li>-Z unzip -Z 等于执行 zipinfo 指令。</li></ul><h3 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h3><p><strong>功能说明</strong>：压缩文件。<br><strong>语 法</strong>：zip [-AcdDfFghjJKlLmoqrSTuvVwXyz$][-b &lt;工作目录&gt;][-ll][-n &lt;字尾字<br>符串&gt;][-t &lt;日期时间&gt;][-&lt;压缩效率&gt;][压缩文件][文件…][-i &lt;范本样式&gt;][-x &lt;范本样式&gt;]<br><strong>补充说明</strong>：zip 是个使用广泛的压缩程序，文件经它压缩后会另外产生具有”.zip”扩展名的压缩文件。<br><strong>参 数</strong>：</p><ul><li>-A 调整可执行的自动解压缩文件。</li><li>-b&lt;工作目录&gt; 指定暂时存放文件的目录。</li><li>-c 替每个被压缩的文件加上注释。</li><li>-d 从压缩文件内删除指定的文件。</li><li>-D 压缩文件内不建立目录名称。</li><li>-f 此参数的效果和指定”-u”参数类似，但不仅更新既有文件，如果某些文件原本不存在于压缩文件内，使用本参数会一并将其加入压缩文件中。</li><li>-F 尝试修复已损坏的压缩文件。</li><li>-g 将文件压缩后附加在既有的压缩文件之后，而非另行建立新的压缩文件。</li><li>-h 在线帮助。</li><li>-i&lt;范本样式&gt; 只压缩符合条件的文件。</li><li>-j 只保存文件名称及其内容，而不存放任何目录名称。</li><li>-J 删除压缩文件前面不必要的数据。</li><li>-k 使用 MS-DOS 兼容格式的文件名称。</li><li>-l 压缩文件时，把 LF 字符置换成 LF+CR 字符。</li><li>-ll 压缩文件时，把 LF+CR 字符置换成 LF 字符。</li><li>-L 显示版权信息。</li><li>-m 将文件压缩并加入压缩文件后，删除原始文件，即把文件移到压缩文件中。</li><li>-n&lt;字尾字符串&gt; 不压缩具有特定字尾字符串的文件。</li><li>-o 以压缩文件内拥有最新更改时间的文件为准，将压缩文件的更改时间设成和该文件相同。</li><li>-q 不显示指令执行过程。</li><li>-r 递归处理，将指定目录下的所有文件和子目录一并处理。</li><li>-S 包含系统和隐藏文件。</li><li>-t&lt;日期时间&gt; 把压缩文件的日期设成指定的日期。</li><li>-T 检查备份文件内的每个文件是否正确无误。</li><li>-u 更换较新的文件到压缩文件内。</li><li>-v 显示指令执行过程或显示版本信息。</li><li>-V 保存 VMS 操作系统的文件属性。</li><li>-w 在文件名称里假如版本编号，本参数仅在 VMS 操作系统下有效。</li><li>-x&lt;范本样式&gt; 压缩时排除符合条件的文件。</li><li>-X 不保存额外的文件属性。</li><li>-y 直接保存符号连接，而非该连接所指向的文件，本参数仅在 UNIX 之类的系统下有效。</li><li>-z 替压缩文件加上注释。</li><li>-$ 保存第一个被压缩文件所在磁盘的卷册名称。</li><li>-&lt;压缩效率&gt; 压缩效率是一个介于 1-9 的数值。</li></ul><h2 id="linux-文件管理命令"><a href="#linux-文件管理命令" class="headerlink" title="linux 文件管理命令"></a>linux 文件管理命令</h2><h3 id="diff-differential"><a href="#diff-differential" class="headerlink" title="diff(differential)"></a>diff(differential)</h3><p><strong>功能说明</strong>：比较文件的差异。<br><strong>语 法</strong>：diff [-abBcdefHilnNpPqrstTuvwy][-&lt;行数&gt;][-C &lt;行数&gt;][-D &lt;巨集名称</p><blockquote><p>][-I &lt; 字符或字符串 &gt;][-S &lt; 文 件 &gt;][-W &lt; 宽 度 &gt;][-x &lt; 文件或目录 &gt;][-X &lt; 文 件&gt;][–help][–left-column][–suppress-common-line][文件或目录 1][文件或目录 2]<br><strong>补充说明</strong>：diff 以逐行的方式，比较文本文件的异同处。所是指定要比较目录，则 diff 会比较目录中相同文件名的文件，但不会比较其中子目录。<br><strong>参 数</strong>：</p></blockquote><ul><li>-&lt;行数&gt; 指定要显示多少行的文本。此参数必须与-c 或-u 参数一并使用。</li><li>-a 或–text diff 预设只会逐行比较文本文件。</li><li>-b 或–ignore-space-change 不检查空格字符的不同。</li><li>-B 或–ignore-blank-lines 不检查空白行。</li><li>-c 显示全部内文，并标出不同之处。</li><li>-C&lt;行数&gt;或–context&lt;行数&gt; 与执行”-c-&lt;行数&gt;”指令相同。</li><li>-d 或–minimal 使用不同的演算法，以较小的单位来做比较。</li><li>-D&lt;巨集名称&gt;或 ifdef&lt;巨集名称&gt; 此参数的输出格式可用于前置处理器巨集。</li><li>-e 或–ed 此参数的输出格式可用于 ed 的 script 文件。</li><li>-f 或-forward-ed 输出的格式类似 ed 的script文件，但按照原来文件的顺序来显示不同处。</li><li>-H 或–speed-large-files 比较大文件时，可加快速度。</li><li>-l&lt;字符或字符串&gt;或–ignore-matching-lines&lt;字符或字符串&gt; 若两个文件在某几行有<br>所不同，而这几行同时都包含了选项中指定的字符或字符串，则不显示这两个文件的差异。</li><li>-i 或–ignore-case 不检查大小写的不同。</li><li>-l 或–paginate 将结果交由 pr 程序来分页。</li><li>-n 或–rcs 将比较结果以 RCS 的格式来显示。</li><li>-N 或–new-file 在比较目录时，若文件 A 仅出现在某个目录中，预设会显示：<br>Only in 目录：文件 A 若使用-N 参数，则 diff 会将文件 A 与一个空白的文件比较。</li><li>-p 若比较的文件为 C 语言的程序码文件时，显示差异所在的函数名称。</li><li>-P 或–unidirectional-new-file 与-N 类似，但只有当第二个目录包含了一个第一个目<br>录所没有的文件时，才会将这个文件与空白的文件做比较。</li><li>-q 或–brief 仅显示有无差异，不显示详细的信息。</li><li>-r 或–recursive 比较子目录中的文件。</li><li>-s 或–report-identical-files 若没有发现任何差异，仍然显示信息。</li><li>-S&lt;文件&gt;或–starting-file&lt;文件&gt; 在比较目录时，从指定的文件开始比较。</li><li>-t 或–expand-tabs 在输出时，将 tab 字符展开。</li><li>-T 或–initial-tab 在每行前面加上 tab 字符以便对齐。</li><li>-u,-U&lt;列数&gt;或–unified=&lt;列数&gt; 以合并的方式来显示文件内容的不同。</li><li>-v 或–version 显示版本信息。</li><li>-w 或–ignore-all-space 忽略全部的空格字符。</li><li>-W&lt;宽度&gt;或–width&lt;宽度&gt; 在使用-y 参数时，指定栏宽。</li><li>-x&lt;文件名或目录&gt;或–exclude&lt;文件名或目录&gt; 不比较选项中所指定的文件或目录。</li><li>-X&lt;文件&gt;或–exclude-from&lt;文件&gt; 您可以将文件或目录类型存成文本文件，然后在<br>=&lt;文件&gt;中指定此文本文件。</li><li>-y 或–side-by-side 以并列的方式显示文件的异同之处。</li><li>–help 显示帮助。</li><li>–left-column 在使用-y 参数时，若两个文件某一行内容相同，则仅在左侧的栏位显示该行内容。</li><li>–suppress-common-lines 在使用-y 参数时，仅显示不同之处。</li></ul><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p><strong>功能说明</strong>：查找文件或目录。<br><strong>语 法</strong>：find [目录…][-amin &lt;分钟&gt;][-anewer &lt;参考文件或目录&gt;][-atime &lt;24小时数 &gt;][-cmin &lt; 分 钟 &gt;][-cnewer &lt; 参考文件或目录 &gt;][-ctime &lt;24小时数&gt;][-daystart][-depyh][-empty][-exec &lt; 执行指令 &gt;][-false][-fls &lt; 列表文件&gt;][-follow][-fprint &lt;列表文件&gt;][-fprint0 &lt;列表文件&gt;][-fprintf&lt;列表文件&gt;&lt;输出格式&gt;][-fstype &lt;文件系统类型&gt;][-gid &lt;群组识别码&gt;][-group &lt;群组名称&gt;][-help][-ilname &lt;<br>范本样式&gt;][-iname &lt;范本样式&gt;][-inum<inode 编号>][-ipath &lt;范本样式&gt;][-iregex &lt;范本样式 &gt;][-links &lt; 连接数目 &gt;][-lname &lt; 范本样式 &gt;][-ls][-maxdepth &lt; 目录层级&gt;][-mindepth &lt;目录层级&gt;][-mmin &lt;分钟&gt;][-mount]<br>[-mtime &lt;24小时数 &gt;][-name &lt; 范本样式 &gt;][-newer &lt; 参考文件或目录&gt;][-nogroup][noleaf] [-nouser][-ok &lt;执行指令&gt;][-path &lt;范本样式&gt;][-perm &lt;权限数值&gt;][-print][-print0][-printf &lt;输出格式&gt;][-prune][-regex &lt;范本样式&gt;][-size &lt;文件大小&gt;][-true][-type &lt;文件类型&gt;][-uid &lt;用户识别码&gt;][-used &lt;日数&gt;][-user &lt;拥有者名称&gt;][-version][-xdev][-xtype &lt;文件类型&gt;]<br><strong>补充说明</strong>：find 指令用于查找符合条件的文件。任何位于参数之前的字符串都将被视为欲查找的目录。<br><strong>参 数</strong>：</inode></p><ul><li>-amin&lt;分钟&gt; 查找在指定时间曾被存取过的文件或目录，单位以分钟计算。</li><li>-anewer&lt;参考文件或目录&gt; 查找其存取时间较指定文件或目录的存取时间更接近现在<br>的文件或目录。</li><li>-atime&lt;24小时数&gt; 查找在指定时间曾被存取过的文件或目录，单位以 24小时计算。</li><li>-cmin&lt;分钟&gt; 查找在指定时间之时被更改的文件或目录。</li><li>-cnewer&lt;参考文件或目录&gt; 查找其更改时间较指定文件或目录的更改时间更接近现在<br>的文件或目录。</li><li>-ctime&lt;24小时数&gt; 查找在指定时间之时被更改的文件或目录，单位以 24小时计算。</li><li>-daystart 从本日开始计算时间。</li><li>-depth 从指定目录下最深层的子目录开始查找。</li><li>-expty 寻找文件大小为 0 Byte 的文件，或目录下没有任何子目录或文件的空目录。</li><li>-exec&lt;执行指令&gt; 假设 find 指令的回传值为 True，就执行该指令。</li><li>-false 将 find 指令的回传值皆设为 False。</li><li>-fls&lt;列表文件&gt; 此参数的效果和指定”-ls”参数类似，但会把结果保存为指定的列表文<br>件。</li><li>-follow 排除符号连接。</li><li>-fprint&lt;列表文件&gt; 此参数的效果和指定”-print”参数类似，但会把结果保存成指定的列表文件。</li><li>-fprint0&lt;列表文件&gt; 此参数的效果和指定”-print0”参数类似，但会把结果保存成指定<br>的列表文件。</li><li>-fprintf&lt;列表文件&gt;&lt;输出格式&gt; 此参数的效果和指定”-printf”参数类似，但会把结果保存成指定的列表文件。</li><li>-fstype&lt;文件系统类型&gt; 只寻找该文件系统类型下的文件或目录。</li><li>-gid&lt;群组识别码&gt; 查找符合指定之群组识别码的文件或目录。</li><li>-group&lt;群组名称&gt; 查找符合指定之群组名称的文件或目录。</li><li>-help 或–help 在线帮助。</li><li>-ilname&lt;范本样式&gt; 此参数的效果和指定”-lname”参数类似，但忽略字符大小写的差<br>别。</li><li>-iname&lt;范本样式&gt; 此参数的效果和指定”-name”参数类似，但忽略字符大小写的差<br>别。</li><li>-inum<inode 编号>查找符合指定的 inode 编号的文件或目录。</inode></li><li>-ipath&lt;范本样式&gt; 此参数的效果和指定”-ipath”参数类似，但忽略字符大小写的差别。</li><li>-iregex&lt;范本样式&gt; 此参数的效果和指定”-regexe”参数类似，但忽略字符大小写的差<br>别。</li><li>-links&lt;连接数目&gt; 查找符合指定的硬连接数目的文件或目录。</li><li>-iname&lt;范本样式&gt; 指定字符串作为寻找符号连接的范本样式。</li><li>-ls 假设 find 指令的回传值为 True，就将文件或目录名称列出到标准输出。</li><li>-maxdepth&lt;目录层级&gt; 设置最大目录层级。</li><li>-mindepth&lt;目录层级&gt; 设置最小目录层级。</li><li>-mmin&lt;分钟&gt; 查找在指定时间曾被更改过的文件或目录，单位以分钟计算。</li><li>-mount 此参数的效果和指定”-xdev”相同。</li><li>-mtime&lt;24小时数&gt; 查找在指定时间曾被更改过的文件或目录，单位以 24小时计算。</li><li>-name&lt;范本样式&gt; 指定字符串作为寻找文件或目录的范本样式。</li><li>-newer&lt;参考文件或目录&gt; 查找其更改时间较指定文件或目录的更改时间更接近现在<br>的文件或目录。</li><li>-nogroup 找出不属于本地主机群组识别码的文件或目录。</li><li>-noleaf 不去考虑目录至少需拥有两个硬连接存在。</li><li>-nouser 找出不属于本地主机用户识别码的文件或目录。</li><li>-ok&lt;执行指令&gt; 此参数的效果和指定”-exec”参数类似，但在执行指令之前会先询问用<br>户，若回答”y”或”Y”，则放弃执行指令。</li><li>-path&lt;范本样式&gt; 指定字符串作为寻找目录的范本样式。</li><li>-perm&lt;权限数值&gt; 查找符合指定的权限数值的文件或目录。</li><li>-print 假设 find 指令的回传值为True，就将文件或目录名称列出到标准输出。格式为每列一个名称，每个名称之前皆有”./“字符串。</li><li>-print0 假设 find 指令的回传值为 True，就将文件或目录名称列出到标准输出。格式<br>为全部的名称皆在同一行。</li><li>-printf&lt;输出格式&gt; 假设find指令的回传值为True，就将文件或目录名称列出到标准输出。格式可以自行指定。</li><li>-prune 不寻找字符串作为寻找文件或目录的范本样式。</li><li>-regex&lt;范本样式&gt; 指定字符串作为寻找文件或目录的范本样式。</li><li>-size&lt;文件大小&gt; 查找符合指定的文件大小的文件。</li><li>-true 将 find 指令的回传值皆设为 True。</li><li>-typ&lt;文件类型&gt; 只寻找符合指定的文件类型的文件。</li><li>-uid&lt;用户识别码&gt; 查找符合指定的用户识别码的文件或目录。</li><li>-used&lt;日数&gt; 查找文件或目录被更改之后在指定时间曾被存取过的文件或目录，单位以<br>日计算。</li><li>-user&lt;拥有者名称&gt; 查找符合指定的拥有者名称的文件或目录。</li><li>-version 或–version 显示版本信息。</li><li>-xdev 将范围局限在先行的文件系统中。</li><li>-xtype&lt;文件类型&gt; 此参数的效果和指定”-type”参数类似，差别在于它针对符号连接检<br>查。</li></ul><h3 id="git-gnu-interactive-tools"><a href="#git-gnu-interactive-tools" class="headerlink" title="git(gnu interactive tools)"></a>git(gnu interactive tools)</h3><p><strong>功能说明</strong>：文字模式下的文件管理员。<br><strong>语 法</strong>：git<br><strong>补充说明</strong>：git 是用来管理文件的程序，它十分类似 DOS 下的 Norton Commander，具<br>有互动式操作界面。它的操作方法和 Norton Commander 几乎一样，略诉如下：</p><ul><li>F1 ：执行 info 指令，查询指令相关信息，会要求您输入欲查询的名称。</li><li>F2 ：执行 cat 指令，列出文件内容。</li><li>F3 ：执行 gitview 指令，观看文件内容。</li><li>F4 ：执行 vi 指令，编辑文件内容。</li><li>F5 ：执行 cp 指令，复制文件或目录，会要求您输入目标文件或目录。</li><li>F6 ：执行 mv 指令，移动文件或目录，或是更改其名称，会要求您输入目标文件或目录。</li><li>F7 ：执行 mkdir 指令，建立目录。</li><li>F8 ：执行 rm 指令，删除文件或目录。</li><li>F9 ：执行 make 指令，批处理执行指令或编译程序时，会要求您输入相关命令。</li><li>F10 ：离开 git 文件管理员。</li></ul><h3 id="lsattr-list-attribute"><a href="#lsattr-list-attribute" class="headerlink" title="lsattr(list attribute)"></a>lsattr(list attribute)</h3><p><strong>功能说明</strong>：显示文件属性。<br><strong>语 法</strong>：lsattr [-adlRvV][文件或目录…]<br><strong>补充说明</strong>：用 chattr 执行改变文件或目录的属性，可执行lsattr指令查询其属性。<br><strong>参 数</strong>：</p><ul><li>-a 显示所有文件和目录，包括以”.”为名称开头字符的额外内建，现行目录”.”与上层目录”..”。</li><li>-d 显示，目录名称，而非其内容。</li><li>-l 此参数目前没有任何作用。</li><li>-R 递归处理，将指定目录下的所有文件及子目录一并处理。</li><li>-v 显示文件或目录版本。</li><li>-V 显示版本信息。</li></ul><h3 id="rcp-remote-copy"><a href="#rcp-remote-copy" class="headerlink" title="rcp(remote copy)"></a>rcp(remote copy)</h3><p><strong>功能说明</strong>：远端复制文件或目录。<br><strong>语 法</strong>：rcp [-pr][源文件或目录][目标文件或目录] 或 rcp [-pr][源文件或目<br>录…][目标文件]<br><strong>补充说明</strong>：rcp 指令用在远端复制文件或目录，如同时指定两个以上的文件或目<br>录，且最后的目的地是一个已经存在的目录，则它灰把前面指定的所有文件或目<br>录复制到该目录中。<br><strong>参 数</strong>：</p><ul><li>-p 保留源文件或目录的属性，包括拥有者，所属群组，权限与时间。</li><li>-r 递归处理，将指定目录下的文件与子目录一并处理。</li></ul><h3 id="rm-remove"><a href="#rm-remove" class="headerlink" title="rm(remove)"></a>rm(remove)</h3><p><strong>功能说明</strong>：删除文件或目录。<br><strong>语 法</strong>：rm [-dfirv][–help][–version][文件或目录…]<br><strong>补充说明</strong>：执行 rm 指令可删除文件或目录，如欲删除目录必须加上参数”-r”，<br>否则预设仅会删除文件。<br><strong>参 数</strong>：</p><ul><li>-d 或–directory 直接把欲删除的目录的硬连接数据删成 0，删除该目录。</li><li>-f 或–force 强制删除文件或目录。</li><li>-i 或–interactive 删除既有文件或目录之前先询问用户。</li><li>-r 或-R 或–recursive 递归处理，将指定目录下的所有文件及子目录一并处理。</li><li>-v 或–verbose 显示指令执行过程。</li><li>–help 在线帮助。</li><li>–version 显示版本信息。</li></ul><h3 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h3><p><strong>功能说明</strong>：改变文件或目录时间。<br><strong>语 法</strong>：touch [-acfm][-d &lt;日期时间&gt;][-r &lt;参考文件或目录&gt;][-t &lt;日期时间&gt;][–help] [–version][文件或目录…] 或touch[-acfm][–help][–version][日期时间][文件或目录…]<br><strong>补充说明</strong>：使用 touch 指令可更改文件或目录的日期时间，包括存取时间和更改<br>时间。<br><strong>参 数</strong>：</p><ul><li>-a 或–time=atime 或–time=access 或–time=use 只更改存取时间。</li><li>-c 或–no-create 不建立任何文件。</li><li>-d&lt;时间日期&gt; 使用指定的日期时间，而非现在的时间。</li><li>-f 此参数将忽略不予处理，仅负责解决 BSD 版本 touch 指令的兼容性问题。</li><li>-m 或–time=mtime 或–time=modify 只更改变动时间。</li><li>-r&lt;参考文件或目录&gt; 把指定文件或目录的日期时间，统统设成和参考文件或<br>目录的日期时间相同。</li><li>-t&lt;日期时间&gt; 使用指定的日期时间，而非现在的时间。</li><li>–help 在线帮助。</li><li>–version 显示版本信息。</li></ul><h3 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h3><p><strong>使用权限</strong>：所有使用者<br><strong>使用方式</strong>：cat [-AbeEnstTuv] [–help] [–version] fileName<br><strong>说明</strong>：把档案串连接后传到基本输出（萤幕或加 &gt; fileName 到另一个档案）<br><strong>参数</strong>：</p><ul><li>-n 或 –number 由 1 开始对所有输出的行数编号</li><li>-b 或 –number-nonblank 和 -n 相似，只不过对于空白行不编号</li><li>-s 或 –squeeze-blank 当遇到有连续两行以上的空白行，就代换为一行的空白行</li><li>-v 或 –show-nonprinting<br><strong>范例</strong>：</li><li>cat -n textfile1 &gt; textfile2 把 textfile1 的档案内容加上行号后输入 textfile2 这个档案里</li><li>cat -b textfile1 textfile2 &gt;&gt; textfile3 把 textfile1 和 textfile2 的档案内容加上行号（空白行不加）之后将内容附加到 textfile3 里。</li></ul><h3 id="chgrp-change-group"><a href="#chgrp-change-group" class="headerlink" title="chgrp(change group)"></a>chgrp(change group)</h3><p><strong>功能说明</strong>：变更文件或目录的所属群组。<br><strong>语 法</strong>： chgrp [-cfhRv][–help][–version][ 所属群组 ][ 文件或目录…] 或 chgrp [-cfhRv][–help][–reference=&lt;参考文件或目录&gt;][–version][文件或目录…]<br><strong>补充说明</strong>：在 UNIX 系统家族里，文件或目录权限的掌控以拥有者及所属群组来<br>管理。您可以使用 chgrp 指令去变更文件与目录的所属群组，设置方式采用群组<br>名称或群组识别码皆可。<br><strong>参 数</strong>：</p><ul><li>-c 或–changes 效果类似”-v”参数，但仅回报更改的部分。</li><li>-f 或–quiet 或–silent 不显示错误信息。</li><li>-h 或–no-dereference 只对符号连接的文件作修改，而不更动其他任何相关文<br>件。</li><li>-R 或–recursive 递归处理，将指定目录下的所有文件及子目录一并处理。</li><li>-v 或–verbose 显示指令执行过程。</li><li>–help 在线帮助。</li><li>–reference=&lt;参考文件或目录&gt; 把指定文件或目录的所属群组全部设成和参<br>考文件或目录的所属群组相同。</li><li>–version 显示版本信息。</li></ul><h3 id="chmod-change-mode"><a href="#chmod-change-mode" class="headerlink" title="chmod(change mode)"></a>chmod(change mode)</h3><p><strong>功能说明</strong>：变更文件或目录的权限。<br><strong>语 法</strong>：chmod [-cfRv][–help][–version][&lt;权限范围&gt;+/-/=&lt;权限设置…&gt;][文件<br>或目录 …] 或 chmod [-cfRv][–help][–version][ 数字代号 ][ 文件或目<br>录…] 或 chmod [-cfRv][–help][–reference=&lt;参考文件或目录&gt;][–version][文件或目录…]<br><strong>补充说明</strong>：在 UNIX 系统家族里，文件或目录权限的控制分别以读取，写入，执<br>行 3 种一般权限来区分，另有 3 种特殊权限可供运用，再搭配拥有者与所属群组<br>管理权限范围。您可以使用 chmod 指令去变更文件与目录的权限，设置方式采<br>用文字或数字代号皆可。符号连接的权限无法变更，如果您对符号连接修改权限，<br>其改变会作用在被连接的原始文件。权限范围的表示法如下：</p><ul><li>u：User，即文件或目录的拥有者。</li><li>g：Group，即文件或目录的所属群组。</li><li>o：Other，除了文件或目录拥有者或所属群组之外，其他用户皆属于这个范围。</li><li>a：All，即全部的用户，包含拥有者，所属群组以及其他用户。<br>有关权限代号的部分，列表于下：</li><li>r：读取权限，数字代号为”4”。</li><li>w：写入权限，数字代号为”2”。</li><li>x：执行或切换权限，数字代号为”1”。</li><li>-：不具任何权限，数字代号为”0”。</li><li>s：特殊?b&gt;功能说明：变更文件或目录的权限。<br>参 数：</li><li>-c 或–changes 效果类似”-v”参数，但仅回报更改的部分。</li><li>-f 或–quiet 或–silent 不显示错误信息。</li><li>-R 或–recursive 递归处理，将指定目录下的所有文件及子目录一并处理。</li><li>-v 或–verbose 显示指令执行过程。</li><li>–help 在线帮助。</li><li>–reference=&lt;参考文件或目录&gt; 把指定文件或目录的权限全部设成和参考文件或目录的权限相同</li><li>–version 显示版本信息。</li></ul><h3 id="chown-change-owner"><a href="#chown-change-owner" class="headerlink" title="chown(change owner)"></a>chown(change owner)</h3><p><strong>功能说明</strong>：变更文件或目录的拥有者或所属群组。<br><strong>语 法</strong>：chown [-cfhRv][–dereference][–help][–version][拥有者.&lt;所属群组&gt;][文件或目录..] 或 chown [-chfRv][–dereference][–help][–version][.所属群组][文件或<br>目录… …] 或 chown[-cfhRv][–dereference][–help][–reference=&lt;参考文件或目录&gt;][–version][文件或目录…]<br><strong>补充说明</strong>：在 UNIX 系统家族里，文件或目录权限的掌控以拥有者及所属群组来<br>管理。您可以使用 chown 指令去变更文件与目录的拥有者或所属群组，设置方<br>式采用用户名称或用户识别码皆可，设置群组则用群组名称或群组识别码。<br><strong>参 数</strong>：</p><ul><li>-c 或–changes 效果类似”-v”参数，但仅回报更改的部分。</li><li>-f 或–quite 或–silent 不显示错误信息。</li><li>-h 或–no-dereference 之对符号连接的文件作修改，而不更动其他任何相关文<br>件。</li><li>-R 或–recursive 递归处理，将指定目录下的所有文件及子目录一并处理。</li><li>-v 或–version 显示指令执行过程。</li><li>–dereference 效果和”-h”参数相同。</li><li>–help 在线帮助。</li><li>–reference=&lt;参考文件或目录&gt; 把指定文件或目录的拥有者与所属群组全部<br>设成和参考文件或目 录的拥有者与所属群组相同。</li><li>–version 显示版本信息。</li></ul><h3 id="cp-copy"><a href="#cp-copy" class="headerlink" title="cp(copy)"></a>cp(copy)</h3><p><strong>功能说明</strong>：复制文件或目录。<br><strong>语 法</strong>： cp [-abdfilpPrRsuvx][-S &lt; 备份字尾字符串 &gt;][-V &lt; 备份方式&gt;][–help][–spares=&lt;使用时机&gt;][–version][源文件或目录][目标文件或目录] [目的目录]<br><strong>补充说明</strong>：cp 指令用在复制文件或目录，如同时指定两个以上的文件或目录，<br>且最后的目的地是一个已经存在的目录，则它会把前面指定的所有文件或目录复<br>制到该目录中。若同时指定多个文件或目录，而最后的目的地并非是一个已存在<br>的目录，则会出现错误信息。<br><strong>参 数</strong>：</p><ul><li>-a 或–archive 此参数的效果和同时指定”-dpR”参数相同。</li><li>-b 或–backup 删除，覆盖目标文件之前的备份，备份文件会在字尾加上一个<br>备份字符串。</li><li>-d 或–no-dereference 当复制符号连接时，把目标文件或目录也建立为符号连<br>接，并指向与源文件或目录连接的原始文件或目录。</li><li>-f 或–force 强行复制文件或目录，不论目标文件或目录是否已存在。</li><li>-i 或–interactive 覆盖既有文件之前先询问用户。</li><li>-l 或–link 对源文件建立硬连接，而非复制文件。</li><li>-p 或–preserve 保留源文件或目录的属性。</li><li>-P 或–parents 保留源文件或目录的路径。</li><li>-r 递归处理，将指定目录下的文件与子目录一并处理。</li><li>-R 或–recursive 递归处理，将指定目录下的所有文件与子目录一并处理。</li><li>-s 或–symbolic-link 对源文件建立符号连接，而非复制文件。</li><li>-S&lt;备份字尾字符串&gt;或–suffix=&lt;备份字尾字符串&gt; 用”-b”参数备份目标文件<br>后，备份文件的字尾会被加上一个备份字符串，预设的备份字尾字符串是符号<br>“~”。</li><li>-u 或–update 使用这项参数后只会在源文件的更改时间较目标文件更新时或<br>是 名称相互对应的目标文件并不存在，才复制文件。</li><li>-v 或–verbose 显示指令执行过程。</li><li>-V&lt;备份方式&gt;或–version-control=&lt;备份方式&gt; 用”-b”参数备份目标文件后，<br>备份文件的字尾会被加上一个备份字符串，这字符串不仅可用”-S”参数变更，当<br>使用”-V”参数指定不同备份方式时，也会产生不同字尾的备份字串。</li><li>-x 或–one-file-system 复制的文件或目录存放的文件系统，必须与 cp 指令执<br>行时所处的文件系统相同，否则不予复制。</li><li>–help 在线帮助。</li><li>–sparse=&lt;使用时机&gt; 设置保存稀疏文件的时机。</li><li>–version 显示版本信息。</li></ul><h3 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h3><p><strong>使用权限</strong>：所有使用者<br><strong>用法</strong>：cut -cnum1-num2 filename<br><strong>说明</strong>：显示每行从开头算起 num1 到 num2 的文字。<br><strong>范例</strong>：<br>shell&gt;&gt; cat example<br>test2<br>this is test1<br>shell&gt;&gt; cut -c0-6 example ## print 开头算起前 6 个字元<br>test2<br>this i</p><h2 id="linux-文件传输命令"><a href="#linux-文件传输命令" class="headerlink" title="linux 文件传输命令"></a>linux 文件传输命令</h2><h3 id="ncftp-nc-file-transfer-protocol"><a href="#ncftp-nc-file-transfer-protocol" class="headerlink" title="ncftp(nc file transfer protocol)"></a>ncftp(nc file transfer protocol)</h3><p><strong>功能说明</strong>：传输文件。<br><strong>语 法</strong>：ncftp [主机或 IP 地址]<br><strong>补充说明</strong>：FTP 让用户得以下载存放于服务器主机的文件，也能将文件上传到远<br>端主机放置。NcFTP 是文字模式 FTP 程序的佼佼者，它具备多样特色， 包括显<br>示传输速率，下载进度，自动续传，标住书签，可通过防火墙和代理服务器等。</p><h3 id="tftp-trivial-file-transfer-protocol"><a href="#tftp-trivial-file-transfer-protocol" class="headerlink" title="tftp(trivial file transfer protocol)"></a>tftp(trivial file transfer protocol)</h3><p><strong>功能说明</strong>：传输文件。<br><strong>语 法</strong>：tftp [主机名称或 IP 地址]<br><strong>补充说明</strong>：FTP 让用户得以下载存放于远端主机的文件，也能将文件上传到远端<br>主机放置。tftp 是简单的文字模式 ftp 程序，它所使用的指令和 FTP 类似。</p><h3 id="uucp"><a href="#uucp" class="headerlink" title="uucp"></a>uucp</h3><p><strong>功能说明</strong>：在 Unix 系统之间传送文件。<br><strong>语 法</strong>：uucp [-cCdfjmrRtvW][-g&lt;等级&gt;][-I&lt;配置文件&gt;][-n&lt;用户&gt;][-x&lt;类型</p><blockquote><p>][–help][…来源][目的]<br><strong>补充说明</strong>：UUCP 为 Unix 系统之间，通过序列线来连线的协议。uucp 使用 UUCP<br>协议，主要的功能为传送文件。<br><strong>参 数</strong>：</p></blockquote><ul><li>-c 或–nocopy 不用将文件复制到缓冲区。</li><li>-C 或–copy 将文件复制到缓冲区。</li><li>-d 或–directiories 在传送文件时，自动在[目的]建立必要的目录。</li><li>-f 或–nodirectiories 在传送文件时，若需要在[目的]建立目录，则放弃执行该作<br>业。</li><li>-g&lt;等级&gt;或–grade&lt;等级&gt; 指定文件传送作业的优先顺序。</li><li>-I&lt;配置文件&gt;或–config&lt;配置文件&gt; 指定 uucp 配置文件。</li><li>-j 或–jobid 显示作业编号。</li><li>-m 或–mail 作业结束后，以电子邮件报告作业是否顺利完成。</li><li>-n&lt;用户&gt;或–notify&lt;用户&gt; 作业结束后，以电子邮件向指定的用户报告作业是<br>否顺利完成。</li><li>-r 或–nouucico 不要立即启动 uucico 服务程序，仅将作业送到队列中，待稍后<br>再执行。</li><li>-R 或–recursive 若[来源]为目录，则将整个目录包含子目录复制到[目的]。</li><li>-t 或–uuto 将最后一个参数视为”主机名!用户”。</li><li>-v 或–version 显示版本信息。</li><li>-W 或–noexpand 不要将目前所在的目录加入路径。</li><li>-x&lt;类型&gt;或–debug&lt;类型&gt;启动指定的排错模式。</li><li>–help 显示帮助。<br>[源…] 指定源文件或路径。<br>[目的] 指定目标文件或路径。</li></ul><h2 id="linux-磁盘管理命令"><a href="#linux-磁盘管理命令" class="headerlink" title="linux 磁盘管理命令"></a>linux 磁盘管理命令</h2><h3 id="cd-change-directory"><a href="#cd-change-directory" class="headerlink" title="cd(change directory)"></a>cd(change directory)</h3><p><strong>功能说明</strong>：切换目录。<br><strong>语 法</strong>：cd [目的目录]<br><strong>补充说明</strong>：cd 指令可让用户在不同的目录间切换，但该用户必须拥有足够的权<br>限进入目的目录。</p><h3 id="df-disk-free"><a href="#df-disk-free" class="headerlink" title="df(disk free)"></a>df(disk free)</h3><p><strong>功能说明</strong>：显示磁盘的相关信息。<br><strong>语 法</strong>：df [-ahHiklmPT][–block-size=&lt;区块大小&gt;][-t &lt;文件系统类型&gt;][-x &lt;文<br>件系统类型&gt;][–help][–no-sync][–sync][–version][文件或设备]<br>补充说明：df 可显示磁盘的文件系统与使用情形。<br><strong>参 数</strong>：</p><ul><li>-a 或–all 包含全部的文件系统。</li><li>–block-size=&lt;区块大小&gt; 以指定的区块大小来显示区块数目。</li><li>-h 或–human-readable 以可读性较高的方式来显示信息。</li><li>-H 或–si 与-h 参数相同，但在计算时是以 1000 Bytes 为换算单位而非<br>1024 Bytes。</li><li>-i 或–inodes 显示 inode 的信息。</li><li>-k 或–kilobytes 指定区块大小为 1024 字节。</li><li>-l 或–local 仅显示本地端的文件系统。</li><li>-m 或–megabytes 指定区块大小为 1048576 字节。</li><li>–no-sync 在取得磁盘使用信息前，不要执行 sync 指令，此为预设值。</li><li>-P 或–portability 使用 POSIX 的输出格式。</li><li>–sync 在取得磁盘使用信息前，先执行 sync 指令。</li><li>-t&lt;文件系统类型&gt;或–type=&lt;文件系统类型&gt; 仅显示指定文件系统类型的磁盘<br>信息。</li><li>-T 或–print-type 显示文件系统的类型。</li><li>-x&lt;文件系统类型&gt;或–exclude-type=&lt;文件系统类型&gt; 不要显示指定文件系统<br>类型的磁盘信息。</li><li>–help 显示帮助。</li><li>–version 显示版本信息。<br>[文件或设备] 指定磁盘设备。</li></ul><h3 id="du-disk-usage"><a href="#du-disk-usage" class="headerlink" title="du(disk usage)"></a>du(disk usage)</h3><p><strong>功能说明</strong>：显示目录或文件的大小。<br><strong>语 法</strong>： du [-abcDhHklmsSx][-L &lt; 符号连接 &gt;][-X &lt;文件&gt;][–block-size][–exclude=&lt; 目录或文件 &gt;][–max-depth=&lt; 目录层数&gt;][–help][–version][目录或文件]<br><strong>补充说明</strong>：du 会显示指定的目录或文件所占用的磁盘空间。<br><strong>参 数</strong>：</p><ul><li>-a 或-all 显示目录中个别文件的大小。</li><li>-b 或-bytes 显示目录或文件大小时，以 byte 为单位。</li><li>-c 或–total 除了显示个别目录或文件的大小外，同时也显示所有目录或文件的<br>总和。</li><li>-D 或–dereference-args 显示指定符号连接的源文件大小。</li><li>-h 或–human-readable 以 K，M，G 为单位，提高信息的可读性。</li><li>-H 或–si 与-h 参数相同，但是 K，M，G 是以 1000 为换算单位。</li><li>-k 或–kilobytes 以 1024 bytes 为单位。</li><li>-l 或–count-links 重复计算硬件连接的文件。</li><li>-L&lt;符号连接&gt;或–dereference&lt;符号连接&gt; 显示选项中所指定符号连接的源文<br>件大小。</li><li>-m 或–megabytes 以 1MB 为单位。</li><li>-s 或–summarize 仅显示总计。</li><li>-S 或–separate-dirs 显示个别目录的大小时，并不含其子目录的大小。</li><li>-x 或–one-file-xystem 以一开始处理时的文件系统为准，若遇上其它不同的文<br>件系统目录则略过。</li><li>-X&lt;文件&gt;或–exclude-from=&lt;文件&gt; 在&lt;文件&gt;指定目录或文件。</li><li>–exclude=&lt;目录或文件&gt; 略过指定的目录或文件。</li><li>–max-depth=&lt;目录层数&gt; 超过指定层数的目录后，予以忽略。</li><li>–help 显示帮助。</li><li>–version 显示版本信息。</li></ul><h3 id="ls-list"><a href="#ls-list" class="headerlink" title="ls(list)"></a>ls(list)</h3><p><strong>功能说明</strong>：列出目录内容。<br><strong>语 法</strong>： ls [-1aAbBcCdDfFgGhHiklLmnNopqQrRsStuUvxX][-I &lt; 范本样式</p><blockquote><p>][-T &lt;跳格字数&gt;][-w &lt;每列字符数&gt;][–block-size=&lt;区块大小&gt;][–color=&lt;使用时<br>机 &gt;][–format=&lt; 列表格式 &gt;][–full-time][–help][–indicator-style=&lt; 标注样式<br>][–quoting-style=&lt; 引号样式 &gt;][–show-control-chars][–sort=&lt; 排序方式<br>][–time=&lt;时间戳记&gt;][–version][文件或目录…]<br><strong>补充说明</strong>：执行 ls 指令可列出目录的内容，包括文件和子目录的名称。<br><strong>参 数</strong>：</p></blockquote><ul><li>-1 每列仅显示一个文件或目录名称。</li><li>-a 或–all 下所有文件和目录。</li><li>-A 或–almost-all 显示所有文件和目录，但不显示现行目录和上层目录。</li><li>-b 或–escape 显示脱离字符。</li><li>-B 或–ignore-backups 忽略备份文件和目录。</li><li>-c 以更改时间排序，显示文件和目录。</li><li>-C 以又上至下，从左到右的直行方式显示文件和目录名称。</li><li>-d 或–directory 显示目录名称而非其内容。</li><li>-D 或–dired 用 Emacs 的模式产生文件和目录列表。</li><li>-f 此参数的效果和同时指定”aU”参数相同，并关闭”lst”参数的效果。</li><li>-F 或–classify 在执行文件，目录，Socket，符号连接，管道名称后面，各自加<br>上”*”,”/“,”=”,”@”,”|”号。</li><li>-g 次参数将忽略不予处理。</li><li>-G 或–no-group 不显示群组名称。</li><li>-h 或–human-readable 用”K”,”M”,”G”来显示文件和目录的大小。</li><li>-H 或–si 此参数的效果和指定”-h”参数类似，但计算单位是 1000Bytes 而非<br>1024Bytes。</li><li>-i 或–inode 显示文件和目录的 inode 编号。</li><li>-I&lt;范本样式&gt;或–ignore=&lt;范本样式&gt; 不显示符合范本样式的文件或目录名称。</li><li>-k 或–kilobytes 此参数的效果和指定”block-size=1024”参数相同。</li><li>-l 使用详细格式列表。</li><li>-L 或–dereference 如遇到性质为符号连接的文件或目录，直接列出该连接所指<br>向的原始文件或目录。</li><li>-m 用”,”号区隔每个文件和目录的名称。</li><li>-n 或–numeric-uid-gid 以用户识别码和群组识别码替代其名称。</li><li>-N 或–literal 直接列出文件和目录名称，包括控制字符。</li><li>-o 此参数的效果和指定”-l” 参数类似，但不列出群组名称或识别码。</li><li>-p 或–file-type 此参数的效果和指定”-F”参数类似，但不会在执行文件名称后面<br>加上”*”号。</li><li>-q 或–hide-control-chars 用”?”号取代控制字符，列出文件和目录名称。</li><li>-Q 或–quote-name 把文件和目录名称以””号标示起来。</li><li>-r 或–reverse 反向排序。</li><li>-R 或–recursive 递归处理，将指定目录下的所有文件及子目录一并处理。</li><li>-s 或–size 显示文件和目录的大小，以区块为单位。</li><li>-S 用文件和目录的大小排序。</li><li>-t 用文件和目录的更改时间排序。</li><li>-T&lt;跳格字符&gt;或–tabsize=&lt;跳格字数&gt; 设置跳格字符所对应的空白字符数。</li><li>-u 以最后存取时间排序，显示文件和目录。</li><li>-U 列出文件和目录名称时不予排序。</li><li>-v 文件和目录的名称列表以版本进行排序。</li><li>-w&lt;每列字符数&gt;或–width=&lt;每列字符数&gt; 设置每列的最大字符数。</li><li>-x 以从左到右，由上至下的横列方式显示文件和目录名称。</li><li>-X 以文件和目录的最后一个扩展名排序。</li><li>–block-size=&lt;区块大小&gt; 指定存放文件的区块大小。</li><li>–color=&lt;列表格式&gt; 培植文件和目录的列表格式。</li><li>–full-time 列出完整的日期与时间。</li><li>–help 在线帮助。</li><li>–indicator-style=&lt;标注样式&gt; 在文件和目录等名称后面加上标注，易于辨识该<br>名称所属的类型。</li><li>–quoting-syte=&lt;引号样式&gt; 把文件和目录名称以指定的引号样式标示起来。</li><li>–show-control-chars 在文件和目录列表时，使用控制字符。</li><li>–sort=&lt;排序方式&gt; 配置文件和目录列表的排序方式。</li><li>–time=&lt;时间戳记&gt; 用指定的时间戳记取代更改时间。</li><li>–version 显示版本信息。</li></ul><h3 id="mkdir-make-directories"><a href="#mkdir-make-directories" class="headerlink" title="mkdir(make directories)"></a>mkdir(make directories)</h3><p><strong>功能说明</strong>：建立目录<br><strong>语 法</strong>：mkdir [-p][–help][–version][-m &lt;目录属性&gt;][目录名称]<br><strong>补充说明</strong>：mkdir 可建立目录并同时设置目录的权限。<br><strong>参 数</strong>：</p><ul><li>-m&lt;目录属性&gt;或–mode&lt;目录属性&gt; 建立目录时同时设置目录的权限。</li><li>-p 或–parents 若所要建立目录的上层目录目前尚未建立，则会一并建立上层目<br>录。</li><li>–help 显示帮助。</li><li>–verbose 执行时显示详细的信息。</li><li>–version 显示版本信息。</li></ul><h3 id="quota"><a href="#quota" class="headerlink" title="quota"></a>quota</h3><p><strong>功能说明</strong>：显示磁盘已使用的空间与限制。<br><strong>语 法</strong>：quota [-quvV][用户名称…] 或 quota [-gqvV][群组名称…]<br><strong>补充说明</strong>：执行 quota 指令，可查询磁盘空间的限制，并得知已使用多少空间。<br><strong>参 数</strong>：</p><ul><li>-g 列出群组的磁盘空间限制。</li><li>-q 简明列表，只列出超过限制的部分。</li><li>-u 列出用户的磁盘空间限制。</li><li>-v 显示该用户或群组，在所有挂入系统的存储设备的空间限制。</li><li>-V 显示版本信息。</li></ul><h3 id="rmdir-remove-directory"><a href="#rmdir-remove-directory" class="headerlink" title="rmdir(remove directory)"></a>rmdir(remove directory)</h3><p><strong>功能说明</strong>：删除目录。<br><strong>语 法</strong>：rmdir [-p][–help][–ignore-fail-on-non-empty][–verbose][–version][目<br>录…]<br><strong>补充说明</strong>：当有空目录要删除时，可使用 rmdir 指令。<br><strong>参 数</strong>：</p><ul><li>-p 或–parents 删除指定目录后，若该目录的上层目录已变成空目录，则将其一<br>并删除。</li><li>–help 在线帮助。</li><li>–ignore-fail-on-non-empty 忽略非空目录的错误信息。</li><li>–verbose 显示指令执行过程。</li><li>–version 显示版本信息。</li></ul><h2 id="linux-网络通讯命令"><a href="#linux-网络通讯命令" class="headerlink" title="linux 网络通讯命令"></a>linux 网络通讯命令</h2><h3 id="ifconfig"><a href="#ifconfig" class="headerlink" title="ifconfig"></a>ifconfig</h3><p><strong>功能说明</strong>：显示或设置网络设备。<br><strong>语 法</strong>：ifconfig [网络设备][down up -allmulti -arp -promisc][add&lt;地址&gt;][del&lt;<br>地址&gt;][&lt;hw&lt;网络设备类型&gt;&lt;硬件地址&gt;][io_addr&lt;I/O 地址&gt;][irq<irq 地址>][media&lt;网络媒介类型&gt;][mem_start&lt;内存地址&gt;][metric&lt;数目&gt;][mtu&lt;字节&gt;][netmask&lt;子网掩码&gt;][tunnel&lt;地址&gt;][-broadcast&lt;地址&gt;][-pointopoint&lt;地址&gt;][IP地址]<br><strong>补充说明</strong>：ifconfig 可设置网络设备的状态，或是显示目前的设置。<br><strong>参 数</strong>：</irq></p><ul><li>add&lt;地址&gt; 设置网络设备 IPv6 的 IP 地址。</li><li>del&lt;地址&gt; 删除网络设备 IPv6 的 IP 地址。</li><li>down 关闭指定的网络设备。</li><li>&lt;hw&lt;网络设备类型&gt;&lt;硬件地址&gt; 设置网络设备的类型与硬件地址。</li><li>io_addr&lt;I/O 地址&gt; 设置网络设备的 I/O 地址。</li><li>irq<irq 地址>设置网络设备的 IRQ。</irq></li><li>media&lt;网络媒介类型&gt; 设置网络设备的媒介类型。</li><li>mem_start&lt;内存地址&gt; 设置网络设备在主内存所占用的起始地址。<br>metric&lt;数目&gt; 指定在计算数据包的转送次数时，所要加上的数目。<br>mtu&lt;字节&gt; 设置网络设备的 MTU。<br>netmask&lt;子网掩码&gt; 设置网络设备的子网掩码。<br>tunnel&lt;地址&gt; 建立 IPv4 与 IPv6 之间的隧道通信地址。<br>up 启动指定的网络设备。<br>-broadcast&lt;地址&gt; 将要送往指定地址的数据包当成广播数据包来处理。<br>-pointopoint&lt;地址&gt; 与指定地址的网络设备建立直接连线，此模式具有保密功<br>能。</li><li>-promisc 关闭或启动指定网络设备的 promiscuous 模式。</li><li>[IP 地址] 指定网络设备的 IP 地址。</li><li>[网络设备] 指定网络设备的名称。</li></ul><h3 id="nc"><a href="#nc" class="headerlink" title="nc"></a>nc</h3><p><strong>功能说明</strong>：设置路由器。<br><strong>语 法</strong>：nc [-hlnruz][-g&lt;网关…&gt;][-G&lt;指向器数目&gt;][-i&lt;延迟秒数&gt;][-o&lt;输出文<br>件&gt;][-p&lt;通信端口&gt;][-s&lt;来源位址&gt;][-v…][-w&lt;超时秒数&gt;][主机名称][通信端口…]<br>补充说明：执行本指令可设置路由器的相关参数。<br><strong>参 数</strong>：</p><ul><li>-g&lt;网关&gt; 设置路由器跃程通信网关，最丢哦可设置 8 个。</li><li>-G&lt;指向器数目&gt; 设置来源路由指向器，其数值为 4 的倍数。</li><li>-h 在线帮助。</li><li>-i&lt;延迟秒数&gt; 设置时间间隔，以便传送信息及扫描通信端口。</li><li>-l 使用监听模式，管控传入的资料。</li><li>-n 直接使用 IP 地址，而不通过域名服务器。</li><li>-o&lt;输出文件&gt; 指定文件名称，把往来传输的数据以 16 进制字码倾倒成该文件<br>保存。</li><li>-p&lt;通信端口&gt; 设置本地主机使用的通信端口。</li><li>-r 乱数指定本地与远端主机的通信端口。</li><li>-s&lt;来源位址&gt; 设置本地主机送出数据包的 IP 地址。</li><li>-u 使用 UDP 传输协议。</li><li>-v 显示指令执行过程。</li><li>-w&lt;超时秒数&gt; 设置等待连线的时间。</li><li>-z 使用 0 输入/输出模式，只在扫描通信端口时使用。</li></ul><h3 id="netconf"><a href="#netconf" class="headerlink" title="netconf"></a>netconf</h3><p><strong>功能说明</strong>：设置各项网络功能。<br><strong>语 法</strong>：netconf<br><strong>补充说明</strong>：netconf 是 Red Hat Linux 发行版专门用来调整 Linux 各项设置的程序。</p><h3 id="netconfig"><a href="#netconfig" class="headerlink" title="netconfig"></a>netconfig</h3><p><strong>功能说明</strong>：设置网络环境。<br><strong>语 法</strong>：netconfig<br><strong>补充说明</strong>：这是 Slackware 发行版内附程序，它具有互动式的问答界面，让用户<br>轻易完成网络环境的设置。</p><h3 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h3><p><strong>功能说明</strong>：显示网络状态。<br><strong>语 法</strong>：netstat [-acCeFghilMnNoprstuvVwx][-A&lt;网络类型&gt;][–ip]<br><strong>补充说明</strong>：利用 netstat 指令可让你得知整个 Linux 系统的网络情况。<br><strong>参 数</strong>：</p><ul><li>-a 或–all 显示所有连线中的 Socket。</li><li>-A&lt;网络类型&gt;或–&lt;网络类型&gt; 列出该网络类型连线中的相关地址。</li><li>-c 或–continuous 持续列出网络状态。</li><li>-C 或–cache 显示路由器配置的快取信息。</li><li>-e 或–extend 显示网络其他相关信息。</li><li>-F 或–fib 显示 FIB。</li><li>-g 或–groups 显示多重广播功能群组组员名单。</li><li>-h 或–help 在线帮助。</li><li>-i 或–interfaces 显示网络界面信息表单。</li><li>-l 或–listening 显示监控中的服务器的 Socket。</li><li>-M 或–masquerade 显示伪装的网络连线。</li><li>-n 或–numeric 直接使用 IP 地址，而不通过域名服务器。</li><li>-N 或–netlink 或–symbolic 显示网络硬件外围设备的符号连接名称。</li><li>-o 或–timers 显示计时器。</li><li>-p 或–programs 显示正在使用 Socket 的程序识别码和程序名称。</li><li>-r 或–route 显示 Routing Table。</li><li>-s 或–statistice 显示网络工作信息统计表。</li><li>-t 或–tcp 显示 TCP 传输协议的连线状况。</li><li>-u 或–udp 显示 UDP 传输协议的连线状况。</li><li>-v 或–verbose 显示指令执行过程。</li><li>-V 或–version 显示版本信息。</li><li>-w 或–raw 显示 RAW 传输协议的连线状况。</li><li>-x 或–unix 此参数的效果和指定”-A unix”参数相同。</li><li>–ip 或–inet 此参数的效果和指定”-A inet”参数相同。</li></ul><h3 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h3><p><strong>功能说明</strong>：检测主机。<br><strong>语 法</strong>：ping [-dfnqrRv][-c&lt;完成次数&gt;][-i&lt;间隔秒数&gt;][-I&lt;网络界面&gt;][-l&lt;前置<br>载入&gt;][-p&lt;范本样式&gt;][-s&lt;数据包大小&gt;][-t&lt;存活数值&gt;][主机名称或IP地址]<br><strong>补充说明</strong>：执行ping指令会使用ICMP传输协议，发出要求回应的信息，若远端<br>主机的网络功能没有问题，就会回应该信息，因而得知该主机运作正常。<br><strong>参 数</strong>：</p><ul><li>-d 使用Socket的SO_DEBUG功能。</li><li>-c&lt;完成次数&gt; 设置完成要求回应的次数。</li><li>-f 极限检测。</li><li>-i&lt;间隔秒数&gt; 指定收发信息的间隔时间。</li><li>-I&lt;网络界面&gt; 使用指定的网络界面送出数据包。</li><li>-l&lt;前置载入&gt; 设置在送出要求信息之前，先行发出的数据包。</li><li>-n 只输出数值。</li><li>-p&lt;范本样式&gt; 设置填满数据包的范本样式。</li><li>-q 不显示指令执行过程，开头和结尾的相关信息除外。</li><li>-r 忽略普通的Routing Table，直接将数据包送到远端主机上。</li><li>-R 记录路由过程。</li><li>-s&lt;数据包大小&gt; 设置数据包的大小。</li><li>-t&lt;存活数值&gt; 设置存活数值TTL的大小。</li><li>-v 详细显示指令的执行过程。</li></ul><h3 id="statserial-status-ofserial-port"><a href="#statserial-status-ofserial-port" class="headerlink" title="statserial(status ofserial port)"></a>statserial(status ofserial port)</h3><p><strong>功能说明</strong>：显示串口状态。<br><strong>语 法</strong>：statserial [-dnx][串口设备名称]<br><strong>补充说明</strong>：statserial 可显示各个接脚的状态，常用来判断串口是否正常。<br><strong>参 数</strong>：</p><ul><li>-d 以 10 进制数字来表示串口的状态。</li><li>-n 仅显示一次串口的状态后即结束程序。</li><li>-x 与-n 参数类似，但是以 16 进制来表示。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Linux命令大全&quot;&gt;&lt;a href=&quot;#Linux命令大全&quot; class=&quot;headerlink&quot; title=&quot;Linux命令大全&quot;&gt;&lt;/a&gt;Linux命令大全&lt;/h1&gt;&lt;h2 id=&quot;linux-系统管理命令&quot;&gt;&lt;a href=&quot;#linux-系统管理命令&quot; class=&quot;headerlink&quot; title=&quot;linux 系统管理命令&quot;&gt;&lt;/a&gt;linux 系统管理命令&lt;/h2&gt;&lt;h3 id=&quot;adduser&quot;&gt;&lt;a href=&quot;#adduser&quot; class=&quot;headerlink&quot; title=&quot;adduser&quot;&gt;&lt;/a&gt;adduser&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;功能说明&lt;/strong&gt;：新增用户帐号。&lt;br&gt;&lt;strong&gt;语 法&lt;/strong&gt;：adduser&lt;br&gt;&lt;strong&gt;补充说明&lt;/strong&gt;：在 Slackware 中，adduser 指令是个 script 程序，利用交谈的方式取得&lt;br&gt;输入的用户帐号资料，然后再交由真正建立帐号的 useradd 指令建立新用户，如&lt;br&gt;此可方便管理员建立用户帐号。在 Red Hat Linux 中，adduser 指令则是 useradd&lt;br&gt;指令的符号连接，两者实际上是同一个指令。&lt;/p&gt;&lt;h3 id=&quot;chfn-change-finger-information&quot;&gt;&lt;a href=&quot;#chfn-change-finger-information&quot; class=&quot;headerlink&quot; title=&quot;chfn(change finger information)&quot;&gt;&lt;/a&gt;chfn(change finger information)&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;功能说明&lt;/strong&gt;：改变 finger 指令显示的信息。&lt;br&gt;&lt;strong&gt;语 法&lt;/strong&gt;：chfn [-f &amp;lt;真实姓名&amp;gt;][-h &amp;lt;家中电话&amp;gt;][-o &amp;lt;办公地址&amp;gt;][-p &amp;lt;办公电话&amp;gt;][-uv][帐号名称]&lt;br&gt;&lt;strong&gt;补充说明&lt;/strong&gt;：chfn 指令可用来更改执行 finger 指令时所显示的信息，这些信息都存&lt;br&gt;放在/etc 目录里的 asswd 文件里。若不指定任何参数，则 chfn 指令会进入问答式&lt;br&gt;界面。&lt;br&gt;&lt;strong&gt;参 数&lt;/strong&gt;：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;-f&amp;lt;真实姓名&amp;gt;或–full-name&amp;lt;真实姓名&amp;gt; 设置真实姓名。&lt;/li&gt;&lt;li&gt;-h&amp;lt;家中电话&amp;gt;或–home-phone&amp;lt;家中电话&amp;gt; 设置家中的电话号码。&lt;/li&gt;&lt;li&gt;-o&amp;lt;办公地址&amp;gt;或–office&amp;lt;办公地址&amp;gt; 设置办公室的地址。&lt;/li&gt;&lt;li&gt;-p&amp;lt;办公电话&amp;gt;或–office-phone&amp;lt;办公电话&amp;gt; 设置办公室的电话号码。&lt;/li&gt;&lt;li&gt;-u 或–help 在线帮助。&lt;/li&gt;&lt;li&gt;&lt;p&gt;-v 或-version 显示版本信息。&lt;/p&gt;&lt;h3 id=&quot;chsh-change-shell&quot;&gt;&lt;a href=&quot;#chsh-change-shell&quot; class=&quot;headerlink&quot; title=&quot;chsh(change shell)&quot;&gt;&lt;/a&gt;chsh(change shell)&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;功能说明&lt;/strong&gt;：更换登入系统时使用的 shell。&lt;br&gt;&lt;strong&gt;语 法&lt;/strong&gt;：chsh [-luv][-s&lt;shell 名称&gt;][用户名称]&lt;br&gt;&lt;strong&gt;补充说明&lt;/strong&gt;：每位用户在登入系统时，都会拥有预设的 shell 环境，这个指令可更&lt;br&gt;改其预设值。若不指定任何参数与用户名称，则 chsh 会以应答的方式进行设置。&lt;br&gt;&lt;strong&gt;参 数&lt;/strong&gt;：&lt;/shell&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;-s&lt;shell 名称&gt;或–shell&lt;shell 名称&gt;更改系统预设的 shell 环境。&lt;/shell&gt;&lt;/shell&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;-l 或–list-shells 列出目前系统可用的 shell 清单。&lt;/li&gt;&lt;li&gt;-u 或–help 在线帮助。&lt;/li&gt;&lt;li&gt;-v 或-version 显示版本信息。&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://little8.top/categories/Linux/"/>
    
    
      <category term="little_eight" scheme="https://little8.top/tags/little-eight/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程</title>
    <link href="https://little8.top/2018/12/10/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>https://little8.top/2018/12/10/Java多线程/</id>
    <published>2018-12-10T05:49:27.000Z</published>
    <updated>2019-07-23T13:00:40.947Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线程基础"><a href="#线程基础" class="headerlink" title="线程基础"></a>线程基础</h2><h3 id="什么是线程？"><a href="#什么是线程？" class="headerlink" title="什么是线程？"></a>什么是线程？</h3><p>几乎每种操作系统都支持进程的概念 —— 进程就是在某种程度上相互隔离的、独立运行的程序。</p><p>线程化是允许多个活动共存于一个进程中的工具。大多数现代的操作系统都支持线程，而且线程的<br>概念以各种形式已存在了好多年。Java 是第一个在语言本身中显式地包含线程的主流编程语言，它没有把线程化看作是底层操作系统的工具。</p><p>有时候，线程也称作轻量级进程。就象进程一样，线程在程序中是独立的、并发的执行路径，每个线程有它自己的堆栈、自己的程序计数器和自己的局部变量。但是，与分隔的进程相比，进程中的线程之间的隔离程度要小。它们共享内存、文件句柄和其它每个进程应有的状态。</p><p>进程可以支持多个线程，它们看似同时执行，但互相之间并不同步。一个进程中的多个线程共享相同的内存地址空间，这就意味着它们可以访问相同的变量和对象，而且它们从同一堆中分配对象。尽管这让线程之间共享信息变得更容易，但您必须小心，确保它们不会妨碍同一进程里的其它线程。</p><p>Java 线程工具和 API 看似简单。但是，编写有效使用线程的复杂程序并不十分容易。因为有多个线程共存在相同的内存空间中并共享相同的变量，所以您必须小心，确保您的线程不会互相干扰。</p><h3 id="每个-Java-程序都使用线程"><a href="#每个-Java-程序都使用线程" class="headerlink" title="每个 Java 程序都使用线程"></a>每个 Java 程序都使用线程</h3><p>每个 Java 程序都至少有一个线程 — 主线程。当一个 Java 程序启动时，JVM 会创建主线程，并在该线程中调用程序的 main() 方法。 JVM 还创建了其它线程，您通常都看不到它们 — 例如，与垃圾收集、对象终止和其它 JVM 内务处理任务相关的线程。其它工具也创建线程，如 AWT（抽象窗口工具箱（Abstract Windowing Toolkit））或 Swing UI 工具箱、servlet 容器、应用程序服务器和 RMI（远程方法调用（Remote Method Invocation））</p><h3 id="Java-线程的风险"><a href="#Java-线程的风险" class="headerlink" title="Java 线程的风险"></a>Java 线程的风险</h3><p>虽然 Java 线程工具非常易于使用，但当我们创建多线程程序时，应该尽量避免一些风险。<br>当多个线程访问同一数据项（如静态字段、可全局访问对象的实例字段或共享集合）时，需要确保它们协调了对数据的访问，这样它们都可以看到数据的一致视图，而且相互不会干扰另一方的更改。<br>为了实现这个目的，Java 语言提供了两个关键字：synchronized 和 volatile。当从多个线程中访问变量时，必须确保对该访问正确地进行了同步。对于简单变量，将变量声明成volatile 也许就足够了，但在大多数情况下，需要使用同步。<br>如果将要使用同步来保护对共享变量的访问，那么必须确保在程序中所有访问该变量的地方都使用同步。</p><p>虽然线程可以大大简化许多类型的应用程序，过度使用线程可能会危及程序的性能及其可维护性。<br>线程消耗了资源。因此，在不降低性能的情况下，可以创建的线程的数量是有限制的。 尤其在单处理器系统中，使用多个线程不会使主要消耗 CPU 资源的程序运行得更快。<br><a id="more"></a></p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>以下示例使用两个线程，一个用于计时，一个用于执行实际工作。主线程使用非常简单的算法计算<br>素数。<br>在它启动之前，它创建并启动一个计时器线程，这个线程会休眠十秒钟，然后设置一个主线程要检查的标志。十秒钟之后，主线程将停止。请注意，共享标志被声明成 volatile。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalculatePrimes</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_PRIMES = <span class="number">1000000</span>; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TEN_SECONDS = <span class="number">10000</span>; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> finished = <span class="keyword">false</span>; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">int</span>[] primes = <span class="keyword">new</span> <span class="keyword">int</span>[MAX_PRIMES]; </span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>; count&lt;MAX_PRIMES; i++) &#123; </span><br><span class="line">        <span class="comment">// Check to see if the timer has expired </span></span><br><span class="line">            <span class="keyword">if</span> (finished) &#123; </span><br><span class="line">            <span class="keyword">break</span>; &#125; </span><br><span class="line">        <span class="keyword">boolean</span> prime = <span class="keyword">true</span>; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;count; j++) &#123; </span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>) &#123; </span><br><span class="line">                  prime = <span class="keyword">false</span>; </span><br><span class="line">               <span class="keyword">break</span>; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span> (prime) &#123; </span><br><span class="line">            primes[count++] = i; </span><br><span class="line">            System.out.println(<span class="string">"Found prime: "</span> + i); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">    CalculatePrimes calculator = <span class="keyword">new</span> CalculatePrimes(); </span><br><span class="line">    calculator.start(); </span><br><span class="line">    <span class="keyword">try</span> &#123; </span><br><span class="line">    Thread.sleep(TEN_SECONDS); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">catch</span> (InterruptedException e) &#123; </span><br><span class="line">    <span class="comment">// fall through </span></span><br><span class="line">    &#125; </span><br><span class="line">    calculator.finished = <span class="keyword">true</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程的生命"><a href="#线程的生命" class="headerlink" title="线程的生命"></a>线程的生命</h2><h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><p>在 Java 程序中创建线程有几种方法。每个 Java程序至少包含一个线程：主线程。其它线程都是通过 Thread 构造器或实例化继承类 Thread 的类来创建的。</p><p>Java 线程可以通过直接实例化 Thread 对象或实例化继承 Thread 的对象来创建其它线程。在线程基础中的示例（其中，我们在十秒钟之内计算尽量多的素数）中，我们通过实例化 CalculatePrimes 类型的对象（它继承了 Thread），创建了一个线程。</p><p>当我们讨论 Java 程序中的线程时，也许会提到两个相关实体：完成工作的实际线程或代表线程的Thread 对象。正在运行的线程通常是由操作系统创建的；Thread 对象是由 Java VM 创建的，作为控制相关线程的一种方式。</p><h3 id="创建线程和启动线程并不相同"><a href="#创建线程和启动线程并不相同" class="headerlink" title="创建线程和启动线程并不相同"></a>创建线程和启动线程并不相同</h3><p>在一个线程对新线程的 Thread 对象调用 start() 方法之前，这个新线程并没有真正开始执行。<br>Thread 对象在其线程真正启动之前就已经存在了，而且其线程退出之后仍然存在。这可以让您控制或获取关于已创建的线程的信息，即使线程还没有启动或已经完成了。</p><p>通常在构造器中通过 start()启动线程并不是好主意。这样做，会把部分构造的对象暴露给新的线程。如果对象拥有一个线程，那么它应该提供一个启动该线程的 start() 或 init() 方法，而不是从构造器中启动它。</p><h3 id="结束线程"><a href="#结束线程" class="headerlink" title="结束线程"></a>结束线程</h3><p>线程会以以下三种方式之一结束：</p><ul><li>线程到达其 run() 方法的末尾。</li><li>线程抛出一个未捕获到的 Exception 或 Error。</li><li>另一个线程调用一个弃用的stop()方法。弃用是指这些方法仍然存在，但是您不应该在新代码中使用它们，并且应该尽量从现有代码中除去它们。<br>当 Java 程序中的所有线程都完成时，程序就退出了。</li></ul><h3 id="加入线程"><a href="#加入线程" class="headerlink" title="加入线程"></a>加入线程</h3><p>Thread API 包含了等待另一个线程完成的方法：join() 方法。当调用 Thread.join() 时，调用线程将阻塞，直到目标线程完成为止。</p><p>Thread.join() 通常由使用线程的程序使用，以将大问题划分成许多小问题，每个小问题分配一个线程。本章结尾处的示例创建了十个线程，启动它们，然后使用Thread.join() 等待它们全部完成。</p><h3 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h3><p>除了何时使用 Thread.join() 和 Object.wait() 外，线程调度和执行的计时是不确定的。如果两个线程同时运行，而且都不等待，您必须假设在任何两个指令之间，其它线程都可以运行并修改程序变量。如果线程要访问其它线程可以看见的变量，如从静态字段（全局变量）直接或间接引用的数据，则必须使用同步以确保数据一致性。</p><p>在以下的简单示例中，我们将创建并启动两个线程，每个线程都打印两行到 System.out</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoThreads</span> </span>&#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        System.out.println(<span class="string">"A"</span>); </span><br><span class="line">        System.out.println(<span class="string">"B"</span>); </span><br><span class="line">    &#125; </span><br><span class="line"> &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread2</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123; </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">            System.out.println(<span class="string">"1"</span>); </span><br><span class="line">            System.out.println(<span class="string">"2"</span>); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">new</span> Thread1().start(); </span><br><span class="line">        <span class="keyword">new</span> Thread2().start(); </span><br><span class="line">    &#125; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>我们并不知道这些行按什么顺序执行，只知道“1”在“2”之前打印，以及“A”在“B”之前打印,输出可能是”12AB”、”1A2B”等等的任何一种。</p><h3 id="休眠"><a href="#休眠" class="headerlink" title="休眠"></a>休眠</h3><p>Thread API 包含了一个sleep()方法，它将使当前线程进入等待状态，直到过了一段指定时间，或者直到另一个线程对当前线程的 Thread 对象调用了 Thread.interrupt()，从而中断了线程。当过了指定时间后，线程又将变成可运行的，并且回到调度程序的可运行线程队列中。</p><p>如果线程是由对 Thread.interrupt() 的调用而中断的，那么休眠的线程会抛出<br>InterruptedException，这样线程就知道它是由中断唤醒的，就不必查看计时器是否过期。</p><p>Thread.yield() 方法就象 Thread.sleep() 一样，但它并不引起休眠，而只是暂停当前线程片刻，这样其它线程就可以运行了。在大多数实现中，当较高优先级的线程调用 Thread.yield() 时，较低优先级的线程就不会运行。</p><p>CalculatePrimes 示例使用了一个后台线程计算素数，然后休眠十秒钟。当计时器过期后，它就会设置一个标志，表示已经过了十秒。</p><h3 id="守护程序线程"><a href="#守护程序线程" class="headerlink" title="守护程序线程"></a>守护程序线程</h3><p>我们提到过当 Java 程序的所有线程都完成时，该程序就退出，但这并不完全正确。隐藏的系统线程，如垃圾收集线程和由JVM创建的其它线程会怎么样？我们没有办法停止这些线程。如果那些线程正在运行，那么 Java 程序怎么退出呢？</p><p>这些系统线程称作守护程序线程。Java程序实际上是在它的所有非守护程序线程完成后退出的。</p><p>任何线程都可以变成守护程序线程。可以通过调用 Thread.setDaemon() 方法来指明某个线程是守护程序线程。您也许想要使用守护程序线程作为在程序中创建的后台线程，如计时器线程或其它延迟的事件线程，只有当其它非守护程序线程正在运行时，这些线程才有用。</p><h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><p>在这个示例中，TenThreads显示了一个创建了十个线程的程序，每个线程都执行一部分工作。该程序等待所有线程全部完成，然后收集结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TenThreads</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE; </span><br><span class="line">    <span class="keyword">int</span>[] ourArray; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WorkerThread</span><span class="params">(<span class="keyword">int</span>[] ourArray)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.ourArray = ourArray; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// Find the maximum value in our particular piece of the array </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ourArray.length; i++) </span><br><span class="line">            max = Math.max(max, ourArray[i]); </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMax</span><span class="params">()</span> </span>&#123; </span><br><span class="line">            <span class="keyword">return</span> max; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">        WorkerThread[] threads = <span class="keyword">new</span> WorkerThread[<span class="number">10</span>]; </span><br><span class="line">        <span class="keyword">int</span>[][] bigMatrix = getBigHairyMatrix(); </span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE; </span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Give each thread a slice of the matrix to work with </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123; </span><br><span class="line">            threads[i] = <span class="keyword">new</span> WorkerThread(bigMatrix[i]); </span><br><span class="line">             threads[i].start(); </span><br><span class="line">             &#125; </span><br><span class="line">        <span class="comment">// Wait for each thread to finish </span></span><br><span class="line">        <span class="keyword">try</span> &#123; </span><br><span class="line">             <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123; </span><br><span class="line">             threads[i].join(); </span><br><span class="line">             max = Math.max(max, threads[i].getMax()); </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">catch</span> (InterruptedException e) &#123; </span><br><span class="line">         <span class="comment">// fall through </span></span><br><span class="line">        &#125; </span><br><span class="line">        System.out.println(<span class="string">"Maximum value was "</span> + max); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>就象程序一样，线程有生命周期：它们启动、执行，然后完成。一个程序或进程也许包含多个线程，而这些线程看来互相单独地执行。</p><p>线程是通过实例化 Thread 对象或实例化继承 Thread 的对象来创建的，但在对新的 Thread 对象调用 start() 方法之前，这个线程并没有开始执行。当线程运行到其 run() 方法的末尾或抛出未经处理的异常时，它们就结束了。</p><p>sleep() 方法可以用于等待一段特定时间；而 join()方法可能用于等到另一个线程完成。</p><h2 id="共享对数据的访问"><a href="#共享对数据的访问" class="headerlink" title="共享对数据的访问"></a>共享对数据的访问</h2><h3 id="受控访问的同步"><a href="#受控访问的同步" class="headerlink" title="受控访问的同步"></a>受控访问的同步</h3><p>为了确保可以在线程之间以受控方式共享数据，Java语言提供了两个关键字：synchronized 和volatile。</p><p>Synchronized 有两个重要含义：它确保了一次只有一个线程可以执行代码的受保护部分（互斥，mutual exclusion或者说mutex），而且它确保了一个线程更改的数据对于其它线程是可见的（更改的可见性）。</p><p>如果没有同步，数据很容易就处于不一致状态。例如，如果一个线程正在更新两个相关值（比如，粒子的位置和速率），而另一个线程正在读取这两个值，有可能在第一个线程只写了一个值，还没有写另一个值的时候，调度第二个线程运行，这样它就会看到一个旧值和一个新值。同步让我们可以定义必须原子地运行的代码块，这样对于其他线程而言，它们要么都执行，要么都不执行。</p><p>同步的原子执行或互斥方面类似于其它操作环境中的临界段的概念。</p><h3 id="用锁保护的原子代码块"><a href="#用锁保护的原子代码块" class="headerlink" title="用锁保护的原子代码块"></a>用锁保护的原子代码块</h3><p>Volatile 对于确保每个线程看到最新的变量值非常有用，但有时我们需要保护比较大的代码片段，如涉及更新多个变量的片段。</p><p>同步使用监控器（monitor）或锁的概念，以协调对特定代码块的访问。</p><p>每个 Java 对象都有一个相关的锁。同一时间只能有一个线程持有 Java 锁。当线程进入synchronized代码块时，线程会阻塞并等待，直到锁可用，当它可用时，就会获得这个锁，然后执行代码块。当控制退出受保护的代码块时，即到达了代码块末尾或者抛出了没有在 synchronized 块中捕获的异常时，它就会释放该锁。</p><p>这样，每次只有一个线程可以执行受给定监控器保护的代码块。从其它线程的角度看，该代码块可以看作是原子的，它要么全部执行，要么根本不执行。</p><h3 id="同步例子"><a href="#同步例子" class="headerlink" title="同步例子"></a>同步例子</h3><p>使用 synchronized 块可以让您将一组相关更新作为一个集合来执行，而不必担心其它线程中断或看到计算的中间结果。以下示例代码将打印“1 0”或“01”。如果没有同步，它还会打印“1 1”（或“0 0”，随便您信不信）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncExample</span> </span>&#123; </span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> lockObject = <span class="keyword">new</span> Object(); </span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123; </span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">            <span class="keyword">synchronized</span> (lockObject) &#123; </span><br><span class="line">                x = y = <span class="number">0</span>; </span><br><span class="line">                System.out.println(x); </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">     &#125; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread2</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123; </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">             <span class="keyword">synchronized</span> (lockObject) &#123; </span><br><span class="line">             x = y = <span class="number">1</span>; </span><br><span class="line">             System.out.println(y); </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">     <span class="keyword">new</span> Thread1().run(); </span><br><span class="line">     <span class="keyword">new</span> Thread2().run(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这两个线程中都必须使用同步，以便使这个程序正确工作。</p><h3 id="Java-锁定"><a href="#Java-锁定" class="headerlink" title="Java 锁定"></a>Java 锁定</h3><p>Java 锁定合并了一种互斥形式。每次只有一个线程可以持有锁。锁用于保护代码块或整个方法，必须记住是锁的身份保护了代码块，而不是代码块本身，这一点很重要。一个锁可以保护许多代码块或方法。</p><p>反之，仅仅因为代码块由锁保护并不表示两个线程不能同时执行该代码块。它只表示如果两个线程正在等待相同的锁，则它们不能同时执行该代码。</p><p>在以下示例中，两个线程可以同时不受限制地执行 setLastAccess() 中的 synchronized 块，因为每个线程有一个不同的 thingie 值。因此，synchronized 代码块受到两个正在执行的线程中不同锁的保护。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncExample</span> </span>&#123; </span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Thingie</span> </span>&#123; </span><br><span class="line">         <span class="keyword">private</span> Date lastAccess; </span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setLastAccess</span><span class="params">(Date date)</span> </span>&#123; </span><br><span class="line">            <span class="keyword">this</span>.lastAccess = date; </span><br><span class="line">         &#125; </span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123; </span><br><span class="line">         <span class="keyword">private</span> Thingie thingie; </span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(Thingie thingie)</span> </span>&#123; </span><br><span class="line">         <span class="keyword">this</span>.thingie = thingie; </span><br><span class="line">         &#125; </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">            thingie.setLastAccess(<span class="keyword">new</span> Date()); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">         Thingie thingie1 = <span class="keyword">new</span> Thingie(), </span><br><span class="line">         thingie2 = <span class="keyword">new</span> Thingie(); </span><br><span class="line">         <span class="keyword">new</span> MyThread(thingie1).start(); </span><br><span class="line">         <span class="keyword">new</span> MyThread(thingie2).start(); </span><br><span class="line">     &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="同步的方法"><a href="#同步的方法" class="headerlink" title="同步的方法"></a>同步的方法</h3><p>创建 synchronized 块的最简单方法是将方法声明成synchronized。这表示在进入方法主体之前，调用者必须获得锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123; </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setXY</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; </span><br><span class="line">         <span class="keyword">this</span>.x = x; </span><br><span class="line">         <span class="keyword">this</span>.y = y; </span><br><span class="line">     &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于普通的 synchronized 方法，这个锁是一个对象，将针对它调用方法。对于静态 synchronized 方法，这个锁是与 Class 对象相关的监控器，在该对象中声明了方法。</p><p>仅仅因为 setXY() 被声明成 synchronized 并不表示两个不同的线程不能同时执行 setXY()，只要它们调用不同的 Point 实例的 setXY() 就可同时执行。对于一个 Point 实例，一次只能有一个线程执行 setXY()，或 Point 的任何其它 synchronized 方法。</p><h3 id="同步的块"><a href="#同步的块" class="headerlink" title="同步的块"></a>同步的块</h3><p>synchronized 块的语法比synchronized方法稍微复杂一点，因为还需要显式地指定锁要保护哪个块。Point 的以下版本等价于前一页中显示的版本：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123; </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setXY</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; </span><br><span class="line">         <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123; </span><br><span class="line">             <span class="keyword">this</span>.x = x; </span><br><span class="line">             <span class="keyword">this</span>.y = y; </span><br><span class="line">         &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 this 引用作为锁很常见，但这并不是必需的。这表示该代码块将与这个类中的 synchronized 方法使用同一个锁。</p><p>由于同步防止了多个线程同时执行一个代码块，因此性能上就有问题，即使是在单处理器系统上。最好在尽可能最小的需要保护的代码块上使用同步。</p><p>访问局部（基于堆栈的）变量从来不需要受到保护，因为它们只能被自己所属的线程访问。</p><h3 id="大多数类并没有同步"><a href="#大多数类并没有同步" class="headerlink" title="大多数类并没有同步"></a>大多数类并没有同步</h3><p>因为同步会带来小小的性能损失，大多数通用类，如 java.util 中的 Collection 类，不在内部使用同步。这表示在没有附加同步的情况下，不能在多个线程中使用诸如 HashMap 这样的类。</p><p>通过每次访问共享集合中的方法时使用同步，可以在多线程应用程序中使用 Collection 类。对于任何给定的集合，每次必须用同一个锁进行同步。通常可以选择集合对象本身作为锁。</p><p>下一页中的示例类 SimpleCache显示了如何使用HashMap以线程安全的方式提供高速缓存。但是，通常适当的同步并不只是意味着同步每个方法。</p><p>Collections 类提供了一组便利的用于 List、Map 和 Set 接口的封装器。您可以用Collections.synchronizedMap 封装Map，它将确保所有对该映射的访问都被正确同步。<br>如果类的文档没有说明它是线程安全的，那么您必须假设它不是。</p><h3 id="示例：简单的线程安全的高速缓存"><a href="#示例：简单的线程安全的高速缓存" class="headerlink" title="示例：简单的线程安全的高速缓存"></a>示例：简单的线程安全的高速缓存</h3><p>如以下代码样本所示，SimpleCache.java使用HashMap为对象装入器提供了一个简单的高速缓存。load() 方法知道怎样按对象的键装入对象。在一次装入对象之后，该对象就被存储到高速缓存中，这样以后的访问就会从高速缓存中检索它，而不是每次都全部地装入它。对共享高速缓存的每个访问都受到synchronized块保护。由于它被正确同步，所以多个线程可以同时调用 getObject 和clearCache 方法，而没有数据损坏的风险。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleCache</span> </span>&#123; </span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">final</span> Map cache = <span class="keyword">new</span> HashMap(); </span><br><span class="line">         <span class="function"><span class="keyword">public</span> Object <span class="title">load</span><span class="params">(String objectName)</span> </span>&#123; </span><br><span class="line">         <span class="comment">// load the object somehow </span></span><br><span class="line">     &#125; </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clearCache</span><span class="params">()</span> </span>&#123; </span><br><span class="line">         <span class="keyword">synchronized</span> (cache) &#123; </span><br><span class="line">            cache.clear(); </span><br><span class="line">         &#125; </span><br><span class="line">     &#125; </span><br><span class="line">     <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">(String objectName)</span> </span>&#123; </span><br><span class="line">         <span class="keyword">synchronized</span> (cache) &#123; </span><br><span class="line">             Object o = cache.get(objectName); </span><br><span class="line">             <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123; </span><br><span class="line">                 o = load(objectName); </span><br><span class="line">                 cache.put(objectName, o); </span><br><span class="line">             &#125; </span><br><span class="line">         &#125; </span><br><span class="line">     <span class="keyword">return</span> o; </span><br><span class="line">     &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>由于线程执行的计时是不确定的，我们需要小心，以控制线程对共享数据的访问。否则，多个并发线程会互相干扰对方的更改，从而损坏数据，或者其它线程也许不能及时看到对共享数据的更改。</p><p>通过使用同步来保护对共享变量的访问，我们可以确保线程以可预料的方式与程序变量进行交互.</p><p>每个 Java 对象都可以充当锁，synchronized块可以确保一次只有一个线程执行由给定锁保护的synchronized 代码。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;线程基础&quot;&gt;&lt;a href=&quot;#线程基础&quot; class=&quot;headerlink&quot; title=&quot;线程基础&quot;&gt;&lt;/a&gt;线程基础&lt;/h2&gt;&lt;h3 id=&quot;什么是线程？&quot;&gt;&lt;a href=&quot;#什么是线程？&quot; class=&quot;headerlink&quot; title=&quot;什么是线程？&quot;&gt;&lt;/a&gt;什么是线程？&lt;/h3&gt;&lt;p&gt;几乎每种操作系统都支持进程的概念 —— 进程就是在某种程度上相互隔离的、独立运行的程序。&lt;/p&gt;&lt;p&gt;线程化是允许多个活动共存于一个进程中的工具。大多数现代的操作系统都支持线程，而且线程的&lt;br&gt;概念以各种形式已存在了好多年。Java 是第一个在语言本身中显式地包含线程的主流编程语言，它没有把线程化看作是底层操作系统的工具。&lt;/p&gt;&lt;p&gt;有时候，线程也称作轻量级进程。就象进程一样，线程在程序中是独立的、并发的执行路径，每个线程有它自己的堆栈、自己的程序计数器和自己的局部变量。但是，与分隔的进程相比，进程中的线程之间的隔离程度要小。它们共享内存、文件句柄和其它每个进程应有的状态。&lt;/p&gt;&lt;p&gt;进程可以支持多个线程，它们看似同时执行，但互相之间并不同步。一个进程中的多个线程共享相同的内存地址空间，这就意味着它们可以访问相同的变量和对象，而且它们从同一堆中分配对象。尽管这让线程之间共享信息变得更容易，但您必须小心，确保它们不会妨碍同一进程里的其它线程。&lt;/p&gt;&lt;p&gt;Java 线程工具和 API 看似简单。但是，编写有效使用线程的复杂程序并不十分容易。因为有多个线程共存在相同的内存空间中并共享相同的变量，所以您必须小心，确保您的线程不会互相干扰。&lt;/p&gt;&lt;h3 id=&quot;每个-Java-程序都使用线程&quot;&gt;&lt;a href=&quot;#每个-Java-程序都使用线程&quot; class=&quot;headerlink&quot; title=&quot;每个 Java 程序都使用线程&quot;&gt;&lt;/a&gt;每个 Java 程序都使用线程&lt;/h3&gt;&lt;p&gt;每个 Java 程序都至少有一个线程 — 主线程。当一个 Java 程序启动时，JVM 会创建主线程，并在该线程中调用程序的 main() 方法。 JVM 还创建了其它线程，您通常都看不到它们 — 例如，与垃圾收集、对象终止和其它 JVM 内务处理任务相关的线程。其它工具也创建线程，如 AWT（抽象窗口工具箱（Abstract Windowing Toolkit））或 Swing UI 工具箱、servlet 容器、应用程序服务器和 RMI（远程方法调用（Remote Method Invocation））&lt;/p&gt;&lt;h3 id=&quot;Java-线程的风险&quot;&gt;&lt;a href=&quot;#Java-线程的风险&quot; class=&quot;headerlink&quot; title=&quot;Java 线程的风险&quot;&gt;&lt;/a&gt;Java 线程的风险&lt;/h3&gt;&lt;p&gt;虽然 Java 线程工具非常易于使用，但当我们创建多线程程序时，应该尽量避免一些风险。&lt;br&gt;当多个线程访问同一数据项（如静态字段、可全局访问对象的实例字段或共享集合）时，需要确保它们协调了对数据的访问，这样它们都可以看到数据的一致视图，而且相互不会干扰另一方的更改。&lt;br&gt;为了实现这个目的，Java 语言提供了两个关键字：synchronized 和 volatile。当从多个线程中访问变量时，必须确保对该访问正确地进行了同步。对于简单变量，将变量声明成volatile 也许就足够了，但在大多数情况下，需要使用同步。&lt;br&gt;如果将要使用同步来保护对共享变量的访问，那么必须确保在程序中所有访问该变量的地方都使用同步。&lt;/p&gt;&lt;p&gt;虽然线程可以大大简化许多类型的应用程序，过度使用线程可能会危及程序的性能及其可维护性。&lt;br&gt;线程消耗了资源。因此，在不降低性能的情况下，可以创建的线程的数量是有限制的。 尤其在单处理器系统中，使用多个线程不会使主要消耗 CPU 资源的程序运行得更快。&lt;br&gt;
    
    </summary>
    
    
      <category term="java" scheme="https://little8.top/categories/java/"/>
    
    
      <category term="little_eight" scheme="https://little8.top/tags/little-eight/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot整合Dubbo(入门篇)</title>
    <link href="https://little8.top/2018/12/03/SpringBoot%E6%95%B4%E5%90%88Dubbo%EF%BC%88%E5%85%A5%E9%97%A8%E7%AF%87)/"/>
    <id>https://little8.top/2018/12/03/SpringBoot整合Dubbo（入门篇)/</id>
    <published>2018-12-03T10:35:52.000Z</published>
    <updated>2019-07-23T13:00:40.947Z</updated>
    
    <content type="html"><![CDATA[<h2 id="遇到的坑"><a href="#遇到的坑" class="headerlink" title="遇到的坑"></a>遇到的坑</h2><blockquote><ul><li>zookeeper版本不一致问题</li><li>虚拟机防火墙没关</li></ul></blockquote><h2 id="如何搭建"><a href="#如何搭建" class="headerlink" title="如何搭建"></a>如何搭建</h2><h3 id="Linux上安装zookeeper"><a href="#Linux上安装zookeeper" class="headerlink" title="Linux上安装zookeeper"></a>Linux上安装zookeeper</h3><p>因为最近在学习Linux，所以这个东西直接安装在本机的虚拟机上。（你也可以直接在windows上安装和启用zookeeper，道理是一样的，这里不多描述了。）</p><ul><li>linux命令直接下载<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://archive.apache.org/dist/zookeeper/zookeeper-3.4.8/zookeeper-3.4.8.tar.gz</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>这里有个坑，就是版本必须与程序里的依赖对应的版本一致，否则会出bug，而且不容易发现。</p></blockquote><ul><li>解压下载的tar,然后进入zookeeper根目录，新建data和logs俩个目录</li><li>用pwd复制目录名字，后面有用</li><li>从根目录进入conf目录下，把zoo_sample.cfg命名为zoo.cfg，删除zoo_sample.cfg</li><li>编辑zoo.cfg，把里面的dataDir=…删除，加上下面2行代码<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dataDir=/粘贴你自己zookeeper的目录/data</span><br><span class="line">dataLogDir=/粘贴你自己zookeeper的目录/logs</span><br></pre></td></tr></table></figure></li></ul><a id="more"></a><ul><li>返回zookeeper根目录，进入bin，然后运行以下代码</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./zkServer.sh start</span><br></pre></td></tr></table></figure><blockquote><p>输出Starting zookeeper … STARTED,代表启动成功。你也可以用<br>./zkServer.sh status 查看，输出Mode: standalone 代表启动中</p></blockquote><ul><li>关闭zookeeper是./zkServer.sh stop，暂时用不上</li><li>记得要把防火墙关了<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld.service</span><br><span class="line"></span><br><span class="line">这个你选择性用。关闭开机自启动：systemctl disable firewalld.service</span><br></pre></td></tr></table></figure></li></ul><h3 id="搭建springboot项目"><a href="#搭建springboot项目" class="headerlink" title="搭建springboot项目"></a>搭建springboot项目</h3><p>这里会分服务端跟消费端</p><h4 id="先新建主项目，作版本控制-springboot-dubbo"><a href="#先新建主项目，作版本控制-springboot-dubbo" class="headerlink" title="先新建主项目，作版本控制 springboot-dubbo"></a>先新建主项目，作版本控制 springboot-dubbo</h4><ul><li>我用的是idea，File -&gt; new-&gt; Project ,选择maven，第一页不用勾选任何东西，点next，填好项目的一些信息，一直next下去即可。</li><li>新建完成后，把不要的文件夹删除（.idea和src），然后在pom.xml里加入必要的依赖<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line"></span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">  &lt;groupId&gt;bdbk&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;springboot-dubbo&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">  &lt;packaging&gt;war&lt;/packaging&gt;</span><br><span class="line"></span><br><span class="line">  &lt;name&gt;springboot-dubbo Maven Webapp&lt;/name&gt;</span><br><span class="line"></span><br><span class="line">  &lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.1.1.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">  &lt;/parent&gt;</span><br><span class="line"></span><br><span class="line">  &lt;dependencies&gt;</span><br><span class="line">    &lt;!--web必要--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;!--test必要--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;!--引入dubbo的依赖--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;com.alibaba.spring.boot&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;2.0.0&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;!-- 引入zookeeper的依赖，就是这里引用的zookeeper版本必须对应服务器上的 --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;com.101tec&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;zkclient&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;0.9&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">  &lt;/dependencies&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure></li></ul><h4 id="然后新建服务端-dubbo-server"><a href="#然后新建服务端-dubbo-server" class="headerlink" title="然后新建服务端 dubbo-server"></a>然后新建服务端 dubbo-server</h4><ul><li>直接在 springboot-dubbo 项目上右键 选择new -&gt; Module</li><li>不用勾选next，然后输入 dubbo-server</li><li><p>新建后，在java目录下创建你自己的包（这里是bdbk），然后创建启动类 DubboServerApplication</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> bdbk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.spring.boot.annotation.EnableDubboConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDubboConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboServerApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SpringApplication.run(DubboServerApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>同包下（或者你再自己创建一个 service 包，因为是入门篇东西比较简单就不再区分结构了）创建接口类 HelloService</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> bdbk;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 接口类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> little_eight</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2018/12/3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  String <span class="title">sayHello</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建实现类 HelloServiceImpl</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> bdbk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.annotation.Service;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 接口实现类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> little_eight</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2018/12/3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServiceImpl</span> <span class="keyword">implements</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello "</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在resources目录下新建 application.yml 配置文件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 配置端口</span><br><span class="line">server:</span><br><span class="line">    port: 8081</span><br><span class="line"></span><br><span class="line"># dubbo配置</span><br><span class="line">spring:</span><br><span class="line">    dubbo:</span><br><span class="line">        application:</span><br><span class="line">            # 应用名称</span><br><span class="line">            name: dubbo-server</span><br><span class="line">            # 注册中心地址 这里要填你自己zookeeper的地址</span><br><span class="line">            registry: zookeeper://192.168.211.128:2181</span><br><span class="line">        protocol:</span><br><span class="line">            # 协议端口</span><br><span class="line">            port: 20880</span><br></pre></td></tr></table></figure></li></ul><h4 id="再创建消费端项目-dubbo-client-新建跟-dubbo-server-一样"><a href="#再创建消费端项目-dubbo-client-新建跟-dubbo-server-一样" class="headerlink" title="再创建消费端项目 dubbo-client ,新建跟 dubbo-server 一样"></a>再创建消费端项目 dubbo-client ,新建跟 dubbo-server 一样</h4><ul><li><p>因为要引用服务端，所以先在pom.xml里添加对应的依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">&lt;groupId&gt;bdbk&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;dubbo-client&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">&lt;packaging&gt;jar&lt;/packaging&gt;</span><br><span class="line"></span><br><span class="line">&lt;name&gt;dubbo-client&lt;/name&gt;</span><br><span class="line">&lt;description&gt;Demo project for Spring Boot&lt;/description&gt;</span><br><span class="line"></span><br><span class="line">&lt;parent&gt;</span><br><span class="line">&lt;groupId&gt;bdbk&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;springboot-dubbo&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">&lt;/parent&gt;</span><br><span class="line">&lt;!-- 添加服务端 --&gt;</span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;bdbk&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;dubbo-server&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure></li><li><p>新建包bdbk,然后创建启动类 DubboClientApplication</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> bdbk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.spring.boot.annotation.EnableDubboConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDubboConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboClientApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SpringApplication.run(DubboClientApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>再写个控制类 HelloController，作为测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> bdbk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.annotation.Reference;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 控制类 用于测试</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> little_eight</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2018/12/3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Reference</span></span><br><span class="line">    <span class="keyword">private</span> HelloService helloService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String hello = helloService.sayHello(<span class="string">"World"</span>);</span><br><span class="line">        <span class="keyword">return</span> hello;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在resources目录下新建application.yml配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 配置端口</span><br><span class="line">server:</span><br><span class="line">    port: 8082</span><br><span class="line"></span><br><span class="line"># dubbo配置</span><br><span class="line">spring:</span><br><span class="line">    dubbo:</span><br><span class="line">        application:</span><br><span class="line">            # 应用名称</span><br><span class="line">            name: dubbo-client</span><br><span class="line">            # 注册中心地址 这里要填你自己zookeeper的地址</span><br><span class="line">            registry: zookeeper://192.168.211.128:2181</span><br><span class="line">        protocol:</span><br><span class="line">            # 协议端口</span><br><span class="line">            port: 20881</span><br></pre></td></tr></table></figure></li></ul><h4 id="最后先启动服务端，再启动消费端。"><a href="#最后先启动服务端，再启动消费端。" class="headerlink" title="最后先启动服务端，再启动消费端。"></a>最后先启动服务端，再启动消费端。</h4><p><a href="http://localhost:8082" target="_blank" rel="noopener">点击访问</a>,页面输出Hello World即为成功。</p><h4 id="源码地址"><a href="#源码地址" class="headerlink" title="源码地址"></a>源码地址</h4><p><a href="https://github.com/little-eight-china/springboot-project/tree/master/springboot-dubbo" target="_blank" rel="noopener">github源码</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;遇到的坑&quot;&gt;&lt;a href=&quot;#遇到的坑&quot; class=&quot;headerlink&quot; title=&quot;遇到的坑&quot;&gt;&lt;/a&gt;遇到的坑&lt;/h2&gt;&lt;blockquote&gt;&lt;ul&gt;&lt;li&gt;zookeeper版本不一致问题&lt;/li&gt;&lt;li&gt;虚拟机防火墙没关&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;h2 id=&quot;如何搭建&quot;&gt;&lt;a href=&quot;#如何搭建&quot; class=&quot;headerlink&quot; title=&quot;如何搭建&quot;&gt;&lt;/a&gt;如何搭建&lt;/h2&gt;&lt;h3 id=&quot;Linux上安装zookeeper&quot;&gt;&lt;a href=&quot;#Linux上安装zookeeper&quot; class=&quot;headerlink&quot; title=&quot;Linux上安装zookeeper&quot;&gt;&lt;/a&gt;Linux上安装zookeeper&lt;/h3&gt;&lt;p&gt;因为最近在学习Linux，所以这个东西直接安装在本机的虚拟机上。（你也可以直接在windows上安装和启用zookeeper，道理是一样的，这里不多描述了。）&lt;/p&gt;&lt;ul&gt;&lt;li&gt;linux命令直接下载&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;wget https://archive.apache.org/dist/zookeeper/zookeeper-3.4.8/zookeeper-3.4.8.tar.gz&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote&gt;&lt;p&gt;这里有个坑，就是版本必须与程序里的依赖对应的版本一致，否则会出bug，而且不容易发现。&lt;/p&gt;&lt;/blockquote&gt;&lt;ul&gt;&lt;li&gt;解压下载的tar,然后进入zookeeper根目录，新建data和logs俩个目录&lt;/li&gt;&lt;li&gt;用pwd复制目录名字，后面有用&lt;/li&gt;&lt;li&gt;从根目录进入conf目录下，把zoo_sample.cfg命名为zoo.cfg，删除zoo_sample.cfg&lt;/li&gt;&lt;li&gt;编辑zoo.cfg，把里面的dataDir=…删除，加上下面2行代码&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dataDir=/粘贴你自己zookeeper的目录/data&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dataLogDir=/粘贴你自己zookeeper的目录/logs&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
      <category term="springboot" scheme="https://little8.top/categories/springboot/"/>
    
    
      <category term="little_eight" scheme="https://little8.top/tags/little-eight/"/>
    
  </entry>
  
</feed>
