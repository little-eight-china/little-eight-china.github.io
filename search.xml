<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Docker简单介绍</title>
    <url>/2019/02/27/Docker%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><ul>
<li>镜像（ Image ）</li>
<li>容器（ Container ）</li>
<li>仓库（ Repository ）</li>
</ul>
<h2 id="Docker镜像"><a href="#Docker镜像" class="headerlink" title="Docker镜像"></a>Docker镜像</h2><p>Docker 镜像（Image），就相当于是一个 root 文件系统，它除了提供容器运行时所需的程序、库、资<br>源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p>
<h3 id="分层存储"><a href="#分层存储" class="headerlink" title="分层存储"></a>分层存储</h3><p>因为镜像体积庞大，就将其设计成分层存储的架构，所以严格来说镜像由一组文件系统组成。<br>镜像构建时，会一层层构建，前一层是后一层的基础。。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。</p>
<span id="more"></span> 
<h2 id="Docker-容器"><a href="#Docker-容器" class="headerlink" title="Docker 容器"></a>Docker 容器</h2><p>容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p>
<h2 id="Docker仓库"><a href="#Docker仓库" class="headerlink" title="Docker仓库"></a>Docker仓库</h2><p>镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker仓库就是这样的服务。<br>一个 Docker Registry 中可以包含多个仓库（ Repository ）；每个仓库可以包含多个标签（ Tag ）；每个标签对应一个镜像。<br>通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 &lt;仓库名&gt;:&lt;标签&gt; 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签。<br>以 Ubuntu 镜像 为例， ubuntu 是仓库的名字，其内包含有不同的版本标签，如， 16.04 , 18.04。我们可以通过 ubuntu:14.04，或者ubuntu:18.04来具体指定所需哪个版本的镜像。如果忽略了标签，比如 ubuntu ，那将视为ubuntu:latest 。</p>
<h3 id="私有-Docker仓库"><a href="#私有-Docker仓库" class="headerlink" title="私有 Docker仓库"></a>私有 Docker仓库</h3><p>除了使用公开服务外，用户还可以在本地搭建私有Docker仓库。Docker官方提供了Docker仓库镜像，可以直接使用做为私有 Registry 服务。</p>
<h2 id="使用-Docker-镜像"><a href="#使用-Docker-镜像" class="headerlink" title="使用 Docker 镜像"></a>使用 Docker 镜像</h2><h3 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h3><p>从 Docker 镜像仓库获取镜像的命令是 docker pull 。其命令格式为：</p>
<blockquote>
<p>docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]</p>
</blockquote>
<ul>
<li>Docker 镜像仓库地址：地址的格式一般是 &lt;域名/IP&gt;[:端口号] 。默认地址是 Docker Hub。</li>
<li>仓库名：如之前所说，这里的仓库名是两段式名称，即&lt;用户名&gt;/&lt;软件名&gt;。对于DockerHub，如果不给出用户名，则默认为 library ，也就是官方镜像。<br>比如<!--more-->
<blockquote>
<p>$ docker pull ubuntu:18.04</p>
</blockquote>
</li>
</ul>
<p>18.04: Pulling from library/ubuntu<br>bf5d46315322: Pull complete<br>9f13e0ac480c: Pull complete<br>e8988b5b3097: Pull complete<br>40af181810e7: Pull complete<br>e6f7c7e5c03e: Pull complete<br>Digest: sha256:147913621d9cdea08853f6ba9116c2e27a3ceffecf3b49298<br>3ae97c3d643fbbe<br>Status: Downloaded newer image for ubuntu:18.04</p>
<p>上面的命令中没有给出 Docker 镜像仓库地址，因此将会从 Docker Hub 获取镜像。而镜像名称是 ubuntu:18.04 ，因此将会获取官方镜像 library/ubuntu仓库中标签为 18.04 的镜像。</p>
<h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>有了镜像后，我们就能够以这个镜像为基础启动并运行一个容器。以上面的<br>ubuntu:18.04 为例，如果我们打算启动里面的 bash 并且进行交互式操作的<br>话，可以执行下面的命令。</p>
<blockquote>
<p>$ docker run -it –rm <br>ubuntu:18.04 <br>bash<br>root@e7009c6ce357:/# cat /etc/os-release<br>NAME=”Ubuntu”<br>VERSION=”18.04.1 LTS (Bionic Beaver)”<br>ID=ubuntu<br>ID_LIKE=debian<br>PRETTY_NAME=”Ubuntu 18.04.1 LTS”<br>VERSION_ID=”18.04”<br>HOME_URL=”<a href="https://www.ubuntu.com/&quot;">https://www.ubuntu.com/&quot;</a><br>SUPPORT_URL=”<a href="https://help.ubuntu.com/&quot;">https://help.ubuntu.com/&quot;</a><br>BUG_REPORT_URL=”<a href="https://bugs.launchpad.net/ubuntu/&quot;">https://bugs.launchpad.net/ubuntu/&quot;</a><br>PRIVACY_POLICY_URL=”<a href="https://www.ubuntu.com/legal/terms-and-polic">https://www.ubuntu.com/legal/terms-and-polic</a><br>ies/privacy-policy”<br>VERSION_CODENAME=bionic<br>UBUNTU_CODENAME=bionic</p>
</blockquote>
<ul>
<li>docker run 就是运行容器的命令</li>
<li>-it ：这是两个参数，一个是 -i ：交互式操作，一个是 -t 终端。我们<br>这里打算进入 bash 执行一些命令并查看返回结果，因此我们需要交互式终<br>端。</li>
<li>–rm ：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需<br>求，退出的容器并不会立即删除，除非手动 docker rm 。我们这里只是随便<br>执行个命令，看看结果，不需要排障和保留结果，因此使用 –rm 可以避免<br>浪费空间。</li>
<li>ubuntu:18.04 ：这是指用 ubuntu:18.04 镜像为基础来启动容器。</li>
<li>bash ：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的<br>是 bash 。</li>
</ul>
<h3 id="列出镜像"><a href="#列出镜像" class="headerlink" title="列出镜像"></a>列出镜像</h3><p>要想列出已经下载下来的镜像，可以使用 docker image ls 命令。</p>
<blockquote>
<p>$ docker image ls<br>REPOSITORY TAG IMAGE ID CRE<br>ATED SIZE<br>redis latest 5f515359c7f8 5 d<br>ays ago 183 MB<br>nginx latest 05a60462f8ba 5 d<br>ays ago 181 MB<br>mongo 3.2 fe9198c04d62 5 d<br>ays ago 342 MB<br><none> <none> 00285df0df87 5 d<br>ays ago 342 MB<br>ubuntu 18.04 f753707788c5 4 w<br>eeks ago 127 MB<br>ubuntu latest f753707788c5 4 w<br>eeks ago 127 MB</p>
</blockquote>
<p>列表包含了 仓库名 、 标签 、 镜像 ID 、 创建时间 以及 所占用的空间 。</p>
<h3 id="删除本地镜像"><a href="#删除本地镜像" class="headerlink" title="删除本地镜像"></a>删除本地镜像</h3><p>如果要删除本地的镜像，可以使用 docker image rm 命令</p>
<h2 id="使用-Dockerfile-定制镜像"><a href="#使用-Dockerfile-定制镜像" class="headerlink" title="使用 Dockerfile 定制镜像"></a>使用 Dockerfile 定制镜像</h2><p>Dockerfile 是一个文本文件，其内包含了一条条的指令(Instruction)，每一条指令<br>构建一层，因此每一条指令的内容，就是描述该层应当如何构建。</p>
<p>看一个Dockerfile文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">FROM nginx</span><br><span class="line">RUN echo &#x27;<span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, Docker!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>&#x27; &gt; /usr/share/nginx/html/index</span><br><span class="line">.html</span><br></pre></td></tr></table></figure>

<h3 id="FROM-指定基础镜像"><a href="#FROM-指定基础镜像" class="headerlink" title="FROM 指定基础镜像"></a>FROM 指定基础镜像</h3><p>所谓定制镜像，那一定是以一个镜像为基础，在其上进行定制。就像我们之前运行<br>了一个 nginx 镜像的容器，再进行修改一样，基础镜像是必须指定的。而<br>FROM 就是指定基础镜像，因此一个 Dockerfile 中 FROM 是必备的指令，并<br>且必须是第一条指令。</p>
<h3 id="RUN-执行命令"><a href="#RUN-执行命令" class="headerlink" title="RUN 执行命令"></a>RUN 执行命令</h3><p>RUN 指令是用来执行命令行命令的。由于命令行的强大能力， RUN 指令在定制<br>镜像时是最常用的指令之一。其格式有两种：</p>
<ul>
<li>shell 格式： RUN &lt;命令&gt; ，就像直接在命令行中输入的命令一样。刚才写的<br>Dockerfile 中的 RUN 指令就是这种格式。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RUN echo &#x27;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#x27; &gt; /usr/share/nginx/html/index</span><br><span class="line">.html</span><br></pre></td></tr></table></figure></li>
<li>exec 格式： RUN [“可执行文件”, “参数1”, “参数2”] ，这更像是函数调用中<br>的格式。</li>
</ul>
<p>Dockerfile 支持 Shell 类的行尾添加 \ 的<br>命令换行方式，以及行首 # 进行注释的格式。良好的格式，比如换行、缩进、注<br>释等，会让维护、排障更为容易，这是一个比较好的习惯。</p>
<h3 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h3><p>在 Dockerfile 文件所在目录执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker build -t nginx:v3 .</span><br><span class="line">Sending build context to Docker daemon 2.048 kB</span><br><span class="line">Step 1 : FROM nginx</span><br><span class="line">---&gt; e43d811ce2f4</span><br><span class="line">Step 2 : RUN echo &#x27;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#x27; &gt; /usr/share/nginx/h</span><br><span class="line">tml/index.html</span><br><span class="line">---&gt; Running in 9cdc27646c7b</span><br><span class="line">---&gt; 44aa4490ce2c</span><br><span class="line">Removing intermediate container 9cdc27646c7b</span><br><span class="line">Successfully built 44aa4490ce2c</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里我们使用了 docker build 命令进行镜像构建。其格式为：</p>
<blockquote>
<p>docker build [选项] &lt;上下文路径/URL/-&gt;</p>
</blockquote>
<p>在这里我们指定了最终镜像的名称 -t nginx:v3 ，构建成功后，我们可以像之前<br>运行 nginx:v2 那样来运行这个镜像，其结果会和 nginx:v2 一样。</p>
<p>更多Dockerfile命令可参考官方文档：<a href="https://docs.docker.com/engine/reference/builder/">https://docs.docker.com/engine/reference/builder/</a></p>
<h2 id="docker使用"><a href="#docker使用" class="headerlink" title="docker使用"></a>docker使用</h2><h3 id="docker安装"><a href="#docker安装" class="headerlink" title="docker安装"></a>docker安装</h3><ul>
<li><p>使用 sudo 或 root 权限登录 Centos，确保 yum 包更新到最新。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo yum update</span><br></pre></td></tr></table></figure></li>
<li><p>执行 Docker 安装脚本。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ curl -fsSL https://get.docker.com -o get-docker.sh</span><br><span class="line">$ sudo sh get-docker.sh</span><br></pre></td></tr></table></figure></li>
<li><p>启动 Docker 进程。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo systemctl start docker</span><br></pre></td></tr></table></figure></li>
</ul>
<p>后期可能会出现这样的错误信息：</p>
<blockquote>
<p>Got permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Get http://%2Fvar%2Frun%2Fdocker.sock/v1.39/images/json: dial unix /var/run/docker.sock: connect: permission denied</p>
</blockquote>
<p>原因：</p>
<blockquote>
<p>docker守护进程启动的时候，会默认赋予名字为docker的用户组读写Unix socket的权限，因此只要创建docker用户组，并将当前用户加入到docker用户组中，那么当前用户就有权限访问Unix socket了，进而也就可以执行docker相关命令。</p>
</blockquote>
<p>解决方案</p>
<blockquote>
<p>.#添加docker用户组<br>sudo groupadd docker<br> #添加将登陆用户加入到docker用户组中<br>sudo gpasswd -a $USER docker<br> #将登陆用户加入到docker更新用户组中<br>newgrp docker     #更新用户组<br>docker ps<br> #测试docker命令是否可以使用sudo正常使用</p>
</blockquote>
<h2 id="Kubernetes（太多，后期再补充吧）"><a href="#Kubernetes（太多，后期再补充吧）" class="headerlink" title="Kubernetes（太多，后期再补充吧）"></a>Kubernetes（太多，后期再补充吧）</h2><p>Kubernetes，因为首尾字母中间有8个字符，所以被简写成 K8s。</p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>little_eight</tag>
      </tags>
  </entry>
  <entry>
    <title>Dockerfile命令</title>
    <url>/2019/03/12/Dockerfile%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="FROM指令"><a href="#FROM指令" class="headerlink" title="FROM指令"></a>FROM指令</h2><p>脚本的第1行是FROM指令。通过FROM指令，docker编译程序能够知道在哪个基础镜像执行来进行编译。所有的Dockerfile都必须以FROM指令开始。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FROM devops-reg.io/public/openjdk:8</span><br></pre></td></tr></table></figure>

<h2 id="MAINTAINER指令"><a href="#MAINTAINER指令" class="headerlink" title="MAINTAINER指令"></a>MAINTAINER指令</h2><p>第二条指令MAINTAINER，用来标明这个镜像的维护者信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#MAINTAINER xxxx@qq.com</span><br></pre></td></tr></table></figure>

<h2 id="RUN指令"><a href="#RUN指令" class="headerlink" title="RUN指令"></a>RUN指令</h2><p>接下来是RUN指令。这条指令用来在docker的编译环境中运行指定命令。上面这条指令会在编译环境运行/bin/sh -c “apt-get update &amp;&amp; apt-get -y install …”。RUN指令还有另外一种格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RUN [&quot;程序名&quot;, &quot;参数1&quot;, &quot;参数2&quot;]</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>这种格式运行程序，可以免除运行/bin/sh的消耗。这种格式使用Json格式将程序名与所需参数组成一个字符串数组，所以如果参数中有引号等特殊字符，需要进行转义。</p>
<h2 id="ENV指令"><a href="#ENV指令" class="headerlink" title="ENV指令"></a>ENV指令</h2><p>ENV指令用来指定在执行docker run命令运行镜像时，自动设置的环境变量。这些环境变量可以通过docker run命令的–evn参数来进行修改。</p>
<h2 id="COPY指令和ADD指令"><a href="#COPY指令和ADD指令" class="headerlink" title="COPY指令和ADD指令"></a>COPY指令和ADD指令</h2><p>COPY指令用来将本地（Dockerfile所在位置）的文件或文件夹复制到编译环境的指定路径下。上面的例子里，boot2docker的Dockerfile希望将与Dockerfile同一目录下的kernel_config文件复制到编译环境的/linux-kernal/.config。Dockerfile还提供了另外一个类似的指令：ADD。在复制文件方面ADD指令和COPY指令的格式和效果是完全一样的。这两个指令的区别主要由两点：</p>
<ul>
<li>ADD指令可以从一个URL地址下载内容复制到容器的文件系统中</li>
<li>ADD指令会将压缩打包格式的文件解开后复制到指定位置，而COPY指令只做复制操作</li>
</ul>
<h2 id="CMD指令"><a href="#CMD指令" class="headerlink" title="CMD指令"></a>CMD指令</h2><p>这是整个Dockerfile脚本的最后一条指令。当Dockerfile已经完成了所有环境的安装与配置，通过CMD指令来指示docker run命令运行镜像时要执行的命令。上面的例子里，在完成所有工作后，boot2docker的编译脚本将编译结果输出到本地环境下。</p>
<h3 id="其他指令"><a href="#其他指令" class="headerlink" title="其他指令"></a>其他指令</h3><h3 id="EXPOSE指令"><a href="#EXPOSE指令" class="headerlink" title="EXPOSE指令"></a>EXPOSE指令</h3><p>EXPOSE &lt;端口&gt; [&lt;端口&gt;…]指令用于标明，这个镜像中的应用将会侦听某个端口，并且希望能将这个端口映射到主机的网络界面上。但是，为了安全，docker run命令如果没有带上响应的端口映射参数，docker并不会将端口映射出了。</p>
<h3 id="ENTRYPOINT指令"><a href="#ENTRYPOINT指令" class="headerlink" title="ENTRYPOINT指令"></a>ENTRYPOINT指令</h3><p>ENTRYPOINT指令和前面介绍过的CMD一样，用于标明一个镜像作为容器运行时，最后要执行的程序或命令。这两个指令有相同之处，也有区别。通过两个指令的配合使用可以配置出不同的效果。</p>
<p>ENTRYPOINT指令有两种格式，CMD指令有三种格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ENTRYPOINT [&quot;程序名&quot;, &quot;参数1&quot;, &quot;参数2&quot;]</span><br><span class="line">ENTRYPOINT 命令 参数1 参数2</span><br><span class="line"></span><br><span class="line">CMD [&quot;程序名&quot;, &quot;参数1&quot;, &quot;参数2&quot;]</span><br><span class="line">CMD 命令 参数1 参数2</span><br><span class="line">CMD 参数1 参数2</span><br></pre></td></tr></table></figure>

<p>ENTRYPOINT是容器运行程序的入口。也就是说，在docker run命令中指定的命令都将作为参数提供给ENTRYPOINT指定的程序。同样，上面列举的CMD指令格式的后面两种格式也将作为参数提供给ENTRYPOINT指定的程序。</p>
<p>默认的ENTRYPOINT是/bin/sh -c。你可以根据实际需要任意设置。但是如果在一个Dockerfile中出现了多个ENTRYPOINT指令，那么，只有最后一个ENTRYPOINT指令是起效的。</p>
<p>一种常用的设置是将命令与必要参数设置到ENTRYPOINT中，而运行时只提供其他选项。例如：你有一个MySQL的客户端程序运行在容器中，而客户端所需要的主机地址、用户名和密码你不希望每次都输入，你就可以将ENTRYPOINT设置成：ENTRYPOINT mysql -u &lt;用户名&gt; -p &lt;密码&gt; -h &lt;主机名&gt;。而你运行时，只需要指定数据库名。</p>
<h3 id="VOLUME指令"><a href="#VOLUME指令" class="headerlink" title="VOLUME指令"></a>VOLUME指令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">VOLUME [&quot;路径&quot;]</span><br></pre></td></tr></table></figure>
<p>VOLUME指令用于在容器内创建一个或多个卷。而更多的时候，是在执行docker run时指定要创建的卷以及本地路径来进行映射。关于这个用法将在后面的章节学习到。</p>
<h3 id="USER指令"><a href="#USER指令" class="headerlink" title="USER指令"></a>USER指令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">USER 用户名或用户ID</span><br></pre></td></tr></table></figure>
<p>USER指令用于容器内运行RUN指令或CMD指令的用户。例如，在构建一个nginx镜像时，你希望最后运行nginx的用户为nginx，就可以在CMD [“nginx”]之前将用户设置为nginx。</p>
<p>如果在运行docker run命令时设置了-u 用户名参数，那么将覆盖USER指令设置的用户。</p>
<h3 id="WORKDIR指令"><a href="#WORKDIR指令" class="headerlink" title="WORKDIR指令"></a>WORKDIR指令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">WORKDIR 路径</span><br></pre></td></tr></table></figure>
<p>WORKDIR指令用于设置执行RUN指令、CMD指令和ENTRYPOINT指令执行时的工作目录。在Dockerfile中可以多次设置WORKDIR，在每次设置之后的命令将使用新的路径。</p>
<h3 id="ONBUILD指令"><a href="#ONBUILD指令" class="headerlink" title="ONBUILD指令"></a>ONBUILD指令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ONBUILD 指令</span><br></pre></td></tr></table></figure>
<p>ONBUILD指令用于设置一些指令，当本镜像作为基础镜像被其他Dockerfile用FROM指令引用时，在所有其他指令执行之前先执行这些指令。</p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>little_eight</tag>
      </tags>
  </entry>
  <entry>
    <title>Github Page+Hexo搭建个人博客</title>
    <url>/2018/07/16/Github%20Page+Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>简单介绍怎么搭起这个博客的</p>
<h3 id="首先执行四条命令（Hexo官网）"><a href="#首先执行四条命令（Hexo官网）" class="headerlink" title="首先执行四条命令（Hexo官网）"></a>首先执行四条命令（<a href="https://hexo.io/zh-cn">Hexo官网</a>）</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-cli -g</span><br><span class="line">$ hexo init blog</span><br><span class="line">$ <span class="built_in">cd</span> blog</span><br><span class="line">$ npm install</span><br><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>1、打开你的localhost:4000便可看到初始化的页面</p>
<h3 id="然后去下主题（现在用的是nexT）"><a href="#然后去下主题（现在用的是nexT）" class="headerlink" title="然后去下主题（现在用的是nexT）"></a>然后去下主题（现在用的是nexT）</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/theme-next/hexo-theme-next.git</span><br></pre></td></tr></table></figure>
<p>1、下完主题，把整个hexo-theme-next的文件夹拿到themes包下</p>
<p>2、修改根目录的配置_config.yml，把theme: 后面的改成hexo-theme-next</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">theme: hexo-theme-next</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>3、再执行命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo g</span><br><span class="line">$ hexo s</span><br></pre></td></tr></table></figure>
<p>4、打开你的localhost:4000，是不是变化了，当然还是英文的，如果你想主题为中文，改根目录配置_config.yml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">language: zh-cn</span><br></pre></td></tr></table></figure>
<h3 id="上传到github"><a href="#上传到github" class="headerlink" title="上传到github"></a>上传到github</h3><p>1、在自己的github上面新建一个repository,然后在repository name里输入你的 “用户名+.github.io”，create</p>
<p>2、在配置_config.yml修改对应的参数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repository: git@github.com:xx/xx.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<p>3、如果你是第一次装git，搞定你的ssh问题（<a href="https://www.cnblogs.com/ayseeing/p/3572582.html">随便百度的教材</a>）</p>
<p>3.5、如果步骤4会报错的话，就先装下git的插件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<p>4、运行命令吧</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<p>5、等它部署完成，访问你的地址</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">https://xx.github.io/</span><br></pre></td></tr></table></figure>

<h3 id="当然你也可以搞成自动化，参照这个"><a href="#当然你也可以搞成自动化，参照这个" class="headerlink" title="当然你也可以搞成自动化，参照这个"></a>当然你也可以搞成自动化，参照这个</h3><p><a href="https://segmentfault.com/a/1190000009054888">使用 Travis 自动部署 Hexo 到 Github 与 自己的服务器</a></p>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>little_eight</tag>
      </tags>
  </entry>
  <entry>
    <title>java线程池</title>
    <url>/2021/09/02/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<h1 id="线程池是什么"><a href="#线程池是什么" class="headerlink" title="线程池是什么"></a>线程池是什么</h1><p>线程池是一种基于池化思想管理线程的工具,是存储线程的容器,线程事先创建好后放入线程池,当有任务需要执行时,直接从线程池拿空闲线程使用,使用完毕后归还给线程池.</p>
<span id="more"></span>
<h1 id="为什么使用线程池"><a href="#为什么使用线程池" class="headerlink" title="为什么使用线程池"></a>为什么使用线程池</h1><p>线程过多会带来额外的开销，其中包括创建销毁线程的开销、调度线程的开销等等，同时也降低了计算机的整体性能。<br>线程池维护多个线程，等待监督管理者分配可并发执行的任务。<br>这种做法，一方面避免了处理任务时创建销毁线程开销的代价，另一方面避免了线程数量膨胀导致的过分调度问题，保证了对内核的充分利用。<br>可以用下面几点来概括使用线程池的好处。</p>
<ul>
<li>降低资源消耗：通过池化技术重复利用已创建的线程，降低线程创建和销毁造成的损耗。</li>
<li>提高响应速度：任务到达时，无需等待线程创建即可立即执行。</li>
<li>提高线程的可管理性：线程是稀缺资源，如果无限制创建，不仅会消耗系统资源，还会因为线程的不合理分布导致资源调度失衡，降低系统的稳定性。使用线程池可以进行统一的分配、调优和监控。</li>
<li>提供更多更强大的功能：线程池具备可拓展性，允许开发人员向其中增加更多的功能。比如延时定时线程池ScheduledThreadPoolExecutor，就允许任务延期执行或定期执行。</li>
</ul>
<h1 id="线程池核心设计与实现"><a href="#线程池核心设计与实现" class="headerlink" title="线程池核心设计与实现"></a>线程池核心设计与实现</h1><h2 id="ThreadPoolExecutor类"><a href="#ThreadPoolExecutor类" class="headerlink" title="ThreadPoolExecutor类"></a>ThreadPoolExecutor类</h2><h3 id="核心类关系"><a href="#核心类关系" class="headerlink" title="核心类关系"></a>核心类关系</h3><p>ThreadPoolExecutor -&gt; AbstractExecutorService -&gt; ExecutorService -&gt; Executor</p>
<p>ThreadPoolExecutor实现的顶层接口是Executor，顶层接口Executor提供了一种思想：将任务提交和任务执行进行解耦。用户无需关注如何创建线程，如何调度线程来执行任务，用户只需提供Runnable对象，将任务的运行逻辑提交到执行器(Executor)中，由Executor框架完成线程的调配和任务的执行部分。ExecutorService接口增加了一些能力：（1）扩充执行任务的能力，补充可以为一个或一批异步任务生成Future的方法；（2）提供了管控线程池的方法，比如停止线程池的运行。</p>
<p>AbstractExecutorService则是上层的抽象类，将执行任务的流程串联了起来，保证下层的实现只需关注一个执行任务的方法即可。最下层的实现类ThreadPoolExecutor实现最复杂的运行部分，ThreadPoolExecutor将会一方面维护自身的生命周期，另一方面同时管理线程和任务，使两者良好的结合从而执行并行任务。</p>
<p>ThreadPoolExecutor是如何运行，如何同时维护线程和执行任务的呢？其运行机制如下:</p>
<p>executor1</p>
<h3 id="七大参数"><a href="#七大参数" class="headerlink" title="七大参数"></a>七大参数</h3><ul>
<li>corePollSize：核心线程数。在创建了线程池后，线程中没有任何线程，等到有任务到来时才创建线程去执行任务。默认情况下，在创建了线程池后，线程池中的线程数为0，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到缓存队列当中。</li>
<li>maximumPoolSize：最大线程数。表明线程中最多能够创建的线程数量。</li>
<li>keepAliveTime：空闲的线程保留的时间。</li>
<li>TimeUnit：空闲线程的保留时间单位。</li>
<li>BlockingQueue：阻塞队列，存储等待执行的任务。</li>
<li>ThreadFactory：线程工厂，用来创建线程</li>
<li>RejectedExecutionHandler：队列已满，而且任务量大于最大线程的异常处理策略。</li>
</ul>
<h3 id="四大默认线程池"><a href="#四大默认线程池" class="headerlink" title="四大默认线程池"></a>四大默认线程池</h3><ul>
<li>newCachedThreadPool：创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。容易造成堆外内存溢出OOM，因为它的最大值是在初始化的时候设置为 Integer.MAX_VALUE</li>
<li>newFixedThreadPool: 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</li>
<li>newScheduledThreadPool: 创建一个定长线程池，支持定时及周期性任务执行。</li>
<li>newSingleThreadExecutor: 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</li>
</ul>
<h3 id="生命周期管理"><a href="#生命周期管理" class="headerlink" title="生命周期管理"></a>生命周期管理</h3><p>线程池运行的状态，并不是用户显式设置的，而是伴随着线程池的运行，由内部来维护。线程池内部使用一个变量维护两个值：运行状态(runState)和线程数量 (workerCount)。在具体实现中，线程池将运行状态(runState)、线程数量 (workerCount)两个关键参数的维护放在了一起，如下代码所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br></pre></td></tr></table></figure>
<p>ctl这个AtomicInteger类型，是对线程池的运行状态和线程池中有效线程的数量进行控制的一个字段， 它同时包含两部分的信息：线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount)，高3位保存runState，低29位保存workerCount，两个变量之间互不干扰。用一个变量去存储两个值，可避免在做相关决策时，出现不一致的情况，不必为了维护两者的一致，而占用锁资源。通过阅读线程池源代码也可以发现，经常出现要同时判断线程池运行状态和线程数量的情况。线程池也提供了若干方法去供用户获得线程池当前的运行状态、线程个数。这里都使用的是位运算的方式，相比于基本运算，速度也会快很多。</p>
<p>关于内部封装的获取生命周期状态、获取线程池线程数量的计算方法如以下代码所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125; <span class="comment">//计算当前运行状态</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;  <span class="comment">//计算当前线程数量</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;   <span class="comment">//通过状态和线程数生成ctl</span></span><br></pre></td></tr></table></figure>

<p>ThreadPoolExecutor的运行状态有5种，分别为：</p>
<ul>
<li>RUNNING：能接受新提交的任务，也能处理阻塞队列中的任务。</li>
<li>SHUTDOWN: 不再接受新提交的任务，但却可以继续处理阻塞队列的中的任务。</li>
<li>STOP: 不能接受新的任务，也不处理队列中的任务，同时终止正在处理任务的线程。</li>
<li>TIDYING: 所有任务都已终止了，workerCount有效线程数为0。</li>
<li>TERMINATEN: 在进行terminaten()方法后进入此状态。</li>
</ul>
<p>executor3</p>
<h3 id="任务执行机制"><a href="#任务执行机制" class="headerlink" title="任务执行机制"></a>任务执行机制</h3><p>任务调度是线程池的主要入口，当用户提交了一个任务，接下来这个任务将如何执行都是由这个阶段决定的。了解这部分就相当于了解了线程池的核心运行机制。</p>
<p>首先，所有任务的调度都是由execute方法完成的，这部分完成的工作是：检查现在线程池的运行状态、运行线程数、运行策略，决定接下来执行的流程，是直接申请线程执行，或是缓冲到队列中执行，亦或是直接拒绝该任务。其执行过程如下：</p>
<p>首先检测线程池运行状态，如果不是RUNNING，则直接拒绝，线程池要保证在RUNNING的状态下执行任务。<br>如果workerCount &lt; corePoolSize，则创建并启动一个线程来执行新提交的任务。<br>如果workerCount &gt;= corePoolSize，且线程池内的阻塞队列未满，则将任务添加到该阻塞队列中。<br>如果workerCount &gt;= corePoolSize &amp;&amp; workerCount &lt; maximumPoolSize，且线程池内的阻塞队列已满，则创建并启动一个线程来执行新提交的任务。<br>如果workerCount &gt;= maximumPoolSize，并且线程池内的阻塞队列已满, 则根据拒绝策略来处理该任务, 默认的处理方式是直接抛异常。<br>其执行流程如下图所示：</p>
<p>executor4</p>
<h3 id="任务缓冲"><a href="#任务缓冲" class="headerlink" title="任务缓冲"></a>任务缓冲</h3><p>任务缓冲模块是线程池能够管理任务的核心部分。线程池的本质是对任务和线程的管理，而做到这一点最关键的思想就是将任务和线程两者解耦，不让两者直接关联，才可以做后续的分配工作。线程池中是以生产者消费者模式，通过一个阻塞队列来实现的。阻塞队列缓存任务，工作线程从阻塞队列中获取任务。</p>
<p>阻塞队列(BlockingQueue)是一个支持两个附加操作的队列。这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。</p>
<p>使用不同的队列可以实现不一样的任务存取策略。在这里，我们可以再介绍下阻塞队列的成员：</p>
<ul>
<li>ArrayBlockingQueue: 一个用数组实现的有界阻塞队列。此队列按照先进先出的原则对元素进行排序。支持公平锁和非公平锁。</li>
<li>LinkedBlockingQueue：一个由链表结构组成的有界队列。此队列按照先进先出的原则对元素进行排序。默认长度是Integer最大值。</li>
<li>PriorityBlockingQueue：一个支持线程优先级排序的无界队列，默认自然排序，也可以自定义实现排序规则。</li>
<li>DelayQueue：一个实现实现延迟获取的无界队列。在创建元素的时候，可以指定多久才能从队列中获取当前元素。只有延时期满后才能从队列中获取元素。</li>
<li>SynchronousQueue：一个不存储元素的阻塞队列，每一个put操作必须等待take操作，否则不添加新元素。</li>
<li>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。</li>
<li>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。队列头部跟尾部都可以添加和移除元素，多线程并发时，可以将锁的竞争最多降到一半、</li>
</ul>
<h3 id="任务申请"><a href="#任务申请" class="headerlink" title="任务申请"></a>任务申请</h3><p>任务的执行有两种可能：一种是任务直接由新创建的线程执行。另一种是线程从任务队列中获取任务然后执行，执行完任务的空闲线程会再次去从队列中申请任务再去执行。第一种情况仅出现在线程初始创建的时候，第二种是线程获取任务绝大多数的情况。</p>
<p>executor5</p>
<p>getTask这部分进行了多次判断，为的是控制线程的数量，使其符合线程池的状态。如果线程池现在不应该持有那么多线程，则会返回null值。工作线程Worker会不断接收新任务去执行，而当工作线程Worker接收不到任务的时候，就会开始被回收。</p>
<h3 id="任务拒绝"><a href="#任务拒绝" class="headerlink" title="任务拒绝"></a>任务拒绝</h3><p>任务拒绝模块是线程池的保护部分，线程池有一个最大的容量，当线程池的任务缓存队列已满，并且线程池中的线程数目达到maximumPoolSize时，就需要拒绝掉该任务，采取任务拒绝策略，保护线程池。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>little_eight</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux的基本命令入门</title>
    <url>/2018/09/27/Linux%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="Linux的基本命令入门"><a href="#Linux的基本命令入门" class="headerlink" title="Linux的基本命令入门"></a>Linux的基本命令入门</h1><h2 id="目录切换命令"><a href="#目录切换命令" class="headerlink" title="目录切换命令"></a>目录切换命令</h2><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><ul>
<li>/ (根目录)<ul>
<li>bin（binaries）存放二进制可执行文件</li>
<li>boot 存放用于系统引导时使用的各种文件</li>
<li>dev （devices）用于存放设备文件</li>
<li>etc （etcetera）存放系统配置文件</li>
<li>home 存放用户文件的根目录<ul>
<li>每个用户的根目录的存放的位置，home下创建每个用户的根目录。</li>
<li>例如：用户是test，那么在home下就会存在一个叫test的目录</li>
</ul>
</li>
<li>lib （library）存放跟文件系统中的程序运行所需要的共享库及内核模块</li>
<li>sbin （super user binaries）存放二进制可执行文件，只有root才能访问</li>
<li>usr （unix shared resources）用于存放共享的系统资源</li>
<li>var （variable）用于存放运行时需要改变数据的文件</li>
<li>…<h3 id="目录切换命令-1"><a href="#目录切换命令-1" class="headerlink" title="目录切换命令"></a>目录切换命令</h3>cd usr        切换到该目录下usr目录<br>cd ../        切换到上一层目录<br>cd /        切换到系统根目录<br>cd ~        切换到用户主目录<br>cd -        切换到上一个所在目录<span id="more"></span>
<h2 id="目录的操作命令"><a href="#目录的操作命令" class="headerlink" title="目录的操作命令"></a>目录的操作命令</h2><h3 id="增加目录操作"><a href="#增加目录操作" class="headerlink" title="增加目录操作"></a>增加目录操作</h3>命令：mkdir 目录名称<br>示例：在根目录 / 下 mkdir test，就会在根目录 /下产生一个test问目录<br><img data-src="https://github.com/little-eight-china/image/blob/master/bdbk/linux/add.png?raw=true" alt="Alt"><h3 id="查看目录"><a href="#查看目录" class="headerlink" title="查看目录"></a>查看目录</h3>命令：ls [-al] 父目录<br>示例：在根目录 / 下使用ls，可以看到该目录下的所有的目录和文件<br><img data-src="https://github.com/little-eight-china/image/blob/master/bdbk/linux/query.png?raw=true" alt="Alt"><br>示例：在根目录 / 下使用ls -a，可以看到该目录下的所有文件和目录，包括隐藏的<br><img data-src="https://github.com/little-eight-china/image/blob/master/bdbk/linux/q21.png?raw=true" alt="Alt"><br>示例：在根目录 / 下使用ls -l（ls -l 可以缩写成ll），可以看到该目录下的所有目录和文件的详细信息<br><img data-src="https://github.com/little-eight-china/image/blob/master/bdbk/linux/query2.png?raw=true" alt="Alt"><h3 id="寻找目录"><a href="#寻找目录" class="headerlink" title="寻找目录"></a>寻找目录</h3>命令：find 目录 参数<br>示例：查找/root下的与test相关的目录(文件)  find /root -name ‘test*’<h3 id="修改目录的名称"><a href="#修改目录的名称" class="headerlink" title="修改目录的名称"></a>修改目录的名称</h3>命令：mv 目录名称 新目录名称（注意：mv的语法不仅可以对目录进行重命名而且也可以对各种文件，压缩包等进行    重命名的操作）<br>示例：test目录下有一个oldTest目录，使用mv oldTest newTest命令修改<br><img data-src="https://github.com/little-eight-china/image/blob/master/bdbk/linux/mv.png?raw=true" alt="Alt"><h3 id="移动目录的位置—剪切"><a href="#移动目录的位置—剪切" class="headerlink" title="移动目录的位置—剪切"></a>移动目录的位置—剪切</h3>命令：mv 目录名称 目录的新位置（注意：mv语法不仅可以对目录进行剪切操作，对文件和压缩包等都可执行剪切操作）<br>示例：在test下将newTest目录剪切到 /usr下面，使用mv newTest /usr<br><img data-src="https://github.com/little-eight-china/image/blob/master/bdbk/linux/move.png?raw=true" alt="Alt"></li>
</ul>
</li>
</ul>
<h3 id="拷贝目录"><a href="#拷贝目录" class="headerlink" title="拷贝目录"></a>拷贝目录</h3><p>命令：cp -r 目录名称 目录拷贝的目标位置 —–r代表递归拷贝（注意：cp命令不仅可以拷贝目录还可以拷贝文件，压缩包等，拷贝文件和压缩包时不    用写-r递归）<br>示例：将/usr下的newTest拷贝到根目录下的test中，使用cp -r /usr/newTest /test<br><img data-src="https://github.com/little-eight-china/image/blob/master/bdbk/linux/copy.png?raw=true" alt="Alt"></p>
<h3 id="删除目录"><a href="#删除目录" class="headerlink" title="删除目录"></a>删除目录</h3><p>命令：rm [-rf] 目录<br>示例：删除/usr下的newTest，进入/usr下使用rm -r newTest<br><img data-src="https://github.com/little-eight-china/image/blob/master/bdbk/linux/delete1.png?raw=true" alt="Alt"><br>示例：删除/test下的newTest而不需要询问强制删除，在/test下使用rm -rf newTest<br><img data-src="https://github.com/little-eight-china/image/blob/master/bdbk/linux/delete2.png?raw=true" alt="Alt"><br>注意：rm不仅可以删除目录，也可以删除其他文件或压缩包，为了增强大家的记忆，无论删除任何目录或文件，都直接使用rm -rf 目录/文件/压缩包</p>
<h2 id="文件的操作命令"><a href="#文件的操作命令" class="headerlink" title="文件的操作命令"></a>文件的操作命令</h2><h3 id="文件的创建"><a href="#文件的创建" class="headerlink" title="文件的创建"></a>文件的创建</h3><p>命令：touch 文件名称  —– 空文件<br>示例：在test目录下创建一个空文件 touch aaa.txt<br><img data-src="https://github.com/little-eight-china/image/blob/master/bdbk/linux/add2.png?raw=true" alt="Alt"></p>
<h3 id="文件的查看"><a href="#文件的查看" class="headerlink" title="文件的查看"></a>文件的查看</h3><p>命令：cat/more/less/tail 文件<br>示例：使用cat查看/etc/sudo.conf文件，只能显示最后一屏内容<br><img data-src="https://github.com/little-eight-china/image/blob/master/bdbk/linux/query3.png?raw=true" alt="Alt"><br>示例：使用more查看/etc/sudo.conf文件，可以显示百分比，回车可以向下一行，    空格可以向下一页，q可以退出查看<br><img data-src="https://github.com/little-eight-china/image/blob/master/bdbk/linux/query4.png?raw=true" alt="Alt"><br>示例：使用less查看/etc/sudo.conf文件，可以使用键盘上的PgUp和PgDn向上    和向下翻页，q结束查看<br><img data-src="https://github.com/little-eight-china/image/blob/master/bdbk/linux/query5.png?raw=true" alt="Alt"><br>示例：使用tail -10 查看/etc/sudo.conf文件的后10行，Ctrl+C结束<br><img data-src="https://github.com/little-eight-china/image/blob/master/bdbk/linux/query6.png?raw=true" alt="Alt"><br>注意：命令 tail -f 文件 可以对某个文件进行动态监控，例如tomcat的日志文件，    会随着程序的运行，日志会变化，可以使用tail -f catalina-2018-11-11.log 监控    文件的变化 </p>
<h3 id="修改文件的内容"><a href="#修改文件的内容" class="headerlink" title="修改文件的内容"></a>修改文件的内容</h3><p>命令：vim 文件<br>示例：编辑/test下的aaa.txt文件，使用vim aaa.txt<br>进入文件内容后，此时并不能编辑，因为此时处于命令模式，点击键盘i/a/o进入编辑模式，可以    编辑文件。编辑完成后，按下Esc，退回命令模式，此时文件虽然已经编辑完成，但是没有保存，需输入冒号：进入底行模式，在底行模    式下输入wq代表写入内容并退出，即保存；输入q!代表强制退出不保存。<br>关于vim使用过程：<br>在实际开发中，使用vim编辑器主要作用就是修改配置文件<br>vim 文件——&gt;进入文件—–&gt;命令模式——&gt;按i进入编辑模式—–&gt;编辑文件    ——-&gt;按Esc进入底行模式—–&gt;输入:wq/q!<br>（关于vim的操作，这里只做最简单的阐述）</p>
<h2 id="压缩文件的操作命令"><a href="#压缩文件的操作命令" class="headerlink" title="压缩文件的操作命令"></a>压缩文件的操作命令</h2><h3 id="打包并压缩文件"><a href="#打包并压缩文件" class="headerlink" title="打包并压缩文件"></a>打包并压缩文件</h3><p>Linux中的打包文件一般是以.tar结尾的，压缩的命令一般是以.gz结尾的。<br>而一般情况下打包和压缩是一起进行的，打包并压缩后的文件的后缀名一般.tar.gz。<br>命令：tar -zcvf 打包压缩后的文件名 要打包压缩的文件<br>其中：z：调用gzip压缩命令进行压缩<br>  c：打包文件<br>  v：显示运行过程<br>  f：指定文件名<br>示例：打包并压缩/test下的所有文件 压缩后的压缩包指定名称为xxx.tar.gz<br>tar -zcvf xxx.tar.gz aaa.txt bbb.txt ccc.txt<br>或：tar -zcvf xxx.tar.gz /test/*<br><img data-src="https://github.com/little-eight-china/image/blob/master/bdbk/linux/dabao1.png?raw=true" alt="Alt"></p>
<h3 id="解压压缩包"><a href="#解压压缩包" class="headerlink" title="解压压缩包"></a>解压压缩包</h3><p>命令：tar [-xvf] 压缩文件<br>其中：x：代表解压<br>示例：将/test下的xxx.tar.gz解压到当前目录下<br>tar -xvf xxx.tar.gz<br><img data-src="https://github.com/little-eight-china/image/blob/master/bdbk/linux/jieya1.png?raw=true" alt="Alt"><br>示例：将/test下的xxx.tar.gz解压到根目录/usr下<br>tar -xvf xxx.tar.gz -C /usr——C代表指定解压的位置<br><img data-src="https://github.com/little-eight-china/image/blob/master/bdbk/linux/jieya2.png?raw=true" alt="Alt"></p>
<h2 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h2><h3 id="显示当前所在位置"><a href="#显示当前所在位置" class="headerlink" title="显示当前所在位置"></a>显示当前所在位置</h3><p>命令：pwd<br><img data-src="" alt="Alt"></p>
<h3 id="搜索命令"><a href="#搜索命令" class="headerlink" title="搜索命令"></a>搜索命令</h3><p>命令：grep 要搜索的字符串 要搜索的文件<br>示例：搜索/usr/sudu.conf文件中包含字符串to的行<br><img data-src="https://github.com/little-eight-china/image/blob/master/bdbk/linux/sousuo1.png?raw=true" alt="Alt"><br>示例：搜索/usr/sudu.conf文件中包含字符串to的行 to要高亮显示<br><img data-src="https://github.com/little-eight-china/image/blob/master/bdbk/linux/sousuo2.png?raw=true" alt="Alt"></p>
<h3 id="管道命令"><a href="#管道命令" class="headerlink" title="管道命令"></a>管道命令</h3><p>命令：|   将前一个命令的输出作为本次目录的输入<br>示例：查看当前系统中所有的进程中包括system字符串的进程<br><img data-src="https://github.com/little-eight-china/image/blob/master/bdbk/linux/sousuo.png?raw=true" alt="Alt"></p>
<h3 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h3><p>命令：ps -ef<br>示例：查看当前系统中运行的进程 </p>
<h3 id="杀死进程"><a href="#杀死进程" class="headerlink" title="杀死进程"></a>杀死进程</h3><p>命令：kill -9 进程的pid</p>
<h3 id="网络通信命令"><a href="#网络通信命令" class="headerlink" title="网络通信命令"></a>网络通信命令</h3><p>查看当前系统的网卡信息：ifconfig<br><img data-src="https://github.com/little-eight-china/image/blob/master/bdbk/linux/ifconfig.png?raw=true" alt="Alt"></p>
<p>查看与某台机器的连接情况：ping<br><img data-src="https://github.com/little-eight-china/image/blob/master/bdbk/linux/ping.png?raw=true" alt="Alt"><br>查看当前系统的端口使用：netstat -an<br><img data-src="https://github.com/little-eight-china/image/blob/master/bdbk/linux/nes.png?raw=true" alt="Alt"></p>
<h1 id="Linux的权限命令"><a href="#Linux的权限命令" class="headerlink" title="Linux的权限命令"></a>Linux的权限命令</h1><h2 id="权限说明"><a href="#权限说明" class="headerlink" title="权限说明"></a>权限说明</h2><p>权限是Linux中的重要概念，每个文件/目录等都具有权限，通过ls -l命令我们可以    查看某个目录下的文件或目录的权限<br>示例：在随意某个目录下ls -l（用缩写。。这里为了美观）<br><img data-src="https://github.com/little-eight-china/image/blob/master/bdbk/linux/quanxian0.png?raw=true" alt="Alt"><br>第一列的内容的信息解释如下：<br><img data-src="https://github.com/little-eight-china/image/blob/master/bdbk/linux/quanxian.png?raw=true" alt="Alt"></p>
<ul>
<li>文件的类型:<ul>
<li> d：代表目录</li>
<li>-：代表文件</li>
<li>l：代表链接（可以认为是window中的快捷方式）</li>
<li>l：代表链接（可以认为是window中的快捷方式）<br>后面的9位分为3组，每3位置一组，分别代表属主的权限，与当前用户同组的    用户的权限，其他用户的权限</li>
<li>r：代表权限是可读，r也可以用数字4表示</li>
<li>w：代表权限是可写，w也可以用数字2表示</li>
<li>x：代表权限是可执行，x也可以用数字1表示<br><img data-src="https://github.com/little-eight-china/image/blob/master/bdbk/linux/quanxian2.jpg?raw=true" alt="Alt"><h2 id="修改文件-目录的权限的命令：chmod"><a href="#修改文件-目录的权限的命令：chmod" class="headerlink" title="修改文件/目录的权限的命令：chmod"></a>修改文件/目录的权限的命令：chmod</h2>示例：修改/test下的aaa.txt的权限为属主有全部权限，属主所在的组有读写权限，<br>其他用户只有读的权限<br>chmod u=rwx,g=rw,o=r aaa.txt<br><img data-src="https://github.com/little-eight-china/image/blob/master/bdbk/linux/chmod.png?raw=true" alt="Alt"><br>上述示例还可以使用数字表示：<br>chmod 764 aaa.txt</li>
</ul>
</li>
</ul>
<h2 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a>切换用户</h2><p>有时候用户并不是root用户，没有权限修改文件权限<br>命令：sudo su ，然后输入密码，回车<br>root用户转回普通用户<br>命令：exit</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>little_eight</tag>
      </tags>
  </entry>
  <entry>
    <title>MQ如何避免消息重复消费</title>
    <url>/2021/08/30/MQ%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E6%B6%88%E6%81%AF%E9%87%8D%E5%A4%8D%E6%B6%88%E8%B4%B9/</url>
    <content><![CDATA[<p>消息中间件是分布式系统常用的组件，无论是异步化、解耦、削峰等都有广泛的应用价值。</p>
<p>我们通常会认为，消息中间件是一个可靠的组件——这里所谓的可靠是指，只要我把消息成功投递到了消息中间件，消息就不会丢。<br>即消息肯定会至少保证消息能被消费者成功消费一次，这是消息中间件最基本的特性之一。<br>也就是我们常说的“AT LEAST ONCE”，即消息至少会被“成功消费一遍”。<br><strong>举个例子</strong>，一个消息 M 发送到了消息中间件，消息投递到了消费程序 A。A 接受到了消息，然后进行消费。但在消费到一半的时候程序重启了，这时候这个消息并没有标记为消费成功，这个消息还会继续投递给这个消费者，直到其消费成功了，消息中间件才会停止投递。<br><strong>然而这种可靠的特性会导致消息可能被多次地投递，</strong>这时候就可能出现程序 A 接受到这个消息 M 并完成消费逻辑之后，正想通知消息中间件“我已经消费成功了”的时候，程序就重启了，那么对于消息中间件来说，这个消息并没有成功消费过，所以它还会继续投递，但这时候对于应用程序 A 来说，看起来就是这个消息明明消费成功了，但是消息中间件还在重复投递。</p>
<span id="more"></span> 

<h2 id="简单的消息去重方案"><a href="#简单的消息去重方案" class="headerlink" title="简单的消息去重方案"></a>简单的消息去重方案</h2><p>假设我们业务的消息消费逻辑是：插入某张订单表的数据，然后更新库存。<br><strong>insert into t_order values …..update t_inv set count = count-1 where good_id = ‘good123’;</strong><br>要实现消息的幂等，只要先判断这个good_id是否存在即可。这对于很多情况下，的确能起到不错的效果，但是在并发场景下，还是会有问题。<br>​</p>
<h2 id="Exactly-Once"><a href="#Exactly-Once" class="headerlink" title="Exactly Once"></a>Exactly Once</h2><p>在消息中间件里，有一个投递语义的概念。而这个语义里有一个叫 Exactly Once ，即消息肯定会被成功消费，并且只会被消费一次。<br>以下是Exactly Once的通俗解释：<br>Exactly-Once 是指发送到消息系统的消息只能被消费端处理且仅处理一次，即使生产端重试消息发送导致某消息重复投递，该消息在消费端也只被消费一次。<br>在我们业务消息幂等处理的领域内，可以认为业务消息的代码肯定会被执行，并且只被执行一次，那么我们可以认为是 Exactly Once。<br>​</p>
<p>Exactly-Once 语义是消息系统和流式计算系统中消息流转的最理想状态，但是在业界并没有太多理想的实现。因为真正意义上的 Exactly-Once 依赖消息系统的服务端、消息系统的客户端和用户消费逻辑这三者状态的协调。<br>    <strong>例如</strong>，当您的消费端完成一条消息的消费处理后出现异常宕机，而消费端重启后由于消费的位点没有同步到消息系统的服务端，该消息有可能被重复消费。<br>业界对于 Exactly-Once 投递语义存在很大的争议，很多人会拿出“FLP不可能理论”或者其他一致性定律对此议题进行否定，但事实上，特定场景的Exactly-Once语义实现并不是非常复杂，只是因为通常大家没有精确的描述问题的本质。如果要实现一条消息的消费结果只能在业务系统中生效一次，需要解决的只是如何保证同一条消息的消费幂等问题。<br>​</p>
<p>要实现 Exaclty Once 即这个消息只被消费一次（并且肯定要保证能消费一次），我们可以这样做。<br>在数据库中增加一个消息消费记录表，把消息插入到这个表，并且把原来的订单更新和这个插入的动作放到同一个事务中一起提交，就能保证消息只会被消费一遍了。流程看起来像是这样的：</p>
<ol>
<li>开启事务</li>
<li>插入消息表</li>
<li>更新订单表</li>
<li>提交事务</li>
</ol>
<p>这时候如果消息消费成功并且事务提交了，那么消息表就插入成功了。</p>
<p>这时候就算MQ还没有收到消费位点的更新，从而再次投递，也会插入消息失败而视为已经消费过，后续就直接更新消费位点了。</p>
<p>这保证我们消费代码只会执行一次。</p>
<p>如果<strong>事务提交之前服务挂了</strong>（例如重启），对于本地事务并没有执行所以订单没有更新，消息表也没插入成功。</p>
<p>但是这里有它的局限性：<strong>消息的消费逻辑必须是依赖于关系型数据库事务</strong>。<br>如果消费的消费过程中还涉及其他数据的修改，例如 Redis 这种不支持事务特性的数据源，则这些数据是不可回滚的。</p>
<p>还有，数据库的数据必须是在一个库，跨库无法解决。</p>
<p>另外，需要特别注意的是，在业务上，<strong>消息表的设计不应该以消息 ID 作为标识</strong>，而应该以业务的业务主键作为标识更为合理，以应对生产者的重发。<br>​</p>
<h2 id="去事务化的解决方案"><a href="#去事务化的解决方案" class="headerlink" title="去事务化的解决方案"></a>去事务化的解决方案</h2><p>​</p>
<p><img data-src="https://gitee.com/littleeight/blog-images/raw/master/mq%E9%81%BF%E5%85%8D%E9%87%8D%E5%A4%8D%E6%B6%88%E8%B4%B9/1.png"></p>
<p>这样的设计解决了三个问题</p>
<ul>
<li>消息已经消费成功了，第二条消息将被直接幂等处理掉（消费成功）。</li>
<li>并发场景下的消息，依旧能满足不会出现消息重复，即穿透幂等挡板的问题。</li>
<li>上游业务生产者重发的业务重复的消息幂等问题。</li>
</ul>
<p>关于第二个问题是如何解决的？主要是依靠插入消息表的这个动作做控制的，假设我们用 MySQL 作为消息表的存储媒介，设置消息的唯一 ID 为主键，那么插入的动作只有一条消息会成功。后面的消息插入会由于主键冲突而失败，走向延迟消费的分支，然后后面延迟消费的时候就会变成上面第一个场景的问题。<br>关于第三个问题，只要我们设计去重的消息键让其支持业务的主键（例如订单号、请求流水号等），而不仅仅是 messageId 即可。所以也不是问题。<br><strong>但这样的方案还是会有消息丢失的风险的，</strong>当在并发场景下我们依赖于消息状态是做并发控制使得第 2 条消息重复的消息会不断延迟消费，即重试。但如果这时候第 1 条消息也由于一些异常原因，例如机器重启了、外部异常导致消费失败，没有消费成功呢？也就是说这时候延迟消费实际上每次过来看到的都是消费中的状态，最后消费就会被视为消费失败而被投递到死信 Topic 中。<br>对于此，我们解决的方法是，<strong>插入的消息表必须要带一个最长消费过期时间，例如 10 分钟</strong>。意思是如果一个消息处于消费中超过 10 分钟，就需要从消息表中删除，这一点需要程序自行实现。<br><img data-src="https://gitee.com/littleeight/blog-images/raw/master/mq%E9%81%BF%E5%85%8D%E9%87%8D%E5%A4%8D%E6%B6%88%E8%B4%B9/2.png"></p>
<p>这个方案实际上没有事务的，只需要一个存储的中心媒介，那么自然我们可以选择更灵活的存储媒介，例如Redis。<br>使用Redis有两个好处：</p>
<ul>
<li>性能上损耗更低</li>
<li>上面我们讲到的超时时间可以直接利用Redis本身的ttl实现</li>
</ul>
<p>当然Redis存储的数据可靠性、一致性等方面是不如MySQL的，需要用户自己取舍。<br>​</p>
<h2 id="一些其他的消息去重的建议"><a href="#一些其他的消息去重的建议" class="headerlink" title="一些其他的消息去重的建议"></a>一些其他的消息去重的建议</h2><p>事实上，这已经能解决 99% 的消息重复问题了，毕竟异常的场景肯定是少数的。那么如果希望异常场景下也能处理好幂等的问题，可以做以下工作降低问题率：</p>
<ul>
<li>消息消费失败做好回滚处理。如果消息消费失败本身是带回滚机制的，那么消息重试自然就没有副作用了。</li>
<li>消费者做好优雅退出处理。这是为了尽可能避免消息消费到一半程序退出导致的消息重试。</li>
<li>一些无法做到幂等的操作，至少要做到终止消费并告警。例如锁库存的操作，如果统一的业务流水锁成功了一次库存，再触发锁库存，如果做不到幂等的处理，至少要做到消息消费触发异常（例如主键冲突导致消费异常等）。</li>
<li>​</li>
</ul>
<p>在上面做好的前提下，做好消息的消费监控，发现消息重试不断失败的时候，手动做好 #1 的回滚，使得下次重试消费成功。</p>
]]></content>
      <categories>
        <category>mq</category>
      </categories>
      <tags>
        <tag>little_eight</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty的基本知识</title>
    <url>/2021/07/02/Netty%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>Netty 是一个 NIO 客户机服务器框架，它支持快速简单地开发网络应用程序，如协议服务器和客户机。它极大地简化了网络编程，如 TCP 和 UDP 套接字服务器。经过多年的发展它已成为构建一个java网络生态的首选架构，在一些开源的项目中可见。<br>下面是netty框架的组成：<br><img data-src="https://gitee.com/littleeight/blog-images/raw/master/netty%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/1.png"></p>
<p>Netty是一个非阻塞、事件驱动的网络框架，整个Netty的api都是异步设计，对网络应用来讲，io一般是性能的瓶颈，使用异步io可以较大程度上提高程序性能，对于熟悉多线程编程的读者可能会需要同步代码。这样的方式不好，因为同步会影响程序的性能，Netty的设计保证程序处理事件不会有同步。</p>
<span id="more"></span> 

<p>​</p>
<h2 id="核心类"><a href="#核心类" class="headerlink" title="核心类"></a>核心类</h2><p>​</p>
<p>一个Netty程序开始于Bootstrap类，Bootstrap类是Netty提供的一个可以通过简单配置来设置或”引导”程序的一个很重要的类。Netty中设计了Handlers来处理特定的”event”和设置Netty中的事件，从而来处理多个协议和数据。事件可以描述成一个非常通用的方法，因为你可以自定义一个handler,用来将Object转成byte[]或将byte[]转成Object；也可以定义个handler处理抛出的异常。<br>你会经常编写一个实现ChannelInboundHandler的类，ChannelInboundHandler是用来接收消息，当有消息过来时，你可以决定如何处理。当程序需要返回消息时可以在ChannelInboundHandler里write/flush数据。可以认为应用程序的业务逻辑都是在ChannelInboundHandler中来处理的，业务罗的生命周期在ChannelInboundHandler中。<br>Netty连接客户端端或绑定服务器需要知道如何发送或接收消息，这是通过不同类型的handlers来做的，多个Handlers是怎么配置的？Netty提供了ChannelInitializer类用来配置Handlers。ChannelInitializer是通过ChannelPipeline来添加ChannelHandler的，如发送和接收消息，这些Handlers将确定发的是什么消息。ChannelInitializer自身也是一个ChannelHandler，在添加完其他的handlers之后会自动从ChannelPipeline中删除自己。<br>所有的Netty程序都是基于ChannelPipeline。ChannelPipeline和EventLoop和EventLoopGroup密切相关，因为它们三个都和事件处理相关，所以这就是为什么它们处理IO的工作由EventLoop管理的原因。<br>     Netty中所有的IO操作都是异步执行的，例如你连接一个主机默认是异步完成的；写入/发送消息也是同样是异步。也就是说操作不会直接执行，而是会等一会执行，因为你不知道返回的操作结果是成功还是失败，但是需要有检查是否成功的方法或者是注册监听来通知；Netty使用Futures和ChannelFutures来达到这种目的。Future注册一个监听，当操作成功或失败时会通知。ChannelFuture封装的是一个操作的相关信息，操作被执行时会立刻返回ChannelFuture。</p>
<h3 id="一段客户端的示例代码"><a href="#一段客户端的示例代码" class="headerlink" title="一段客户端的示例代码"></a>一段客户端的示例代码</h3><p><code>public void start() throws Exception &#123;      EventLoopGroup group = new NioEventLoopGroup();      try &#123;          Bootstrap b = new Bootstrap();          b.group(group).channel(NioSocketChannel.class).remoteAddress(new InetSocketAddress(&quot;127.0.0.1&quot;, 8080))                  .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;                      @Override                     protected void initChannel(SocketChannel ch) throws Exception &#123;                          ch.pipeline().addLast(new EchoClientHandler());                      &#125;                  &#125;);          ChannelFuture f = b.connect().sync();          f.channel().closeFuture().sync();      &#125; finally &#123;          group.shutdownGracefully().sync();      &#125;  &#125;</code><br>​</p>
<p>​</p>
<h3 id="一段服务端的示例代码"><a href="#一段服务端的示例代码" class="headerlink" title="一段服务端的示例代码"></a>一段服务端的示例代码</h3><p><code>public void start() throws Exception &#123;     EventLoopGroup bossGroup = new NioEventLoopGroup();     EventLoopGroup workGroup = new NioEventLoopGroup();     try &#123;          _//create ServerBootstrap instance          _ServerBootstrap b = new ServerBootstrap();          _//Specifies NIO transport, local socket address          //Adds handler to channel pipeline     _b.group(bossGroup,workGroup).channel(NioServerSocketChannel.class)</code><br>                             <code>.localAddress(8080)                 .childHandler(new ChannelInitializer&lt;Channel&gt;() &#123;                     @Override                      protected void initChannel(Channel ch) throws Exception &#123;                          ch.pipeline().addLast(new EchoServerHandler());                      &#125;                  &#125;);          _//Binds server, waits for server to close, and releases resources         _ChannelFuture f = b.bind().sync();          System._out_.println(EchoServer.class.getName() + &quot;started and listen on &quot; + f.channel().localAddress());         f.channel().closeFuture().sync();      &#125; finally &#123;          group.shutdownGracefully().sync();      &#125;  &#125;</code></p>
<h3 id="Bootstrap、ServerBootstrap"><a href="#Bootstrap、ServerBootstrap" class="headerlink" title="Bootstrap、ServerBootstrap"></a>Bootstrap、ServerBootstrap</h3><pre><code>  相当于客户端与服务端。
</code></pre>
<p>Bootstrap和ServerBootstrap之间的差异：<br>Bootstrap用来连接远程主机，有1个EventLoopGroup,专门处理连接。<br>ServerBootstrap用来绑定本地端口，有2个EventLoopGroup，一个处理客户端的新连接，一个处理与客户端的交互。前者会轮询将连接交给后者的一个NioEventLoop处理。<br>​</p>
<p>Netty的启动流程中，涉及到多个操作，比如register、bind、注册对应事件等，为了不影响main线程执行，这些工作以task的形式提交给NioEventLoop，由NioEventLoop来执行这些task，也就是register、bind、注册事件等操作。</p>
<p>​</p>
<h3 id="EventLoop、EventLoopGroup"><a href="#EventLoop、EventLoopGroup" class="headerlink" title="EventLoop、EventLoopGroup"></a>EventLoop、EventLoopGroup</h3><p>​</p>
<p>EventLoopGroup中可能包含了多个EventLoop，EventLoop是一个Reactor模型的事件处理器，一个EventLoop对应一个线程，其内部会维护一个selector和taskQueue（fifo的队列），负责处理客户端请求和内部任务，内部任务如ServerSocketChannel注册和ServerSocket绑定操作等。<br>IO事件和内部任务执行时间百分比通过ioRatio来调节，ioRatio表示执行IO时间所占百分比。任务包括普通任务和已经到时的延迟任务，延迟任务存放到一个优先级队列PriorityQueue中，执行任务前从PriorityQueue读取所有到时的task，然后添加到taskQueue中，最后统一执行task。<br>​</p>
<h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><p>在Nio网络编程模型中, 服务端和客户端进行IO数据交互(得到彼此推送的信息)的媒介就是Channel。Netty的channel包含了以下信息：<br>id<br>可能存在的parent Channel<br>管道 pepiline<br>用于数据读写的unsafe内部类<br>关联上相伴终生的NioEventLoop<br>​</p>
<p>Channel提供了很多方法，如下列表：<br>eventLoop()，返回分配给Channel的EventLoop<br>pipeline()，返回分配给Channel的ChannelPipeline<br>isActive()，返回Channel是否激活，已激活说明与远程连接对等<br>localAddress()，返回已绑定的本地SocketAddress<br>remoteAddress()，返回已绑定的远程SocketAddress<br>write()，写数据到远程客户端，数据通过ChannelPipeline传输过去</p>
<h3 id="ChannelPipeline"><a href="#ChannelPipeline" class="headerlink" title="ChannelPipeline"></a>ChannelPipeline</h3><p>​</p>
<p>每个channel内部都会持有一个ChannelPipeline对象pipeline，ChannelPipeline 提供了一个容器给 ChannelHandler 链并提供了一个API 用于管理沿着链入站和出站事件的流动。pipeline默认实现DefaultChannelPipeline内部维护了一个DefaultChannelHandlerContext链表。<br>channel的读写操作都会走到DefaultChannelPipeline中，当channel完成register、active、read、readComplete等操作时，会触发pipeline的相应方法。<br>当channel注册到selector后，触发pipeline的fireChannelRegistered方法；<br>当channel是可用时，触发pipeline的fireChannelActive方法。（fireChannelActive触发一般是在fireChannelRegistered之后触发的）；<br>当客户端发送数据时，触发pipeline的fireChannelRead方法；<br>触发pipeline的fireChannelRead方法之后会触发pipeline的fireChannelReadComplete方法。<br>​</p>
<h3 id="Future-or-ChannelFuture"><a href="#Future-or-ChannelFuture" class="headerlink" title="Future or ChannelFuture"></a>Future or ChannelFuture</h3><p>​</p>
<p>Netty 所有的 I/O 操作都是异步。因为一个操作可能无法立即返回，我们需要有一种方法在以后获取它的结果。出于这个目的，Netty 提供了接口 ChannelFuture,它的 addListener 方法。<br>​</p>
<h3 id="ChannelInitializer"><a href="#ChannelInitializer" class="headerlink" title="ChannelInitializer"></a>ChannelInitializer</h3><p>​</p>
<p>用于在某个Channel注册到EventLoop后，对这个Channel执行一些初始化操作。ChannelInitializer虽然会在一开始会被注册到Channel相关的pipeline里，但是在初始化完成之后，ChannelInitializer会将自己从pipeline中移除，不会影响后续的操作。</p>
<h3 id="ChannelHandler"><a href="#ChannelHandler" class="headerlink" title="ChannelHandler"></a>ChannelHandler</h3><p>netty的channelHandler是channel处理器，基于netty的业务处理，不管多么复杂，都是由channelHandler来做的，可能涉及到多个channelHandler，channelHandler分为多种类型：encoder、decoder、业务处理等。<br>​</p>
<h2 id="粘包半包"><a href="#粘包半包" class="headerlink" title="粘包半包"></a>粘包半包</h2><p>粘包就是接收端读取时，多个发送过来的bytebuf粘到了一起，半包就是一个完整的bytebuf被分成了2部分2次发送。例如：<br>1、服务端一次接收到了两个数据包，D1和D2粘合在一起，被称为TCP粘包；<br>2、服务端分两次读取到了两个数据包，第一次读取到了完整的D1包和D2包的部分内容，3、第二次读取到了D2包的剩余内容，这被称为TCP拆包<br>4、服务端分两次读取到了两个数据包，第一次读取到了D1包的部分内容D1_1，第二次读取到了D1包的剩余内容D1_2和D2包的整包。<br>​</p>
<h3 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h3><p>基本思路是，在接收端，需要根据自定义协议来，来读取底层的数据包，重新组装我们应用层的数据包，这个过程通常在接收端称为<strong>拆包</strong>。<br>1、接收端应用层不断从底层的TCP 缓冲区中读取数据。<br>2、每次读取完，判断一下是否为一个完整的应用层数据包。如果是，上层应用层数据包读取完成。<br>3、如果不是，那就保留该数据在应用层缓冲区，然后继续从 TCP 缓冲区中读取，直到得到一个完整的应用层数据包为止。<br>4、至此，半包问题得以解决。<br>5、如果从TCP底层读到了多个应用层数据包，则将整个应用层缓冲区，拆成一个一个的独立的应用层数据包，返回给调用程序。<br>6、至此，粘包问题得以解决。<br>​</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>Netty提供了4种解码器（基类都是ByteToMessageDecoder）来解决，分别如下：<br>1、固定长度的拆包器 FixedLengthFrameDecoder，每个应用层数据包的都拆分成都是固定长度的大小，通过在包头增加消息体长度的解码器，解析数据时首先获取首部长度，然后定长读取socket中的数据。<br>2、行拆包器 LineBasedFrameDecoder，每个应用层数据包，都以换行符作为分隔符，进行分割拆分。换行符解码器，报文尾部增加固定换行符rn，解析数据时以换行符作为报文结尾。<br>3、分隔符拆包器 DelimiterBasedFrameDecoder，每个应用层数据包，都通过自定义的分隔符，进行分割拆分。分隔符解码器，使用特定分隔符作为报文的结尾，解析数据时以定义的分隔符作为报文结尾<br>4、基于数据包长度的拆包器 LengthFieldBasedFrameDecoder，将应用层数据包的长度，作为接收端应用层数据包的拆分依据。按照应用层数据包的大小，拆包。这个拆包器，有一个要求，就是应用层协议中包含数据包的长度。定长解码器，这个最简单，消息体固定长度，解析数据时按长度读取即可</p>
]]></content>
      <categories>
        <category>java第三方框架</category>
      </categories>
      <tags>
        <tag>little_eight</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot发送qq邮件</title>
    <url>/2018/08/11/Spring-Boot%E5%8F%91%E9%80%81qq%E9%82%AE%E4%BB%B6/</url>
    <content><![CDATA[<h3 id="Spring-Boot中可以直接使用JavaMailSender发送邮件。"><a href="#Spring-Boot中可以直接使用JavaMailSender发送邮件。" class="headerlink" title="Spring Boot中可以直接使用JavaMailSender发送邮件。"></a>Spring Boot中可以直接使用JavaMailSender发送邮件。</h3><ul>
<li><p>新建工程，在pom.xml中引入相关依赖，注意加上版本号，不然可能有意想不到的bug。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;</span><br><span class="line">           &lt;version&gt;1.2.0.RELEASE&lt;/version&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>配置application.yml，注意密码填的是授权码，填密码的话会报503错误。如何获取可自行百度，非常简单。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  mail:</span><br><span class="line">    #设置邮箱类型为qq</span><br><span class="line">    host: smtp.qq.com</span><br><span class="line">    #qq邮箱账户</span><br><span class="line">    username: xxx@qq.com</span><br><span class="line">    #qq邮箱授权码</span><br><span class="line">    password: iuxynhopeeqecb</span><br></pre></td></tr></table></figure>
<p>配置完这些我们便可直接在测试用例中发送简单的邮件了</p>
</li>
<li><p>在测试类中引入JavaMailSender，在测试方法里使用它的send方法，咦，发送成功。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> @Autowired</span><br><span class="line">  private JavaMailSender javaMailSender;</span><br><span class="line">  </span><br><span class="line">  @Test</span><br><span class="line">  public void sendSimpleMail() &#123;</span><br><span class="line">      SimpleMailMessage message = new SimpleMailMessage();</span><br><span class="line">      // 发送方邮箱账户</span><br><span class="line">      message.setFrom(&quot;111@qq.com&quot;);</span><br><span class="line">      // 接收方邮箱账户</span><br><span class="line">      message.setTo(&quot;222@qq.com&quot;);</span><br><span class="line">      message.setSubject(&quot;测试邮件标题&quot;);</span><br><span class="line">      message.setText(&quot;测试邮件内容&quot;);</span><br><span class="line">// 发送邮件</span><br><span class="line">      javaMailSender.send(message);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>操作实战</category>
      </categories>
      <tags>
        <tag>little_eight</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot整合Dubbo(入门篇)</title>
    <url>/2018/12/03/SpringBoot%E6%95%B4%E5%90%88Dubbo%EF%BC%88%E5%85%A5%E9%97%A8%E7%AF%87)/</url>
    <content><![CDATA[<h2 id="遇到的坑"><a href="#遇到的坑" class="headerlink" title="遇到的坑"></a>遇到的坑</h2><blockquote>
<ul>
<li>zookeeper版本不一致问题</li>
<li>虚拟机防火墙没关</li>
</ul>
</blockquote>
<h2 id="如何搭建"><a href="#如何搭建" class="headerlink" title="如何搭建"></a>如何搭建</h2><h3 id="Linux上安装zookeeper"><a href="#Linux上安装zookeeper" class="headerlink" title="Linux上安装zookeeper"></a>Linux上安装zookeeper</h3><p>因为最近在学习Linux，所以这个东西直接安装在本机的虚拟机上。（你也可以直接在windows上安装和启用zookeeper，道理是一样的，这里不多描述了。）</p>
<ul>
<li><p>linux命令直接下载</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget https://archive.apache.org/dist/zookeeper/zookeeper-3.4.8/zookeeper-3.4.8.tar.gz</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里有个坑，就是版本必须与程序里的依赖对应的版本一致，否则会出bug，而且不容易发现。</p>
</blockquote>
</li>
<li><p>解压下载的tar,然后进入zookeeper根目录，新建data和logs俩个目录</p>
</li>
<li><p>用pwd复制目录名字，后面有用</p>
</li>
<li><p>从根目录进入conf目录下，把zoo_sample.cfg命名为zoo.cfg，删除zoo_sample.cfg</p>
</li>
<li><p>编辑zoo.cfg，把里面的dataDir=…删除，加上下面2行代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dataDir=/粘贴你自己zookeeper的目录/data</span><br><span class="line">dataLogDir=/粘贴你自己zookeeper的目录/logs</span><br></pre></td></tr></table></figure>
<span id="more"></span></li>
<li><p>返回zookeeper根目录，进入bin，然后运行以下代码</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./zkServer.sh start</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出Starting zookeeper … STARTED,代表启动成功。你也可以用<br>./zkServer.sh status 查看，输出Mode: standalone 代表启动中</p>
</blockquote>
<ul>
<li>关闭zookeeper是./zkServer.sh stop，暂时用不上</li>
<li>记得要把防火墙关了<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld.service</span><br><span class="line"></span><br><span class="line">这个你选择性用。关闭开机自启动：systemctl disable firewalld.service</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="搭建springboot项目"><a href="#搭建springboot项目" class="headerlink" title="搭建springboot项目"></a>搭建springboot项目</h3><p>这里会分服务端跟消费端</p>
<h4 id="先新建主项目，作版本控制-springboot-dubbo"><a href="#先新建主项目，作版本控制-springboot-dubbo" class="headerlink" title="先新建主项目，作版本控制 springboot-dubbo"></a>先新建主项目，作版本控制 springboot-dubbo</h4><ul>
<li>我用的是idea，File -&gt; new-&gt; Project ,选择maven，第一页不用勾选任何东西，点next，填好项目的一些信息，一直next下去即可。</li>
<li>新建完成后，把不要的文件夹删除（.idea和src），然后在pom.xml里加入必要的依赖<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line"></span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">  &lt;groupId&gt;bdbk&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;springboot-dubbo&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">  &lt;packaging&gt;war&lt;/packaging&gt;</span><br><span class="line"></span><br><span class="line">  &lt;name&gt;springboot-dubbo Maven Webapp&lt;/name&gt;</span><br><span class="line"></span><br><span class="line">  &lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.1.1.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">  &lt;/parent&gt;</span><br><span class="line"></span><br><span class="line">  &lt;dependencies&gt;</span><br><span class="line">    &lt;!--web必要--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;!--test必要--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;!--引入dubbo的依赖--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;com.alibaba.spring.boot&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;2.0.0&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;!-- 引入zookeeper的依赖，就是这里引用的zookeeper版本必须对应服务器上的 --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;com.101tec&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;zkclient&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;0.9&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">  &lt;/dependencies&gt;</span><br><span class="line">&lt;/project&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="然后新建服务端-dubbo-server"><a href="#然后新建服务端-dubbo-server" class="headerlink" title="然后新建服务端 dubbo-server"></a>然后新建服务端 dubbo-server</h4><ul>
<li><p>直接在 springboot-dubbo 项目上右键 选择new -&gt; Module</p>
</li>
<li><p>不用勾选next，然后输入 dubbo-server</p>
</li>
<li><p>新建后，在java目录下创建你自己的包（这里是bdbk），然后创建启动类 DubboServerApplication</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> bdbk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.spring.boot.annotation.EnableDubboConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDubboConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboServerApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SpringApplication.run(DubboServerApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>同包下（或者你再自己创建一个 service 包，因为是入门篇东西比较简单就不再区分结构了）创建接口类 HelloService</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> bdbk;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 接口类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> little_eight</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2018/12/3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  String <span class="title">sayHello</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>创建实现类 HelloServiceImpl</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> bdbk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.annotation.Service;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 接口实现类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> little_eight</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2018/12/3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServiceImpl</span> <span class="keyword">implements</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello &quot;</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在resources目录下新建 application.yml 配置文件<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 配置端口</span><br><span class="line">server:</span><br><span class="line">    port: 8081</span><br><span class="line"></span><br><span class="line"># dubbo配置</span><br><span class="line">spring:</span><br><span class="line">    dubbo:</span><br><span class="line">        application:</span><br><span class="line">            # 应用名称</span><br><span class="line">            name: dubbo-server</span><br><span class="line">            # 注册中心地址 这里要填你自己zookeeper的地址</span><br><span class="line">            registry: zookeeper://192.168.211.128:2181</span><br><span class="line">        protocol:</span><br><span class="line">            # 协议端口</span><br><span class="line">            port: 20880</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="再创建消费端项目-dubbo-client-新建跟-dubbo-server-一样"><a href="#再创建消费端项目-dubbo-client-新建跟-dubbo-server-一样" class="headerlink" title="再创建消费端项目 dubbo-client ,新建跟 dubbo-server 一样"></a>再创建消费端项目 dubbo-client ,新建跟 dubbo-server 一样</h4><ul>
<li><p>因为要引用服务端，所以先在pom.xml里添加对应的依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">	xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">	&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">	&lt;groupId&gt;bdbk&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;dubbo-client&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">	&lt;packaging&gt;jar&lt;/packaging&gt;</span><br><span class="line"></span><br><span class="line">	&lt;name&gt;dubbo-client&lt;/name&gt;</span><br><span class="line">	&lt;description&gt;Demo project for Spring Boot&lt;/description&gt;</span><br><span class="line"></span><br><span class="line">	&lt;parent&gt;</span><br><span class="line">		&lt;groupId&gt;bdbk&lt;/groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;springboot-dubbo&lt;/artifactId&gt;</span><br><span class="line">		&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">	&lt;/parent&gt;</span><br><span class="line">	&lt;!-- 添加服务端 --&gt;</span><br><span class="line">	&lt;dependencies&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;bdbk&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;dubbo-server&lt;/artifactId&gt;</span><br><span class="line">			&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">	&lt;/dependencies&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>新建包bdbk,然后创建启动类 DubboClientApplication</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> bdbk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.spring.boot.annotation.EnableDubboConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDubboConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboClientApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SpringApplication.run(DubboClientApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>再写个控制类 HelloController，作为测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> bdbk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.annotation.Reference;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 控制类 用于测试</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> little_eight</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2018/12/3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Reference</span></span><br><span class="line">    <span class="keyword">private</span> HelloService helloService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String hello = helloService.sayHello(<span class="string">&quot;World&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> hello;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在resources目录下新建application.yml配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 配置端口</span><br><span class="line">server:</span><br><span class="line">    port: 8082</span><br><span class="line"></span><br><span class="line"># dubbo配置</span><br><span class="line">spring:</span><br><span class="line">    dubbo:</span><br><span class="line">        application:</span><br><span class="line">            # 应用名称</span><br><span class="line">            name: dubbo-client</span><br><span class="line">            # 注册中心地址 这里要填你自己zookeeper的地址</span><br><span class="line">            registry: zookeeper://192.168.211.128:2181</span><br><span class="line">        protocol:</span><br><span class="line">            # 协议端口</span><br><span class="line">            port: 20881</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="最后先启动服务端，再启动消费端。"><a href="#最后先启动服务端，再启动消费端。" class="headerlink" title="最后先启动服务端，再启动消费端。"></a>最后先启动服务端，再启动消费端。</h4><p><a href="http://localhost:8082/">点击访问</a>,页面输出Hello World即为成功。</p>
<h4 id="源码地址"><a href="#源码地址" class="headerlink" title="源码地址"></a>源码地址</h4><p><a href="https://github.com/little-eight-china/springboot-project/tree/master/springboot-dubbo">github源码</a></p>
]]></content>
      <categories>
        <category>操作实战</category>
      </categories>
      <tags>
        <tag>little_eight</tag>
      </tags>
  </entry>
  <entry>
    <title>dockerfile的基本使用</title>
    <url>/2019/08/29/dockerfile%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="dockerfile的属性"><a href="#dockerfile的属性" class="headerlink" title="dockerfile的属性"></a>dockerfile的属性</h2><p>​</p>
<h3 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h3><p>基础镜像，该配置是基于某些镜像的基础上实现的，比如jdk镜像</p>
<h3 id="MAINTAINER"><a href="#MAINTAINER" class="headerlink" title="MAINTAINER"></a>MAINTAINER</h3><p>维护者信息</p>
<h3 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h3><p>设置环境变量</p>
<h3 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h3><p>文件放在当前目录下，拷过去会自动解压</p>
<h3 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h3><p>执行命令。RUN命令是创建Docker镜像（image）的步骤，RUN命令对Docker容器造成的改变是会被反映到创建的Docker镜像上的。一个Dockerfile中可以有许多个RUN命令。</p>
<h3 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h3><p>指定容器的一个目录， 容器启动时执行的命令会在该目录下执行</p>
<h3 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h3><p>映射端口</p>
<h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h3><p>镜像最终运行的命令。CMD命令是当Docker镜像被启动后Docker容器将会默认执行的命令。一个Dockerfile中只能有一个CMD命令。通过执行docker run xxx启动镜像可以重载CMD命令。<br>​</p>
<span id="more"></span> 
<h2 id="dockerfile例子"><a href="#dockerfile例子" class="headerlink" title="dockerfile例子"></a>dockerfile例子</h2><p>比如我们想运行一个jar包，先拉取jdk镜像<br><code>docker pull openjdk:8</code><br>​</p>
<p>然后创建一个dockerfile<br><code>touch Dockerfile</code><br>​</p>
<p>编辑这个文件</p>
<p><code>FROM openjdk:8</code><br><code>MAINTAINER huangjuguan@gmail.com </code><br><code>ADD *.jar / </code><br><code>EXPOSE 80 </code><br><code>WORKDIR / </code><br><code>CMD [&quot;bash&quot;, &quot;-c&quot;, &quot;java -jar *.jar&quot;]</code><br>​</p>
<h2 id="dockerfile使用"><a href="#dockerfile使用" class="headerlink" title="dockerfile使用"></a>dockerfile使用</h2><p>使用docker build的命令来构建镜像<br><code>docker build -f Dockerfile -t dockerfile-test:v1 .</code><br>​</p>
<p>docker build的命令大概如下：</p>
<ul>
<li>**–build-arg=[] :**设置镜像创建时的变量；</li>
<li>**–cpu-shares :**设置 cpu 使用权重；</li>
<li>**–cpu-period :**限制 CPU CFS周期；</li>
<li>**–cpu-quota :**限制 CPU CFS配额；</li>
<li>**–cpuset-cpus :**指定使用的CPU id；</li>
<li>**–cpuset-mems :**指定使用的内存 id；</li>
<li>**–disable-content-trust :**忽略校验，默认开启；</li>
<li>**-f :**指定要使用的Dockerfile路径；</li>
<li>**–force-rm :**设置镜像过程中删除中间容器；</li>
<li>**–isolation :**使用容器隔离技术；</li>
<li>**–label=[] :**设置镜像使用的元数据；</li>
<li>**-m :**设置内存最大值；</li>
<li>**–memory-swap :**设置Swap的最大值为内存+swap，”-1”表示不限swap；</li>
<li>**–no-cache :**创建镜像的过程不使用缓存；</li>
<li>**–pull :**尝试去更新镜像的新版本；</li>
<li>**–quiet, -q :**安静模式，成功后只输出镜像 ID；</li>
<li>**–rm :**设置镜像成功后删除中间容器；</li>
<li>**–shm-size :**设置/dev/shm的大小，默认值是64M；</li>
<li>**–ulimit :**Ulimit配置。</li>
<li>**–squash :**将 Dockerfile 中所有的操作压缩为一层。</li>
<li><strong>–tag, -t:</strong> 镜像的名字及标签，通常 name:tag 或者 name 格式；可以在一次构建中为一个镜像设置多个标签。</li>
<li><strong>–network:</strong> 默认 default。在构建期间设置RUN指令的网络模式</li>
</ul>
<p>​</p>
<p>使用docker images便可查看我们刚刚构建的镜像，然后就可以启动他了。<br>​</p>
<p>​<br>​</p>
<p>​</p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>little_eight</tag>
      </tags>
  </entry>
  <entry>
    <title>docker搭建mongodb</title>
    <url>/2019/08/05/docker%E6%90%AD%E5%BB%BAmongodb/</url>
    <content><![CDATA[<h2 id="下载与安装"><a href="#下载与安装" class="headerlink" title="下载与安装"></a>下载与安装</h2><p>拉取4.4.8版本的镜像，看仓库的描述是一百多兆的，没想到要400多。<br><code>docker pull mongo:4.4.8</code><br><img data-src="https://gitee.com/littleeight/blog-images/raw/master/docker%E6%90%AD%E5%BB%BAmongodb/1.png"></p>
<h2 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h2><p>mongodb默认是没有用户验证的，所以加个–auth开启，并把数据持久化到/data/mongo-data中<br><code>docker run --name mongo -v /data/mongo-data:/data/db -p 27017:27017 -d mongo:4.4.8 --auth</code><br><strong>进入admin数据库</strong><br><code>docker exec -it mongo mongo admin</code></p>
<span id="more"></span> 
<p><strong>创建用户时需要了解的属性</strong></p>
<ol>
<li><p>user：用户名</p>
</li>
<li><p>pwd：密码</p>
</li>
<li><p>roles：指定用户的角色，可以用一个空数组给新用户设定空角色；在roles字段,可以指定内置角色和用户定义的角色。</p>
<p>  role ：角色可以选：</p>
</li>
<li><p>数据库用户角色：read、readWrite;</p>
</li>
<li><p>数据库管理角色：dbAdmin、dbOwner、userAdmin；</p>
<pre><code> 3. 集群管理角色：clusterAdmin、clusterManager、clusterMonitor、hostManager；
 4. 备份恢复角色：backup、restore；
 5. 所有数据库角色：readAnyDatabase、readWriteAnyDatabase、userAdminAnyDatabase、dbAdminAnyDatabase
 6. 超级用户角色：root 
</code></pre>
<p>  // 这里还有几个角色间接或直接提供了系统超级用户的访问（dbOwner 、userAdmin、userAdminAnyDatabase）</p>
<pre><code> 7. 内部角色：__system
</code></pre>
<p>db：指定使用的数据库<br>​</p>
</li>
</ol>
<p>其中具体角色的意思：<br>Read：允许用户读取指定数据库<br>readWrite：允许用户读写指定数据库<br>dbAdmin：允许用户在指定数据库中执行管理函数，如索引创建、删除，查看统计或访问system.profile<br>userAdmin：允许用户向system.users集合写入，可以找指定数据库里创建、删除和管理用户<br>clusterAdmin：只在admin数据库中可用，赋予用户所有分片和复制集相关函数的管理权限。<br>readAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的读权限<br>readWriteAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的读写权限<br>userAdminAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的userAdmin权限<br>dbAdminAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的dbAdmin权限。<br>root：只在admin数据库中可用。超级账号，超级权限。<br>​</p>
<p><strong>创建一个名为admin，密码是12345的超管用户</strong></p>
<p><code>db.createUser(&#123;user:&quot;admin&quot;,pwd:&quot;12345&quot;,roles:[&#123;role:&#39;root&#39;,db:&#39;admin&#39;&#125;]&#125;)</code><br><img data-src="https://gitee.com/littleeight/blog-images/raw/master/docker%E6%90%AD%E5%BB%BAmongodb/2.png"></p>
<h2 id="测试新建用户的连接"><a href="#测试新建用户的连接" class="headerlink" title="测试新建用户的连接"></a>测试新建用户的连接</h2><p><code>db.auth(&#39;admin&#39;,&#39;12345&#39;)</code><br>连接成功会返回一个1<br><img data-src="https://gitee.com/littleeight/blog-images/raw/master/docker%E6%90%AD%E5%BB%BAmongodb/3.png"></p>
<p>​</p>
<p>​</p>
]]></content>
      <categories>
        <category>操作实战</category>
      </categories>
      <tags>
        <tag>little_eight</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring实战笔记（一）</title>
    <url>/2018/10/01/Spring%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h2 id="装配bean"><a href="#装配bean" class="headerlink" title="装配bean"></a>装配bean</h2><p>它提供了三种主要的装配机制：</p>
<ul>
<li>隐式的Bean发现机制和自动装配</li>
<li>在Java中进行显式配置</li>
<li>在XML中进行显式配置</li>
</ul>
<h3 id="自动化装配Bean"><a href="#自动化装配Bean" class="headerlink" title="自动化装配Bean"></a>自动化装配Bean</h3><ul>
<li>组件扫描（Component Scanning）：Spring会自动发现应用上下文中所创建的Bean</li>
<li>自动装配（Autowired）：Spring自动满足Bean之间的依赖</li>
</ul>
<h4 id="Component"><a href="#Component" class="headerlink" title="@Component"></a>@Component</h4><p>这个注解表明该类会作为组件类（还有个类似的注解--@Named(“bean name”)，用法一样。）</p>
<h4 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h4><p>不过，组件扫描默认是不开启的，用@ComponentScan注解，如果没有其他配置，它默认会扫描与配置类相同的包（包括这个包下的所有子包），查找带有@Component注解的类，并在Spring中自动为其创建一个Bean</p>
<h4 id="ComponentScan的属性"><a href="#ComponentScan的属性" class="headerlink" title="@ComponentScan的属性"></a>@ComponentScan的属性</h4><ul>
<li>basePackages,值为扫描对象包，如：@ComponentScan(basePackages={“first”,”second”…})</li>
<li>basePackageClasses，值为扫描对象类，如：@ComponentScan(basePackageClasses={“first”,”second”…})</li>
</ul>
<h4 id="Autowired（-Inject用法大致一样）"><a href="#Autowired（-Inject用法大致一样）" class="headerlink" title="@Autowired（@Inject用法大致一样）"></a>@Autowired（@Inject用法大致一样）</h4><p>自动装配，bean之间的依赖，有构造器、setter方法、其他方法注入。</p>
<pre><code>在构造器上加此注解，如下，表明当Spring创建BeanA的bean时，会通过这个构造器来进行实例化并且会传入一个可设置给BeanB类型的bean
</code></pre>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> BeanA implement BeanDady&#123;</span><br><span class="line">    <span class="keyword">private</span> BeanB b；</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> BeanA（BeanB b）&#123;</span><br><span class="line">        <span class="keyword">this</span>.b = b</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;!--more--&gt;</span><br></pre></td></tr></table></figure>

<pre><code>用在属性的setter方法上，比如：
</code></pre>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> BeanA implement BeanDady&#123;</span><br><span class="line">    <span class="keyword">private</span> BeanB b；</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> setBeanB（BeanB b）&#123;</span><br><span class="line">        <span class="keyword">this</span>.b = b</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>用在方法上,比如：
</code></pre>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> BeanA implement BeanDady&#123;</span><br><span class="line">    <span class="keyword">private</span> BeanB b；</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> test（BeanB b）&#123;</span><br><span class="line">        <span class="keyword">this</span>.b = b</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不管什么方式，Spring都会尝试满足方法参数上所声明的依赖。假如有且只有一个bean匹配依赖需求的话，那么这个bean将会被装配起来，其他情况的话，在应用上下文创建时，Spring会抛出异常。为了避免异常，你可以将@Autowired的属性required设置为false</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired(required=false)</span></span><br></pre></td></tr></table></figure>
<p>设置false后，如果没有匹配的bean，Spring会设置这个bean为未装配的状态，当然你的代码也有可能会出现空指针异常。</p>
<h3 id="通过Java代码装配bean"><a href="#通过Java代码装配bean" class="headerlink" title="通过Java代码装配bean"></a>通过Java代码装配bean</h3><h4 id="Configuration"><a href="#Configuration" class="headerlink" title="@Configuration"></a>@Configuration</h4><p>该注解表明这个类是一个配置类</p>
<h3 id="Bean"><a href="#Bean" class="headerlink" title="Bean"></a>Bean</h3><p>声明bean，我们给配置类里的方法加上此注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuratione</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanConfig</span></span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanA <span class="title">beanA</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BeanA();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@Bean注解会告诉Spring这个方法将会返回一个对象，该对象要注册为Spring应用上下文的bean。默认情况下，bean的id跟此方法名一样，你也可以设置@Bean的属性name来指定一个不同的名字</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean(name=&quot;xxx&quot;)</span></span><br></pre></td></tr></table></figure>

<h3 id="通过XML装配bean"><a href="#通过XML装配bean" class="headerlink" title="通过XML装配bean"></a>通过XML装配bean</h3><p>不喜欢这种，，，</p>
<h4 id="声明一个简单的bean"><a href="#声明一个简单的bean" class="headerlink" title="声明一个简单的bean"></a>声明一个简单的bean</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;beanA&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.BeanA&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>建议使用自动化配置，减少维护成本。</p>
<span id="more"></span>
<h2 id="高技装配"><a href="#高技装配" class="headerlink" title="高技装配"></a>高技装配</h2><h3 id="Primary"><a href="#Primary" class="headerlink" title="@Primary"></a>@Primary</h3><p>在声明bean时，会有多个匹配的可能，比如BeanDady是一个接口，实现类有BeanA、BeanB</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBean</span><span class="params">(BeanDady beanDady)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.beanDady = beanDady;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在组件扫描时，Spring就无法判断是装配哪个然后出现异常，所以我们将这个@Primary注解加到指定的类或者方法上，就可成为匹配首选,在匹配群里，此注解只能是唯一。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanA</span> <span class="title">implement</span> <span class="title">BeanDady</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanA <span class="title">beanA</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> BeanA();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然xml方式也有。。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;beanA&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.BeanA&quot;</span> <span class="attr">primary</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="Qualifier"><a href="#Qualifier" class="headerlink" title="@Qualifier"></a>@Qualifier</h3><p>这个注解是使用限定符的主要方式，在注入的时候指定想要注入的bean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowried</span></span><br><span class="line"><span class="meta">@Qualifier(&quot;beanA&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBean</span><span class="params">(BeanDady beanDady)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.beanDady = beanDady;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个注解的值默认是bean的id，当然你也可以自定义限定符,这样匹配的时候就以这个“a”为值，跟@Primary一样，此注解只能唯一</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Qualifier(&quot;a&quot;)</span></span><br><span class="line"><span class="keyword">public</span> BeanA implement BeanDady&#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="bean的作用域"><a href="#bean的作用域" class="headerlink" title="bean的作用域"></a>bean的作用域</h2><p>Spring定义了多种作用域，可以基于这些作用域创建bean</p>
<ul>
<li>单例（singleton）：在整个应用中，只创建bean的一个实例</li>
<li>原型（prototype）：每次注入或者通过Spring应用上下文获取的时候，都会创建一个新的bean实例</li>
<li>会话（session）：在web应用中，为每个会话创建一个bean实例</li>
<li>请求（request）：在web应用中，为每个请求创建一个bean实例</li>
</ul>
<h3 id="Scope"><a href="#Scope" class="headerlink" title="@Scope"></a>@Scope</h3><p>单例是默认的作用域，如果想选择其他作用域，在bean的类加上此注解,值的话，为了安全跟不易出错，用ConfigurationBeanFactory.SCOPE_PROTOTYPE常量更好。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line"><span class="comment">//这个更好。。 @Scope(ConfigurationBeanFactory.SCOPE_PROTOTYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanA</span>...</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Scope(ConfigurationBeanFactory.SCOPE_PROTOTYPE)</span></span><br><span class="line"><span class="keyword">public</span> BeanA beanA（）&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> BeanA（）；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然xml也有。。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;beanA&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.BeanA&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>


<h2 id="面向切面编程"><a href="#面向切面编程" class="headerlink" title="面向切面编程"></a>面向切面编程</h2><h3 id="AOP术语"><a href="#AOP术语" class="headerlink" title="AOP术语"></a>AOP术语</h3><ul>
<li>通知（advice）：定义切面是什么以及什么时候使用</li>
<li>切点（poincut）：定义切面在哪里</li>
<li>连接点（join point）：所有可能的切面</li>
<li>切面（aspect）：通知和切点的结合</li>
<li>引入（introduction）：向现有的类加入新方法或者属性</li>
<li>织入（weaving）：</li>
</ul>
<h4 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h4><ul>
<li>前置通知（before）：在目标方法被调用前通知功能</li>
<li>后置通知（after）：在目标方法完成之后通知功能</li>
<li>返回通知（after-retrning）：在目标成功执行后调用通知</li>
<li>异常通知（after-throwing）：在目标方法抛出异常后通知</li>
<li>环绕通知（around）：通知包裹了被通知的方法，在被通知的方法调用之前和之后执行自定义的行为</li>
</ul>
<h3 id="编写切面"><a href="#编写切面" class="headerlink" title="编写切面"></a>编写切面</h3><h4 id="编写切点"><a href="#编写切点" class="headerlink" title="编写切点"></a>编写切点</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">execution(* com.Test.test(..)) &amp;&amp; within(com.*)</span><br></pre></td></tr></table></figure>
<ul>
<li>execution（），表示使用这种指示器</li>
<li>里面的“*”，这里表示方法返回值的类型，星号表示全部</li>
<li>com.Test.test(..),指定类型和方法名，括号的..代表不在乎这个方法的参数是什么</li>
<li>&amp;&amp;,和的意思，可选，后面的within（com.*）代表仅匹配com包</li>
</ul>
<h4 id="Aspect、-Before、-AfterReturning、-AfterThrowing"><a href="#Aspect、-Before、-AfterReturning、-AfterThrowing" class="headerlink" title="@Aspect、@Before、@AfterReturning、@AfterThrowing"></a>@Aspect、@Before、@AfterReturning、@AfterThrowing</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Qiemian</span></span>&#123;</span><br><span class="line">    <span class="comment">//调用之前，其他类型通知类似</span></span><br><span class="line">    <span class="meta">@Before(&quot;execution(* com.Test.test(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h4 id="Pointcut"><a href="#Pointcut" class="headerlink" title="@Pointcut"></a>@Pointcut</h4><p>当然每次都这么写切点表达式不麻烦死，所以这里可以用这个注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Qiemian</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义切点的方法,里面的实现最好是空的</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.Test.test(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointcutMethod</span><span class="params">()</span>  </span>&#123;&#125;</span><br><span class="line">    <span class="comment">//调用之前，其他类型通知类似</span></span><br><span class="line">    <span class="meta">@Before(&quot;pointcutMethod()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h4 id="Around"><a href="#Around" class="headerlink" title="@Around"></a>@Around</h4><p>这个通知注解也是其他注解（@After是一定执行的。）的整合</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Qiemian</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义切点的方法,里面的实现最好是空的</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.Test.test(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointcutMethod</span><span class="params">()</span>  </span>&#123;&#125;</span><br><span class="line">    <span class="comment">//环绕通知 </span></span><br><span class="line">    <span class="meta">@Around(&quot;pointcutMethod()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">around</span><span class="params">(ProceedingJoinPoint jp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//这里是调用之前通知</span></span><br><span class="line">            System.out.println(<span class="string">&quot;调用之前&quot;</span>);</span><br><span class="line">            <span class="comment">//调用这个方法后，代表调用之后</span></span><br><span class="line">            jp.proceed();</span><br><span class="line">            <span class="comment">// 这里是调用执行成功之后通知</span></span><br><span class="line">            System.out.println(<span class="string">&quot;调用执行成功之后&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exection e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;抛异常之后&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>当然xml也有，这里不搞了。</p>
]]></content>
      <categories>
        <category>java杂记</category>
      </categories>
      <tags>
        <tag>little_eight</tag>
      </tags>
  </entry>
  <entry>
    <title>docker搭建redis集群</title>
    <url>/2019/06/30/docker%E6%90%AD%E5%BB%BAredis%E9%9B%86%E7%BE%A4/</url>
    <content><![CDATA[<h2 id="拉取redis镜像（版本5-0-5）"><a href="#拉取redis镜像（版本5-0-5）" class="headerlink" title="拉取redis镜像（版本5.0.5）"></a>拉取redis镜像（版本5.0.5）</h2><p><code>docker pull redis:5.0.5</code><br><img data-src="https://gitee.com/littleeight/blog-images/raw/master/docker%E6%90%AD%E5%BB%BAredis%E9%9B%86%E7%BE%A4/1.png"></p>
<h2 id="创建并运行三个redis容器"><a href="#创建并运行三个redis容器" class="headerlink" title="创建并运行三个redis容器"></a>创建并运行三个redis容器</h2><ul>
<li>redis-node1 6379</li>
<li>redis-node1 6380</li>
<li>redis-node1 6381</li>
</ul>
<span id="more"></span> 

<p><code>docker run -d --name redis-node1 -v /data/redis-data/node1:/data -p 6379:6379 redis:5.0.5 --cluster-enabled yes --cluster-config-file nodes-node-1.conf</code><br>​</p>
<p><code>docker run -d --name redis-node2 -v /data/redis-data/node2:/data -``p 6380:6379 redis:5.0.5 --cluster-enabled yes --cluster-config-file nodes-node-2.conf</code><br>​</p>
<p><code>docker run -d --name redis-node3 -v /data/redis-data/node3:/data -p 6381:6379 redis:5.0.5 --cluster-enabled yes --cluster-config-file nodes-node-3.conf</code><br>​</p>
<h2 id="查看三个容器是否正常运行"><a href="#查看三个容器是否正常运行" class="headerlink" title="查看三个容器是否正常运行"></a>查看三个容器是否正常运行</h2><p><code>docker ps</code><br><img data-src="https://gitee.com/littleeight/blog-images/raw/master/docker%E6%90%AD%E5%BB%BAredis%E9%9B%86%E7%BE%A4/2.png"></p>
<h2 id="查看容器分配的ip"><a href="#查看容器分配的ip" class="headerlink" title="查看容器分配的ip"></a>查看容器分配的ip</h2><p><code>docker inspect redis-node1 | grep IPAddress</code><br><code>docker inspect redis-node2 | grep IPAddress</code><br><code>docker inspect redis-node3 | grep IPAddress</code><br>​<br><img data-src="https://gitee.com/littleeight/blog-images/raw/master/docker%E6%90%AD%E5%BB%BAredis%E9%9B%86%E7%BE%A4/3.png"></p>
<p>可以得到</p>
<ul>
<li>redis-node1 172.18.0.2</li>
<li>redis-node2 172.18.0.3</li>
<li>redis-node3 172.18.0.4</li>
</ul>
<p>​</p>
<h2 id="进入容器配置集群信息"><a href="#进入容器配置集群信息" class="headerlink" title="进入容器配置集群信息"></a>进入容器配置集群信息</h2><h3 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h3><p><code>docker exec -it redis-node1 /bin/bash</code></p>
<h3 id="使用redis-cli连接配置（注意ip需要替换成自己的）"><a href="#使用redis-cli连接配置（注意ip需要替换成自己的）" class="headerlink" title="使用redis-cli连接配置（注意ip需要替换成自己的）"></a>使用redis-cli连接配置（注意ip需要替换成自己的）</h3><p><code>redis-cli --cluster create 172.18.0.2:6379  172.18.0.3:6379 172.18.0.4:6379 --cluster-replicas 0</code><br>中途记得输入yes，回车的话是没有默认值的。<br><img data-src="https://gitee.com/littleeight/blog-images/raw/master/docker%E6%90%AD%E5%BB%BAredis%E9%9B%86%E7%BE%A4/4.png"></p>
<h3 id="查看集群信息"><a href="#查看集群信息" class="headerlink" title="查看集群信息"></a>查看集群信息</h3><p><code>cluster nodes</code><br><code>cluster info</code><br>状态是ok，说明集群正常。<br><img data-src="https://gitee.com/littleeight/blog-images/raw/master/docker%E6%90%AD%E5%BB%BAredis%E9%9B%86%E7%BE%A4/5.png"></p>
<p>至此，集群搭建完毕。<br>​</p>
<h2 id="测试集群"><a href="#测试集群" class="headerlink" title="测试集群"></a>测试集群</h2><p>使用<code>redis-cli -c</code> 连接到集群节点，然后set值，set值之后会根据hash槽算法存储到指定的节点。现在有三个节点，则node1分配槽为0－5460，node2分配槽为5461－10922，node3分配槽为10923－16383。现在测试set key值123跟1234567890。可以发现不同的key会存到不同的节点。<br>​</p>
<p><img data-src="https://gitee.com/littleeight/blog-images/raw/master/docker%E6%90%AD%E5%BB%BAredis%E9%9B%86%E7%BE%A4/6.png"></p>
<p>用rdm可看到set的俩值在不同的节点。<br><img data-src="https://gitee.com/littleeight/blog-images/raw/master/docker%E6%90%AD%E5%BB%BAredis%E9%9B%86%E7%BE%A4/7.png"></p>
<p>至此，成功搭建了集群。</p>
]]></content>
      <categories>
        <category>操作实战</category>
      </categories>
      <tags>
        <tag>little_eight</tag>
      </tags>
  </entry>
  <entry>
    <title>java.lang.String类解析</title>
    <url>/2019/05/09/java-lang-String%E7%B1%BB%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 底层由数组存数据</span><br><span class="line"> */</span><br><span class="line">private final char value[];</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * hash值</span><br><span class="line"> */</span><br><span class="line">private int hash;</span><br></pre></td></tr></table></figure>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><span id="more"></span>
<h3 id="charAt"><a href="#charAt" class="headerlink" title="charAt"></a>charAt</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> /**</span><br><span class="line">  * 返回指定下标的字符</span><br><span class="line">  */</span><br><span class="line">public char charAt(int index) &#123;</span><br><span class="line">     if ((index &lt; 0) || (index &gt;= value.length)) &#123;</span><br><span class="line">         throw new StringIndexOutOfBoundsException(index);</span><br><span class="line">     &#125;</span><br><span class="line">     return value[index];</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="compareTo、compareToIgnoreCase"><a href="#compareTo、compareToIgnoreCase" class="headerlink" title="compareTo、compareToIgnoreCase"></a>compareTo、compareToIgnoreCase</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  /**</span><br><span class="line">   * 比较两个字符串的字典顺序，anotherString在后面的话就返回负数，相等为0，前面就正数</span><br><span class="line">   */</span><br><span class="line">public int compareTo(String anotherString) &#123;</span><br><span class="line">      int len1 = value.length;</span><br><span class="line">      int len2 = anotherString.value.length;</span><br><span class="line">      int lim = Math.min(len1, len2);</span><br><span class="line">      char v1[] = value;</span><br><span class="line">      char v2[] = anotherString.value;</span><br><span class="line"></span><br><span class="line">      int k = 0;</span><br><span class="line">      while (k &lt; lim) &#123;</span><br><span class="line">          char c1 = v1[k];</span><br><span class="line">          char c2 = v2[k];</span><br><span class="line">          if (c1 != c2) &#123;</span><br><span class="line">              return c1 - c2;</span><br><span class="line">          &#125;</span><br><span class="line">          k++;</span><br><span class="line">      &#125;</span><br><span class="line">      return len1 - len2;</span><br><span class="line">  &#125;</span><br><span class="line">  /**</span><br><span class="line">   * 忽略大小写的对比</span><br><span class="line">   */</span><br><span class="line">  public int compareToIgnoreCase(String str) &#123;</span><br><span class="line">      return CASE_INSENSITIVE_ORDER.compare(this, str);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 将指定的字符串参数连接到字符串上</span><br><span class="line"> */</span><br><span class="line">public String concat(String str) &#123;</span><br><span class="line">    int otherLen = str.length();</span><br><span class="line">    if (otherLen == 0) &#123;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">    int len = value.length;</span><br><span class="line">    char buf[] = Arrays.copyOf(value, len + otherLen);</span><br><span class="line">    str.getChars(buf, len);</span><br><span class="line">    return new String(buf, true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="contains"><a href="#contains" class="headerlink" title="contains"></a>contains</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> /**</span><br><span class="line">  * 是否存在此字符</span><br><span class="line">  */</span><br><span class="line">public boolean contains(CharSequence s) &#123;</span><br><span class="line">     return indexOf(s.toString()) &gt; -1;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="contentEquals"><a href="#contentEquals" class="headerlink" title="contentEquals"></a>contentEquals</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  /**</span><br><span class="line">   * 比较两者的内容是否相同，不检查被比较对象的类型</span><br><span class="line">   */</span><br><span class="line">public boolean contentEquals(CharSequence cs) &#123;</span><br><span class="line">      // Argument is a StringBuffer, StringBuilder</span><br><span class="line">      if (cs instanceof AbstractStringBuilder) &#123;</span><br><span class="line">          if (cs instanceof StringBuffer) &#123;</span><br><span class="line">              synchronized(cs) &#123;</span><br><span class="line">                 return nonSyncContentEquals((AbstractStringBuilder)cs);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">              return nonSyncContentEquals((AbstractStringBuilder)cs);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      // Argument is a String</span><br><span class="line">      if (cs instanceof String) &#123;</span><br><span class="line">          return equals(cs);</span><br><span class="line">      &#125;</span><br><span class="line">      // Argument is a generic CharSequence</span><br><span class="line">      char v1[] = value;</span><br><span class="line">      int n = v1.length;</span><br><span class="line">      if (n != cs.length()) &#123;</span><br><span class="line">          return false;</span><br><span class="line">      &#125;</span><br><span class="line">      for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">          if (v1[i] != cs.charAt(i)) &#123;</span><br><span class="line">              return false;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return true;</span><br><span class="line">  &#125;</span><br><span class="line">  /**</span><br><span class="line">   * 还可以直接传入StringBuffer对比</span><br><span class="line">   */</span><br><span class="line">  public boolean contentEquals(StringBuffer sb) &#123;</span><br><span class="line">      return contentEquals((CharSequence)sb);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="copyValueOf"><a href="#copyValueOf" class="headerlink" title="copyValueOf"></a>copyValueOf</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 根据char数组new一个新的string</span><br><span class="line"> */</span><br><span class="line">public static String copyValueOf(char data[]) &#123;</span><br><span class="line">    return new String(data);</span><br><span class="line">&#125;</span><br><span class="line"> /**</span><br><span class="line"> * 更多参数new一个新的string</span><br><span class="line"> */</span><br><span class="line">public static String copyValueOf(char data[], int offset, int count) &#123;</span><br><span class="line">    return new String(data, offset, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="endsWith、startsWith"><a href="#endsWith、startsWith" class="headerlink" title="endsWith、startsWith"></a>endsWith、startsWith</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 比较是否与尾部的字符串一致</span><br><span class="line"> */</span><br><span class="line">public boolean endsWith(String suffix) &#123;</span><br><span class="line">    return startsWith(suffix, value.length - suffix.value.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 对比指定范围的字符串是否一致</span><br><span class="line"> */</span><br><span class="line">public boolean startsWith(String prefix, int toffset) &#123;</span><br><span class="line">    char ta[] = value;</span><br><span class="line">    int to = toffset;</span><br><span class="line">    char pa[] = prefix.value;</span><br><span class="line">    int po = 0;</span><br><span class="line">    int pc = prefix.value.length;</span><br><span class="line">    // Note: toffset might be near -1&gt;&gt;&gt;1.</span><br><span class="line">    if ((toffset &lt; 0) || (toffset &gt; value.length - pc)) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    while (--pc &gt;= 0) &#123;</span><br><span class="line">        if (ta[to++] != pa[po++]) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">/**</span><br><span class="line"> * 比较是否与头部的字符串一致</span><br><span class="line"> */</span><br><span class="line"> public boolean startsWith(String prefix) &#123;</span><br><span class="line">    return startsWith(prefix, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  /**</span><br><span class="line">   * 比较两者的内容是否相同，还会检查被比较对象的类型</span><br><span class="line">   */</span><br><span class="line">public boolean equals(Object anObject) &#123;</span><br><span class="line">      if (this == anObject) &#123;</span><br><span class="line">          return true;</span><br><span class="line">      &#125;</span><br><span class="line">      if (anObject instanceof String) &#123;</span><br><span class="line">          String anotherString = (String)anObject;</span><br><span class="line">          int n = value.length;</span><br><span class="line">          if (n == anotherString.value.length) &#123;</span><br><span class="line">              char v1[] = value;</span><br><span class="line">              char v2[] = anotherString.value;</span><br><span class="line">              int i = 0;</span><br><span class="line">              while (n-- != 0) &#123;</span><br><span class="line">                  if (v1[i] != v2[i])</span><br><span class="line">                      return false;</span><br><span class="line">                  i++;</span><br><span class="line">              &#125;</span><br><span class="line">              return true;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return false;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="format"><a href="#format" class="headerlink" title="format"></a>format</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 字符串格式化</span><br><span class="line"> * %s 字符串类型、 %c 字符类型、 %b 布尔类型、%d 整数类型（十进制）、%f 浮点类型.....</span><br><span class="line"> */</span><br><span class="line">public static String format(String format, Object... args) &#123;</span><br><span class="line">    return new Formatter().format(format, args).toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="getBytes"><a href="#getBytes" class="headerlink" title="getBytes"></a>getBytes</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> /**</span><br><span class="line">  * char数组转换成byte 数组</span><br><span class="line">  */</span><br><span class="line">public byte[] getBytes() &#123;</span><br><span class="line">     return StringCoding.encode(value, 0, value.length);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="indexOf、lastIndexOf"><a href="#indexOf、lastIndexOf" class="headerlink" title="indexOf、lastIndexOf"></a>indexOf、lastIndexOf</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> /**</span><br><span class="line">  * 其实有很多重载方法，这是最常用的，返回第一次出现该字符串的下标，不存在返回-1</span><br><span class="line">  */</span><br><span class="line">public int indexOf(String str) &#123;</span><br><span class="line">     return indexOf(str, 0);</span><br><span class="line"> &#125;</span><br><span class="line"> /**</span><br><span class="line">  * 返回最后一次出现该字符串的下标，不存在返回-1</span><br><span class="line">  */</span><br><span class="line"> public int lastIndexOf(String str) &#123;</span><br><span class="line">     return lastIndexOf(str, value.length);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="length"><a href="#length" class="headerlink" title="length"></a>length</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 经常会提问的数组跟String是属性还是方法</span><br><span class="line"> */</span><br><span class="line">public int length() &#123;</span><br><span class="line">    return value.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="matches"><a href="#matches" class="headerlink" title="matches"></a>matches</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 检测字符串是否匹配给定的正则表达式</span><br><span class="line"> */</span><br><span class="line">    public boolean matches(String regex) &#123;</span><br><span class="line">    return Pattern.matches(regex, this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="replaceAll"><a href="#replaceAll" class="headerlink" title="replaceAll"></a>replaceAll</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 替换指定字符串的内容</span><br><span class="line"> */</span><br><span class="line">public String replaceAll(String regex, String replacement) &#123;</span><br><span class="line">    return Pattern.compile(regex).matcher(this).replaceAll(replacement);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="split"><a href="#split" class="headerlink" title="split"></a>split</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 转换成数组，regex为区分标识</span><br><span class="line"> */</span><br><span class="line">public String[] split(String regex) &#123;</span><br><span class="line">    return split(regex, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="substring"><a href="#substring" class="headerlink" title="substring"></a>substring</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 从指定下标开始截取字符串</span><br><span class="line"> * 感觉直接返回substring(beginIndex, value.length - beginIndex)可以吧</span><br><span class="line"> */</span><br><span class="line">    public String substring(int beginIndex) &#123;</span><br><span class="line">    if (beginIndex &lt; 0) &#123;</span><br><span class="line">        throw new StringIndexOutOfBoundsException(beginIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    int subLen = value.length - beginIndex;</span><br><span class="line">    if (subLen &lt; 0) &#123;</span><br><span class="line">        throw new StringIndexOutOfBoundsException(subLen);</span><br><span class="line">    &#125;</span><br><span class="line">    return (beginIndex == 0) ? this : new String(value, beginIndex, subLen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 从指定下标开始截取字符串</span><br><span class="line"> */</span><br><span class="line"> public String substring(int beginIndex, int endIndex) &#123;</span><br><span class="line">    if (beginIndex &lt; 0) &#123;</span><br><span class="line">        throw new StringIndexOutOfBoundsException(beginIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    if (endIndex &gt; value.length) &#123;</span><br><span class="line">        throw new StringIndexOutOfBoundsException(endIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    int subLen = endIndex - beginIndex;</span><br><span class="line">    if (subLen &lt; 0) &#123;</span><br><span class="line">        throw new StringIndexOutOfBoundsException(subLen);</span><br><span class="line">    &#125;</span><br><span class="line">    return ((beginIndex == 0) &amp;&amp; (endIndex == value.length)) ? this</span><br><span class="line">            : new String(value, beginIndex, subLen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="toCharArray"><a href="#toCharArray" class="headerlink" title="toCharArray"></a>toCharArray</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 转换成字符数组</span><br><span class="line"> */</span><br><span class="line">public char[] toCharArray() &#123;</span><br><span class="line">    // Cannot use Arrays.copyOf because of class initialization order issues</span><br><span class="line">    char result[] = new char[value.length];</span><br><span class="line">    System.arraycopy(value, 0, result, 0, value.length);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="toLowerCase、toUpperCase"><a href="#toLowerCase、toUpperCase" class="headerlink" title="toLowerCase、toUpperCase"></a>toLowerCase、toUpperCase</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 全部转换小写</span><br><span class="line"> */</span><br><span class="line"> public String toLowerCase() &#123;</span><br><span class="line">    return toLowerCase(Locale.getDefault());</span><br><span class="line">&#125;</span><br><span class="line"> /**</span><br><span class="line"> * 全部转换大写</span><br><span class="line"> */</span><br><span class="line">public String toUpperCase() &#123;</span><br><span class="line">    return toUpperCase(Locale.getDefault());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="valueOf-NaN"><a href="#valueOf-NaN" class="headerlink" title="valueOf"></a>valueOf</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> /**</span><br><span class="line">  * 转换成z</span><br><span class="line">  */</span><br><span class="line"> public static String valueOf(boolean b) &#123;</span><br><span class="line">     return b ? &quot;true&quot; : &quot;false&quot;;</span><br><span class="line"> &#125;</span><br><span class="line"> public static String valueOf(char data[]) &#123;</span><br><span class="line">     return new String(data);</span><br><span class="line"> &#125;</span><br><span class="line"> public static String valueOf(char c) &#123;</span><br><span class="line">     char data[] = &#123;c&#125;;</span><br><span class="line">     return new String(data, true);</span><br><span class="line"> &#125;</span><br><span class="line"> public static String valueOf(char data[], int offset, int count) &#123;</span><br><span class="line">     return new String(data, offset, count);</span><br><span class="line"> &#125;</span><br><span class="line"> public static String valueOf(double d) &#123;</span><br><span class="line">     return Double.toString(d);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">public static String valueOf(float f) &#123;</span><br><span class="line">     return Float.toString(f);</span><br><span class="line"> &#125;</span><br><span class="line"> public static String valueOf(int i) &#123;</span><br><span class="line">     return Integer.toString(i);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> public static String valueOf(long l) &#123;</span><br><span class="line">     return Long.toString(l);</span><br><span class="line"> &#125;</span><br><span class="line"> public static String valueOf(Object obj) &#123;</span><br><span class="line">     return (obj == null) ? &quot;null&quot; : obj.toString();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>little_eight</tag>
      </tags>
  </entry>
  <entry>
    <title>java.util.LinkedHashMap类解析</title>
    <url>/2019/04/22/java-util-LinkedHashMap%E7%B1%BB%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>LinkedHashMap 是基于 HashMap实现的一种集合，有序，它单独维护了一个具有所有数据的双向链表，该链表保证了元素迭代的顺序。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 继承HashMap，实现Map</span><br><span class="line"> */</span><br><span class="line">public class LinkedHashMap&lt;K,V&gt; extends HashMap&lt;K,V&gt; implements Map&lt;K,V&gt;&#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">    * 双向链表头</span><br><span class="line">    */</span><br><span class="line">   transient LinkedHashMap.Entry&lt;K,V&gt; head;</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * 双向链表尾</span><br><span class="line">    */</span><br><span class="line">   transient LinkedHashMap.Entry&lt;K,V&gt; tail;</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * 决定迭代排序方法：true是根据访问顺序来排序，false是根据插入顺序来排序</span><br><span class="line">    */</span><br><span class="line">   final boolean accessOrder;</span><br></pre></td></tr></table></figure>

<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>4种构造方法，都用HaspMap的实现方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public LinkedHashMap() &#123;</span><br><span class="line">    super();</span><br><span class="line">    accessOrder = false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public LinkedHashMap(int initialCapacity) &#123;</span><br><span class="line">    super(initialCapacity);</span><br><span class="line">    accessOrder = false;</span><br><span class="line">&#125;</span><br><span class="line">public LinkedHashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">    super(initialCapacity, loadFactor);</span><br><span class="line">    accessOrder = false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public LinkedHashMap(int initialCapacity,</span><br><span class="line">                     float loadFactor,</span><br><span class="line">                     boolean accessOrder) &#123;</span><br><span class="line">    super(initialCapacity, loadFactor);</span><br><span class="line">    this.accessOrder = accessOrder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="afterNodeAccess"><a href="#afterNodeAccess" class="headerlink" title="afterNodeAccess"></a>afterNodeAccess</h3><blockquote>
<p>这个方法除了在LinkedHashMap的get方法用到，还在HashMap的put、replace用到，因为这些方法是直接实现HashMap的，下面的afterNodeInsertion、afterNodeRemoval同理。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> /**</span><br><span class="line">  *  把指定节点放到双向链表的尾部</span><br><span class="line">  */</span><br><span class="line">void afterNodeAccess(Node&lt;K,V&gt; e) &#123; // move node to last</span><br><span class="line">     LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">     // 当accessOrder为true，指定节点不是链表尾才有效</span><br><span class="line">     if (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class="line">         // 把p当做指定节点，并注明它的前后节点 b，a</span><br><span class="line">         LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">             (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">         // 清除p的后节点指向</span><br><span class="line">         p.after = null;</span><br><span class="line">         /**</span><br><span class="line">          * 下面会分别对a跟b判空，是为了把p提取出来同时，成功接上断掉的节点</span><br><span class="line">          */</span><br><span class="line">         // 如果b是空的，说明p是链表头，把head等于p的后节点</span><br><span class="line">         if (b == null)</span><br><span class="line">             head = a;</span><br><span class="line">         // 如果b不为空，就让p的前节点的后节点指向p的后节点</span><br><span class="line">         else</span><br><span class="line">             b.after = a;</span><br><span class="line">         // 如果a不为空，就让p的后节点的前节点指向p的前节点</span><br><span class="line">         if (a != null)</span><br><span class="line">             a.before = b;</span><br><span class="line">         /**</span><br><span class="line">          * 本人对下面注释可能有问题，理解不到位吧</span><br><span class="line">          */</span><br><span class="line">         // 如果a是空的，说明链表尾tail为null（不然就解释不通p不等于tail了），last等于p的前节点</span><br><span class="line">         else</span><br><span class="line">             last = b;</span><br><span class="line">         // last为空 说明链表条还没有链表，而且p的前节点为null，链表头设置为p</span><br><span class="line">         if (last == null)</span><br><span class="line">             head = p;</span><br><span class="line">         // last不为空，就把last跟p连到一起</span><br><span class="line">         else &#123;</span><br><span class="line">             p.before = last;</span><br><span class="line">             last.after = p;</span><br><span class="line">         &#125;</span><br><span class="line">         // 最后把p设为链表尾</span><br><span class="line">         tail = p;</span><br><span class="line">         ++modCount;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="afterNodeInsertion"><a href="#afterNodeInsertion" class="headerlink" title="afterNodeInsertion"></a>afterNodeInsertion</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 移除链表头</span><br><span class="line"> */</span><br><span class="line">void afterNodeInsertion(boolean evict) &#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line">    // 当evict = true，并且 头节点不为null，removeEldestEntry(first)为true，才进行移除</span><br><span class="line">    if (evict &amp;&amp; (first = head) != null &amp;&amp; removeEldestEntry(first)) &#123;</span><br><span class="line">        K key = first.key;</span><br><span class="line">        // 用到HashMap的，里面有个方法afterNodeRemoval，下面讲</span><br><span class="line">        removeNode(hash(key), key, null, false, true);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 再看看这个方法，其实是返回false的，所以要想实现移除链表头，必须得继承LinkedHashMap然后重写这个方法</span><br><span class="line"> */</span><br><span class="line">protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest) &#123;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="afterNodeRemoval"><a href="#afterNodeRemoval" class="headerlink" title="afterNodeRemoval"></a>afterNodeRemoval</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  /**</span><br><span class="line">   * 移除了e后，保证链表条不断掉</span><br><span class="line">   */</span><br><span class="line">void afterNodeRemoval(Node&lt;K,V&gt; e) &#123;</span><br><span class="line">      LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">          (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">      p.before = p.after = null;</span><br><span class="line">      if (b == null)</span><br><span class="line">          head = a;</span><br><span class="line">      else</span><br><span class="line">          b.after = a;</span><br><span class="line">      if (a == null)</span><br><span class="line">          tail = b;</span><br><span class="line">      else</span><br><span class="line">          a.before = b;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="containsValue"><a href="#containsValue" class="headerlink" title="containsValue"></a>containsValue</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 是否包含此值</span><br><span class="line"> */</span><br><span class="line">public boolean containsValue(Object value) &#123;</span><br><span class="line">    // 很明显是遍历链表条了</span><br><span class="line">    for (LinkedHashMap.Entry&lt;K,V&gt; e = head; e != null; e = e.after) &#123;</span><br><span class="line">        V v = e.value;</span><br><span class="line">        if (v == value || (value != null &amp;&amp; value.equals(v)))</span><br><span class="line">            return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="get、getOrDefault"><a href="#get、getOrDefault" class="headerlink" title="get、getOrDefault"></a>get、getOrDefault</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> /**</span><br><span class="line">  * 根据key获取对应值</span><br><span class="line">  */</span><br><span class="line"> public V get(Object key) &#123;</span><br><span class="line">     Node&lt;K,V&gt; e;</span><br><span class="line">     if ((e = getNode(hash(key), key)) == null)</span><br><span class="line">         return null;</span><br><span class="line">     // 如果true，还会把这个链表放到尾部</span><br><span class="line">     if (accessOrder)</span><br><span class="line">         afterNodeAccess(e);</span><br><span class="line">     return e.value;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> /**</span><br><span class="line">  * 还提供一个不存在就返回默认值</span><br><span class="line">  */</span><br><span class="line"> public V getOrDefault(Object key, V defaultValue) &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    if ((e = getNode(hash(key), key)) == null)</span><br><span class="line">        return defaultValue;</span><br><span class="line">    if (accessOrder)</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">    return e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="keySet"><a href="#keySet" class="headerlink" title="keySet"></a>keySet</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 获取key集合，有兴趣可以自己看LinkedKeySet</span><br><span class="line"> */</span><br><span class="line">public Set&lt;K&gt; keySet() &#123;</span><br><span class="line">    Set&lt;K&gt; ks = keySet;</span><br><span class="line">    if (ks == null) &#123;</span><br><span class="line">        ks = new LinkedKeySet();</span><br><span class="line">        keySet = ks;</span><br><span class="line">    &#125;</span><br><span class="line">    return ks;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final class LinkedKeySet extends AbstractSet&lt;K&gt; &#123;</span><br><span class="line">    public final int size()                 &#123; return size; &#125;</span><br><span class="line">    public final void clear()               &#123; LinkedHashMap.this.clear(); &#125;</span><br><span class="line">    public final Iterator&lt;K&gt; iterator() &#123;</span><br><span class="line">        return new LinkedKeyIterator();</span><br><span class="line">    &#125;</span><br><span class="line">    public final boolean contains(Object o) &#123; return containsKey(o); &#125;</span><br><span class="line">    public final boolean remove(Object key) &#123;</span><br><span class="line">        return removeNode(hash(key), key, null, false, true) != null;</span><br><span class="line">    &#125;</span><br><span class="line">    public final Spliterator&lt;K&gt; spliterator()  &#123;</span><br><span class="line">        return Spliterators.spliterator(this, Spliterator.SIZED |</span><br><span class="line">                                        Spliterator.ORDERED |</span><br><span class="line">                                        Spliterator.DISTINCT);</span><br><span class="line">    &#125;</span><br><span class="line">    public final void forEach(Consumer&lt;? super K&gt; action) &#123;</span><br><span class="line">        if (action == null)</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        int mc = modCount;</span><br><span class="line">        for (LinkedHashMap.Entry&lt;K,V&gt; e = head; e != null; e = e.after)</span><br><span class="line">            action.accept(e.key);</span><br><span class="line">        if (modCount != mc)</span><br><span class="line">            throw new ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="newNode、newTreeNode"><a href="#newNode、newTreeNode" class="headerlink" title="newNode、newTreeNode"></a>newNode、newTreeNode</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 新建链表</span><br><span class="line"> */</span><br><span class="line">Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; e) &#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">        new LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e);</span><br><span class="line">    linkNodeLast(p);</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 新建红黑树节点</span><br><span class="line"> */ </span><br><span class="line">TreeNode&lt;K,V&gt; newTreeNode(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; p = new TreeNode&lt;K,V&gt;(hash, key, value, next);</span><br><span class="line">    linkNodeLast(p);</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 上面都有用到，把p接到旧链表尾后面</span><br><span class="line"> */</span><br><span class="line">private void linkNodeLast(LinkedHashMap.Entry&lt;K,V&gt; p) &#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last = tail;</span><br><span class="line">    tail = p;</span><br><span class="line">    if (last == null)</span><br><span class="line">        head = p;</span><br><span class="line">    else &#123;</span><br><span class="line">        p.before = last;</span><br><span class="line">        last.after = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="values"><a href="#values" class="headerlink" title="values"></a>values</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 获取value集合</span><br><span class="line"> */</span><br><span class="line">public Collection&lt;V&gt; values() &#123;</span><br><span class="line">    Collection&lt;V&gt; vs = values;</span><br><span class="line">    if (vs == null) &#123;</span><br><span class="line">        vs = new LinkedValues();</span><br><span class="line">        values = vs;</span><br><span class="line">    &#125;</span><br><span class="line">    return vs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final class LinkedValues extends AbstractCollection&lt;V&gt; &#123;</span><br><span class="line">    public final int size()                 &#123; return size; &#125;</span><br><span class="line">    public final void clear()               &#123; LinkedHashMap.this.clear(); &#125;</span><br><span class="line">    public final Iterator&lt;V&gt; iterator() &#123;</span><br><span class="line">        return new LinkedValueIterator();</span><br><span class="line">    &#125;</span><br><span class="line">    public final boolean contains(Object o) &#123; return containsValue(o); &#125;</span><br><span class="line">    public final Spliterator&lt;V&gt; spliterator() &#123;</span><br><span class="line">        return Spliterators.spliterator(this, Spliterator.SIZED |</span><br><span class="line">                                        Spliterator.ORDERED);</span><br><span class="line">    &#125;</span><br><span class="line">    public final void forEach(Consumer&lt;? super V&gt; action) &#123;</span><br><span class="line">        if (action == null)</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        int mc = modCount;</span><br><span class="line">        for (LinkedHashMap.Entry&lt;K,V&gt; e = head; e != null; e = e.after)</span><br><span class="line">            action.accept(e.value);</span><br><span class="line">        if (modCount != mc)</span><br><span class="line">            throw new ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>little_eight</tag>
      </tags>
  </entry>
  <entry>
    <title>java.util.HashSet类解析</title>
    <url>/2019/04/16/java-util-HashSet%E7%B1%BB%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>HashSet 是一个由 HashMap 实现的集合，元素无序且不能重复。<br>其方法基本都是HashMap的方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">    * 继承 AbstractSet</span><br><span class="line">    *          AbstractSet也是实现了Set接口的，跟HashMap一个毛病，脱裤子放屁....</span><br><span class="line">    * 实现 Set 接口</span><br><span class="line">    *          这个接口是 Set 类集合的上层接口，定义了实现该接口的类都必须要实现的一组方法</span><br><span class="line">    * 实现 Cloneable 接口</span><br><span class="line">    *          这个类是 java.lang.Cloneable，前面我们讲解深拷贝和浅拷贝的原理时，</span><br><span class="line">    *          我们介绍了浅拷贝可以通过调用 Object.clone() 方法来实现，</span><br><span class="line">    *          但是调用该方法的对象必须要实现 Cloneable 接口，</span><br><span class="line">    *          否则会抛出 CloneNoSupportException异常。</span><br><span class="line">    * 实现 Serializable 接口</span><br><span class="line">    *          序列化</span><br><span class="line">    */</span><br><span class="line">   public class HashSet&lt;E&gt; extends AbstractSet&lt;E&gt;</span><br><span class="line">   implements Set&lt;E&gt;, Cloneable, java.io.Serializable&#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 就是一个HashMap，说明靠这个来存储数据了</span><br><span class="line"> */</span><br><span class="line">  private transient HashMap&lt;E,Object&gt; map;</span><br><span class="line">/**</span><br><span class="line"> * 向HashSet中添加数据，数据在上面的 map 结构是作为 key 存在的，而value统一都是 PRESENT</span><br><span class="line"> */</span><br><span class="line">private static final Object PRESENT = new Object();</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 就是new一个HashMap</span><br><span class="line"> */</span><br><span class="line">public HashSet() &#123;</span><br><span class="line">    map = new HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 指定初始容量HashMap </span><br><span class="line"> */</span><br><span class="line">public HashSet(int initialCapacity) &#123;</span><br><span class="line">    map = new HashMap&lt;&gt;(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 指定初始容量和加载因子HashMap </span><br><span class="line"> */</span><br><span class="line">public HashSet(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">    map = new HashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 这个dummy都没用到,兼容旧版本用的吧。</span><br><span class="line"> */</span><br><span class="line">HashSet(int initialCapacity, float loadFactor, boolean dummy) &#123;</span><br><span class="line">    map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 构造包含指定集合中的元素</span><br><span class="line"> */</span><br><span class="line">public HashSet(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">    map = new HashMap&lt;&gt;(Math.max((int) (c.size()/.75f) + 1, 16));</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="add"><a href="#add" class="headerlink" title="add"></a>add</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 往map里put值</span><br><span class="line"> */</span><br><span class="line"> public boolean add(E e) &#123;</span><br><span class="line">    return map.put(e, PRESENT)==null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 清除map</span><br><span class="line"> */</span><br><span class="line">public void clear() &#123;</span><br><span class="line">    map.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 克隆</span><br><span class="line"> */</span><br><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">public Object clone() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        HashSet&lt;E&gt; newSet = (HashSet&lt;E&gt;) super.clone();</span><br><span class="line">        newSet.map = (HashMap&lt;E, Object&gt;) map.clone();</span><br><span class="line">        return newSet;</span><br><span class="line">    &#125; catch (CloneNotSupportedException e) &#123;</span><br><span class="line">        throw new InternalError(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="contains"><a href="#contains" class="headerlink" title="contains"></a>contains</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 是否包含此值，也就是判断是否包含此key</span><br><span class="line"> */</span><br><span class="line">public boolean contains(Object o) &#123;</span><br><span class="line">    return map.containsKey(o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="isEmpty"><a href="#isEmpty" class="headerlink" title="isEmpty"></a>isEmpty</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 是否为空</span><br><span class="line"> */</span><br><span class="line">public boolean isEmpty() &#123;</span><br><span class="line">    return map.isEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="iterator"><a href="#iterator" class="headerlink" title="iterator"></a>iterator</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 迭代类</span><br><span class="line"> */</span><br><span class="line">public Iterator&lt;E&gt; iterator() &#123;</span><br><span class="line">    return map.keySet().iterator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 移除某值</span><br><span class="line"> */</span><br><span class="line">public boolean remove(Object o) &#123;</span><br><span class="line">    return map.remove(o)==PRESENT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>little_eight</tag>
      </tags>
  </entry>
  <entry>
    <title>java.util.LinkedHashSet类解析</title>
    <url>/2019/04/22/java-util-LinkedHashSet%E7%B1%BB%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>元素有序且不能重复。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">    * 实现 Cloneable 接口</span><br><span class="line">    *          这个类是 java.lang.Cloneable，前面我们讲解深拷贝和浅拷贝的原理时，</span><br><span class="line">    *          我们介绍了浅拷贝可以通过调用 Object.clone() 方法来实现，</span><br><span class="line">    *          但是调用该方法的对象必须要实现 Cloneable 接口，</span><br><span class="line">    *          否则会抛出 CloneNoSupportException异常。</span><br><span class="line">    * 实现 Serializable 接口</span><br><span class="line">    *          序列化</span><br><span class="line">    */</span><br><span class="line">    public class LinkedHashSet&lt;E&gt; extends HashSet&lt;E&gt; implements Set&lt;E&gt;,</span><br><span class="line">    Cloneable,java.io.Serializable&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>看上面似乎LinkedHashSet 是由HashSet实现的集合，其实是LinkedHashMap实现的。从下面的构造方法即可看出。</p>
<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> /**</span><br><span class="line">  * 依然是提供三种构造方法，实现都是super方法，下面我们看看是怎么实现的 </span><br><span class="line">  */</span><br><span class="line">public LinkedHashSet() &#123;</span><br><span class="line">     super(16, .75f, true);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">public LinkedHashSet(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">     super(Math.max(2*c.size(), 11), .75f, true);</span><br><span class="line">     addAll(c);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> public LinkedHashSet(int initialCapacity) &#123;</span><br><span class="line">     super(initialCapacity, .75f, true);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> /**</span><br><span class="line">  * 之前还疑惑这里dummy为啥没用，原来是为了用到这里做区分的</span><br><span class="line">  * 明显看出看出LinkedHashSet 是由LinkedHashMap实现的集合</span><br><span class="line">  */</span><br><span class="line"> HashSet(int initialCapacity, float loadFactor, boolean dummy) &#123;</span><br><span class="line">     map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line"> &#125;    </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="其他方法基本都可以看HashSet了"><a href="#其他方法基本都可以看HashSet了" class="headerlink" title="其他方法基本都可以看HashSet了"></a>其他方法基本都可以看HashSet了</h2>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>little_eight</tag>
      </tags>
  </entry>
  <entry>
    <title>java.util.LinkedList类解析</title>
    <url>/2019/04/15/java-util-LinkedList%E7%B1%BB%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>　LinkedList 是一个用链表实现的集合，元素有序且可以重复。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 实现 List 接口</span><br><span class="line"> *          这个接口是 List 类集合的上层接口，定义了实现该接口的类都必须要实现的一组方法</span><br><span class="line"> * 实现 Deque 接口</span><br><span class="line"> *          这是一个双向队列接口，双向队列就是两端都可以进行增加和删除操作。</span><br><span class="line"> * 实现 Cloneable 接口</span><br><span class="line"> *          这个类是 java.lang.Cloneable，前面我们讲解深拷贝和浅拷贝的原理时，</span><br><span class="line"> *          我们介绍了浅拷贝可以通过调用 Object.clone() 方法来实现，</span><br><span class="line"> *          但是调用该方法的对象必须要实现 Cloneable 接口，</span><br><span class="line"> *          否则会抛出 CloneNoSupportException异常。</span><br><span class="line"> * 实现 Serializable 接口</span><br><span class="line"> *          序列化</span><br><span class="line"> */</span><br><span class="line">public class LinkedList&lt;E&gt;</span><br><span class="line">extends AbstractSequentialList&lt;E&gt;</span><br><span class="line">implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 链表的个数，也就是集合的大小吧</span><br><span class="line"> */</span><br><span class="line">transient int size = 0;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 链表的头</span><br><span class="line"> */</span><br><span class="line">transient Node&lt;E&gt; first;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 链表的尾</span><br><span class="line"> */</span><br><span class="line">transient Node&lt;E&gt; last;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> /**</span><br><span class="line">  * 链表的类</span><br><span class="line">  */</span><br><span class="line">private static class Node&lt;E&gt; &#123;</span><br><span class="line">     // 存的值</span><br><span class="line">     E item;</span><br><span class="line">     // 指向下一个节点的引用</span><br><span class="line">     Node&lt;E&gt; next;</span><br><span class="line">     // 指向上一个节点的引用</span><br><span class="line">     Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">     Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">         this.item = element;</span><br><span class="line">         this.next = next;</span><br><span class="line">         this.prev = prev;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">   * 什么都没初始化。。。</span><br><span class="line">   */</span><br><span class="line">  public LinkedList() &#123;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 就是集合c转换成LinkedList吧，addAll方法后面再说</span><br><span class="line"> */</span><br><span class="line">public LinkedList(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">    this();</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    int numNew = a.length;</span><br><span class="line">    if (numNew == 0)</span><br><span class="line">        return false;</span><br><span class="line"></span><br><span class="line">    Node&lt;E&gt; pred, succ;</span><br><span class="line">    if (index == size) &#123;</span><br><span class="line">        succ = null;</span><br><span class="line">        pred = last;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        succ = node(index);</span><br><span class="line">        pred = succ.prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (Object o : a) &#123;</span><br><span class="line">        @SuppressWarnings(&quot;unchecked&quot;) E e = (E) o;</span><br><span class="line">        Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, null);</span><br><span class="line">        if (pred == null)</span><br><span class="line">            first = newNode;    </span><br><span class="line">        else</span><br><span class="line">            pred.next = newNode;</span><br><span class="line">        pred = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (succ == null) &#123;</span><br><span class="line">        last = pred;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        pred.next = succ;</span><br><span class="line">        succ.prev = pred;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    size += numNew;</span><br><span class="line">    modCount++;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="add"><a href="#add" class="headerlink" title="add"></a>add</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> /**</span><br><span class="line">  *把元素加到指定下标，也就是在指定下标插入（新建）链表</span><br><span class="line">  */</span><br><span class="line"></span><br><span class="line">public void add(int index, E element) &#123;</span><br><span class="line">        checkPositionIndex(index);</span><br><span class="line">        // 如果下标刚好是集合大小，就直接把这个元素加到链表尾</span><br><span class="line">        if (index == size)</span><br><span class="line">            linkLast(element);</span><br><span class="line">        else</span><br><span class="line">            linkBefore(element, node(index));</span><br><span class="line">    &#125;</span><br><span class="line">      /**</span><br><span class="line">       * 加到链表尾的方法</span><br><span class="line">       */</span><br><span class="line">      void linkLast(E e) &#123;</span><br><span class="line">        // 现在的链表尾赋给 l</span><br><span class="line">        final Node&lt;E&gt; l = last;</span><br><span class="line">        // 新建链表，上一节点为 l，下一节点为null</span><br><span class="line">        final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);</span><br><span class="line">        // newNode为链表尾</span><br><span class="line">        last = newNode;</span><br><span class="line">        // 如果l为空，说明是没有链表的，把newNode也设置成链表头</span><br><span class="line">        if (l == null)</span><br><span class="line">            first = newNode;</span><br><span class="line">        // 否则的话 就把newNode赋值给l.next，让整条链表完整</span><br><span class="line">        else</span><br><span class="line">            l.next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br><span class="line">        /**</span><br><span class="line">         * 在某个链表前面插入一个链表</span><br><span class="line">         */</span><br><span class="line">       void linkBefore(E e, Node&lt;E&gt; succ) &#123;</span><br><span class="line">        final Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">        final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ);</span><br><span class="line">        succ.prev = newNode;</span><br><span class="line">        if (pred == null)</span><br><span class="line">            first = newNode;</span><br><span class="line">        else</span><br><span class="line">            pred.next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="addAll"><a href="#addAll" class="headerlink" title="addAll"></a>addAll</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 在下标index后，添加集合c</span><br><span class="line"> */</span><br><span class="line">public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">       checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">       Object[] a = c.toArray();</span><br><span class="line">       int numNew = a.length;</span><br><span class="line">       if (numNew == 0)</span><br><span class="line">           return false;</span><br><span class="line"></span><br><span class="line">       Node&lt;E&gt; pred, succ;</span><br><span class="line">       if (index == size) &#123;</span><br><span class="line">           succ = null;</span><br><span class="line">           pred = last;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           succ = node(index);</span><br><span class="line">           pred = succ.prev;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       for (Object o : a) &#123;</span><br><span class="line">           @SuppressWarnings(&quot;unchecked&quot;) E e = (E) o;</span><br><span class="line">           Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, null);</span><br><span class="line">           if (pred == null)</span><br><span class="line">               first = newNode;</span><br><span class="line">           else</span><br><span class="line">               pred.next = newNode;</span><br><span class="line">           pred = newNode;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if (succ == null) &#123;</span><br><span class="line">           last = pred;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           pred.next = succ;</span><br><span class="line">           succ.prev = pred;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       size += numNew;</span><br><span class="line">       modCount++;</span><br><span class="line">       return true;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="addFirst"><a href="#addFirst" class="headerlink" title="addFirst"></a>addFirst</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 实现的办法是这个私有的，就是在表头加链表</span><br><span class="line"> */</span><br><span class="line">private void linkFirst(E e) &#123;</span><br><span class="line">       final Node&lt;E&gt; f = first;</span><br><span class="line">       final Node&lt;E&gt; newNode = new Node&lt;&gt;(null, e, f);</span><br><span class="line">       first = newNode;</span><br><span class="line">       if (f == null)</span><br><span class="line">           last = newNode;</span><br><span class="line">       else</span><br><span class="line">           f.prev = newNode;</span><br><span class="line">       size++;</span><br><span class="line">       modCount++;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="addLast"><a href="#addLast" class="headerlink" title="addLast"></a>addLast</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 实现的办法是这个私有的，就是在表尾加链表</span><br><span class="line"> */</span><br><span class="line">void linkLast(E e) &#123;</span><br><span class="line">       final Node&lt;E&gt; l = last;</span><br><span class="line">       final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);</span><br><span class="line">       last = newNode;</span><br><span class="line">       if (l == null)</span><br><span class="line">           first = newNode;</span><br><span class="line">       else</span><br><span class="line">           l.next = newNode;</span><br><span class="line">       size++;</span><br><span class="line">       modCount++;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 清除所有链表</span><br><span class="line"> */</span><br><span class="line">     public void clear() &#123;</span><br><span class="line">       for (Node&lt;E&gt; x = first; x != null; ) &#123;</span><br><span class="line">           Node&lt;E&gt; next = x.next;</span><br><span class="line">           x.item = null;</span><br><span class="line">           x.next = null;</span><br><span class="line">           x.prev = null;</span><br><span class="line">           x = next;</span><br><span class="line">       &#125;</span><br><span class="line">       first = last = null;</span><br><span class="line">       size = 0;</span><br><span class="line">       modCount++;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 浅拷贝</span><br><span class="line"> */</span><br><span class="line">   public Object clone() &#123;</span><br><span class="line">       // 就是Object.clone()实现克隆</span><br><span class="line">       LinkedList&lt;E&gt; clone = superClone();</span><br><span class="line">       clone.first = clone.last = null;</span><br><span class="line">       clone.size = 0;</span><br><span class="line">       clone.modCount = 0;</span><br><span class="line"></span><br><span class="line">       for (Node&lt;E&gt; x = first; x != null; x = x.next)</span><br><span class="line">           clone.add(x.item);</span><br><span class="line"></span><br><span class="line">       return clone;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="contains、indexOf、lastIndexOf"><a href="#contains、indexOf、lastIndexOf" class="headerlink" title="contains、indexOf、lastIndexOf"></a>contains、indexOf、lastIndexOf</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 是否包含此元素</span><br><span class="line"> */</span><br><span class="line">   public boolean contains(Object o) &#123;</span><br><span class="line">       return indexOf(o) != -1;</span><br><span class="line">   &#125;</span><br><span class="line">   /**</span><br><span class="line">    * 判断是否存在此元素，存在返回下标，否则返回-1</span><br><span class="line">    */ </span><br><span class="line">   public int indexOf(Object o) &#123;</span><br><span class="line">       int index = 0;</span><br><span class="line">       if (o == null) &#123;</span><br><span class="line">           for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123;</span><br><span class="line">               if (x.item == null)</span><br><span class="line">                   return index;</span><br><span class="line">               index++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123;</span><br><span class="line">               if (o.equals(x.item))</span><br><span class="line">                   return index;</span><br><span class="line">               index++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return -1;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">    /**</span><br><span class="line">    * 从尾部开始循环，判断是否存在此元素，存在返回下标，否则返回-1</span><br><span class="line">    */ </span><br><span class="line">    public int lastIndexOf(Object o) &#123;</span><br><span class="line">       int index = size;</span><br><span class="line">       if (o == null) &#123;</span><br><span class="line">           for (Node&lt;E&gt; x = last; x != null; x = x.prev) &#123;</span><br><span class="line">               index--;</span><br><span class="line">               if (x.item == null)</span><br><span class="line">                   return index;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           for (Node&lt;E&gt; x = last; x != null; x = x.prev) &#123;</span><br><span class="line">               index--;</span><br><span class="line">               if (o.equals(x.item))</span><br><span class="line">                   return index;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return -1;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="get、getFirst、getLast"><a href="#get、getFirst、getLast" class="headerlink" title="get、getFirst、getLast"></a>get、getFirst、getLast</h3><p>这三个get方法都必须保证元素非null的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 根据下标返回元素（）</span><br><span class="line"> */</span><br><span class="line">public E get(int index) &#123;</span><br><span class="line">       checkElementIndex(index);</span><br><span class="line">       return node(index).item;</span><br><span class="line">   &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 返回链表头的元素</span><br><span class="line">     */</span><br><span class="line">    public E getFirst() &#123;</span><br><span class="line">       final Node&lt;E&gt; f = first;</span><br><span class="line">       if (f == null)</span><br><span class="line">           throw new NoSuchElementException();</span><br><span class="line">       return f.item;</span><br><span class="line">   &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 返回链表尾的元素</span><br><span class="line">     */</span><br><span class="line">       public E getLast() &#123;</span><br><span class="line">       final Node&lt;E&gt; l = last;</span><br><span class="line">       if (l == null)</span><br><span class="line">           throw new NoSuchElementException();</span><br><span class="line">       return l.item;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="listIterator"><a href="#listIterator" class="headerlink" title="listIterator"></a>listIterator</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 就是根据下标new一个内部迭代类</span><br><span class="line"> */</span><br><span class="line">  public ListIterator&lt;E&gt; listIterator(int index) &#123;</span><br><span class="line">       checkPositionIndex(index);</span><br><span class="line">       return new ListItr(index);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="offer、offerFirst、offerLast"><a href="#offer、offerFirst、offerLast" class="headerlink" title="offer、offerFirst、offerLast"></a>offer、offerFirst、offerLast</h3><p>这个跟add一样的，只不过返回一个true的结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public boolean offer(E e) &#123;</span><br><span class="line">     return add(e);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> public boolean offerFirst(E e) &#123;</span><br><span class="line">     addFirst(e);</span><br><span class="line">     return true;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">   public boolean offerLast(E e) &#123;</span><br><span class="line">     addLast(e);</span><br><span class="line">     return true;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="peek、peekFirst、peekLast"><a href="#peek、peekFirst、peekLast" class="headerlink" title="peek、peekFirst、peekLast"></a>peek、peekFirst、peekLast</h3><p>这三个方法都不用保证元素非null的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 1.5版本的获取链表头的元素</span><br><span class="line"> */</span><br><span class="line"> public E peek() &#123;</span><br><span class="line">     final Node&lt;E&gt; f = first;</span><br><span class="line">     return (f == null) ? null : f.item;</span><br><span class="line"> &#125;</span><br><span class="line">  /**</span><br><span class="line">   *1.6版本的获取链表头的元素</span><br><span class="line">   */</span><br><span class="line"> public E peekFirst() &#123;</span><br><span class="line">     final Node&lt;E&gt; f = first;</span><br><span class="line">     return (f == null) ? null : f.item;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">   /**</span><br><span class="line">    *获取链表尾的元素</span><br><span class="line">    */</span><br><span class="line"> public E peekLast() &#123;</span><br><span class="line">     final Node&lt;E&gt; l = last;</span><br><span class="line">     return (l == null) ? null : l.item;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<h3 id="poll、pollFirst、pollLast"><a href="#poll、pollFirst、pollLast" class="headerlink" title="poll、pollFirst、pollLast"></a>poll、pollFirst、pollLast</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  /**</span><br><span class="line">   * 1.5版本的删除链表头</span><br><span class="line">   */</span><br><span class="line">public E poll() &#123;</span><br><span class="line">     final Node&lt;E&gt; f = first;</span><br><span class="line">     return (f == null) ? null : unlinkFirst(f);</span><br><span class="line"> &#125;</span><br><span class="line">  /**</span><br><span class="line">   * 1.6版本删除链表头</span><br><span class="line">   */</span><br><span class="line"> public E pollFirst() &#123;</span><br><span class="line">     final Node&lt;E&gt; f = first;</span><br><span class="line">     return (f == null) ? null : unlinkFirst(f);</span><br><span class="line"> &#125;</span><br><span class="line">  /**</span><br><span class="line">   * 删除链表尾</span><br><span class="line">   */</span><br><span class="line">  public E pollLast() &#123;</span><br><span class="line">     final Node&lt;E&gt; l = last;</span><br><span class="line">     return (l == null) ? null : unlinkLast(l);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> /**</span><br><span class="line">  * 把指定的链表设置为null，让gc自己去回收</span><br><span class="line">  */</span><br><span class="line">  private E unlinkLast(Node&lt;E&gt; l) &#123;</span><br><span class="line">     // assert l == last &amp;&amp; l != null;</span><br><span class="line">     final E element = l.item;</span><br><span class="line">     final Node&lt;E&gt; prev = l.prev;</span><br><span class="line">     l.item = null;</span><br><span class="line">     l.prev = null; // help GC</span><br><span class="line">     last = prev;</span><br><span class="line">     if (prev == null)</span><br><span class="line">         first = null;</span><br><span class="line">     else</span><br><span class="line">         prev.next = null;</span><br><span class="line">     size--;</span><br><span class="line">     modCount++;</span><br><span class="line">     return element;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="remove、removeFirst、removeLast"><a href="#remove、removeFirst、removeLast" class="headerlink" title="remove、removeFirst、removeLast"></a>remove、removeFirst、removeLast</h3><p>顾名思义，就是删除链表，实现方法都是unlink（必须保证非null）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> /**</span><br><span class="line">  * 删除指定链表</span><br><span class="line">  */</span><br><span class="line">E unlink(Node&lt;E&gt; x) &#123;</span><br><span class="line">        // assert x != null;</span><br><span class="line">        final E element = x.item;</span><br><span class="line">        final Node&lt;E&gt; next = x.next;</span><br><span class="line">        final Node&lt;E&gt; prev = x.prev;</span><br><span class="line"></span><br><span class="line">        if (prev == null) &#123;</span><br><span class="line">            first = next;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            prev.next = next;</span><br><span class="line">            x.prev = null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (next == null) &#123;</span><br><span class="line">            last = prev;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            next.prev = prev;</span><br><span class="line">            x.next = null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        x.item = null;</span><br><span class="line">        size--;</span><br><span class="line">        modCount++;</span><br><span class="line">        return element;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 根据下标设置对应链表的元素</span><br><span class="line"> */</span><br><span class="line">   public E set(int index, E element) &#123;</span><br><span class="line">       checkElementIndex(index);</span><br><span class="line">       Node&lt;E&gt; x = node(index);</span><br><span class="line">       E oldVal = x.item;</span><br><span class="line">       x.item = element;</span><br><span class="line">       return oldVal;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="toArray"><a href="#toArray" class="headerlink" title="toArray"></a>toArray</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 转换成数组</span><br><span class="line"> */</span><br><span class="line">  public Object[] toArray() &#123;</span><br><span class="line">       Object[] result = new Object[size];</span><br><span class="line">       int i = 0;</span><br><span class="line">       for (Node&lt;E&gt; x = first; x != null; x = x.next)</span><br><span class="line">           result[i++] = x.item;</span><br><span class="line">       return result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>little_eight</tag>
      </tags>
  </entry>
  <entry>
    <title>java.util.Optional类解析</title>
    <url>/2019/04/22/java-util-Optional%E7%B1%BB%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 从后面的构造方法可以看出，这里new一个value为null的Optional</span><br><span class="line"> */</span><br><span class="line">private static final Optional&lt;?&gt; EMPTY = new Optional&lt;&gt;();</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 值</span><br><span class="line"> */</span><br><span class="line">private final T value;</span><br></pre></td></tr></table></figure>


<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * value = null</span><br><span class="line"> */</span><br><span class="line">private Optional() &#123;</span><br><span class="line">    this.value = null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 自定义value值，value为null会抛异常</span><br><span class="line"> */</span><br><span class="line">private Optional(T value) &#123;</span><br><span class="line">    this.value = Objects.requireNonNull(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static &lt;T&gt; T requireNonNull(T obj) &#123;</span><br><span class="line">    if (obj == null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="empty"><a href="#empty" class="headerlink" title="empty"></a>empty</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 返回一个空Optional</span><br><span class="line"> */</span><br><span class="line"> public static&lt;T&gt; Optional&lt;T&gt; empty() &#123;</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    Optional&lt;T&gt; t = (Optional&lt;T&gt;) EMPTY;</span><br><span class="line">    return t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 重写equals，为了实现最后2行代码</span><br><span class="line"> */</span><br><span class="line">public boolean equals(Object obj) &#123;</span><br><span class="line">    if (this == obj) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!(obj instanceof Optional)) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Optional&lt;?&gt; other = (Optional&lt;?&gt;) obj;</span><br><span class="line">    return Objects.equals(value, other.value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 如果value不为空并且满足断言条件返回包含该值的Optional，否则返回空Optional。</span><br><span class="line"> * 用法：filter((value) -&gt; xx())</span><br><span class="line"> */</span><br><span class="line">public Optional&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate) &#123;</span><br><span class="line">    Objects.requireNonNull(predicate);</span><br><span class="line">    if (!isPresent())</span><br><span class="line">        return this;</span><br><span class="line">    else</span><br><span class="line">        return predicate.test(value) ? this : empty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="get"><a href="#get" class="headerlink" title="get"></a>get</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 获取value，为null抛异常</span><br><span class="line"> */</span><br><span class="line">public T get() &#123;</span><br><span class="line">    if (value == null) &#123;</span><br><span class="line">        throw new NoSuchElementException(&quot;No value present&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="isPresent"><a href="#isPresent" class="headerlink" title="isPresent"></a>isPresent</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * value是否为null</span><br><span class="line"> */</span><br><span class="line">public boolean isPresent() &#123;</span><br><span class="line">    return value != null;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 跟上面一样，不过是迎合lambda，写法ifPresent((value) -&gt; xx()）</span><br><span class="line"> */</span><br><span class="line">public void ifPresent(Consumer&lt;? super T&gt; consumer) &#123;</span><br><span class="line">    if (value != null)</span><br><span class="line">        consumer.accept(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 如果value不为null，则对其执行调用mapping函数得到返回值。</span><br><span class="line"> * 如果返回值不为null，则创建包含mapping返回值的Optional作为map方法返回值，否则返回空Optional。</span><br><span class="line"> */</span><br><span class="line">public&lt;U&gt; Optional&lt;U&gt; map(Function&lt;? super T, ? extends U&gt; mapper) &#123;</span><br><span class="line">    Objects.requireNonNull(mapper);</span><br><span class="line">    if (!isPresent())</span><br><span class="line">        return empty();</span><br><span class="line">    else &#123;</span><br><span class="line">        return Optional.ofNullable(mapper.apply(value));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="of"><a href="#of" class="headerlink" title="of"></a>of</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  返回一个带value的Optional</span><br><span class="line"> */</span><br><span class="line">public static &lt;T&gt; Optional&lt;T&gt; of(T value) &#123;</span><br><span class="line">    return new Optional&lt;&gt;(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ofNullable"><a href="#ofNullable" class="headerlink" title="ofNullable"></a>ofNullable</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  相当于综合了empty跟of</span><br><span class="line"> */</span><br><span class="line"> public static &lt;T&gt; Optional&lt;T&gt; ofNullable(T value) &#123;</span><br><span class="line">    return value == null ? empty() : of(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="orElse"><a href="#orElse" class="headerlink" title="orElse"></a>orElse</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * value为null就返回other，不为空返回value</span><br><span class="line"> */</span><br><span class="line">public T orElse(T other) &#123;</span><br><span class="line">    return value != null ? value : other;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="orElseGet"><a href="#orElseGet" class="headerlink" title="orElseGet"></a>orElseGet</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * value为null就返回other，不为空返回value</span><br><span class="line"> * 用法 orElseGet(() -&gt; xx())</span><br><span class="line"> */</span><br><span class="line">public T orElseGet(Supplier&lt;? extends T&gt; other) &#123;</span><br><span class="line">    return value != null ? value : other.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="orElseThrow"><a href="#orElseThrow" class="headerlink" title="orElseThrow"></a>orElseThrow</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 如果value不为空返回value，否则抛出supplier接口创建的异常。</span><br><span class="line"> * 用法： orElseThrow(XXException::new)</span><br><span class="line"> */</span><br><span class="line">public &lt;X extends Throwable&gt; T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier) throws X &#123;</span><br><span class="line">    if (value != null) &#123;</span><br><span class="line">        return value;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        throw exceptionSupplier.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>little_eight</tag>
      </tags>
  </entry>
  <entry>
    <title>java.util.ArrayList类解析</title>
    <url>/2019/04/11/java.util.ArrayList%E7%B1%BB%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>ArrayList 是一个用数组实现的集合，支持随机访问，元素有序且可以重复。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 实现 List 接口</span><br><span class="line"> *          这个接口是 List 类集合的上层接口，定义了实现该接口的类都必须要实现的一组方法</span><br><span class="line"> * 实现 RandomAccess 接口</span><br><span class="line"> *          这是一个标记接口，一般此标记接口用于 List 实现，</span><br><span class="line"> *          以表明它们支持快速（通常是恒定时间）的随机访问。</span><br><span class="line"> *          该接口的主要目的是允许通用算法改变其行为，</span><br><span class="line"> *          以便在应用于随机或顺序访问列表时提供良好的性能</span><br><span class="line"> * 实现 Cloneable 接口</span><br><span class="line"> *          这个类是 java.lang.Cloneable，前面我们讲解深拷贝和浅拷贝的原理时，</span><br><span class="line"> *          我们介绍了浅拷贝可以通过调用 Object.clone() 方法来实现，</span><br><span class="line"> *          但是调用该方法的对象必须要实现 Cloneable 接口，</span><br><span class="line"> *          否则会抛出 CloneNoSupportException异常。</span><br><span class="line"> * 实现 Serializable 接口</span><br><span class="line"> *          序列化</span><br><span class="line"> */</span><br><span class="line">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;</span><br><span class="line">    implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 默认初始大小.</span><br><span class="line"> */</span><br><span class="line">private static final int DEFAULT_CAPACITY = 10;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 用于空实例的共享空数组实例。</span><br><span class="line"> */</span><br><span class="line">private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 共享空数组实例，用于默认大小的空实例。我们将其与空元素数据区分开来，</span><br><span class="line"> * 以了解添加第一个元素时要加多少量。</span><br><span class="line"> */</span><br><span class="line">private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 存储集合元素的数组缓冲区。集合的容量是这个数组缓冲区的长度。</span><br><span class="line"> * 任何带有elementdata==DEFAULTCAPACITY_EMPTY_ELEMENTDATA的空集合</span><br><span class="line"> * 将在添加第一个元素时扩展为默认容量。</span><br><span class="line"> */</span><br><span class="line">transient Object[] elementData;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 集合大小</span><br><span class="line"> */</span><br><span class="line">private int size;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Constructs an empty list with an initial capacity of ten.(构造初始容量为10的空列表。)</span><br><span class="line"> * 明明说是10，其实看代码只是创建了一个空数组，应该是版本更新忘了改注释了。</span><br><span class="line"> */</span><br><span class="line">public ArrayList() &#123;</span><br><span class="line">    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 构造具有指定初始容量的空列表</span><br><span class="line"> */</span><br><span class="line">public ArrayList(int initialCapacity) &#123;</span><br><span class="line">    if (initialCapacity &gt; 0) &#123;</span><br><span class="line">        this.elementData = new Object[initialCapacity];</span><br><span class="line">    &#125; else if (initialCapacity == 0) &#123;</span><br><span class="line">        this.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 按照集合迭代器返回元素的顺序构造包含指定集合的元素的列表。</span><br><span class="line"> */</span><br><span class="line">public ArrayList(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    if ((size = elementData.length) != 0) &#123;</span><br><span class="line">        // c.toArray might (incorrectly) not return Object[] (see 6260652)</span><br><span class="line">        if (elementData.getClass() != Object[].class)</span><br><span class="line">            elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // replace with empty array.</span><br><span class="line">        this.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h2 id="add"><a href="#add" class="headerlink" title="add"></a>add</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public boolean add(E e) &#123;</span><br><span class="line">     ensureCapacityInternal(size + 1);</span><br><span class="line">     elementData[size++] = e;</span><br><span class="line">     return true;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p> 看看ensureCapacityInternal方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> private void ensureCapacityInternal(int minCapacity) &#123;</span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再看看calculateCapacity,可以看到当elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA时，也就是这是new ArrayList后第一次加进元素的话，就会返回初始容量10，后面根据这个新建一个10容量的数组</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> private static int calculateCapacity(Object[] elementData, int minCapacity) &#123;</span><br><span class="line">    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        return Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    return minCapacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ensureExplicitCapacity是干嘛的呢，是确保数组可用，如果容量不够，就要进行扩容了，也就是grow方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void ensureExplicitCapacity(int minCapacity) &#123;</span><br><span class="line">      modCount++;</span><br><span class="line">      if (minCapacity - elementData.length &gt; 0)</span><br><span class="line">          grow(minCapacity);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>看看grow方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> /**</span><br><span class="line">  * 增加容量以确保它至少能容纳最小容量参数指定的元素数。一般是扩容1.5倍</span><br><span class="line">  */</span><br><span class="line">private void grow(int minCapacity) &#123;</span><br><span class="line">     // 现在数组的容量</span><br><span class="line">     int oldCapacity = elementData.length;</span><br><span class="line">     // 扩容1.5倍的容量</span><br><span class="line">     int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</span><br><span class="line">     // 如果1.5倍容量小于minCapacity，那把minC赋值给newC</span><br><span class="line">     if (newCapacity - minCapacity &lt; 0)</span><br><span class="line">         newCapacity = minCapacity;</span><br><span class="line">     // 如果1.5倍容量大于MAX_ARRAY_SIZE（int最大值 - 8）</span><br><span class="line">     if (newCapacity - MAX_ARRAY_SIZE（0x7fffffff - 8） &gt; 0)</span><br><span class="line">         // hugeCapacity是这样的，minC &gt; MAX_ARRAY_SIZE) ?Integer.MAX_VALUE : MAX_ARRAY_SIZE;</span><br><span class="line">         newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">     // 这里用到数组复制的方法，扩容到指定大小</span><br><span class="line">     elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>


<h3 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> // 就是清空数组，也就是清空集合</span><br><span class="line">public void clear() &#123;</span><br><span class="line">     modCount++;</span><br><span class="line"></span><br><span class="line">     // clear to let GC do its work</span><br><span class="line">     for (int i = 0; i &lt; size; i++)</span><br><span class="line">         elementData[i] = null;</span><br><span class="line"></span><br><span class="line">     size = 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> // 克隆集合。。</span><br><span class="line"> public Object clone() &#123;</span><br><span class="line">       try &#123;</span><br><span class="line">           ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) super.clone();</span><br><span class="line">           v.elementData = Arrays.copyOf(elementData, size);</span><br><span class="line">           v.modCount = 0;</span><br><span class="line">           return v;</span><br><span class="line">       &#125; catch (CloneNotSupportedException e) &#123;</span><br><span class="line">           // this shouldn&#x27;t happen, since we are Cloneable</span><br><span class="line">           throw new InternalError(e);</span><br><span class="line">       &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="contains"><a href="#contains" class="headerlink" title="contains"></a>contains</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public boolean contains(Object o) &#123;</span><br><span class="line">    return indexOf(o) &gt;= 0;</span><br><span class="line">&#125;</span><br><span class="line">//  // 从前面开始遍历，返回第一个与o相等的下标，不存在返回-1</span><br><span class="line">public int indexOf(Object o) &#123;</span><br><span class="line">    if (o == null) &#123;</span><br><span class="line">        for (int i = 0; i &lt; size; i++)</span><br><span class="line">            if (elementData[i]==null)</span><br><span class="line">                return i;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        for (int i = 0; i &lt; size; i++)</span><br><span class="line">            if (o.equals(elementData[i]))</span><br><span class="line">                return i;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 根据下标值获取对应元素</span><br><span class="line">public E get(int index) &#123;</span><br><span class="line">       // 检查是否超过最大下标值</span><br><span class="line">       rangeCheck(index);</span><br><span class="line">       // 就是 elementData[index]</span><br><span class="line">       return elementData(index);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="iterator"><a href="#iterator" class="headerlink" title="iterator"></a>iterator</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 返回的是一个内部类 Itr，Itr这里就不做多解释了，有兴趣可以自己去看。</span><br><span class="line">public Iterator&lt;E&gt; iterator() &#123;</span><br><span class="line">      return new Itr();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="lastIndexOf"><a href="#lastIndexOf" class="headerlink" title="lastIndexOf"></a>lastIndexOf</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 从后面开始遍历，返回第一个与o相等的下标，不存在返回-1</span><br><span class="line"> public int lastIndexOf(Object o) &#123;</span><br><span class="line">       if (o == null) &#123;</span><br><span class="line">           for (int i = size-1; i &gt;= 0; i--)</span><br><span class="line">               if (elementData[i]==null)</span><br><span class="line">                   return i;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           for (int i = size-1; i &gt;= 0; i--)</span><br><span class="line">               if (o.equals(elementData[i]))</span><br><span class="line">                   return i;</span><br><span class="line">       &#125;</span><br><span class="line">       return -1;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


<h3 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 移除指定下标的元素，可以看到是用System.arraycopy来实现对移除元素后数组进行重新组合，让其他元素位置不变</span><br><span class="line">public E remove(int index) &#123;</span><br><span class="line">     rangeCheck(index);</span><br><span class="line"></span><br><span class="line">     modCount++;</span><br><span class="line">     E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">     int numMoved = size - index - 1;</span><br><span class="line">     if (numMoved &gt; 0)</span><br><span class="line">         System.arraycopy(elementData, index+1, elementData, index,</span><br><span class="line">                          numMoved);</span><br><span class="line">     elementData[--size] = null; // clear to let GC do its work</span><br><span class="line"></span><br><span class="line">     return oldValue;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>还有一个根据元素值来移除的，就是遍历数组，找到下标，移除，也是用System.arraycopy来实现</p>
<h3 id="removeAll"><a href="#removeAll" class="headerlink" title="removeAll"></a>removeAll</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 从此列表中删除指定集合中包含的所有元素。</span><br><span class="line"> public boolean removeAll(Collection&lt;?&gt; c) &#123;</span><br><span class="line">     Objects.requireNonNull(c);</span><br><span class="line">     return batchRemove(c, false);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 核心还是用到了System.arraycopy</span><br><span class="line">private boolean batchRemove(Collection&lt;?&gt; c, boolean complement) &#123;</span><br><span class="line">       final Object[] elementData = this.elementData;</span><br><span class="line">       int r = 0, w = 0;</span><br><span class="line">       boolean modified = false;</span><br><span class="line">       try &#123;</span><br><span class="line">           for (; r &lt; size; r++)</span><br><span class="line">               // complement等于false，也就是c不包含的元素，重新从下标0赋值到elementData</span><br><span class="line">               if (c.contains(elementData[r]) == complement)</span><br><span class="line">                   elementData[w++] = elementData[r];</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           if (r != size) &#123;</span><br><span class="line">               System.arraycopy(elementData, r,</span><br><span class="line">                                elementData, w,</span><br><span class="line">                                size - r);</span><br><span class="line">               w += size - r;</span><br><span class="line">           &#125;</span><br><span class="line">           if (w != size) &#123;</span><br><span class="line">               // clear to let GC do its work</span><br><span class="line">               for (int i = w; i &lt; size; i++)</span><br><span class="line">                   elementData[i] = null;</span><br><span class="line">               modCount += size - w;</span><br><span class="line">               size = w;</span><br><span class="line">               modified = true;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return modified;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 设值。。</span><br><span class="line"> public E set(int index, E element) &#123;</span><br><span class="line">       rangeCheck(index);</span><br><span class="line"></span><br><span class="line">       E oldValue = elementData(index);</span><br><span class="line">       elementData[index] = element;</span><br><span class="line">       return oldValue;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 对elementData进行排序，用Arrays.sort实现</span><br><span class="line">public void sort(Comparator&lt;? super E&gt; c) &#123;</span><br><span class="line">     final int expectedModCount = modCount;</span><br><span class="line">     Arrays.sort((E[]) elementData, 0, size, c);</span><br><span class="line">     if (modCount != expectedModCount) &#123;</span><br><span class="line">         throw new ConcurrentModificationException();</span><br><span class="line">     &#125;</span><br><span class="line">     modCount++;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="subList"><a href="#subList" class="headerlink" title="subList"></a>subList</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 截取指定访问的元素到SubList.,也就是生成新的集合吧</span><br><span class="line">public List&lt;E&gt; subList(int fromIndex, int toIndex) &#123;</span><br><span class="line">       subListRangeCheck(fromIndex, toIndex, size);</span><br><span class="line">       return new SubList(this, 0, fromIndex, toIndex);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="toArray"><a href="#toArray" class="headerlink" title="toArray"></a>toArray</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 转换成size大小的数组。。。</span><br><span class="line">public Object[] toArray() &#123;</span><br><span class="line">      return Arrays.copyOf(elementData, size);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 还可以指定转换的类型</span><br><span class="line">public &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">       if (a.length &lt; size)</span><br><span class="line">           // Make a new array of a&#x27;s runtime type, but my contents:</span><br><span class="line">           return (T[]) Arrays.copyOf(elementData, size, a.getClass());</span><br><span class="line">       System.arraycopy(elementData, 0, a, 0, size);</span><br><span class="line">       if (a.length &gt; size)</span><br><span class="line">           a[size] = null;</span><br><span class="line">       return a;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="trimToSize"><a href="#trimToSize" class="headerlink" title="trimToSize"></a>trimToSize</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 把数组转换成size大小的数组</span><br><span class="line"> public void trimToSize() &#123;</span><br><span class="line">      modCount++;</span><br><span class="line">      if (size &lt; elementData.length) &#123;</span><br><span class="line">          elementData = (size == 0)</span><br><span class="line">            ? EMPTY_ELEMENTDATA</span><br><span class="line">            : Arrays.copyOf(elementData, size);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>little_eight</tag>
      </tags>
  </entry>
  <entry>
    <title>java一些基本流程图</title>
    <url>/2020/09/02/java%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B%E5%9B%BE/</url>
    <content><![CDATA[<p>一些Java基础流程图/架构图</p>
<h2 id="TCP三次握手，四次挥手"><a href="#TCP三次握手，四次挥手" class="headerlink" title="TCP三次握手，四次挥手"></a>TCP三次握手，四次挥手</h2><p><img data-src="https://github.com/little-eight-china/image/blob/master/bdbk/flowsheet/tcp.png?raw=true" alt="Alt"></p>
<h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><ul>
<li>第一次握手(SYN=1, seq=x)，发送完毕后，客户端进入 SYN_SEND 状态</li>
<li>第二次握手(SYN=1, ACK=1, seq=y, ACKnum=x+1)， 发送完毕后，服务器端进入 SYN_RCVD 状态。</li>
<li>第三次握手(ACK=1，ACKnum=y+1)，发送完毕后，客户端进入 ESTABLISHED 状态，当服务器端接收到这个包时，也进入 ESTABLISHED 状态，TCP 握手，即可以开始数据传输。</li>
</ul>
<h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><ul>
<li>第一次挥手(FIN=1，seq=a)，发送完毕后，客户端进入 FIN_WAIT_1 状态</li>
<li>第二次挥手(ACK=1，ACKnum=a+1)，发送完毕后，服务器端进入 CLOSE_WAIT 状态，客户端接收到这个确认包之后，进入 FIN_WAIT_2 状态</li>
<li>第三次挥手(FIN=1，seq=b)，发送完毕后，服务器端进入 LAST_ACK 状态，等待来自客户端的最后一个ACK。</li>
<li>第四次挥手(ACK=1，ACKnum=b+1)，客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 TIME_WAIT状态，等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 CLOSED 状态。服务器端接收到这个确认包之后，关闭连接，进入 CLOSED 状态。</li>
</ul>
<h2 id="JVM内存结构"><a href="#JVM内存结构" class="headerlink" title="JVM内存结构"></a>JVM内存结构</h2><p><img data-src="https://github.com/little-eight-china/image/blob/master/bdbk/flowsheet/jvm.png?raw=true" alt="Alt"></p>
<h3 id="程序计数器（PC-寄存器）"><a href="#程序计数器（PC-寄存器）" class="headerlink" title="程序计数器（PC 寄存器）"></a>程序计数器（PC 寄存器）</h3><p>程序计数器是一块较小的内存空间，可以看作当前线程所执行的字节码的行号指示器。在虚拟机的模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、异常处理、线程恢复等基础功能都需要依赖计数器完成。</p>
<h3 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h3><ul>
<li>与程序计数器一样，Java虚拟机栈也是线程私有的，它的生命周期与线程相同</li>
<li>每个方法被执行的时候都会创建一个”栈帧”,用于存储局部变量表(包括参数)、操作数栈、动态链接、方法出口等信息。每个方法被调用到执行完的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</li>
<li>局部变量表存放各种基本数据类型boolean、byte、char、short等</li>
</ul>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>与虚拟机栈基本类似，区别在于虚拟机栈为虚拟机执行的java方法服务，而本地方法栈则是为Native方法服务。</p>
<h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h3><ul>
<li>GC堆是java虚拟机所管理的内存中最大的一块内存区域，也是被各个线程共享的内存区域，在JVM启动时创建。<br>其大小通过-Xms(最小值)和-Xmx(最大值)参数设置，-Xms为JVM启动时申请的最小内存，-Xmx为JVM可申请的最大内存。<br>由于现在收集器都是采用分代收集算法，堆被划分为新生代和老年代。新生代由S0和S1构成，可通过-Xmn参数来指定新生代的大小。<br>所有对象实例以及数组都在堆上分配。</li>
<li>Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译器生成的各种符号引用，这部分内容将在类加载后放到方法区的运行时常量池中。</li>
</ul>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><ul>
<li>也称”永久代” ，它用于存储虚拟机加载的类信息、常量、静态变量、是各个线程共享的内存区域。可以通过-XX:PermSize 和 -XX:MaxPermSize 参数限制方法区的大小。<br>运行时常量池：是方法区的一部分，其中的主要内容来自于JVM对Class的加载。</li>
<li>Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译器生成的各种符号引用，这部分内容将在类加载后放到方法区的运行时常量池中。</li>
</ul>
<h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><p><img data-src="https://github.com/little-eight-china/image/blob/master/bdbk/flowsheet/javaMemory.png?raw=true" alt="Alt"></p>
<ul>
<li>Java的多线程之间是通过共享内存进行通信的，在通信过程中会存在一系列如可见性、原子性、顺序性等问题，而JMM就是围绕着多线程通信以及与其相关的一系列特性而建立的模型。JMM定义了一些语法集，这些语法集映射到Java语言中就是volatile、synchronized等关键字。有兴趣可以看看我的另外一篇笔记：<a href="http://www.jianshu.com/p/3c1691aed%E2%80%A6">www.jianshu.com/p/3c1691aed…</a></li>
<li>Java内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了该线程中是用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。</li>
</ul>
<h2 id="spring的生命周期"><a href="#spring的生命周期" class="headerlink" title="spring的生命周期"></a>spring的生命周期</h2><p><img data-src="https://github.com/little-eight-china/image/blob/master/bdbk/flowsheet/spring.png?raw=true" alt="Alt"></p>
<ul>
<li>首先容器启动后，对bean进行初始化</li>
<li>按照bean的定义，注入属性</li>
<li>检测该对象是否实现了xxxAware接口，并将相关的xxxAware实例注入给bean，如BeanNameAware等</li>
<li>以上步骤，bean对象已正确构造，通过实现BeanPostProcessor接口，可以再进行一些自定义方法处理。如:postProcessBeforeInitialzation。</li>
<li>BeanPostProcessor的前置处理完成后，可以实现postConstruct，afterPropertiesSet,init-method等方法， 增加我们自定义的逻辑，</li>
<li>通过实现BeanPostProcessor接口，进行postProcessAfterInitialzation后置处理</li>
<li>接着Bean准备好被使用啦。</li>
<li>容器关闭后，如果Bean实现了DisposableBean接口，则会回调该接口的destroy()方法</li>
<li>通过给destroy-method指定函数，就可以在bean销毁前执行指定的逻</li>
</ul>
<h3 id="springMVC执行流程图"><a href="#springMVC执行流程图" class="headerlink" title="springMVC执行流程图"></a>springMVC执行流程图</h3><p><img data-src="https://github.com/little-eight-china/image/blob/master/bdbk/flowsheet/srpingmvc.png?raw=true" alt="Alt"></p>
<ul>
<li>User向服务器发送request,前端控制Servelt DispatcherServlet捕获;</li>
<li>DispatcherServlet对请求URL进行解析，调用HandlerMapping获得该Handler配置的所有相关的对象，最后以HandlerExecutionChain对象的形式返回.</li>
<li>DispatcherServlet 根据获得的Handler，选择一个合适的HandlerAdapter.</li>
<li>提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller)</li>
<li>Handler执行完成后，返回一个ModelAndView对象到DispatcherServlet</li>
<li>根据返回的ModelAndView，选择一个适合的ViewResolver</li>
<li>ViewResolver 结合Model和View，来渲染视图</li>
<li>将渲染结果返回给客户端。</li>
</ul>
<h2 id="spring-cloud组件架构"><a href="#spring-cloud组件架构" class="headerlink" title="spring cloud组件架构"></a>spring cloud组件架构</h2><p>Spring Cloud是一个基于Spring Boot实现的云原生应用开发工具，它为基于JVM的云原生应用开发中涉及的配置管理、服务发现、熔断器、智能路由、微代理、控制总线、分布式会话和集群状态管理等操作提供了一种简单的开发方式。</p>
<p><img data-src="https://github.com/little-eight-china/image/blob/master/bdbk/flowsheet/springcloud.png?raw=true" alt="Alt"></p>
<ul>
<li>Eureka 负责服务的注册与发现。</li>
<li>Hystrix 负责监控服务之间的调用情况，起到熔断,降级作用。</li>
<li>Spring Cloud Config 提供了统一的配置中心服务。</li>
<li>所有对外的请求和服务，我们都通过Zuul来进行转发，起到 API 网关的作用</li>
<li>最后我们使用 Sleuth+Zipkin 将所有的请求数据记录下来，方便我们进行后续分析。</li>
<li>Spring Cloud Ribbon是基于Netflix Ribbon实现的一套客户端负载均衡的工具。它是一个基于HTTP和TCP的客户端负载均衡器。</li>
<li>Feign是一个声明式的Web Service客户端，它的目的就是让Web Service调用更加简单。</li>
</ul>
<h2 id="dubbo-调用"><a href="#dubbo-调用" class="headerlink" title="dubbo 调用"></a>dubbo 调用</h2><p>Dubbo是一个分布式服务框架，致力于提供高性能和透明化的远程服务调用方案，这容易和负载均衡弄混，负载均衡是对外提供一个公共地址，请求过来时通过轮询、随机等，路由到不同server。</p>
<p><img data-src="https://github.com/little-eight-china/image/blob/master/bdbk/flowsheet/dubbo.png?raw=true" alt="Alt"></p>
<ul>
<li>Provider: 暴露服务的服务提供方。</li>
<li>Consumer: 调用远程服务的服务消费方。</li>
<li>Registry: 服务注册与发现的注册中心。</li>
<li>Monitor: 统计服务的调用次调和调用时间的监控中心。</li>
<li>Container: 服务运行容器。</li>
</ul>
]]></content>
      <categories>
        <category>java杂记</category>
      </categories>
      <tags>
        <tag>little_eight</tag>
      </tags>
  </entry>
  <entry>
    <title>java面试题（一）</title>
    <url>/2018/07/18/java%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h1 id="java面试题"><a href="#java面试题" class="headerlink" title="java面试题"></a>java面试题</h1><p><strong>基础问题</strong><br>1.hashcode相等两个类一定相等吗？equals呢？相反呢？<br>2.介绍一下集合框架<br>3.hashmap和hashtable底层实现有什么区别？<br>hashmap和concurrenthashmap呢？<br>4.hashmap和treemap有什么区别？底层数据结构是什么？<br>5.线程池用过吗?都有什么参数？底层如何实现的？<br>6.sychnized和Lock的区别、sychnized什么情况是对象锁，什么情况是全局锁，为什么？<br>7.ThreadLocal是什么？底层如何实现？写个例子呗？<br>8.volitile的工作原理？<br>9.cas知道吗？如何实现？<br>10.请至少用4种写法 写一个单例模式</p>
<span id="more"></span>
<p><strong>JVM</strong><br>1.介绍一下JVM内存模型、用过什么垃圾回收器？都说说呗？<br>2.线上发送频繁full gc如何处理？CPU使用率过高怎么办？<br>如何定位问题？如何解决？说一下解决思路和处理方法。<br>3.知道字节码吗？字节码都有哪些？<br>Integer x=5,int y=5, 比较x==y都经历哪些步骤？<br>4.讲讲类加载机制呗？都有哪些类加载器，这些类加载器都加载哪些文件？<br>5.知道osgi吗？是如何实现的？<br>6.请问你做过哪些JVM优化？使用什么方法？达到什么效果？？？</p>
]]></content>
      <categories>
        <category>java杂记</category>
      </categories>
      <tags>
        <tag>cz_wsd</tag>
      </tags>
  </entry>
  <entry>
    <title>linux安装redis</title>
    <url>/2019/04/15/linux%E5%AE%89%E8%A3%85redis/</url>
    <content><![CDATA[<h2 id="假设没有虚拟机！"><a href="#假设没有虚拟机！" class="headerlink" title="假设没有虚拟机！"></a>假设没有虚拟机！</h2><p><a href="https://blog.csdn.net/babyxue/article/details/80970526">vm安装centos7</a></p>
<h2 id="redis的操作"><a href="#redis的操作" class="headerlink" title="redis的操作"></a>redis的操作</h2><ul>
<li><p>下载忽略，下载到/usr/local</p>
</li>
<li><p>进到redis根目录，yum install gcc，下载gcc，然后make MALLOC=libc</p>
</li>
<li><p>进入src, make install</p>
</li>
<li><p>回到根目录，vi redis.conf</p>
<blockquote>
<p>1、注释bind 127.0.0.1或一些bind相关的<br>2、修改protected-mode=no，开放外界访问redis<br>3、daemonize属性改为yes，表明需要在后台运行</p>
</blockquote>
</li>
<li><p>防火墙的处理</p>
<blockquote>
<p>停止使用firewall<br>systemctl stop firewalld.service<br>禁止在开机启动<br>systemctl disable firewalld.service docker ps   </p>
</blockquote>
</li>
<li><p>安装结束</p>
</li>
</ul>
]]></content>
      <categories>
        <category>操作实战</category>
      </categories>
      <tags>
        <tag>little_eight</tag>
      </tags>
  </entry>
  <entry>
    <title>一次完整的HTTP请求过程</title>
    <url>/2021/09/02/%E4%B8%80%E6%AC%A1%E5%AE%8C%E6%95%B4%E7%9A%84HTTP%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h2><p>搜索浏览器自身的dns缓存，找不到就搜索系统的缓存，还是找不到就去hosts里找，还是找不到就去域名服务器里找。搜索成功拿到ip的话，接下来就是tcp连接。<br>​<span id="more"></span></p>
<h2 id="tcp三次握手"><a href="#tcp三次握手" class="headerlink" title="tcp三次握手"></a>tcp三次握手</h2><ol>
<li>第一次握手：Client将标志位SYN置为1，以及初始序号seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。</li>
<li>第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，以及初始序号seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。</li>
<li>第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。<h2 id="http请求解析"><a href="#http请求解析" class="headerlink" title="http请求解析"></a>http请求解析</h2>建立TCP连接之后，Web浏览器会向Web服务器发送请求命令。例如：GET /sample/hello.jsp HTTP/1.1。浏览器发送请求信息之后，还要以头信息的形式发送相关信息，并以空行代表发送结束。<br>HTTP请求报文由3部分组成（<strong>请求行+请求头+请求体</strong>）<br>​</li>
</ol>
<p><img data-src="https://gitee.com/littleeight/blog-images/raw/master/%E4%B8%80%E6%AC%A1%E5%AE%8C%E6%95%B4%E7%9A%84http%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B/1.png"></p>
<p>以tomcat为例，tomcat对外服务的部分是连接器，由连接器进行解析和处理交给catalina容器。<br><img data-src="https://gitee.com/littleeight/blog-images/raw/master/%E4%B8%80%E6%AC%A1%E5%AE%8C%E6%95%B4%E7%9A%84http%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B/2.png"></p>
<p>由于协议不同，客户端发过来的请求信息也不尽相同，Tomcat定义了⾃⼰的 Request类来封装这些请求信息，ProtocolHandler接⼝负责解析请求并⽣成 Tomcat Request类，<br>通过适配器CoyoteAdapter调⽤Sevice⽅法，传⼊的是Tomcat Request对象， CoyoteAdapter负责将Tomcat Request转成ServletRequest<br>，在Servlet容器找到对应可以处理请求的Servlet。<br>假如说是Spring的DispatchServlet，它会去HandlerMapping处理器映射器找到处理器适配器HandlerAdapter<br>找到真正处理的方法Handler，进行后台逻辑处理，HandlerAdapter将执行结果ModelAndView返回给DispatcherServlet，DispatcherServlet将ModelAndView传给ViewReslover视图解析器，ViewReslover解析后返回具体View，DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中），最终DispatcherServlet响应用户。<br>​</p>
<p>服务器向客户机回送应答， HTTP/1.1 200 OK ，应答的第一部分是协议的版本号和应答状态码。<br>随同应答向用户发送关于它自己的数据及被请求的文档。<br>Web服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据。<br>​</p>
<p>HTTP的响应报文：<br>​</p>
<p><img data-src="https://gitee.com/littleeight/blog-images/raw/master/%E4%B8%80%E6%AC%A1%E5%AE%8C%E6%95%B4%E7%9A%84http%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B/3.png"></p>
<h2 id="tcp四次挥手"><a href="#tcp四次挥手" class="headerlink" title="tcp四次挥手"></a>tcp四次挥手</h2><ol>
<li>第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。</li>
<li>第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。此时server还可以继续发送未发完的数据。</li>
<li>第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。</li>
<li>第四次挥手：Client收到FIN后，接着发送一个ACK给Server，然后Client进入TIME_WAIT状态（看下面的tcp状态），如果server未收到则会重发fin包，然后client接收到之后重复步骤4。Server确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。</li>
</ol>
<p>​</p>
<p><img data-src="https://gitee.com/littleeight/blog-images/raw/master/%E4%B8%80%E6%AC%A1%E5%AE%8C%E6%95%B4%E7%9A%84http%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B/4.png"></p>
<h2 id="请求过程的一些优化点"><a href="#请求过程的一些优化点" class="headerlink" title="请求过程的一些优化点"></a>请求过程的一些优化点</h2><h3 id="​"><a href="#​" class="headerlink" title="​"></a>​</h3><p>首先** dns** 这块能不能进行一个优化呢？我们可以在这层做一个浏览器缓存。这样的话，返回 dns 的时间就可以缩短很多。<br>然后就是一个网络请求的过程，网络请求的过程涉及到带宽，涉及到网络的选择，涉及到缓存，那么在这个过程中，我们有没有什么优化的点，实际在网络请求的过程中，很多公司基本上都会使用到** CDN** , 使用了 CDN 就实际上解决了网络选择以及缓存的问题。但是在访问 CDN 的过程中还会涉及到一个问题。就是 CDN 是请求静态资源用的。那么对于静态资源来说，实际上，我们请求所带的 cookie 是没有用的。实际上在请求 CDN 的过程中，能把 cookie 给去掉。但是很多时候我们 CDN 域名会弄得跟网站本身的域名相同。那么就会将主站的一些 cookie 。通过我们的网络携带到 CDN 的服务端。这个实际上是对网络无畏的损耗，所以我们的 CDN 的域名要非常注意，这个 CDN 的域名不要和主站的一样。这样的话就可以放置访问 CDN 的时候还携带主站 cookie 这个问题，使用 CDN 可以解决我们静态资源，网络选择，以及缓存的问题。但是对于一些接口是没法使用 CDN 的。实际上可以在浏览器上做缓存<br>除了缓存，路径选择，带宽也是非常重要的一点。<br>如果一个** <strong>http 请求的大小会小一点，那么返回的速度相对会快一些。所以</strong>如何减少 http 请求的大小<strong>也是整个优化中非常重要的一点。<br>另外每一个 http 请求都会经过网络环境到达服务器。实际上每次请求都有一个网络环境的损耗。那么能否</strong>将多次 http 请求合并成一次**，从而减少相同的网络损耗呢<br>最后就是浏览器端的渲染过程。对于现在的一些大型框架来说，比如 react,vue 来说。这样的框架，他的模板都是在浏览器端进行渲染的，不是直出的 html ，而是要通过相应的框架代码才能渲染出我们的页面。这个渲染过程，对于首屏就有很大的损耗。这个其实是不利于前端的性能的。在这个情况下，业界就会有一个服务端渲染的方案，在服务端进行这个 html 渲染，从而将这个 html 直出到浏览器端。而不是在浏览器端进行渲染，所以渲染这层，可以进行服务端渲染以及渲染的方案。<br>​</p>
<p>设置tomcat的最大线程数，以及配合集群可达到较高的并发量。</p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>little_eight</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot整合RabbitMQ（windows环境）</title>
    <url>/2018/08/09/springboot%E6%95%B4%E5%90%88RabbitMQ%EF%BC%88windows%E7%8E%AF%E5%A2%83%EF%BC%89/</url>
    <content><![CDATA[<h3 id="安装-Erlang和RabbitMQ-Server-，启动RabbitMQ-Server"><a href="#安装-Erlang和RabbitMQ-Server-，启动RabbitMQ-Server" class="headerlink" title="安装 Erlang和RabbitMQ Server ，启动RabbitMQ Server"></a>安装 Erlang和RabbitMQ Server ，启动RabbitMQ Server</h3><p><strong>1、安装Erland，通过<a href="http://www.erlang.org/downloads">官方下载页面</a>获取exe安装包，直接打开并完成安装。(好像要翻墙~自己解决)</strong><br><strong>2、安装完Erland，配置好它的环境变量，变量值是你自己的安装地址，然后再在path变量加入它</strong></p>
<blockquote>
<p>%ERLANG_HOME%\bin</p>
</blockquote>
<p><strong>3、然后再安装<a href="https://www.rabbitmq.com/download.html">RabbitMQ服务端</a>,注意如果下载高版本的，对erland的版本也是有要求的，当然你两者都下最新的就没问题了。</strong></p>
<p><strong>4、依然是配置好RabbitMQ的环境变量，和在path变量里新加</strong></p>
<blockquote>
<p>%RABBITMQ_SERVER%\sbin</p>
</blockquote>
<p><strong>5、然后打开命令行（注意要用管理员的身份打开，不然后面会提示错误~）然后输入</strong></p>
<blockquote>
<p>rabbitmq-plugins.bat enable rabbitmq_management</p>
</blockquote>
<span id="more"></span>

<p><strong>开启Web管理插件，这样我们就可以通过浏览器来进行管理了，一般情况下这时候已经自动启动RabbitMQ服务了，我们也可以手动启动验证一下，输入</strong></p>
<blockquote>
<p>net start RabbitMQ<br><strong>要关闭服务的话，输入</strong><br>net stop RabbitMQ</p>
</blockquote>
<p><strong>6、打开web界面，地址 <a href="http://localhost:15672/">http://localhost:15672/</a>  默认的用户名：guest 默认的密码为：guest</strong></p>
<p><strong>你可以点击Admin去创建一个新的用户，我下面配置文件就会用到新的用户的用户名跟密码</strong></p>
<hr>
<h3 id="springboot整合rabbitMQ"><a href="#springboot整合rabbitMQ" class="headerlink" title="springboot整合rabbitMQ"></a>springboot整合rabbitMQ</h3><p><strong>1、新建一个springboot工程，并在<code>pom.xml</code> 中引入与rabbitmq有关的依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>2、修改application.yml,配置关于RabbitMQ的连接和用户信息（新建的工程配置文件不是这个名字，改成它即可。。。）</strong></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">rabbitmq-test</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">admin</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">admin</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p><strong>3、创建RabbitMQ的配置类<code>RabbitConfig</code></strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import org.springframework.amqp.core.Queue;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * RabbitMQ的配置类</span><br><span class="line"> */</span><br><span class="line">@Configuration</span><br><span class="line">public class RabbitConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public Queue helloQueue() &#123;</span><br><span class="line">        return new Queue(&quot;hello&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>4、我们建立一个消息生产类<code>Sender</code>，作为生产者的身边</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.AmqpTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消息生产类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sender</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AmqpTemplate amqpTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String context = <span class="string">&quot;hello &quot;</span> + <span class="keyword">new</span> Date();</span><br><span class="line">        System.out.println(<span class="string">&quot;Sender : &quot;</span> + context);</span><br><span class="line">        amqpTemplate.convertAndSend(<span class="string">&quot;hello&quot;</span>, context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>5、再建立一个消息消费类<code>Receiver</code>，作为消费者</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消息消费类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Receiver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(String hello)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Receiver : &quot;</span> + hello);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>6、最后再创建一个测试类<code>RabbitMQTest</code></strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import org.junit.Test;</span><br><span class="line">import org.junit.runner.RunWith;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line">import org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class RabbitMQTest &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private Sender sender;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testRabbitMQ()&#123;</span><br><span class="line">        sender.send();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>7、先启动主程序<code>RabbitmqApplication</code>,我这边碰到一个错误</strong><br><img data-src="https://raw.githubusercontent.com/little-eight-china/image/master/bdbk/rabbitmq/1.jpg?raw=true"><br><strong>原来是没给admin这个用户设置管理队列的权限，去set一把即可</strong><br><img data-src="https://raw.githubusercontent.com/little-eight-china/image/master/bdbk/rabbitmq/2.jpg?raw=true"></p>
<p><strong>再次运行主程序，成功连接RabbitMQ</strong><br><img data-src="https://raw.githubusercontent.com/little-eight-china/image/master/bdbk/rabbitmq/3.jpg?raw=true"></p>
<p><strong>8、去run我们的测试用例方法，看到控制台输出，表示成功</strong><br><img data-src="https://raw.githubusercontent.com/little-eight-china/image/master/bdbk/rabbitmq/4.jpg?raw=true"><br><strong>再切换回主程序，也可以看到输出日志</strong><br><img data-src="https://raw.githubusercontent.com/little-eight-china/image/master/bdbk/rabbitmq/5.jpg?raw=true"><br><strong>当然我们在RabbitMQ的页面上也可以看到队列的消费信息记录</strong><br><img data-src="https://raw.githubusercontent.com/little-eight-china/image/master/bdbk/rabbitmq/6.jpg?raw=true"></p>
<hr>
<h4 id="以上便是springboot对RabbitMQ的消息生产和消费的最简单的整合，想了解更多请查阅RabbitMQ官网"><a href="#以上便是springboot对RabbitMQ的消息生产和消费的最简单的整合，想了解更多请查阅RabbitMQ官网" class="headerlink" title="以上便是springboot对RabbitMQ的消息生产和消费的最简单的整合，想了解更多请查阅RabbitMQ官网"></a>以上便是springboot对RabbitMQ的消息生产和消费的最简单的整合，想了解更多请查阅<a href="https://www.rabbitmq.com/">RabbitMQ</a>官网</h4>]]></content>
      <categories>
        <category>操作实战</category>
      </categories>
      <tags>
        <tag>little_eight</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Nacos实现服务注册与发现</title>
    <url>/2019/02/15/%E4%BD%BF%E7%94%A8Nacos%E5%AE%9E%E7%8E%B0%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="使用Nacos实现服务注册与发现"><a href="#使用Nacos实现服务注册与发现" class="headerlink" title="使用Nacos实现服务注册与发现"></a>使用Nacos实现服务注册与发现</h1><h2 id="什么是-Nacos"><a href="#什么是-Nacos" class="headerlink" title="什么是 Nacos"></a>什么是 Nacos</h2><p>官网解释：<br>Nacos 致力于帮助您发现、配置和管理微服务。Nacos 提供了一组简单易用的特性集，帮助您快速实现动态服务发现、服务配置、服务元数据及流量管理。</p>
<p>Nacos 帮助您更敏捷和容易地构建、交付和管理微服务平台。 Nacos 是构建以“服务”为中心的现代应用架构 (例如微服务范式、云原生范式) 的服务基础设施。</p>
<p>个人解释：<br>微服务管理平台</p>
<h2 id="Nacos优缺点"><a href="#Nacos优缺点" class="headerlink" title="Nacos优缺点"></a>Nacos优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>开箱即用，适用于dubbo，spring cloud</li>
<li>AP模型，数据最终一致性</li>
<li>注册中心，配置中心二合一，提供控制台管理</li>
<li>纯国产，久经双十一考验</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>刚刚开源不久，社区热度不够，依然存在bug<blockquote>
<p>优缺点4比1，肯定选它呀，</p>
</blockquote>
<span id="more"></span>
<h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2></li>
</ul>
<h3 id="下载Nacos"><a href="#下载Nacos" class="headerlink" title="下载Nacos"></a>下载Nacos</h3><p><a href="ttps://github.com/alibaba/nacos/releases">下载地址(本文版本：0.8.0)</a></p>
<p>下载完成之后，解压。根据不同平台，执行不同命令。本人windows，直接点击bin包下的startup.cmd</p>
<p>启动完成之后，访问：<a href="http://127.0.0.1:8848/nacos/%EF%BC%8C%E9%BB%98%E8%AE%A4%E8%B4%A6%E5%8F%B7%E5%AF%86%E7%A0%81%E5%9D%87%E4%B8%BAnacos%EF%BC%8C%E8%BF%9B%E5%85%A5Nacos%E7%9A%84%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86%E9%A1%B5%E9%9D%A2%EF%BC%8C%E5%A6%82%E4%B8%8B%E5%9B%BE">http://127.0.0.1:8848/nacos/，默认账号密码均为nacos，进入Nacos的服务管理页面，如下图</a><br><img data-src="https://raw.githubusercontent.com/little-eight-china/image/master/bdbk/nacos/1.jpg?raw=true" alt="图片1"></p>
<h3 id="创建服务提供和消费者"><a href="#创建服务提供和消费者" class="headerlink" title="创建服务提供和消费者"></a>创建服务提供和消费者</h3><h4 id="项目架构"><a href="#项目架构" class="headerlink" title="项目架构"></a>项目架构</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">└─springboot-nacos</span><br><span class="line">    └─nacos-server</span><br><span class="line">        └─pom.xml</span><br><span class="line">    └─nacos-client</span><br><span class="line">        └─pom.xml</span><br><span class="line">    └─pom.xml</span><br></pre></td></tr></table></figure>
<ul>
<li>创建一个名为springboot-nacos的springboot项目，然后项目里只留pom.xml文件，其余全部删除。pom.xml的依赖如下</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">	&lt;dependency&gt;</span><br><span class="line">		&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">	&lt;/dependency&gt;</span><br><span class="line">	&lt;dependency&gt;</span><br><span class="line">		&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">	&lt;/dependency&gt;</span><br><span class="line">	&lt;dependency&gt;</span><br><span class="line">		&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">	&lt;/dependency&gt;</span><br><span class="line">	&lt;dependency&gt;</span><br><span class="line">		&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span><br><span class="line">	&lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">	&lt;dependencies&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span><br><span class="line">			&lt;version&gt;0.2.1.RELEASE&lt;/version&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">	&lt;/dependencies&gt;</span><br><span class="line">&lt;/dependencyManagement&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，版本兼容性官方说明：版本 0.2.x.RELEASE 对应的是 Spring Boot 2.0.x 版本，版本 0.1.x.RELEASE 对应的是 Spring Boot 1.x 版本，所以要看清楚自己的springboot是什么版本，如果是2.1.x,会有未知的bug(比如服务注册不上)，本人使用2.0.6</p>
</blockquote>
<ul>
<li><p>在父项目中new一个module，名为nacos-server作为服务提供者，由于依赖可全继承父层，所以pom.xml可删除其它，只留 parent</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">	xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">	&lt;parent&gt;</span><br><span class="line">		&lt;groupId&gt;bdbk&lt;/groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;springboot-nacos&lt;/artifactId&gt;</span><br><span class="line">		&lt;version&gt;1.0.0&lt;/version&gt;</span><br><span class="line">	&lt;/parent&gt;</span><br><span class="line">	&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">	&lt;artifactId&gt;nacos-server&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;1.0.0&lt;/version&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>配置好application.yml</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8080</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: nacos-server #服务名</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      discovery:</span><br><span class="line">        server-addr: 127.0.0.1:8848 #nacos地址</span><br></pre></td></tr></table></figure>

<ul>
<li><p>在启动类里写内部接口服务提供类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 开启Spring Cloud的服务注册与发现</span><br><span class="line">@EnableDiscoveryClient</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class NacosServerApplication &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">SpringApplication.run(NacosServerApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 开放服务接口</span><br><span class="line">	@RestController</span><br><span class="line">	static class ServerController &#123;</span><br><span class="line">		@GetMapping(&quot;/&quot;)</span><br><span class="line">		public String hello() &#123;</span><br><span class="line">			return &quot;hello clien&quot;;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>启动，如果控制台日志看到如下说明注册成功 即可在nacos的管理界面看到我们的服务注册了上去，你可以点击详情查看服务的具体信息。此时还可以改下端口开2个服务，后面做负载均衡的测试<br><img data-src="https://raw.githubusercontent.com/little-eight-china/image/master/bdbk/nacos/2.jpg?raw=true" alt="图片2"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">o.s.c.a.n.registry.NacosServiceRegistry  : nacos registry, nacos-client 192.168.96.122:8090 register finished</span><br></pre></td></tr></table></figure></li>
<li><p>同理创建nacos-client作为服务消费者，配置好application.yml</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8090</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: nacos-client</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      discovery:</span><br><span class="line">        server-addr: 127.0.0.1:8848</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>在启动类里写内部接口服务消费类</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 开启Spring Cloud的服务注册与发现</span><br><span class="line">@EnableDiscoveryClient</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class NacosClientApplication &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		SpringApplication.run(NacosClientApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 调用服务接口</span><br><span class="line">	@RestController</span><br><span class="line">	static class ClientController &#123;</span><br><span class="line">		@Autowired</span><br><span class="line">		private LoadBalancerClient loadBalancerClient;</span><br><span class="line">		@GetMapping(&quot;/&quot;)</span><br><span class="line">		public String test() &#123;</span><br><span class="line">			// 负载均衡接口选取服务提供节点实现接口调用</span><br><span class="line">			ServiceInstance serviceInstance = loadBalancerClient.choose(&quot;nacos-server&quot;);</span><br><span class="line">			RestTemplate restTemplate = new RestTemplate();</span><br><span class="line">			String result = restTemplate.getForObject(serviceInstance.getUri().toString(), String.class);</span><br><span class="line">			return &quot;端口号为 : &quot; + serviceInstance.getPort() + &quot;, 返回结果 : &quot; + result;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>启动，注册成功后，访问localhost:8090,可以看到结果显示在2个端口不断切换，说明不同请求真正实际调用的服务提供者实例是不同的，也就是说，通过LoadBalancerClient接口在获取服务实例的时候，已经实现了对服务提供方实例的负载均衡。</li>
</ul>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://nacos.io/zh-cn/docs/quick-start-spring-cloud.html">Nacos官方文档</a></p>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><p><a href="https://github.com/little-eight-china/springboot-project/tree/master/springboot-nacos">springboot-nacos</a></p>
]]></content>
      <categories>
        <category>java第三方框架</category>
      </categories>
      <tags>
        <tag>little_eight</tag>
      </tags>
  </entry>
  <entry>
    <title>几种基础算法</title>
    <url>/2021/06/28/%E5%87%A0%E7%A7%8D%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h3 id="冒泡算法"><a href="#冒泡算法" class="headerlink" title="冒泡算法"></a>冒泡算法</h3><p>每次遍历进行i与i+1的值进行比较，把大的值都往数组后面丢，保证了数组末尾的元素为最大。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] test1(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=arr.length-<span class="number">1</span>;i&gt;<span class="number">0</span>;i--) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++) &#123;</span><br><span class="line">            <span class="comment">// 前者如果小于后者，就调换</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j+<span class="number">1</span>]) &#123;</span><br><span class="line">                temp = arr[j+<span class="number">1</span>];</span><br><span class="line">                arr[j+<span class="number">1</span>] = arr[j];</span><br><span class="line">                arr[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(change(arr));</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h3 id="选择算法"><a href="#选择算法" class="headerlink" title="选择算法"></a>选择算法</h3><p>对于冒泡是同个理念，不过减少了交换的次数。从左往右遍历，基于左边界的值进行比较，找到最小的元素进行替换，保证左边界的值是最小的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            <span class="comment">// 参照物 &gt; 目标，交换</span></span><br><span class="line">            <span class="keyword">if</span>(arr[i] &gt; arr[j]) &#123;</span><br><span class="line">                temp = arr[i];</span><br><span class="line">                arr[i] = arr[j];</span><br><span class="line">                arr[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(change(arr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​</p>
<h3 id="插入算法"><a href="#插入算法" class="headerlink" title="插入算法"></a>插入算法</h3><p>从左往右，每次都以i+1为右边界，然后i+1的元素需要插入已经排好序的[0,i]的数组里，从后面一直比较到前面，遍历从i到0，只要有元素大于i+1那个元素就交换，最后插入成功后[0,i+1]就是排好序的数组了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="comment">// 前者 &gt; 后者，交换;</span></span><br><span class="line">            <span class="keyword">if</span>(arr[j-<span class="number">1</span>] &gt; arr[j]) &#123;</span><br><span class="line">                temp = arr[j-<span class="number">1</span>];</span><br><span class="line">                arr[j-<span class="number">1</span>] = arr[j];</span><br><span class="line">                arr[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(change(arr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​</p>
<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>缩小增量排序，每次都以rightStart=k为右边界的开始遍历，然后以比较0+k与k+k的方式遍历数组，前者大于后者就替换，直到k=0</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">int</span> k = arr.length/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (k != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> rightStart = k; rightStart &lt; arr.length; rightStart++) &#123;</span><br><span class="line">            <span class="keyword">int</span> left = rightStart - k;</span><br><span class="line">            <span class="keyword">int</span> right = rightStart;</span><br><span class="line">            <span class="comment">// 每次都是左右俩边对比</span></span><br><span class="line">            <span class="keyword">while</span> (right &lt; arr.length) &#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[left] &gt; arr[right]) &#123;</span><br><span class="line">                    temp = arr[left];</span><br><span class="line">                    arr[left] = arr[right];</span><br><span class="line">                    arr[right] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">                left += k;</span><br><span class="line">                right += k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        k /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(change(arr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​</p>
<h3 id="归并算法"><a href="#归并算法" class="headerlink" title="归并算法"></a>归并算法</h3><p>把大数组拆分成小数组不断进行比较排序得到最终结果。比如{1,2,3,4} =&gt; {1,2},{3.4} =&gt; {1}, {2},{3},{4}。<br>每次比较都需要新建一个临时一样大小的数组用来转比较结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test51</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    test52(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">    System.out.println(change(arr));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 归并2</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test52</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left == right) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (right + left) / <span class="number">2</span>;</span><br><span class="line">    test52(arr, left, mid);</span><br><span class="line">    test52(arr, mid + <span class="number">1</span>, right);</span><br><span class="line">    test53(arr, left, mid, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 归并3</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test53</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 比较2个数组的元素大小，设置到left 到 right里</span></span><br><span class="line">    <span class="keyword">int</span> leftIndex = left;</span><br><span class="line">    <span class="keyword">int</span> rightIndex = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 插入的临时排好序的数组;</span></span><br><span class="line">    <span class="keyword">int</span>[] tempArr = <span class="keyword">new</span> <span class="keyword">int</span>[right - left + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> tempIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 左边的界限为 left ---- mid，右边为 mid + 1  ----  right</span></span><br><span class="line">    <span class="keyword">while</span>(leftIndex &lt;= mid &amp;&amp; rightIndex &lt;= right) &#123;</span><br><span class="line">        <span class="comment">// 谁小，就设置谁</span></span><br><span class="line">        <span class="keyword">if</span>(arr[leftIndex] &lt; arr[rightIndex]) &#123;</span><br><span class="line">            tempArr[tempIndex++] = arr[leftIndex++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tempArr[tempIndex++] = arr[rightIndex++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历完，肯定只有一边的数组剩余，没加到临时数组里，加上</span></span><br><span class="line">    <span class="keyword">while</span> (leftIndex &lt;= mid) &#123;</span><br><span class="line">        tempArr[tempIndex++] = arr[leftIndex++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (rightIndex &lt;= right) &#123;</span><br><span class="line">        tempArr[tempIndex++] = arr[rightIndex++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后遍历设置到原数组里</span></span><br><span class="line">    tempIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = left;i&lt;=right;i++) &#123;</span><br><span class="line">        arr[i] = tempArr[tempIndex++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​</p>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>思想跟归并是差不多的，都是分治。快排都会以左边界的元素为参照物，然后把比它小的往左边丢，大的就往右边丢。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 快排1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test61</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    test62(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">    System.out.println(change(arr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快排2</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test62</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(left &gt;= right) &#123;</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 参考物</span></span><br><span class="line">   <span class="keyword">int</span> referenceIndex = left;</span><br><span class="line">   <span class="keyword">int</span> reference = arr[left];</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 结束点</span></span><br><span class="line">   <span class="keyword">int</span> endIndex = right;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">int</span> temp;</span><br><span class="line">   <span class="keyword">int</span> tempIndex = left;</span><br><span class="line">   <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 右边边 &gt; reference, 右边++</span></span><br><span class="line">       <span class="keyword">while</span> (left &lt; right &amp;&amp; arr[right] &gt;= reference) &#123;</span><br><span class="line">           right--;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 左边 &lt; reference, 左边++</span></span><br><span class="line">       <span class="keyword">while</span> (left &lt; right &amp;&amp; arr[left] &lt;= reference) &#123;</span><br><span class="line">           left++;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 左边 &gt; reference , 右边 &lt; reference,就交换</span></span><br><span class="line">       <span class="keyword">if</span>(arr[left] &gt; reference &amp;&amp; arr[right] &lt; reference) &#123;</span><br><span class="line">           temp = arr[left];</span><br><span class="line">           arr[left] = arr[right];</span><br><span class="line">           arr[right] = temp;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 找到了中间点</span></span><br><span class="line">       <span class="keyword">if</span>(left == right) &#123;</span><br><span class="line">           tempIndex = left;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 交换参照物到指定位置，实现左边 &lt; tempIndex &lt; 右边</span></span><br><span class="line">   temp = arr[referenceIndex];</span><br><span class="line">   arr[referenceIndex] = arr[tempIndex];</span><br><span class="line">   arr[tempIndex] = temp;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 往左边跟右边继续</span></span><br><span class="line">   test62(arr, referenceIndex, tempIndex);</span><br><span class="line">   test62(arr, tempIndex+<span class="number">1</span>, endIndex);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>little_eight</tag>
      </tags>
  </entry>
  <entry>
    <title>红黑树</title>
    <url>/2019/04/22/%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
    <content><![CDATA[<h2 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h2><ul>
<li>节点都有颜色</li>
<li>在插入和删除的过程中，要遵循保持这些颜色的不同排列规则</li>
</ul>
<h2 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h2><ul>
<li>每个节点不是红色就是黑色的</li>
<li>根节点总是黑色的</li>
<li>如果节点是红色的，则它的子节点必须是黑色的（反之不一定）,(也就是从每个叶子到根的所有路径上不能有两个连续的红色节点)</li>
<li>从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）<blockquote>
<p>注意：新插入的节点颜色总是红色的，这是因为插入一个红色节点比插入一个黑色节点违背红-黑规则的可能性更小，原因是插入黑色节点总会改变黑色高度（违背规则4），但是插入红色节点只有一半的机会会违背规则3（因为父节点是黑色的没事，父节点是红色的就违背规则3）。</p>
</blockquote>
</li>
</ul>
<h2 id="修正"><a href="#修正" class="headerlink" title="修正"></a>修正</h2><p>插入新节点可能会破坏规则，有2种修正方法，变色跟旋转，旋转分左旋转跟右旋转</p>
<h3 id="左旋转"><a href="#左旋转" class="headerlink" title="左旋转"></a>左旋转</h3><ul>
<li>子右节点Y上升为父节点</li>
<li>父节点X降级为子左节点</li>
<li>把旧子右节点Y的子左节点搞过来当子新左节点子X的子右节点</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  X                                             Y</span><br><span class="line"> / \              以X为轴旋转                  / \</span><br><span class="line">a   Y              -------------&gt;&gt;            X   c</span><br><span class="line">   / \                                       / \</span><br><span class="line">  b   c                                     a   b</span><br></pre></td></tr></table></figure>

<h3 id="右旋转"><a href="#右旋转" class="headerlink" title="右旋转"></a>右旋转</h3><ul>
<li>子左节点Y上升为父节点</li>
<li>父节点X降级为子右节点</li>
<li>把旧子左节点Y的子右节点搞过来当新子右节点X的子左节点</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    X                                             Y</span><br><span class="line">   / \              以X为轴旋转                  / \</span><br><span class="line">  Y   c              -------------&gt;&gt;            a   X</span><br><span class="line"> / \                                               / \</span><br><span class="line">a   b                                             b   c</span><br></pre></td></tr></table></figure>

<blockquote>
<p>多看几次就懂了，明白旋转规则即可</p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>little_eight</tag>
      </tags>
  </entry>
  <entry>
    <title>接口的幂等性设计</title>
    <url>/2021/09/03/%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%B9%82%E7%AD%89%E6%80%A7%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<p>在高并发或者是安全要求下，后端接口会有多次执行的结果与一次执行的结果要一致的要求，这种接口就叫幂等性接口，需要用到幂等性的接口比较常见的就是用户下单支付等，防止出现重试时对业务造成巨大灾害的危险。下文为设计方案的各个要点。</p>
<span id="more"></span>

<h2 id="前端幂等控制"><a href="#前端幂等控制" class="headerlink" title="前端幂等控制"></a>前端幂等控制</h2><ol>
<li><strong>按钮只能点击一次</strong>，如用户点击提交订单号，按钮变灰或页面显示loding状态。防止用户重复点击。</li>
<li><strong>重定向机制</strong>，当用户提交了表单，跳转到另外一个等待处理的页面，然后后台处理完成后再跳转到成功或者失败的界面。这样避免用户按F5刷新浏览器导致重复提交。</li>
</ol>
<p>​</p>
<p>​</p>
<h2 id="全局唯一ID"><a href="#全局唯一ID" class="headerlink" title="全局唯一ID"></a>全局唯一ID</h2><p>要做到幂等性，就需要借助一个唯一的ID来标志每次交易。唯一ID根据业务情况来定，在执行操作前先根据这个全局唯一ID是否存在，来判断这个操作是否已经执行。如果不存在则把全局ID，存储到存储系统中，比如数据库、redis等。如果存在则表示该方法已经执行。<br>从工程的角度来说，使用全局ID做幂等可以作为一个业务的基础的微服务存在，在很多的微服务中都会用到这样的服务，在每个微服务中都完成这样的功能，会存在工作量重复。另外打造一个高可靠的幂等服务还需要考虑很多问题，比如一台机器虽然把全局ID先写入了存储，但是在写入之后挂了，这就需要引入全局ID的超时机制。<br>​</p>
<h2 id="状态机制控制"><a href="#状态机制控制" class="headerlink" title="状态机制控制"></a>状态机制控制</h2><p>很多时候业务表是有状态的，比如订单表中有：1-下单、2-已支付、3-完成、4-撤销等状态。如果这些状态的值是有规律的，按照业务节点正好是从小到大，我们就能通过它来保证接口的幂等性。在更新表时判断状态字段是否符合即可，当数据库更新成功时会返回影响的行数，这样就可做后续的成功与否的逻辑处理。<br>在作者另一篇文章提到了关于消息队列如何去重的文章里，提到的就是用状态机制来控制的方案，业界通常叫这种方式为<strong>重试机制</strong>，这里放个图。<br><img data-src="https://gitee.com/littleeight/blog-images/raw/master/%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%B9%82%E7%AD%89%E6%80%A7%E8%AE%BE%E8%AE%A1/1.png"><br>​</p>
<h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>分布式锁的机制跟全局唯一ID是相似的，不过既然是锁，那就说明同时只能有一个线程执行同一种操作，对高并发场景是不太适用的，分布式锁分三种实现方式：数据库唯一索引、redission、zookeeper，感兴趣深入的可自行查找相关资料，这里就不扩展了。<br>​</p>
<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>将请求快速的接收下来，放入消息队列中，后续消费者服务可自行用逻辑去重。此方法优点是异步处理、高吞吐，不足是不能及时返回请求结果。</p>
<p>​</p>
<p>​</p>
]]></content>
      <categories>
        <category>分布式知识</category>
      </categories>
      <tags>
        <tag>little_eight</tag>
      </tags>
  </entry>
  <entry>
    <title>科学上网：搬瓦工VPS搭建shadowsocks</title>
    <url>/2018/08/21/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%EF%BC%9A%E6%90%AC%E7%93%A6%E5%B7%A5%E6%90%AD%E5%BB%BAshadowsocks%E6%9C%8D%E5%8A%A1%E7%AB%AF/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Shadowsocks，中文名影梭，使用socks5代理，在中国大陆广泛用于翻墙，速度比 pptp和OpenVPN 要快，是一款翻墙必备神器。</p>
<h3 id="VPS"><a href="#VPS" class="headerlink" title="VPS"></a>VPS</h3><p>Shadowsocks的正常使用需要服务器端，其实，所有的翻墙软件都是通过服务器端，而搭建服务器端，你就需要有自己的VPS，所以第一步你就是需要购买一个自己的VPS(或者你可以跟别人合租)，现在普遍使用的搭建服务器端的vps主要包括3种，一个是Linode，一个是DigitalOcean，一个是BandwagonHOST(搬瓦工)，这是从价格，性能等方面做出的推荐。</p>
<h3 id="搬瓦工"><a href="#搬瓦工" class="headerlink" title="搬瓦工"></a>搬瓦工</h3><p>搬瓦工VPS是一款性价比较高的便宜VPS主机，且适合入门级网友学习Linux和建站用途。（具体可在<a href="http://banwagong.cn/">搬瓦工VPS中文网</a>查看）<br>一、选择对应且需要的VPS方案<br><img data-src="https://img-blog.csdn.net/20180821233117700?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2N6X3dzZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<span id="more"></span>
<p>二、核对方案配置以及选择时间期限和机房<br><img data-src="http://banwagong.cn/images/jiaocheng-1.jpg" alt="这里写图片描述"><br>然后会看到上图所示的界面，根据图示我们需要确定选择的方案以及时间，默认是洛杉矶机房，我们也可以选择其他的几个机房之一，点击”ADD TO CART”添加购物车。<br><img data-src="http://banwagong.cn/images/jiaocheng-2.jpg" alt="这里写图片描述"></p>
<blockquote>
<p>搬瓦工优惠码：当前我们可以使用 BWH26FXH3HIQ 优惠码再节省5%</p>
</blockquote>
<p>三、登录或者新注册搬瓦工账户<br><img data-src="http://banwagong.cn/images/jiaocheng-3.jpg" alt="这里写图片描述"><br>根据上图，如果我们有过账户，可以直接点击”Click here to login”登录以及付款就可以，如果还没有账户则需要注册账户。个人信息不要真实的，但也不能太离谱和乱写字符出来，好歹也要稍微用点拼音。</p>
<blockquote>
<p>我们不能用代理IP登录注册账户，国家需要真实，不要乱选择。</p>
</blockquote>
<p>四、付款成功以及使用<br>目前只支持Paypal付款，所以我们需要有账户，如果没有可以注册，且可以用账户余额，也可以绑定信用卡、银联支付<br><img data-src="http://banwagong.cn/images/jiaocheng-4.jpg" alt="这里写图片描述"><br>稍等一分钟左右，我们登录搬瓦工账户后台，就可以看到已经成功后买到的VPS主机，我们可以登录面板使用。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>点击 “KiwiVM Control Panel” 进入 VPS 控制面板。<br><img data-src="http://s15.sinaimg.cn/mw690/006QTR5ezy7htKLALh4ae&690" alt="这里写图片描述"><br>接下来，使用xshell进行连接。</p>
<blockquote>
<p>温馨提示：如果出现死活连接不上linode的情况，可以ping一下你的Ip，看是否能ping通，如果ping不通，可能是你的ip已经被墙了，建议你删除此vps，重新建一个，或者在Linode中申请更换Ip的工单！</p>
</blockquote>
<h3 id="Shadowsocks服务端搭建"><a href="#Shadowsocks服务端搭建" class="headerlink" title="Shadowsocks服务端搭建"></a>Shadowsocks服务端搭建</h3><p>1.环境安装与更新<br>这一步，需要做的是依次执行下面的每条命令：</p>
<blockquote>
<p>yum install epel-release<br>yum update<br>yum install python-setuptools m2crypto supervisor<br>easy_install pip<br>pip install shadowsocks</p>
</blockquote>
<p>2.文件配置<br>接下来需要编辑一下/etc/shadowsocks.json文件，命令如下：</p>
<blockquote>
<p>vi /etc/shadowsocks.json</p>
</blockquote>
<p>执行上述命令后，此时的你已经进入文件编辑模式，这是你创建的一个新的空白文件，你需要做的事情就是将下面的内容粘贴后复制到shadowsocks.json文件里：</p>
<h6 id="单用户配置："><a href="#单用户配置：" class="headerlink" title="单用户配置："></a>单用户配置：</h6><blockquote>
<p>{<br>    “server”:”your_server_ip”,<br>    “server_port”:8388,<br>    “local_port”:1080,<br>    “password”:”yourpassword”,<br>    “timeout”:600,<br>    “method”:”aes-256-cfb”<br>}</p>
</blockquote>
<p>各字段的含义：<br>server：服务器 IP (IPv4/IPv6)，注意这也将是服务端监听的 IP 地址<br>server_port：监听的服务器端口<br>local_address：本地监听的 IP 地址<br>local_port：本地端端口<br>password：用来加密的密码<br>timeout：超时时间（秒）<br>method：加密方法，可选择 “bf-cfb”, “aes-256-cfb”, “des-cfb”, “rc4”, 等等。默认是一种不安全的加密，推荐用 “aes-256-cfb”<br>fast_open：true 或 false<br>works：works数量，默认为 1</p>
<h6 id="多用户配置："><a href="#多用户配置：" class="headerlink" title="多用户配置："></a>多用户配置：</h6><blockquote>
<p>{<br> “server”:”my_server_ip”，<br> “local_address”: “127.0.0.1”,<br> “local_port”:1080,<br>  “port_password”: {<br>     “8381”: “foobar1”,<br>     “8382”: “foobar2”,<br>     “8383”: “foobar3”,<br>     “8384”: “foobar4”<br> },<br> “timeout”:300,<br> “method”:”aes-256-cfb”,<br> “fast_open”: false<br>}</p>
</blockquote>
<h6 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h6><blockquote>
<p>ssserver -c /etc/shadowsocks.json -d start #启动<br>ssserver -c /etc/shadowsocks.json -d stop #停止</p>
</blockquote>
<h6 id="启动-1"><a href="#启动-1" class="headerlink" title="启动"></a>启动</h6><p>日志文件路径：/var/log/shadowsocks.log</p>
<h3 id="配置自动启动"><a href="#配置自动启动" class="headerlink" title="配置自动启动"></a>配置自动启动</h3><p>编辑/etc/supervisord.conf文件，命令如下：</p>
<blockquote>
<p>vi /etc/supervisord.conf</p>
</blockquote>
<p> 此时，你已进入supervisord.conf文件的编辑模式，这不是一个空白文件，里面有很多英文，请把下面的内容粘贴到文件尾部的空行处，然后保存：</p>
<blockquote>
<p>[program:shadowsocks]<br>command=ssserver -c /etc/shadowsocks.json<br>autostart=true<br>autorestart=true<br>user=root<br>log_stderr=true<br>logfile=/var/log/shadowsocks.log</p>
</blockquote>
<p>接下来需要编辑/etc/rc.local文件，请执行以下命令：</p>
<blockquote>
<p>vi /etc/rc.local</p>
</blockquote>
<p>此时，进入了rc.local文件的编辑模式，这也不是一个空白文件，请把以下内容粘贴到文件中部的空白处，然后保存</p>
<blockquote>
<p>service supervisord start</p>
</blockquote>
<p>最后执行reboot命令或者vps的重启按钮，重启服务器。</p>
<blockquote>
<p>小提醒：搬瓦工的VPS在执行完reboot命令后有时会遇到重启失败的情况，这时候进入控制面板，看一下“Status”是不是“Running”，如果不是的话，点一下“Actions”里的“start”按钮即可。</p>
</blockquote>
<p>最后，可通过ps -ef|grep shadowsocks查看shadowsocks进程是否已启动</p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>cz_wsd</tag>
      </tags>
  </entry>
  <entry>
    <title>部署到Linux服务器上访问很卡的排查方法</title>
    <url>/2019/04/15/%E9%83%A8%E7%BD%B2%E5%88%B0Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E8%AE%BF%E9%97%AE%E5%BE%88%E5%8D%A1%E7%9A%84%E6%8E%92%E6%9F%A5%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="查看内存使用情况"><a href="#查看内存使用情况" class="headerlink" title="查看内存使用情况"></a>查看内存使用情况</h2><p>free -g</p>
<p>当观察到free栏已为0的时候，表示内存基本被吃完了，那就释放内存吧</p>
<h2 id="查看磁盘使用情况"><a href="#查看磁盘使用情况" class="headerlink" title="查看磁盘使用情况"></a>查看磁盘使用情况</h2><p>df -h</p>
<p>当发现磁盘使用率很高时，那就要释放磁盘空间了，删除一些不必要的文件（查看各个目录占用磁盘空间，参考之前的du命令文章）</p>
<span id="more"></span>

<h2 id="查看磁盘IO使用情况"><a href="#查看磁盘IO使用情况" class="headerlink" title="查看磁盘IO使用情况"></a>查看磁盘IO使用情况</h2><p>iostat -x 1</p>
<p>1表示1秒刷新一次</p>
<p>当发现最右侧%util很高时，表示IO就很高了，若想看哪个进程占用IO，执行iotop命令查看</p>
<p>你也可以测试自己的读写速率多大</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dd if=/dev/zero of=test bs=64k count=4k oflag=dsync</span><br></pre></td></tr></table></figure>
<p>输出的依次是:复制的大小、用时跟写速率</p>
<h2 id="查看cpu使用情况"><a href="#查看cpu使用情况" class="headerlink" title="查看cpu使用情况"></a>查看cpu使用情况</h2><p>top</p>
<p>下图中红框里表是cpu使用情况，最右侧的%id表示剩余，若很低，则表示cpu被吃完了，在top界面按shift+p对进程使用cpu排序，能看到哪些进程占用cpu较多</p>
<p>（暂时没图、、）</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>little_eight</tag>
      </tags>
  </entry>
  <entry>
    <title>Java多线程</title>
    <url>/2018/12/10/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="线程基础"><a href="#线程基础" class="headerlink" title="线程基础"></a>线程基础</h2><h3 id="什么是线程？"><a href="#什么是线程？" class="headerlink" title="什么是线程？"></a>什么是线程？</h3><p>几乎每种操作系统都支持进程的概念 —— 进程就是在某种程度上相互隔离的、独立运行的程序。</p>
<p>线程化是允许多个活动共存于一个进程中的工具。大多数现代的操作系统都支持线程，而且线程的<br>概念以各种形式已存在了好多年。Java 是第一个在语言本身中显式地包含线程的主流编程语言，它没有把线程化看作是底层操作系统的工具。 </p>
<p>有时候，线程也称作轻量级进程。就象进程一样，线程在程序中是独立的、并发的执行路径，每个线程有它自己的堆栈、自己的程序计数器和自己的局部变量。但是，与分隔的进程相比，进程中的线程之间的隔离程度要小。它们共享内存、文件句柄和其它每个进程应有的状态。 </p>
<p>进程可以支持多个线程，它们看似同时执行，但互相之间并不同步。一个进程中的多个线程共享相同的内存地址空间，这就意味着它们可以访问相同的变量和对象，而且它们从同一堆中分配对象。尽管这让线程之间共享信息变得更容易，但您必须小心，确保它们不会妨碍同一进程里的其它线程。</p>
<p>Java 线程工具和 API 看似简单。但是，编写有效使用线程的复杂程序并不十分容易。因为有多个线程共存在相同的内存空间中并共享相同的变量，所以您必须小心，确保您的线程不会互相干扰。 </p>
<h3 id="每个-Java-程序都使用线程"><a href="#每个-Java-程序都使用线程" class="headerlink" title="每个 Java 程序都使用线程"></a>每个 Java 程序都使用线程</h3><p>每个 Java 程序都至少有一个线程 — 主线程。当一个 Java 程序启动时，JVM 会创建主线程，并在该线程中调用程序的 main() 方法。 JVM 还创建了其它线程，您通常都看不到它们 — 例如，与垃圾收集、对象终止和其它 JVM 内务处理任务相关的线程。其它工具也创建线程，如 AWT（抽象窗口工具箱（Abstract Windowing Toolkit））或 Swing UI 工具箱、servlet 容器、应用程序服务器和 RMI（远程方法调用（Remote Method Invocation）） </p>
<h3 id="Java-线程的风险"><a href="#Java-线程的风险" class="headerlink" title="Java 线程的风险"></a>Java 线程的风险</h3><p>虽然 Java 线程工具非常易于使用，但当我们创建多线程程序时，应该尽量避免一些风险。<br>当多个线程访问同一数据项（如静态字段、可全局访问对象的实例字段或共享集合）时，需要确保它们协调了对数据的访问，这样它们都可以看到数据的一致视图，而且相互不会干扰另一方的更改。<br>为了实现这个目的，Java 语言提供了两个关键字：synchronized 和 volatile。当从多个线程中访问变量时，必须确保对该访问正确地进行了同步。对于简单变量，将变量声明成volatile 也许就足够了，但在大多数情况下，需要使用同步。<br>如果将要使用同步来保护对共享变量的访问，那么必须确保在程序中所有访问该变量的地方都使用同步。</p>
<p>虽然线程可以大大简化许多类型的应用程序，过度使用线程可能会危及程序的性能及其可维护性。<br>线程消耗了资源。因此，在不降低性能的情况下，可以创建的线程的数量是有限制的。 尤其在单处理器系统中，使用多个线程不会使主要消耗 CPU 资源的程序运行得更快。 </p>
<span id="more"></span>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>以下示例使用两个线程，一个用于计时，一个用于执行实际工作。主线程使用非常简单的算法计算<br>素数。<br>在它启动之前，它创建并启动一个计时器线程，这个线程会休眠十秒钟，然后设置一个主线程要检查的标志。十秒钟之后，主线程将停止。请注意，共享标志被声明成 volatile。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalculatePrimes</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_PRIMES = <span class="number">1000000</span>; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TEN_SECONDS = <span class="number">10000</span>; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> finished = <span class="keyword">false</span>; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">int</span>[] primes = <span class="keyword">new</span> <span class="keyword">int</span>[MAX_PRIMES]; </span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>; count&lt;MAX_PRIMES; i++) &#123; </span><br><span class="line">        <span class="comment">// Check to see if the timer has expired </span></span><br><span class="line">            <span class="keyword">if</span> (finished) &#123; </span><br><span class="line">            <span class="keyword">break</span>; &#125; </span><br><span class="line">        <span class="keyword">boolean</span> prime = <span class="keyword">true</span>; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;count; j++) &#123; </span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>) &#123; </span><br><span class="line">                  prime = <span class="keyword">false</span>; </span><br><span class="line">               <span class="keyword">break</span>; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span> (prime) &#123; </span><br><span class="line">            primes[count++] = i; </span><br><span class="line">            System.out.println(<span class="string">&quot;Found prime: &quot;</span> + i); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">    CalculatePrimes calculator = <span class="keyword">new</span> CalculatePrimes(); </span><br><span class="line">    calculator.start(); </span><br><span class="line">    <span class="keyword">try</span> &#123; </span><br><span class="line">    Thread.sleep(TEN_SECONDS); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">catch</span> (InterruptedException e) &#123; </span><br><span class="line">    <span class="comment">// fall through </span></span><br><span class="line">    &#125; </span><br><span class="line">    calculator.finished = <span class="keyword">true</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h2 id="线程的生命"><a href="#线程的生命" class="headerlink" title="线程的生命"></a>线程的生命</h2><h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><p>在 Java 程序中创建线程有几种方法。每个 Java程序至少包含一个线程：主线程。其它线程都是通过 Thread 构造器或实例化继承类 Thread 的类来创建的。</p>
<p>Java 线程可以通过直接实例化 Thread 对象或实例化继承 Thread 的对象来创建其它线程。在线程基础中的示例（其中，我们在十秒钟之内计算尽量多的素数）中，我们通过实例化 CalculatePrimes 类型的对象（它继承了 Thread），创建了一个线程。 </p>
<p>当我们讨论 Java 程序中的线程时，也许会提到两个相关实体：完成工作的实际线程或代表线程的Thread 对象。正在运行的线程通常是由操作系统创建的；Thread 对象是由 Java VM 创建的，作为控制相关线程的一种方式。 </p>
<h3 id="创建线程和启动线程并不相同"><a href="#创建线程和启动线程并不相同" class="headerlink" title="创建线程和启动线程并不相同"></a>创建线程和启动线程并不相同</h3><p>在一个线程对新线程的 Thread 对象调用 start() 方法之前，这个新线程并没有真正开始执行。<br>Thread 对象在其线程真正启动之前就已经存在了，而且其线程退出之后仍然存在。这可以让您控制或获取关于已创建的线程的信息，即使线程还没有启动或已经完成了。 </p>
<p>通常在构造器中通过 start()启动线程并不是好主意。这样做，会把部分构造的对象暴露给新的线程。如果对象拥有一个线程，那么它应该提供一个启动该线程的 start() 或 init() 方法，而不是从构造器中启动它。</p>
<h3 id="结束线程"><a href="#结束线程" class="headerlink" title="结束线程"></a>结束线程</h3><p>线程会以以下三种方式之一结束：</p>
<ul>
<li>线程到达其 run() 方法的末尾。</li>
<li>线程抛出一个未捕获到的 Exception 或 Error。</li>
<li>另一个线程调用一个弃用的stop()方法。弃用是指这些方法仍然存在，但是您不应该在新代码中使用它们，并且应该尽量从现有代码中除去它们。<br>当 Java 程序中的所有线程都完成时，程序就退出了。</li>
</ul>
<h3 id="加入线程"><a href="#加入线程" class="headerlink" title="加入线程"></a>加入线程</h3><p>Thread API 包含了等待另一个线程完成的方法：join() 方法。当调用 Thread.join() 时，调用线程将阻塞，直到目标线程完成为止。</p>
<p>Thread.join() 通常由使用线程的程序使用，以将大问题划分成许多小问题，每个小问题分配一个线程。本章结尾处的示例创建了十个线程，启动它们，然后使用Thread.join() 等待它们全部完成。 </p>
<h3 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h3><p>除了何时使用 Thread.join() 和 Object.wait() 外，线程调度和执行的计时是不确定的。如果两个线程同时运行，而且都不等待，您必须假设在任何两个指令之间，其它线程都可以运行并修改程序变量。如果线程要访问其它线程可以看见的变量，如从静态字段（全局变量）直接或间接引用的数据，则必须使用同步以确保数据一致性。 </p>
<p>在以下的简单示例中，我们将创建并启动两个线程，每个线程都打印两行到 System.out</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoThreads</span> </span>&#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;A&quot;</span>); </span><br><span class="line">        System.out.println(<span class="string">&quot;B&quot;</span>); </span><br><span class="line">    &#125; </span><br><span class="line"> &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread2</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123; </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">            System.out.println(<span class="string">&quot;1&quot;</span>); </span><br><span class="line">            System.out.println(<span class="string">&quot;2&quot;</span>); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">new</span> Thread1().start(); </span><br><span class="line">        <span class="keyword">new</span> Thread2().start(); </span><br><span class="line">    &#125; </span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>
<p>我们并不知道这些行按什么顺序执行，只知道“1”在“2”之前打印，以及“A”在“B”之前打印,输出可能是”12AB”、”1A2B”等等的任何一种。</p>
<h3 id="休眠"><a href="#休眠" class="headerlink" title="休眠"></a>休眠</h3><p>Thread API 包含了一个sleep()方法，它将使当前线程进入等待状态，直到过了一段指定时间，或者直到另一个线程对当前线程的 Thread 对象调用了 Thread.interrupt()，从而中断了线程。当过了指定时间后，线程又将变成可运行的，并且回到调度程序的可运行线程队列中。 </p>
<p>如果线程是由对 Thread.interrupt() 的调用而中断的，那么休眠的线程会抛出<br>InterruptedException，这样线程就知道它是由中断唤醒的，就不必查看计时器是否过期。 </p>
<p>Thread.yield() 方法就象 Thread.sleep() 一样，但它并不引起休眠，而只是暂停当前线程片刻，这样其它线程就可以运行了。在大多数实现中，当较高优先级的线程调用 Thread.yield() 时，较低优先级的线程就不会运行。 </p>
<p>CalculatePrimes 示例使用了一个后台线程计算素数，然后休眠十秒钟。当计时器过期后，它就会设置一个标志，表示已经过了十秒。</p>
<h3 id="守护程序线程"><a href="#守护程序线程" class="headerlink" title="守护程序线程"></a>守护程序线程</h3><p>我们提到过当 Java 程序的所有线程都完成时，该程序就退出，但这并不完全正确。隐藏的系统线程，如垃圾收集线程和由JVM创建的其它线程会怎么样？我们没有办法停止这些线程。如果那些线程正在运行，那么 Java 程序怎么退出呢？ </p>
<p>这些系统线程称作守护程序线程。Java程序实际上是在它的所有非守护程序线程完成后退出的。 </p>
<p>任何线程都可以变成守护程序线程。可以通过调用 Thread.setDaemon() 方法来指明某个线程是守护程序线程。您也许想要使用守护程序线程作为在程序中创建的后台线程，如计时器线程或其它延迟的事件线程，只有当其它非守护程序线程正在运行时，这些线程才有用。 </p>
<h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><p>在这个示例中，TenThreads显示了一个创建了十个线程的程序，每个线程都执行一部分工作。该程序等待所有线程全部完成，然后收集结果。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TenThreads</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE; </span><br><span class="line">    <span class="keyword">int</span>[] ourArray; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WorkerThread</span><span class="params">(<span class="keyword">int</span>[] ourArray)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.ourArray = ourArray; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// Find the maximum value in our particular piece of the array </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ourArray.length; i++) </span><br><span class="line">            max = Math.max(max, ourArray[i]); </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMax</span><span class="params">()</span> </span>&#123; </span><br><span class="line">            <span class="keyword">return</span> max; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">        WorkerThread[] threads = <span class="keyword">new</span> WorkerThread[<span class="number">10</span>]; </span><br><span class="line">        <span class="keyword">int</span>[][] bigMatrix = getBigHairyMatrix(); </span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE; </span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Give each thread a slice of the matrix to work with </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123; </span><br><span class="line">            threads[i] = <span class="keyword">new</span> WorkerThread(bigMatrix[i]); </span><br><span class="line">             threads[i].start(); </span><br><span class="line">             &#125; </span><br><span class="line">        <span class="comment">// Wait for each thread to finish </span></span><br><span class="line">        <span class="keyword">try</span> &#123; </span><br><span class="line">             <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123; </span><br><span class="line">             threads[i].join(); </span><br><span class="line">             max = Math.max(max, threads[i].getMax()); </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">catch</span> (InterruptedException e) &#123; </span><br><span class="line">         <span class="comment">// fall through </span></span><br><span class="line">        &#125; </span><br><span class="line">        System.out.println(<span class="string">&quot;Maximum value was &quot;</span> + max); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>就象程序一样，线程有生命周期：它们启动、执行，然后完成。一个程序或进程也许包含多个线程，而这些线程看来互相单独地执行。 </p>
<p>线程是通过实例化 Thread 对象或实例化继承 Thread 的对象来创建的，但在对新的 Thread 对象调用 start() 方法之前，这个线程并没有开始执行。当线程运行到其 run() 方法的末尾或抛出未经处理的异常时，它们就结束了。 </p>
<p>sleep() 方法可以用于等待一段特定时间；而 join()方法可能用于等到另一个线程完成。</p>
<h2 id="共享对数据的访问"><a href="#共享对数据的访问" class="headerlink" title="共享对数据的访问"></a>共享对数据的访问</h2><h3 id="受控访问的同步"><a href="#受控访问的同步" class="headerlink" title="受控访问的同步"></a>受控访问的同步</h3><p>为了确保可以在线程之间以受控方式共享数据，Java语言提供了两个关键字：synchronized 和volatile。 </p>
<p>Synchronized 有两个重要含义：它确保了一次只有一个线程可以执行代码的受保护部分（互斥，mutual exclusion或者说mutex），而且它确保了一个线程更改的数据对于其它线程是可见的（更改的可见性）。 </p>
<p>如果没有同步，数据很容易就处于不一致状态。例如，如果一个线程正在更新两个相关值（比如，粒子的位置和速率），而另一个线程正在读取这两个值，有可能在第一个线程只写了一个值，还没有写另一个值的时候，调度第二个线程运行，这样它就会看到一个旧值和一个新值。同步让我们可以定义必须原子地运行的代码块，这样对于其他线程而言，它们要么都执行，要么都不执行。 </p>
<p>同步的原子执行或互斥方面类似于其它操作环境中的临界段的概念。 </p>
<h3 id="用锁保护的原子代码块"><a href="#用锁保护的原子代码块" class="headerlink" title="用锁保护的原子代码块"></a>用锁保护的原子代码块</h3><p>Volatile 对于确保每个线程看到最新的变量值非常有用，但有时我们需要保护比较大的代码片段，如涉及更新多个变量的片段。 </p>
<p>同步使用监控器（monitor）或锁的概念，以协调对特定代码块的访问。 </p>
<p>每个 Java 对象都有一个相关的锁。同一时间只能有一个线程持有 Java 锁。当线程进入synchronized代码块时，线程会阻塞并等待，直到锁可用，当它可用时，就会获得这个锁，然后执行代码块。当控制退出受保护的代码块时，即到达了代码块末尾或者抛出了没有在 synchronized 块中捕获的异常时，它就会释放该锁。 </p>
<p>这样，每次只有一个线程可以执行受给定监控器保护的代码块。从其它线程的角度看，该代码块可以看作是原子的，它要么全部执行，要么根本不执行。 </p>
<h3 id="同步例子"><a href="#同步例子" class="headerlink" title="同步例子"></a>同步例子</h3><p>使用 synchronized 块可以让您将一组相关更新作为一个集合来执行，而不必担心其它线程中断或看到计算的中间结果。以下示例代码将打印“1 0”或“01”。如果没有同步，它还会打印“1 1”（或“0 0”，随便您信不信）。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncExample</span> </span>&#123; </span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> lockObject = <span class="keyword">new</span> Object(); </span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123; </span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">            <span class="keyword">synchronized</span> (lockObject) &#123; </span><br><span class="line">                x = y = <span class="number">0</span>; </span><br><span class="line">                System.out.println(x); </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">     &#125; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread2</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123; </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">             <span class="keyword">synchronized</span> (lockObject) &#123; </span><br><span class="line">             x = y = <span class="number">1</span>; </span><br><span class="line">             System.out.println(y); </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">     <span class="keyword">new</span> Thread1().run(); </span><br><span class="line">     <span class="keyword">new</span> Thread2().run(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>在这两个线程中都必须使用同步，以便使这个程序正确工作。</p>
<h3 id="Java-锁定"><a href="#Java-锁定" class="headerlink" title="Java 锁定"></a>Java 锁定</h3><p>Java 锁定合并了一种互斥形式。每次只有一个线程可以持有锁。锁用于保护代码块或整个方法，必须记住是锁的身份保护了代码块，而不是代码块本身，这一点很重要。一个锁可以保护许多代码块或方法。 </p>
<p>反之，仅仅因为代码块由锁保护并不表示两个线程不能同时执行该代码块。它只表示如果两个线程正在等待相同的锁，则它们不能同时执行该代码。 </p>
<p>在以下示例中，两个线程可以同时不受限制地执行 setLastAccess() 中的 synchronized 块，因为每个线程有一个不同的 thingie 值。因此，synchronized 代码块受到两个正在执行的线程中不同锁的保护。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncExample</span> </span>&#123; </span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Thingie</span> </span>&#123; </span><br><span class="line">         <span class="keyword">private</span> Date lastAccess; </span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setLastAccess</span><span class="params">(Date date)</span> </span>&#123; </span><br><span class="line">            <span class="keyword">this</span>.lastAccess = date; </span><br><span class="line">         &#125; </span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123; </span><br><span class="line">         <span class="keyword">private</span> Thingie thingie; </span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(Thingie thingie)</span> </span>&#123; </span><br><span class="line">         <span class="keyword">this</span>.thingie = thingie; </span><br><span class="line">         &#125; </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">            thingie.setLastAccess(<span class="keyword">new</span> Date()); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">         Thingie thingie1 = <span class="keyword">new</span> Thingie(), </span><br><span class="line">         thingie2 = <span class="keyword">new</span> Thingie(); </span><br><span class="line">         <span class="keyword">new</span> MyThread(thingie1).start(); </span><br><span class="line">         <span class="keyword">new</span> MyThread(thingie2).start(); </span><br><span class="line">     &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="同步的方法"><a href="#同步的方法" class="headerlink" title="同步的方法"></a>同步的方法</h3><p>创建 synchronized 块的最简单方法是将方法声明成synchronized。这表示在进入方法主体之前，调用者必须获得锁： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123; </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setXY</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; </span><br><span class="line">         <span class="keyword">this</span>.x = x; </span><br><span class="line">         <span class="keyword">this</span>.y = y; </span><br><span class="line">     &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>对于普通的 synchronized 方法，这个锁是一个对象，将针对它调用方法。对于静态 synchronized 方法，这个锁是与 Class 对象相关的监控器，在该对象中声明了方法。 </p>
<p>仅仅因为 setXY() 被声明成 synchronized 并不表示两个不同的线程不能同时执行 setXY()，只要它们调用不同的 Point 实例的 setXY() 就可同时执行。对于一个 Point 实例，一次只能有一个线程执行 setXY()，或 Point 的任何其它 synchronized 方法。 </p>
<h3 id="同步的块"><a href="#同步的块" class="headerlink" title="同步的块"></a>同步的块</h3><p>synchronized 块的语法比synchronized方法稍微复杂一点，因为还需要显式地指定锁要保护哪个块。Point 的以下版本等价于前一页中显示的版本： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123; </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setXY</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; </span><br><span class="line">         <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123; </span><br><span class="line">             <span class="keyword">this</span>.x = x; </span><br><span class="line">             <span class="keyword">this</span>.y = y; </span><br><span class="line">         &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>使用 this 引用作为锁很常见，但这并不是必需的。这表示该代码块将与这个类中的 synchronized 方法使用同一个锁。 </p>
<p>由于同步防止了多个线程同时执行一个代码块，因此性能上就有问题，即使是在单处理器系统上。最好在尽可能最小的需要保护的代码块上使用同步。 </p>
<p>访问局部（基于堆栈的）变量从来不需要受到保护，因为它们只能被自己所属的线程访问。 </p>
<h3 id="大多数类并没有同步"><a href="#大多数类并没有同步" class="headerlink" title="大多数类并没有同步"></a>大多数类并没有同步</h3><p>因为同步会带来小小的性能损失，大多数通用类，如 java.util 中的 Collection 类，不在内部使用同步。这表示在没有附加同步的情况下，不能在多个线程中使用诸如 HashMap 这样的类。 </p>
<p>通过每次访问共享集合中的方法时使用同步，可以在多线程应用程序中使用 Collection 类。对于任何给定的集合，每次必须用同一个锁进行同步。通常可以选择集合对象本身作为锁。</p>
<p>下一页中的示例类 SimpleCache显示了如何使用HashMap以线程安全的方式提供高速缓存。但是，通常适当的同步并不只是意味着同步每个方法。 </p>
<p>Collections 类提供了一组便利的用于 List、Map 和 Set 接口的封装器。您可以用Collections.synchronizedMap 封装Map，它将确保所有对该映射的访问都被正确同步。<br>如果类的文档没有说明它是线程安全的，那么您必须假设它不是。 </p>
<h3 id="示例：简单的线程安全的高速缓存"><a href="#示例：简单的线程安全的高速缓存" class="headerlink" title="示例：简单的线程安全的高速缓存"></a>示例：简单的线程安全的高速缓存</h3><p>如以下代码样本所示，SimpleCache.java使用HashMap为对象装入器提供了一个简单的高速缓存。load() 方法知道怎样按对象的键装入对象。在一次装入对象之后，该对象就被存储到高速缓存中，这样以后的访问就会从高速缓存中检索它，而不是每次都全部地装入它。对共享高速缓存的每个访问都受到synchronized块保护。由于它被正确同步，所以多个线程可以同时调用 getObject 和clearCache 方法，而没有数据损坏的风险。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleCache</span> </span>&#123; </span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">final</span> Map cache = <span class="keyword">new</span> HashMap(); </span><br><span class="line">         <span class="function"><span class="keyword">public</span> Object <span class="title">load</span><span class="params">(String objectName)</span> </span>&#123; </span><br><span class="line">         <span class="comment">// load the object somehow </span></span><br><span class="line">     &#125; </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clearCache</span><span class="params">()</span> </span>&#123; </span><br><span class="line">         <span class="keyword">synchronized</span> (cache) &#123; </span><br><span class="line">            cache.clear(); </span><br><span class="line">         &#125; </span><br><span class="line">     &#125; </span><br><span class="line">     <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">(String objectName)</span> </span>&#123; </span><br><span class="line">         <span class="keyword">synchronized</span> (cache) &#123; </span><br><span class="line">             Object o = cache.get(objectName); </span><br><span class="line">             <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123; </span><br><span class="line">                 o = load(objectName); </span><br><span class="line">                 cache.put(objectName, o); </span><br><span class="line">             &#125; </span><br><span class="line">         &#125; </span><br><span class="line">     <span class="keyword">return</span> o; </span><br><span class="line">     &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>由于线程执行的计时是不确定的，我们需要小心，以控制线程对共享数据的访问。否则，多个并发线程会互相干扰对方的更改，从而损坏数据，或者其它线程也许不能及时看到对共享数据的更改。 </p>
<p>通过使用同步来保护对共享变量的访问，我们可以确保线程以可预料的方式与程序变量进行交互.</p>
<p>每个 Java 对象都可以充当锁，synchronized块可以确保一次只有一个线程执行由给定锁保护的synchronized 代码。 </p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>little_eight</tag>
      </tags>
  </entry>
  <entry>
    <title>ThreadPoolExecutor类解析</title>
    <url>/2019/07/23/ThreadPoolExecutor%E7%B1%BB%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>  在《阿里巴巴java开发手册》中指出了线程资源必须通过线程池提供，不允许在应用中自行显示的创建线程，这样一方面是线程的创建更加规范，可以合理控制开辟线程的数量；另一方面线程的细节管理交给线程池处理，优化了资源的开销。而线程池不允许使用Executors去创建，而要通过ThreadPoolExecutor方式，这一方面是由于jdk中Executor框架虽然提供了如newFixedThreadPool()、newSingleThreadExecutor()、newCachedThreadPool()等创建线程池的方法，但都有其局限性，不够灵活；另外由于前面几种方法内部也是通过ThreadPoolExecutor方式实现，使用ThreadPoolExecutor有助于大家明确线程池的运行规则，创建符合自己的业务场景需要的线程池，避免资源耗尽的风险。</p>
<h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 线程池的控制状态，是AtomicInteger类型的，里面包含两部分，workcount---线程的数量，</span><br><span class="line"> * runState---线程池的运行状态。这里限制了最大线程数是2^29-1，大约500百万个线程，</span><br><span class="line"> * 这也是个问题，所以ctl也可以变成AtomicLong类型的</span><br><span class="line"> */</span><br><span class="line">private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));</span><br><span class="line">/**</span><br><span class="line"> * 线程数量所占位数</span><br><span class="line"> */</span><br><span class="line">private static final int COUNT_BITS = Integer.SIZE - 3;</span><br><span class="line">/**</span><br><span class="line"> * 理论上的最大活跃线程数</span><br><span class="line"> */</span><br><span class="line">private static final int CAPACITY   = (1 &lt;&lt; COUNT_BITS) - 1;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * RUNNING - 接受新任务并且继续处理阻塞队列中的任务</span><br><span class="line"> * SHUTDOWN - 不接受新任务但是会继续处理阻塞队列中的任务</span><br><span class="line"> * STOP -  不接受新任务，不在执行阻塞队列中的任务，中断正在执行的任务</span><br><span class="line"> * TIDYING - 所有任务都已经完成，线程数都被回收，线程会转到TIDYING状态会继续执行钩子方法</span><br><span class="line"> * TERMINATED - 钩子方法执行完毕</span><br><span class="line"> */</span><br><span class="line">private static final int RUNNING    = -1 &lt;&lt; COUNT_BITS;</span><br><span class="line">private static final int SHUTDOWN   =  0 &lt;&lt; COUNT_BITS;</span><br><span class="line">private static final int STOP       =  1 &lt;&lt; COUNT_BITS;</span><br><span class="line">private static final int TIDYING    =  2 &lt;&lt; COUNT_BITS;</span><br><span class="line">private static final int TERMINATED =  3 &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  存放任务的队列，只有当线程数&gt;核心线程数，才会把其他的任务放入queue，</span><br><span class="line"> * 一般常用的是queue就是ArrayBlockingQueue，LinkedBlockingQueue，</span><br><span class="line"> * SynchronousQueue， ConcurrentLinkedQueue。</span><br><span class="line"> *</span><br><span class="line">　　 * 1）ArrayBlockingQueue：基于数组的先进先出队列，此队列创建时必须指定大小；</span><br><span class="line"> *    </span><br><span class="line">　　 * 2）LinkedBlockingQueue：基于链表的先进先出队列，如果创建时没有指定此队列大小，则默认为Integer.MAX_VALUE；</span><br><span class="line">　　 * 3）synchronousQueue：这个队列比较特殊，它不会保存提交的任务，而是将直接新建一个线程来执行新来的任务。</span><br><span class="line">　　 * 4) ConcurrentLinkedQueue: 无界线程安全队列</span><br><span class="line"> */</span><br><span class="line">private final BlockingQueue&lt;Runnable&gt; workQueue;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 包含池中所有工作线程的集合。仅当保持主锁.</span><br><span class="line"> */</span><br><span class="line">private final HashSet&lt;Worker&gt; workers = new HashSet&lt;Worker&gt;();</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 支持等待终止的等待条件</span><br><span class="line"> */</span><br><span class="line">private final Condition termination = mainLock.newCondition();</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 跟踪获得的最大池大小。仅在主锁下访问。</span><br><span class="line"> */</span><br><span class="line">private int largestPoolSize;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 已完成任务的计数器。仅在工作线程终止时更新。仅在主锁下访问</span><br><span class="line"> */</span><br><span class="line">private long completedTaskCount;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 创建线程的工厂类</span><br><span class="line"> */</span><br><span class="line">private volatile ThreadFactory threadFactory;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 在执行中饱和或关闭时调用的处理程序。拒绝策略；当任务太多来不及处理时，如何拒绝任务</span><br><span class="line"> */</span><br><span class="line">private volatile RejectedExecutionHandler handler;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 当线程池中创建的线程超过了核心线程数的时候，这些多余的空闲线程在结束之前等待新的                  * 创建线程的工厂类任务最大的存活时间。</span><br><span class="line"> */</span><br><span class="line">private volatile long keepAliveTime;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 允许核心线程被回收</span><br><span class="line"> */</span><br><span class="line">private volatile boolean allowCoreThreadTimeOut;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 线程池中的核心线程数，空闲的线程也不会回收，除非把allowCoreThreadTimeOut设置为true，              * 这时核心线程才会被回收</span><br><span class="line"> */</span><br><span class="line">private volatile int corePoolSize;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 线程池中可以创建的最大线程数，限定为2^29-1，大约500百万个线程。</span><br><span class="line"> * 需要注意的是，当使用无界的阻塞队列的时候，maximumPoolSize就起不到作用了。</span><br><span class="line"> */</span><br><span class="line">private volatile int maximumPoolSize;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 默认被拒绝的执行处理程序</span><br><span class="line"> */</span><br><span class="line">private static final RejectedExecutionHandler defaultHandler =</span><br><span class="line">    new AbortPolicy();</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 终止的权限</span><br><span class="line"> */</span><br><span class="line">private static final RuntimePermission shutdownPerm =</span><br><span class="line">    new RuntimePermission(&quot;modifyThread&quot;);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> */</span><br><span class="line">private final AccessControlContext acc;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 有多个构造方法，只讲最终实现的</span><br><span class="line"> */</span><br><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                          int maximumPoolSize,</span><br><span class="line">                          long keepAliveTime,</span><br><span class="line">                          TimeUnit unit,</span><br><span class="line">                          BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                          ThreadFactory threadFactory,</span><br><span class="line">                          RejectedExecutionHandler handler) &#123;</span><br><span class="line">    // 设置的核心线程数小于0，或者最大线程数小于0，或者最大线程数小于核心线程数，</span><br><span class="line">    // 创建线程的工厂类任务最大的存活时间小于0都抛出异常</span><br><span class="line">    if (corePoolSize &lt; 0 ||</span><br><span class="line">        maximumPoolSize &lt;= 0 ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; 0)</span><br><span class="line">        throw new IllegalArgumentException();</span><br><span class="line">    // 存放任务的队列、线程工厂、处理程序为null也抛出异常</span><br><span class="line">    if (workQueue == null || threadFactory == null || handler == null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    this.acc = System.getSecurityManager() == null ?</span><br><span class="line">            null :</span><br><span class="line">            AccessController.getContext();</span><br><span class="line">    // 下面就是设置参数了</span><br><span class="line">    this.corePoolSize = corePoolSize;</span><br><span class="line">    this.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    this.workQueue = workQueue;</span><br><span class="line">    this.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    this.threadFactory = threadFactory;</span><br><span class="line">    this.handler = handler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="主要方法（从用法入手）"><a href="#主要方法（从用法入手）" class="headerlink" title="主要方法（从用法入手）"></a>主要方法（从用法入手）</h2><h3 id="execute"><a href="#execute" class="headerlink" title="execute"></a>execute</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 执行入口</span><br><span class="line"> *</span><br><span class="line"> * 三步操作</span><br><span class="line"> *</span><br><span class="line"> * 1. 如果当前运行的线程数&lt;核心线程数,创建一个新的线程执行任务,调用addWorker方法原子性地检查</span><br><span class="line"> *    运行状态和线程数,通过返回false防止不需要的时候添加线程</span><br><span class="line"> * 2. 如果一个任务能够成功的入队,仍然需要双重检查,因为我们添加了一个线程(有可能这个线程在上次检查后就已经死亡了)</span><br><span class="line"> *    或者进入此方法的时候调用了shutdown,所以需要重新检查线程池的状态,如果必要的话,当停止的时候要回滚入队操作,</span><br><span class="line"> *    或者当线程池为空的话创建一个新的线程</span><br><span class="line"> * 3. 如果不能入队,尝试着开启一个新的线程,如果开启失败,说明线程池已经是shutdown状态或饱和了,所以拒绝执行该任务</span><br><span class="line"> */</span><br><span class="line">  public void execute(Runnable command) &#123;</span><br><span class="line">     if (command == null)</span><br><span class="line">         throw new NullPointerException();</span><br><span class="line">     // 获取当前线程池的控制状态</span><br><span class="line">     int c = ctl.get();</span><br><span class="line">     // 如果当前运行的线程数&lt;核心线程数</span><br><span class="line">     if (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">         // 调用addWorker方法原子性地检查运行状态和线程数,通过返回false防止不需要的时候添加线程</span><br><span class="line">         // 添加worker,成功则返回,下面再解析这个方法</span><br><span class="line">         if (addWorker(command, true))</span><br><span class="line">             return;</span><br><span class="line">         // 不成功则再次获取线程池控制状态</span><br><span class="line">         c = ctl.get();</span><br><span class="line">     &#125;</span><br><span class="line">     // 线程池处于RUNNING状态，将命令（用户自定义的Runnable对象）添加进workQueue队列</span><br><span class="line">     if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">          // 再次检查，获取线程池控制状态</span><br><span class="line">         int recheck = ctl.get();</span><br><span class="line">         // 线程池不处于RUNNING状态，将命令从workQueue队列中移除</span><br><span class="line">         if (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">             // 拒绝执行命令</span><br><span class="line">             reject(command);</span><br><span class="line">         // worker数量等于0,添加worker</span><br><span class="line">         else if (workerCountOf(recheck) == 0)</span><br><span class="line">             addWorker(null, false);</span><br><span class="line">     &#125;</span><br><span class="line">     // 添加worker失败,拒绝执行命令</span><br><span class="line">     else if (!addWorker(command, false))</span><br><span class="line">         reject(command);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="addWorker"><a href="#addWorker" class="headerlink" title="addWorker"></a>addWorker</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> */</span><br><span class="line"> private boolean addWorker(Runnable firstTask, boolean core) &#123;</span><br><span class="line">    retry:</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int c = ctl.get();</span><br><span class="line">        int rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        // 检查线程池状态是否正常，否则返回false</span><br><span class="line">        if (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask == null &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            return false;</span><br><span class="line"></span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            int wc = workerCountOf(c);</span><br><span class="line">            // 检查工作线程数是否正常，否则返回false</span><br><span class="line">            if (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                return false;</span><br><span class="line">            // 用到了原子CAS方法比较，使用CAS增加worker计数器成功，才能进入下一步</span><br><span class="line">            if (compareAndIncrementWorkerCount(c))</span><br><span class="line">                break retry;</span><br><span class="line">            c = ctl.get(); </span><br><span class="line">             // 这里表示执行到这里的时候线程池的运行状态发生改变的话，需要重新跳到retry处执行</span><br><span class="line">            if (runStateOf(c) != rs)</span><br><span class="line">                continue retry;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // worker开始标识</span><br><span class="line">    boolean workerStarted = false;</span><br><span class="line">    // worker被添加标识</span><br><span class="line">    boolean workerAdded = false;</span><br><span class="line">    Worker w = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 使用firstTask初始化Worker，first可能为null，那么则表示该worker为空闲</span><br><span class="line">        w = new Worker(firstTask);</span><br><span class="line">        // 获取worker对应的线程</span><br><span class="line">        final Thread t = w.thread;</span><br><span class="line">        if (t != null) &#123;</span><br><span class="line">             // 获取线程池锁</span><br><span class="line">            final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            try &#123;</span><br><span class="line">                // 线程池的运行状态</span><br><span class="line">                int rs = runStateOf(ctl.get());</span><br><span class="line">                // 判断线程池状态</span><br><span class="line">                if (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123;</span><br><span class="line">                    // 线程刚添加进来，还未启动就存活,抛出线程状态异常</span><br><span class="line">                    if (t.isAlive())</span><br><span class="line">                        throw new IllegalThreadStateException();</span><br><span class="line">                    // 添加worker</span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    int s = workers.size();</span><br><span class="line">                    // 如果队列大小大于最大池大小，让后者等于前者</span><br><span class="line">                    if (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    // 标识worker添加成功</span><br><span class="line">                    workerAdded = true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                // 解锁</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            // 如果worker添加成功，就标识运行成功</span><br><span class="line">            if (workerAdded) &#123;</span><br><span class="line">                // 开始执行worker的run方法</span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        // worker没有运行</span><br><span class="line">        if (! workerStarted)</span><br><span class="line">            // 添加worker失败，后面解析这个方法</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    // 返回worker的运行状态</span><br><span class="line">    return workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="addWorkerFailed"><a href="#addWorkerFailed" class="headerlink" title="addWorkerFailed"></a>addWorkerFailed</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> */</span><br><span class="line"> private void addWorkerFailed(Worker w) &#123;</span><br><span class="line">    // 获取主锁</span><br><span class="line">    final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        if (w != null)</span><br><span class="line">            // 移除该worker</span><br><span class="line">            workers.remove(w);</span><br><span class="line">        // 数量减1</span><br><span class="line">        decrementWorkerCount();</span><br><span class="line">        // 调用tryTerminate方法来尝试中止线程池,或者是清理一下线程池，下面说</span><br><span class="line">        tryTerminate();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="tryTerminate"><a href="#tryTerminate" class="headerlink" title="tryTerminate"></a>tryTerminate</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    /**</span><br><span class="line">     * 尝试终止线程池</span><br><span class="line">     */</span><br><span class="line">final void tryTerminate() &#123;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            // 获取线程池控制状态</span><br><span class="line">            int c = ctl.get();</span><br><span class="line">            // 线程池的运行状态为RUNNING</span><br><span class="line">            if (isRunning(c) ||      </span><br><span class="line">                // 线程池的运行状态最小要大于TIDYING</span><br><span class="line">                runStateAtLeast(c, TIDYING) ||   </span><br><span class="line">                 // 线程池的运行状态为SHUTDOWN并且workQueue队列不为null</span><br><span class="line">                (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))   </span><br><span class="line">                // 不能终止，直接返回</span><br><span class="line">                return;</span><br><span class="line">            // 线程池正在运行的worker数量不为0   </span><br><span class="line">            if (workerCountOf(c) != 0) &#123; </span><br><span class="line">                // 仅仅中断一个空闲的worker，下面说</span><br><span class="line">                interruptIdleWorkers(ONLY_ONE);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            // 获取线程池的锁</span><br><span class="line">            final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">            // 获取锁</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            try &#123;</span><br><span class="line">                // 比较并设置线程池控制状态为TIDYING</span><br><span class="line">                if (ctl.compareAndSet(c, ctlOf(TIDYING, 0))) &#123; </span><br><span class="line">                    try &#123;</span><br><span class="line">                        // 终止，钩子函数</span><br><span class="line">                        terminated();</span><br><span class="line">                    &#125; finally &#123;</span><br><span class="line">                        // 设置线程池控制状态为TERMINATED</span><br><span class="line">                        ctl.set(ctlOf(TERMINATED, 0));</span><br><span class="line">                        // 释放在termination条件上等待的所有线程</span><br><span class="line">                        termination.signalAll();</span><br><span class="line">                    &#125;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                // 释放锁</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            // else retry on failed CAS</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="interruptIdleWorkers"><a href="#interruptIdleWorkers" class="headerlink" title="interruptIdleWorkers"></a>interruptIdleWorkers</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    /**</span><br><span class="line">     * 尝试中断线程，onlyOne标识是否只中断一个</span><br><span class="line">     */</span><br><span class="line">private void interruptIdleWorkers(boolean onlyOne) &#123;</span><br><span class="line">        // 线程池的锁</span><br><span class="line">        final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">        // 获取锁</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            for (Worker w : workers) &#123; // 遍历workers队列</span><br><span class="line">                // worker对应的线程</span><br><span class="line">                Thread t = w.thread;</span><br><span class="line">                if (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123; // 线程未被中断并且成功获得锁</span><br><span class="line">                    try &#123;</span><br><span class="line">                        // 中断线程</span><br><span class="line">                        t.interrupt();</span><br><span class="line">                    &#125; catch (SecurityException ignore) &#123;</span><br><span class="line">                    &#125; finally &#123;</span><br><span class="line">                        // 释放锁</span><br><span class="line">                        w.unlock();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (onlyOne) // 若只中断一个，则跳出循环</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            // 释放锁</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h3 id="runWorker-重点关注这个"><a href="#runWorker-重点关注这个" class="headerlink" title="runWorker 重点关注这个"></a>runWorker 重点关注这个</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> */</span><br><span class="line"> final void runWorker(Worker w) &#123;</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = null;</span><br><span class="line">    w.unlock(); // allow interrupts</span><br><span class="line">    boolean completedAbruptly = true;</span><br><span class="line">    try &#123;</span><br><span class="line">         // 不断循环getTask来获取任务，getTask后面说</span><br><span class="line">        while (task != null || (task = getTask()) != null) &#123;</span><br><span class="line">            w.lock();</span><br><span class="line">            // 如果当前线程是stop，那么将确认其为interrupted</span><br><span class="line">            if ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            try &#123;</span><br><span class="line">                // 调用钩子函数</span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                Throwable thrown = null;</span><br><span class="line">                try &#123;</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; catch (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; throw x;</span><br><span class="line">                &#125; catch (Error x) &#123;</span><br><span class="line">                    thrown = x; throw x;</span><br><span class="line">                &#125; catch (Throwable x) &#123;</span><br><span class="line">                    thrown = x; throw new Error(x);</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    // 调用钩子函数</span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                task = null;</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = false;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        // 处理完成后，调用,下面会说</span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="getTask"><a href="#getTask" class="headerlink" title="getTask"></a>getTask</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 获取任务</span><br><span class="line"> */</span><br><span class="line"> private Runnable getTask() &#123;</span><br><span class="line">    // 超时标识</span><br><span class="line">    boolean timedOut = false;</span><br><span class="line"></span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int c = ctl.get();</span><br><span class="line">        int rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        // 检验线程池状态 </span><br><span class="line">        if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">        // 是否允许coreThread超时或者workerCount大于核心大小</span><br><span class="line">        boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line">        // 检查线程数量</span><br><span class="line">        if ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">            &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) &#123;</span><br><span class="line">            if (compareAndDecrementWorkerCount(c))</span><br><span class="line">                return null;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            Runnable r = timed ?</span><br><span class="line">                // 等待指定时间</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                // 一直等待，直到有元素</span><br><span class="line">                workQueue.take();</span><br><span class="line">            if (r != null)</span><br><span class="line">                return r;</span><br><span class="line">            // 等待指定时间后，没有获取元素，则超时</span><br><span class="line">            timedOut = true;</span><br><span class="line">        &#125; catch (InterruptedException retry) &#123;</span><br><span class="line">            // 抛出了被中断异常，重试，没有超时</span><br><span class="line">            timedOut = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="processWorkerExit"><a href="#processWorkerExit" class="headerlink" title="processWorkerExit"></a>processWorkerExit</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 根据是否中断了空闲线程来确定是否减少workerCount的值，并且将worker从workers集合中移除并且会尝试终止线程池。</span><br><span class="line"> */</span><br><span class="line">private void processWorkerExit(Worker w, boolean completedAbruptly) &#123;</span><br><span class="line">    // 如果被中断，则需要减少workCount</span><br><span class="line">    if (completedAbruptly)</span><br><span class="line">        decrementWorkerCount();</span><br><span class="line">    // 获取可重入锁</span><br><span class="line">    final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">    // 获取锁</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        // 将worker完成的任务添加到总的完成任务中</span><br><span class="line">        completedTaskCount += w.completedTasks;</span><br><span class="line">        // 从workers集合中移除该worker</span><br><span class="line">        workers.remove(w);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        // 释放锁</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    // 尝试终止</span><br><span class="line">    tryTerminate();</span><br><span class="line">    // 获取线程池控制状态</span><br><span class="line">    int c = ctl.get();</span><br><span class="line">    // 小于STOP的运行状态</span><br><span class="line">    if (runStateLessThan(c, STOP)) &#123; </span><br><span class="line">        if (!completedAbruptly) &#123;</span><br><span class="line">            int min = allowCoreThreadTimeOut ? 0 : corePoolSize;</span><br><span class="line">             // 允许核心超时并且workQueue阻塞队列不为空</span><br><span class="line">            if (min == 0 &amp;&amp; ! workQueue.isEmpty())</span><br><span class="line">                min = 1;</span><br><span class="line">            // workerCount大于等于min</span><br><span class="line">            if (workerCountOf(c) &gt;= min) </span><br><span class="line">                // 直接返回</span><br><span class="line">                return; // replacement not needed</span><br><span class="line">        &#125;</span><br><span class="line">        // 添加worker</span><br><span class="line">        addWorker(null, false);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>little_eight</tag>
      </tags>
  </entry>
  <entry>
    <title>kafka的一万字精华总结</title>
    <url>/2021/09/27/kafka%E7%9A%84%E4%B8%80%E4%B8%87%E5%AD%97%E7%B2%BE%E5%8D%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="什么是-Kafka"><a href="#什么是-Kafka" class="headerlink" title="什么是 Kafka"></a>什么是 Kafka</h2><p>Kafka 是一个分布式的，支持多分区、多副本的分布式消息流平台，它同时也是一款开源的<strong>基于发布订阅模式的消息引擎系统，</strong>简单来说就是一个分布式消息队列。<br>在2.8版本之前，无论是Kafka 集群，还是consumer都依赖于zookeeper集群保存一些meta信息，来保证系统可用性。2.8版本之后使用内嵌的KRaft作为zookeeper部分功能的替代品。<br><img data-src="https://gitee.com/littleeight/blog-images/raw/master/kafka%E7%9A%84%E4%B8%80%E4%B8%87%E5%AD%97%E7%B2%BE%E5%8D%8E%E6%80%BB%E7%BB%93/1.png"></p>
<span id="more"></span>
<p>如上图所示，一个典型的 Kafka 集群中包含若干Producer，若干broker（Kafka支持水平扩展，一般broker数量越多，集群吞吐率越高），若干Consumer Group，以及一个Zookeeper集群。Kafka通过Zookeeper管理集群配置，选举leader，以及在Consumer Group发生变化时进行rebalance。Producer使用push模式将消息发布到broker，Consumer使用pull模式从broker订阅并消费消息。<br>​</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><h3 id="活动跟踪"><a href="#活动跟踪" class="headerlink" title="活动跟踪"></a>活动跟踪</h3><p>kafka可以用来跟踪用户行为，比如我们经常回去淘宝购物，你打开淘宝的那一刻，你的登陆信息，登陆次数都会作为消息传输到 kafka，当你浏览购物的时候，你的浏览信息，你的搜索指数，你的购物爱好都会作为一个个消息传递给 kafka，这样就可以生成报告，可以做智能推荐，购买喜好等。</p>
<h3 id="传递消息"><a href="#传递消息" class="headerlink" title="传递消息"></a>传递消息</h3><p>kafka另外一个基本用途是传递消息，应用程序向用户发送通知就是通过传递消息来实现的，这些应用组件可以生成消息，而不需要关心消息的格式，也不需要关心消息是如何发送的；度量指标：Kafka也经常用来记录运营监控数据。包括收集各种分布式应用的数据，生产各种操作的集中反馈，比如报警和报告。</p>
<h3 id="日志记录"><a href="#日志记录" class="headerlink" title="日志记录"></a>日志记录</h3><p>Kafka 的基本概念来源于提交日志，比如我们可以把数据库的更新发送到 kafka上，用来记录数据库的更新时间，通过kafka以统一接口服务的方式开放给各种consumer，例如hadoop、Hbase、Solr等。</p>
<h3 id="流式处理"><a href="#流式处理" class="headerlink" title="流式处理"></a>流式处理</h3><p>流式处理是有一个能够提供多种应用程序的领域；限流削峰：kafka多用于互联网领域某一时刻请求特别多的情况下，可以把请求写入kafka中，避免直接请求后端程序导致服务崩溃。<br>​</p>
<h2 id="基本数据结构"><a href="#基本数据结构" class="headerlink" title="基本数据结构"></a>基本数据结构</h2><h3 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h3><p>生产者，发送消息的一方，负责创建消息发给kafka，会把消息发送到指定的topic里。</p>
<h3 id="Comsumer"><a href="#Comsumer" class="headerlink" title="Comsumer"></a>Comsumer</h3><p>消费者，连接kafka并接收消息，对指定的topic进行消费消息。</p>
<h3 id="Comsumer-group"><a href="#Comsumer-group" class="headerlink" title="Comsumer group"></a>Comsumer group</h3><p>一个消费者组可以包含n个消费者，同一组的消费者会去消费指定的topic，保证不会重复消费同一条消息。<br>因为topic里包含多个partition，kafka规定一个partition不能由多个comsumer消费，如果消费组的comsumer数量小于partition的，就会导致多余的comsumer线程空闲，如果大于那么comsumer会进行轮询直到消费完所有的partition，所以<strong>消费组里的comsumer的数量跟partition一致可达到最高利用率</strong>。<br>​</p>
<h3 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h3><p>服务代理节点，也就是服务节点，kafka的服务器。</p>
<h3 id="Topic"><a href="#Topic" class="headerlink" title="Topic"></a>Topic</h3><p>kafka的消息以topic为单位进行划分，生产者将消息发送到特定的topic，而消费者负责订阅topic的消息并进行消费。</p>
<h3 id="Partition"><a href="#Partition" class="headerlink" title="Partition"></a>Partition</h3><p>​</p>
<p>topic物理上的分组，一个topic可以分为多个partition，每个partition是一个有序的队列。消息到来时会使用轮询制往每个partition写入，如下图。<br><img data-src="https://gitee.com/littleeight/blog-images/raw/master/kafka%E7%9A%84%E4%B8%80%E4%B8%87%E5%AD%97%E7%B2%BE%E5%8D%8E%E6%80%BB%E7%BB%93/2.png"></p>
<p>kafka默认使用的是hash进行分区，所以同一个topic下的不同partition包含的消息是不同的。<br>物理上<strong>每个partition对应的是一个文件夹</strong>，其命名规则为topic名称+有序序号，第一个partiton序号从0开始，序号最大值为partitions数量减1。而文件夹里存储的当然是文件，这个文件就是segment。<br>​</p>
<h3 id="Segment"><a href="#Segment" class="headerlink" title="Segment"></a>Segment</h3><p>partition包含多个segment，每个segment对应一个文件，partition全局的第一个segment从0开始，后续每个segment文件名为上一个segment文件最后一条消息的offset值。数值最大为64位long大小，19位数字字符长度，没有数字用0填充。<br>segment可以手动指定大小（<strong>log.segment.bytes</strong>），当segment达到阈值时，将不再写数据。<br>记录只会被append到segment中，不会被单独删除或者修改，每个segment中的消息数量不一定相等。<br>而segment又分为索引跟手数据文件，2个文件是相关对应的，如下图：<br><img data-src="https://gitee.com/littleeight/blog-images/raw/master/kafka%E7%9A%84%E4%B8%80%E4%B8%87%E5%AD%97%E7%B2%BE%E5%8D%8E%E6%80%BB%E7%BB%93/3.png"></p>
<ul>
<li><strong>索引文件</strong>：以.index结尾的文件，采取<strong>稀疏索引存储方式</strong>，它减少索引文件大小。其中的数据指向对应数据文件的消息的物理偏移地址。在查找的时候利用索引文件快速定位到数据文件的位置实现快速查找，如下图。</li>
<li><strong>数据文件</strong>：存储消息的文件，由多个messager组成。</li>
</ul>
<p><img data-src="https://gitee.com/littleeight/blog-images/raw/master/kafka%E7%9A%84%E4%B8%80%E4%B8%87%E5%AD%97%E7%B2%BE%E5%8D%8E%E6%80%BB%E7%BB%93/4.png"></p>
<h3 id="Messager"><a href="#Messager" class="headerlink" title="Messager"></a>Messager</h3><p>消息的本体。其结构为：</p>
<ul>
<li><strong>offset</strong>：偏移量，8byte大小。在parition内的每条消息都有一个有序的id号，这个id号被称为偏移量,它可以唯一确定每条消息在parition内的位置。</li>
<li>message size：消息大小，4byte大小。</li>
<li>crc32：用crc32校验消息，4byte大小。</li>
<li>magic： 表示本次发布Kafka服务程序协议版本号，1byte大小。</li>
<li>attributes：表示为独立版本、或标识压缩类型、或编码类型，1byte大小。</li>
<li>key length：表示key的长度,当key为-1时，K byte key字段不填。</li>
<li>K byte key：设置消息的key，相同key的消息在不同时刻有不同的值，则只允许存在最新的一条消息。</li>
<li><strong>value bytes payload</strong>：实际数据。<h3 id="Offset"><a href="#Offset" class="headerlink" title="Offset"></a>Offset</h3>每个partition都由一系列有序的、不可变的消息组成，这些消息被连续的追加到partition中。partition中的每个消息都有一个连续的序列号叫做offset,用于partition唯一标识一条消息。<br>​</li>
</ul>
<h3 id="Replication"><a href="#Replication" class="headerlink" title="Replication"></a>Replication</h3><p>副本<strong>，</strong>kafka保证高可用的方式，同一个partition的数据可以在多个broker上存在多个副本，通常只有主副本对外提供读写服务，当主副本挂了之后，kafka会重新进行选举产生主副本。<br>​</p>
<h2 id="kafka的快"><a href="#kafka的快" class="headerlink" title="kafka的快"></a>kafka的快</h2><p>​</p>
<h3 id="写的快"><a href="#写的快" class="headerlink" title="写的快"></a>写的快</h3><p>为了优化写入速度，kafka采用了两种技术，一种是顺序写入，一种是MMAP。</p>
<h4 id="顺序写入"><a href="#顺序写入" class="headerlink" title="顺序写入"></a>顺序写入</h4><p>因为硬盘是机械结构，每次读写都会寻址-&gt;写入，其中寻址是一个“机械动作”，它是最耗时的。所以硬盘最讨厌随机I/O，最喜欢顺序I/O。为了提高读写硬盘的速度，kafka就是使用顺序I/O。<br>​</p>
<h4 id="Memory-Mapped-Files"><a href="#Memory-Mapped-Files" class="headerlink" title="Memory Mapped Files"></a>Memory Mapped Files</h4><p>即便是顺序写入磁盘，磁盘的访问速度还是不可能追上内存的。所以kafka的数据并不是实时的写入硬盘，它充分利用了现代操作系统的分页存储来利用内存，以此来提高I/O效率。Memory Mapped Files（后面简称MMAP）也被翻译成<strong>内存映射文件</strong>，在64位操作系统中一般可以表示20G的数据文件。它的工作原理是直接利用操作系统的Page来实现文件到物理内存的直接映射。完成映射之后，你对物理内存的操作会被同步到硬盘上（操作系统在适当的时候）。<br>通过MMAP，进程就可以像读写硬盘一样读写内存（当然是虚拟机内存），也不必关系内存的大小，因为有虚拟内存为我们兜底。使用这种方式可以获取很大的I/O提升，省去了用户空间到内核空间复制的开销（调用文件的read会有把数据先放到内核空间的内存中，然后再复制到用户空间的内存中）。<br>但是这样也有一个很明显的缺陷：不可靠，因为写到MMAP中的数据并没有被真正地写入到硬盘中，操作系统会在程序主动调用flush命令的时候才会把数据真正地写入到硬盘中。<br>MMAP其实是Linux中的一个函数，就是用来实现内存映射的。Java的NIO提供了一个MappedByteBuffer类来实现内存映射（因此Kafka是沾了Java的光，而不是Scala）。<br>​</p>
<h3 id="读的快"><a href="#读的快" class="headerlink" title="读的快"></a>读的快</h3><p>为了优化读取速度，kafka采用了两种技术，一种是零拷贝，一种是批量压缩。<br>​</p>
<h4 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h4><p>传统的文件读写或者网络传输，通常需要将数据从<strong>内核态</strong>转换为<strong>用户态</strong>。应用程序读取用户态内存数据，写入文件 / Socket之前，需要从用户态转换为内核态之后才可以写入文件或者网卡当中。数据首先从磁盘读取到内核缓冲区，这里面的内核缓冲区就是页缓存（PageCache）。然后从内核缓冲区中复制到应用程序缓冲区（用户态），输出到输出设备时，又会将用户态数据转换为内核态数据，这样的话就相当于数据需要复制4次才能真正获取到。<br><img data-src="https://gitee.com/littleeight/blog-images/raw/master/kafka%E7%9A%84%E4%B8%80%E4%B8%87%E5%AD%97%E7%B2%BE%E5%8D%8E%E6%80%BB%E7%BB%93/5.png"></p>
<p>在介绍零拷贝之前，我们先来看一个技术名词DMA（Direct Memory Access 直接内存访问）。它是现代电脑的重要特征之一，允许不同速度的硬件之间直接交互，而不需要占用CPU的中断负载。DMA传输将一个地址空间复制到另一个地址空间，当CPU 初始化这个传输之后，实际的数据传输是有DMA设备之间完成，这样可以大大的减少CPU的消耗。我们常见的硬件设备都支持DMA，如下图所示：<br>​</p>
<p><img data-src="https://gitee.com/littleeight/blog-images/raw/master/kafka%E7%9A%84%E4%B8%80%E4%B8%87%E5%AD%97%E7%B2%BE%E5%8D%8E%E6%80%BB%E7%BB%93/6.png"></p>
<p>零拷贝技术经过 DMA（Direct Memory Access）技术将文件内容复制到内核态下的页缓存中。不过没有数据被复制到 socket缓冲区，相反只有包含数据的位置和长度的信息的文件描述符被加到 socket缓冲区中。DMA 引擎直接将数据从内核态中传递到网卡设备（协议引擎）。这里数据只经历了2次复制就从磁盘中传送出去了，而且上下文切换也变成了2次。<br>零拷贝是针对内核态而言的，数据在内核态下实现了零拷贝。<br>kafka基于sendfile实现了零拷贝，运行流程如下：</p>
<ol>
<li>sendfile系统调用，文件数据被copy至内核缓冲区。</li>
<li>再从内核缓冲区copy至内核中socket缓冲区。</li>
<li>最后再socket缓冲区copy到协议引擎。<h4 id="批量压缩"><a href="#批量压缩" class="headerlink" title="批量压缩"></a>批量压缩</h4>在很多情况下，系统的瓶颈不是CPU或磁盘，而是网络IO，对于需要在广域网上的数据中心之间发送消息的数据流水线尤其如此。进行数据压缩会消耗少量的CPU资源,不过对于kafka而言,网络IO更应该需要考虑。</li>
</ol>
<ul>
<li>如果每个消息都压缩，会导致压缩率相对很低，所以Kafka使用了批量压缩，即将多个消息一起压缩而不是单个消息压缩。</li>
<li>Kafka允许使用递归的消息集合，批量的消息可以通过压缩的形式传输并且在日志中也可以保持压缩格式，直到被消费者解压缩。</li>
<li>Kafka支持多种压缩协议，包括Gzip和Snappy压缩协议。</li>
</ul>
<p>​</p>
<h2 id="kafka日志清除策略"><a href="#kafka日志清除策略" class="headerlink" title="kafka日志清除策略"></a>kafka日志清除策略</h2><p>众所周知，物理空间并不是无限大的，所以所有程序都会有一定的清除无用数据的策略，来保证程序的正常运转。因为kafka存储的是以文件类型存储数据，所以并不像rabbitmq一样当消费者确认消费完成后就会删除该消息，而是采用2种策略来对数据日志文件进行清除。<strong>log.cleanup.policy</strong>可指定清理策略，分别为<strong>delete</strong>与<strong>compact</strong>。注意的是这2种策略是可以同时设置同时生效的。</p>
<h3 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h3><p>会按照一定的属性来对数据日志文件进行清除。<br>kafka中所有用户创建的topic，默认均为此策略。</p>
<ul>
<li><p>log.retention.hours：指定数据保留的时间（默认为一周，168）</p>
</li>
<li><p>log.retention.bytes：每个partition中保存的最大数据量大小（默认为-1，也就是无限大）</p>
</li>
<li><p>log.retention.check.interval.ms： 指定间隔时间检查文件是否符合清除阈值，如果符合将其标记为deleted，也就是文件名后缀加.delete</p>
</li>
<li><p>log.cleaner.delete.retention.ms: deleted文件保留多长时间，默认是1天</p>
</li>
<li><p>log.cleaner.backoff.ms： 没有日志要清除时的休眠时间，默认15秒</p>
<h3 id="compact"><a href="#compact" class="headerlink" title="compact"></a>compact</h3><p>会按照一定的属性来对消息进行清除，topic __consumer_offsets 默认为此策略，有以下特点：</p>
</li>
<li><p>根据messages中的key，进行删除操作</p>
</li>
<li><p>在active segment 被commit 后，会删除掉old duplicate keys</p>
</li>
<li><p>无限制的时间与空间的日志保留</p>
</li>
</ul>
<p>​</p>
<p>注意的是清除message时是不会对剩下的进行重新排序，如果message已被删除当消费者凭借offset进行消费时会跳过不存在的message。<br>​</p>
<p>其中相关的属性为：</p>
<ul>
<li>segment.ms：在关闭一个active segment前，所需等待的最长时间。默认为7天</li>
<li>segment.bytes：一个segment的最大大小，默认为1G。</li>
<li>min.compaction .lag.ms：在一个message可以被compact前，所需等待的时间，默认为0。</li>
<li>delete.retention.ms：在一条message被加上删除标记后，在实际删除前等待的时间，默认为24小时。</li>
<li>min.Cleanable.dirty.ratio：若是设置的更高，则会有更高效的清理，但是更少的清理操作触发。若是设置的更低，则清理的效率稍低，但是会有更多的清理操作被触发，默认为0.5。</li>
</ul>
<p>​</p>
<h2 id="kafka的消息可靠性"><a href="#kafka的消息可靠性" class="headerlink" title="kafka的消息可靠性"></a>kafka的消息可靠性</h2><p>可靠性是有三方共同保证的。</p>
<h3 id="生产者保证消息可靠性"><a href="#生产者保证消息可靠性" class="headerlink" title="生产者保证消息可靠性"></a>生产者保证消息可靠性</h3><p>生产者先把message发送到partition leader，再由leader发送给其他partition follower。而kafka为生产者提供了2种异步方式，一种是有回调函数的方法send(message)，一种是没有回调函数的send(message,callback)。</p>
<ul>
<li><strong>send(message)</strong></li>
</ul>
<p>该方法可以将一条消息发送出去，但是对发送出去的消息没有掌控能力，无法得知其最后是不是到达了Kafka，所以这是一种不可靠的发送方式，但是也因为客户端只需要负责发送，所以具有较好的性能。</p>
<ul>
<li><strong>send(message,callback)</strong></li>
</ul>
<p>该方法可以将一条消息发送出去，并且可以从callback回调中得到该条消息的发送结果，并且callback是异步回调，所以在兼具性能的情况下，也对消息具有比较好的掌控。而kafka里有一个ack的属性，这个可以保证生产者的消息安全送达kafka。其中：</p>
<ul>
<li>acks=0<br>acks = 0如果设置为零，那么生产者将完全不会管服务器是否收到消息。该记录将立即添加到套接字缓冲区中并视为已发送。并且重试配置不会生效（因为客户端通常不会知道任何故障）。返回值的偏移量将始终等于 -1。该方式具有最大的吞吐量，一般建议直接配合 send(msg)使用。</li>
<li>acks=1<br>当leader接受到消息就会直接给客户端返回成功，一般情况下这种模式都能很好的保证数据的不丢失，只有在laeder接受到数据，然后还没来得及同步到follower，就挂掉了才会导致数据的丢失，这种概率还是比较小的。这也是默认的选择方式，兼具较好的吞吐和较高的可靠性。</li>
<li>acks=all 或者 acks=-1<br>当leader接受到消息，并同步到了一定数量的follower，才向生产者发生成功的消息，同步到的follower数量由 broker 端的 min.insync.replicas 决定。除非一些不可抗力因素，这种方式基本可以确保数据的完全不丢失。</li>
</ul>
<p>​</p>
<p>producer还有一个重试的机制，当发送消息失败时就会间隔指定时间再次发送。当重试次数超过预设的阈值后，需要怎么处理是由<strong>你自己的业务场景决定</strong>。常见的做法包括：</p>
<ul>
<li>继续重试直到天荒地老，如果是网线断了这种方法非常低效。</li>
<li>如果业务对丢失消息不敏感，可以直接抛弃这条信息。</li>
<li>如果业务对丢消息敏感，可以把错误记录下来，然后告警让人工介入处理。</li>
</ul>
<p>​</p>
<h3 id="broker保证消息可靠性"><a href="#broker保证消息可靠性" class="headerlink" title="broker保证消息可靠性"></a>broker保证消息可靠性</h3><p>既然要保证消息可靠性，在集群中是避免不了主从选举的。</p>
<h4 id="broker集群选举"><a href="#broker集群选举" class="headerlink" title="broker集群选举"></a>broker集群选举</h4><p>在一个kafka集群中，有多个broker节点，但是它们之间需要选举出一个leader，其他的broker充当follower角色。集群中第一个启动的broker会通过在zookeeper中创建临时节点/controller来让自己成为控制器，其他broker启动时也会在zookeeper中创建临时节点，但是发现节点已经存在，所以它们会收到一个异常，意识到控制器已经存在，那么就会在zookeeper中创建watch对象，便于它们收到控制器变更的通知。<br>那么如果控制器由于网络原因与zookeeper断开连接或者异常退出，那么其他broker通过watch收到控制器变更的通知，就会去尝试创建临时节点/controller，如果有一个broker创建成功，那么其他broker就会收到创建异常通知，也就意味着集群中已经有了控制器，其他broker只需创建watch对象即可。<br>如果集群中有一个broker发生异常退出了，那么<strong>控制器就会检查这个broker是否有分区的副本leader，如果有那么这个分区就需要一个新的leader，此时控制器就会去遍历其他副本，决定哪一个成为新的leader，同时更新分区的ISR集合</strong>。<br>如果有一个broker加入集群中，那么控制器就会通过broker ID去判断新加入的broker中是否含有现有分区的副本，如果有，就会从分区副本中去同步数据。<br>集群中每选举一次控制器，就会通过zookeeper创建一个controller epoch，每一个选举都会创建一个更大，包含最新信息的epoch，如果有broker收到比这个epoch旧的数据，就会忽略它们，kafka也通过这个epoch来防止集群产生“脑裂”。<br>​</p>
<h4 id="replication副本选举"><a href="#replication副本选举" class="headerlink" title="replication副本选举"></a>replication副本选举</h4><p>​</p>
<p>kafka给partition设置了replication副本的概念，把这些副本均匀的分布到多个broker上，就保证了数据的安全，不再担心某个broker宕机后使其中的partition失效，如下图：<br><img data-src="https://gitee.com/littleeight/blog-images/raw/master/kafka%E7%9A%84%E4%B8%80%E4%B8%87%E5%AD%97%E7%B2%BE%E5%8D%8E%E6%80%BB%E7%BB%93/7.png"></p>
<p>​</p>
<p>总共有三种副本角色：</p>
<ul>
<li>leader副本：也就是leader主副本，每个分区都有一个leader副本，为了保证数据一致性，所有的生产者与消费者的请求都会经过该副本来处理。</li>
<li>follower副本：除了首领副本外的其他所有副本都是follower副本，follower副本不处理来自客户端的任何请求，只负责从leader副本同步数据，保证与首领保持一致。如果leader副本发生崩溃，就会从这其中选举出一个leader。</li>
<li>优先副本：创建分区时指定的优先leader。如果不指定，则为分区的第一个副本。</li>
</ul>
<p>​</p>
<p>leader维护了一个动态的in-sync replica set (<strong>ISR</strong>)，意为和leader保持同步的follower集合，其中<strong>min.insync.replicas</strong>(默认为1)为ISR最小副本数，如果ISR中副本数小于该值则在接收生产者消息时就会以发送失败为结果。当ISR中的follower完成数据的同步之后，leader就会给producer发送ack。如果follower长时间未向leader同步数据，则该follower将被踢出ISR，该时间阈值由<strong>replica.lag.time.max.ms</strong>（默认30秒）参数设定。Leader发生故障之后，就会从ISR中选举新的leader。被踢出ISR的follower重连后依然会从leader中拉取数据，直到拉取的数据到达ISR的中partition的HW位置时，此被踢出的follower会重新加入ISR中。<br>[</p>
<p>](<a href="https://blog.csdn.net/sghuu/article/details/102669495">https://blog.csdn.net/sghuu/article/details/102669495</a>)<br>在<strong>副本所在的broker发生宕机后</strong>，怎么处理呢？<br>首先先了解下三个名词：</p>
<ul>
<li>HW（High Watermark），俗称“高水位”，它表示了一个特定消息的偏移量（offset），消费只能拉取到这个offset之前的消息。</li>
<li>LW（Low Watermark），俗称“低水位”，代表AR集合中最小的logStartOffset值，副本的拉取请求和删除请求都可能促使LW的增长。</li>
<li>LEO（Log End Offset），它表示当前日志文件中下一条待写入消息的offset，LEO的大小相当于当前日志分区中最后一条消息的offset值+1。分区ISR集合中每个副本都会维护自身的LEO，而ISR集合中最小的LEO即为分区的HW，对于消费者而言，只能消费HW之前的消息。</li>
</ul>
<p>[</p>
<p>](<a href="https://blog.csdn.net/weixin_43958358/article/details/114886750">https://blog.csdn.net/weixin_43958358/article/details/114886750</a>)<br><img data-src="https://gitee.com/littleeight/blog-images/raw/master/kafka%E7%9A%84%E4%B8%80%E4%B8%87%E5%AD%97%E7%B2%BE%E5%8D%8E%E6%80%BB%E7%BB%93/8.png"><br>​</p>
<p>​</p>
<ul>
<li>follower故障</li>
</ul>
<p>follower发生故障后会被临时踢出ISR，待该follower恢复后，follower会读取本地磁盘记录的上次的HW，并将log文件高于HW的部分截取掉，从HW开始向leader进行同步。等该follower的LEO大于等于该Partition的HW，即follower追上leader之后，就可以重新加入ISR了。</p>
<ul>
<li>leader故障</li>
</ul>
<p>leader发生故障之后，会从ISR中选出一个新的leader，之后，为保证多个副本之间的数据一致性，其余的follower会先将各自的log文件高于HW的部分截掉，然后从新的leader同步数据。<strong>所以这只能保证副本之间的一致性，并不能保证数据不丢失或者不重复。</strong><br>[</p>
<p>](<a href="https://blog.csdn.net/sghuu/article/details/102669495">https://blog.csdn.net/sghuu/article/details/102669495</a>)<br>​</p>
<h3 id="消费者保证消息可靠性"><a href="#消费者保证消息可靠性" class="headerlink" title="消费者保证消息可靠性"></a>消费者保证消息可靠性</h3><p>在消费者对指定消息分区进行消息消费的过程中，会根据选用的api不同来保存消费的offset。</p>
<ul>
<li>如果是kafka.javaapi.consumer.ConsumerConnector，我们会配置参数<strong>zookeeper.connect</strong>来消费。这种情况下，消费者的offset会更新到zookeeper的。consumers/{group}/offsets/{topic}/{partition}目录下。</li>
<li>如果是根据kafka默认的api来消费，即org.apache.kafka.clients.consumer.KafkaConsumer，我们会配置参数<strong>bootstrap.servers</strong>来消费。而其消费者的offset会更新到一个kafka自带的**__consumer_offsets**下面，查看当前group的消费进度，则要依靠kafka自带的工具kafka-consumer-offset-checker。</li>
</ul>
<p>​</p>
<p>offset更新的方式，不区分是用的哪种api，大致分为两类：</p>
<ul>
<li>自动提交，设置enable.auto.commit=true，更新的频率根据参数<a href="http://auto.commit.interval.ms/"><strong>auto.commit.interval.ms</strong></a>来定。这种方式也被称为at most once，fetch到消息后就可以更新offset，无论是否消费成功。</li>
<li>手动提交，设置enable.auto.commit=false，这种方式称为at least once。fetch到消息后，等消费完成再调用方法**consumer.commitSync()**，手动更新offset；如果消费失败，则offset也不会更新，此条消息会被重复消费一次。设置手动提交的话，就可保证消息消费到。</li>
</ul>
<p>​</p>
<h2 id="消息积压"><a href="#消息积压" class="headerlink" title="消息积压"></a>消息积压</h2><p>通常情况下，企业中会采取轮询或者随机的方式，通过kafka的producer向kafka集群生产数据，来尽可能保证kafka分区之间的数据是均匀分布的。<br>在分区数据均匀分布的前提下，如果我们针对要处理的topic数据量等因素，设计出合理的kafka分区数量。对于一些实时任务，比如Flink和Kafka集成的应用，消费端不存在长时间”挂掉”的情况即数据一直在持续被消费，那么一般不会产生kafka数据积压的情况。<br>但是这些都是有前提的，当一些意外或者不合理的分区数设置情况的发生，积压问题就不可避免。</p>
<h3 id="典型案例"><a href="#典型案例" class="headerlink" title="典型案例"></a>典型案例</h3><p><strong>实时/消费任务挂掉了</strong><br>比如，我们写的实时应用因为某种原因挂掉了，并且这个任务没有被监控程序监控发现通知相关负责人，负责人又没有写自动拉起任务的脚本进行重启。<br>那么在我们重新启动这个实时应用进行消费之前，这段时间的消息就会被滞后处理，如果数据量很大，可就不是简单重启应用直接消费就能解决的。</p>
<h4 id="消费组不断重平衡"><a href="#消费组不断重平衡" class="headerlink" title="消费组不断重平衡"></a>消费组不断重平衡</h4><p>消费组重平衡期间是无法消费的，当我们的消费程序出现间接性消费缓慢或者超时异常的时候，可能是遇到消费者组重平衡了。<br><strong>kafka分区数设置的不合理（太少）和消费者”消费能力”不足</strong><br>kafka单分区生产消息的速度qps通常很高，如果消费者因为某些原因（比如受业务逻辑复杂度影响，消费时间会有所不同），就会出现消费滞后的情况。<br>此外，kafka分区数是kafka并行度调优的最小单元，如果kafka分区数设置的太少，会影响consumer消费的吞吐量。<br><strong>kafka消息的key不均匀，导致分区间数据不均衡</strong><br>在使用kafka producer消息时，可以为消息指定key，但是要求key要均匀，否则会出现kafka分区间数据不均衡。<br>​</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ul>
<li>任务重新启动后直接消费最新的消息，对于”滞后”的历史数据采用离线程序进行”补漏”。</li>
<li>如下面图所示。创建新的topic并配置更多数量的分区，将积压消息的topic消费者逻辑改为直接把消息打入新的topic，将消费逻辑写在新的topic的消费者中。</li>
</ul>
<p>​</p>
<p><img data-src="https://gitee.com/littleeight/blog-images/raw/master/kafka%E7%9A%84%E4%B8%80%E4%B8%87%E5%AD%97%E7%B2%BE%E5%8D%8E%E6%80%BB%E7%BB%93/9.png"></p>
<ul>
<li>对于重平衡导致的问题，不考虑人为的增加分区、消费者等情况，只考虑一些会让kafka误判的情况。<ul>
<li>设置<strong>session.timout.ms大一些，保证zookeeper不容易判定消费者超时导致重平衡。</strong></li>
<li><strong>heartbeat.interval.ms，这个参数控制发送心跳的频率</strong>，频率越高越不容易被误判，但也会消耗更多资源。</li>
<li><strong>max.poll.interval.ms</strong>，我们都知道消费者poll数据后，需要一些处理，再进行拉取。如果两次拉取时间间隔超过这个参数设置的值，那么消费者就会被踢出消费者组。也就是说，拉取，然后处理，这个处理的时间不能超过max.poll.interval.ms这个参数的值。这个参数的默认值是5分钟，而如果消费者接收到数据后会执行耗时的操作，则应该将其设置得大一些。这里给出一个相对较为合理的配置，如下：<ul>
<li>session.timout.ms：设置为6s</li>
<li>heartbeat.interval.ms：设置2s</li>
<li>max.poll.interval.ms：推荐为消费者处理消息最长耗时再加1分钟    </li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>mq</category>
      </categories>
      <tags>
        <tag>little_eight</tag>
      </tags>
  </entry>
  <entry>
    <title>redis一万字精华总结</title>
    <url>/2021/09/06/redis%E4%B8%80%E4%B8%87%E5%AD%97%E7%B2%BE%E5%8D%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="redis的官网简介"><a href="#redis的官网简介" class="headerlink" title="redis的官网简介"></a>redis的官网简介</h2><p>Redis 是一个开放源码(BSD 许可)、内存中的数据结构存储，用作数据库、缓存和消息代理。Redis 提供数据结构，例如string字符串、hash散列、list列表、set集合、sorted set带有范围查询的排序集、bitmaps位图、hyperloglogs超级日志、geospatial indexes地理空间索引、 streams流。Redis 具有内置的复制、 Lua 脚本、 LRU 收回、事务和不同级别的磁盘持久性，并通过 Redis Sentinel 提供高可用性服务，并通过 Redis Cluster 提供自动分区。<br>您可以对这些类型运行原子操作，比如附加到字符串; 在散列中递增值; 将元素推入列表; 计算集合的交集、并集和差集; 或者获得排序集中排名最高的成员。<br>为了获得最佳性能，Redis 使用内存中的数据集。根据您的用例，您可以通过定期将数据集转储到磁盘或将每个命令附加到基于磁盘的日志中来持久化数据。如果您只需要一个功能丰富的网络化内存缓存，那么还可以禁用持久性。<br>Redis 还支持异步复制，具有非常快的非阻塞第一同步，自动重连接和部分重新同步的网络分割。<br>其他功能包括:</p>
<span id="more"></span> 
<ul>
<li><a href="https://redis.io/topics/transactions">Transactions 交易</a></li>
<li><a href="https://redis.io/topics/pubsub">Pub/Sub 发布/订阅</a></li>
<li><a href="https://redis.io/commands/eval">Lua scriptingLua 脚本</a></li>
<li><a href="https://redis.io/commands/expire">Keys with a limited time-to-live 有限时间的</a>keys</li>
<li><a href="https://redis.io/topics/lru-cache">LRU eviction of keysLRU 收回钥匙</a></li>
<li><a href="https://redis.io/topics/sentinel">Automatic failover 自动故障转移</a></li>
</ul>
<p>​</p>
<p>Redis 是用 ANSI c 编写的，在大多数 POSIX 系统中工作，比如 Linux、 * BSD 和 OS x，没有外部依赖性。Linux 和 OS x 是 Redis 开发和测试最多的两个操作系统，我们建议使用 Linux 进行部署。Redis 也许可以在诸如 SmartOS 这样的 solaris 衍生系统中工作，但是这种支持是最好的努力。没有对 Windows 构建的官方支持。<br>​</p>
<h2 id="redis的快"><a href="#redis的快" class="headerlink" title="redis的快"></a>redis的快</h2><p>redis为什么能风靡全球，首要原因就是因为它快，在网络发展如此迅速的时代，时间就是金钱，一个良好的快速反馈时间是第一要素。那为什么redis能这么快？</p>
<h3 id="纯内存存储"><a href="#纯内存存储" class="headerlink" title="纯内存存储"></a>纯内存存储</h3><p>redis将所有数据放在内存中，非数据同步正常工作中，是不需要从磁盘读取数据的，0次IO。内存响应时间大约为100纳秒，所以理论上redis是可以达到100*1000qps的。</p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="I-O多路复用"><a href="#I-O多路复用" class="headerlink" title="I/O多路复用"></a>I/O多路复用</h3><p>I/O 多路复用(select/poll/epoll)机制中多路是指多个连接，复用是指一个线程多次重复使用，也就是一个线程处理多个 IO 流，redis采用的是epoll，在 redis 只运行单线程的情况下，该机制允许内核中同时存在多个监听套接字和已连接套接字。内核会一直监听这些套接字上的连接请求或数据请求，一旦有请求到达就会交给 redis 线程处理，这样就实现了一个 redis 线程处理多个 IO 流的效果。看下图：<br>​</p>
<p><img data-src="https://gitee.com/littleeight/blog-images/raw/master/redis%E7%9A%84%E4%B8%80%E4%B8%87%E5%AD%97%E7%B2%BE%E5%8D%8E%E6%80%BB%E7%BB%93/1.png"></p>
<ul>
<li>一个 socket 客户端与服务端连接时，会生成对应一个套接字描述符(套接字描述符是文件描述符的一种)，每一个 socket 网络连接其实都对应一个文件描述符。</li>
<li>多个客户端与服务端连接时，redis 使用 <strong>「I/O 多路复用程序」</strong> 将客户端 socket 对应的 FD 注册到监听列表(<strong>一个队列</strong>)中。当客服端执行 read、write 等操作命令时，I/O 多路复用程序会将命令封装成一个事件，并绑定到对应的 文件描述符（FD ） 上。</li>
<li><strong>「文件事件处理器」</strong>使用 I/O 多路复用模块同时监控多个 FD 的读写情况（如下图），当 accept、read、write等文件事件产生时，文件事件处理器就会回调 FD 绑定的事件处理器进行处理相关命令操作。</li>
<li>整个文件事件处理器是在单线程上运行的，但是通过 I/O 多路复用模块的引入，实现了同时对多个 FD 读写的监控，当其中一个 client 端达到写或读的状态，文件事件处理器就马上执行，从而就不会出现 I/O 堵塞的问题，提高了网络通信的性能。</li>
</ul>
<p><img data-src="https://gitee.com/littleeight/blog-images/raw/master/redis%E7%9A%84%E4%B8%80%E4%B8%87%E5%AD%97%E7%B2%BE%E5%8D%8E%E6%80%BB%E7%BB%93/2.png"></p>
<h3 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h3><p>单线程避免了线程上下文切换以及加锁释放锁带来的消耗，对于服务端开发来说，锁和线程切换通常是性能杀手。当然了，单线程也会有它的缺点，也是redis的噩梦：<strong>阻塞</strong>。如果执行一个命令过长，那么会造成其他命令的阻塞，对于Redis是十分致命的，所以Redis是面向快速执行场景的数据库。<br>这里需要提到的是，在redis4.0之后引入了多线程，像惰性删除，持久化、集群数据同步等操作，都是由额外的线程执行，而redis单线程是指<strong>主线程专注于网络 IO 和键值对读写</strong>。在redis6引入的多线程则是真正为了提高 I/O 的读写性能而引入的，它的主要实现思路是将主线程的 I/O 读写任务拆分给一组独立的子线程去执行，也就是说从 socket 中读数据和写数据不再由主线程负责，而是交给了多个子线程，这样就可以使多个 socket 的读写并行化了。这么做的原因就在于，虽然在 redis 中使用了 I/O 多路复用，但我们知道数据在内核态空间和用户态空间之间的拷贝是无法避免的，而数据的拷贝这一步是阻塞的，并且当数据量越大时拷贝所需要的时间就越多。所以多线程用于分摊同步读写 I/O 压力，从而提升 redis 的 qps。但是注意，redis 的命令本身依旧是由 redis 主线程串行执行的，只不过具体的读写操作交给独立的子线程去执行了，而这么做的好处就是不需要为 Lua 脚本、事务的原子性而额外开发多线程互斥机制，这样一来 redis 的线程模型实现起来就简单多了，因为和之前一样，所有的命令依旧是由主线程串行执行的，只不过具体的读写任务交给了子线程。下图是主线程跟io线程的交互情况：<br><img data-src="https://gitee.com/littleeight/blog-images/raw/master/redis%E7%9A%84%E4%B8%80%E4%B8%87%E5%AD%97%E7%B2%BE%E5%8D%8E%E6%80%BB%E7%BB%93/3.png"></p>
<p>redis6中，多线程机制默认是关闭的，如果想启动的话，需要修改 redis.conf 中的两个配置。第一个是设置io线程是否开启，第二个是设置其线程数。</p>
<pre><code>  - io-thread-do-reads yes 
  - io-threads 3
</code></pre>
<p>除了redis之外，node.js、nginx也是单线程，他们都是服务器高性能的典范。<br>​</p>
<h2 id="redis的数据结构"><a href="#redis的数据结构" class="headerlink" title="redis的数据结构"></a>redis的数据结构</h2><h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><p>它是二进制安全的，可以存储图片或者序列化的对象，值最大存储为512M。底层用sds来使用，相对于c的原生字符串是char[]实现的好处之一是在获取长度时不需要遍历数据。<br>简单使用举例: set key value、get key等<br>应用场景：共享session、分布式锁，计数器、限流。<br>内部编码有3种，int（8字节长整型）/embstr（小于等于39字节字符串）/raw（大于39个字节字符串）</p>
<h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><p>哈希类型是指v（值）本身又是一个键值对（k-v）结构<br>简单使用举例：hset key field value 、hget key field<br>内部编码：ziplist（压缩列表） 、hashtable（哈希表）<br>应用场景：缓存用户信息等。<br><strong>注意点</strong>：如果开发使用hgetall，哈希元素比较多的话，可能导致redis阻塞，可以使用hscan。而如果只是获取部分field，建议使用hmget。</p>
<h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><p>list<br><img data-src="https://gitee.com/littleeight/blog-images/raw/master/redis%E7%9A%84%E4%B8%80%E4%B8%87%E5%AD%97%E7%B2%BE%E5%8D%8E%E6%80%BB%E7%BB%93/4.png"></p>
<p>列表（list）类型是用来存储多个有序的字符串，一个列表最多可以存储2^32-1个元素。<br>简单实用举例： lpush key value [value …] 、lrange key start end<br>内部编码：ziplist（压缩列表）、linkedlist（链表）<br>应用场景： 消息队列，文章列表。<br>​</p>
<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p><img data-src="https://gitee.com/littleeight/blog-images/raw/master/redis%E7%9A%84%E4%B8%80%E4%B8%87%E5%AD%97%E7%B2%BE%E5%8D%8E%E6%80%BB%E7%BB%93/5.png"></p>
<p>集合（set）类型也是用来保存多个的字符串元素，但是不允许重复元素。<br>简单使用举例：sadd key element [element …]、smembers key<br>内部编码：intset（整数集合）、hashtable（哈希表）<br><strong>注意点</strong>：smembers和lrange、hgetall都属于比较重的命令，如果元素过多存在阻塞Redis的可能性，可以使用sscan来完成。<br>应用场景： 用户标签,生成随机数抽奖、社交需求。<br>​</p>
<h3 id="zset"><a href="#zset" class="headerlink" title="zset"></a>zset</h3><p>已排序的字符串集合，同时元素不能重复。<br>简单格式举例：zadd key score member [score member …]，zrank key member<br>底层内部编码：ziplist（压缩列表）、skiplist（跳跃表）<br>应用场景：排行榜，社交需求（如用户点赞）。<br>​</p>
<p>​</p>
<h3 id="bitmaps"><a href="#bitmaps" class="headerlink" title="bitmaps"></a>bitmaps</h3><p>用一个比特位来映射某个元素的状态，在redis中，它的底层是基于字符串类型实现的，可以把bitmaps成作一个以比特位为单位的数组。</p>
<h3 id="hyperloglogs"><a href="#hyperloglogs" class="headerlink" title="hyperloglogs"></a>hyperloglogs</h3><p>用来做基数统计算法的数据结构，如统计网站的浏览人数，帮程序自主去重。</p>
<h3 id="geospatial-indexes"><a href="#geospatial-indexes" class="headerlink" title="geospatial indexes"></a>geospatial indexes</h3><p>用来推算地理位置的信息，两地之间的距离，方圆几里的人等。</p>
<h3 id="streams"><a href="#streams" class="headerlink" title="streams"></a>streams</h3><p>官方把它定义为：以更抽象的方式建模日志的数据结构。redis的streams主要是一个append only file的数据结构，至少在概念上它是一种在内存中表示的抽象数据类型，只不过它们实现了更强大的操作，以克服日志文件本身的限制。如果你了解MQ，那么可以把streams当做MQ。如果你还了解kafka，那么甚至可以把streams当做kafka。<br>     另外，这个功能有点类似于redis以前的Pub/Sub，但是也有基本的不同：</p>
<ul>
<li>streams支持多个客户端（消费者）等待数据（Linux环境开多个窗口执行XREAD即可模拟），并且每个客户端得到的是完全相同的数据。</li>
<li>Pub/Sub是发送忘记的方式，并且不存储任何数据；而streams模式下，所有消息被无限期追加在streams中，除非用于显示执行删除（XDEL）。</li>
<li>streams的Consumer Groups也是Pub/Sub无法实现的控制方式。</li>
</ul>
<p>​</p>
<h2 id="redis的过期策略"><a href="#redis的过期策略" class="headerlink" title="redis的过期策略"></a>redis的过期策略</h2><p>redis有三种过期策略。</p>
<ul>
<li><strong>定时过期</strong>：每个设置过期时间的key都需要创建一个定时器，到过期时间就会立即对key进行清除。该策略可以立即清除过期的数据，对内存很友好；但是会占用大量的CPU资源去处理过期的数据，从而影响缓存的响应时间和吞吐量。</li>
<li><strong>定期过期</strong>：只有当访问一个key时，才会判断该key是否已过期，过期则清除。该策略可以最大化地节省CPU资源，却对内存非常不友好。极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。</li>
<li><strong>惰性过期</strong>：每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key。该策略是前两者的一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。expires字典会保存所有设置了过期时间的key的过期时间数据，其中，key是指向键空间中的某个键的指针，value是该键的毫秒精度的UNIX时间戳表示的过期时间。</li>
</ul>
<p>​</p>
<p>redis同时使用的是定期过期跟惰性过期。</p>
<h2 id="redis的内存淘汰策略"><a href="#redis的内存淘汰策略" class="headerlink" title="redis的内存淘汰策略"></a>redis的内存淘汰策略</h2><p>内存并不是无限大的，当存储的容量达到一定限度时，redis就会采用内存淘汰策略来保护自己，主要有以下几种：</p>
<ul>
<li><strong>noeviction</strong>：默认策略，当内存不足以容纳新写入数据时，新写入操作会报错。</li>
<li><strong>volatile-lru</strong>：当内存不足以容纳新写入数据时，从设置了过期时间的key中使用LRU（最近最少使用）算法进行淘汰。</li>
<li><strong>allkeys-lru</strong>：当内存不足以容纳新写入数据时，从所有key中使用LRU算法进行淘汰。</li>
<li><strong>volatile-lfu</strong>：4.0版本新增，当内存不足以容纳新写入数据时，在过期的key中，使用LFU算法进行删除key。 </li>
<li><strong>allkeys-lfu</strong>：4.0版本新增，当内存不足以容纳新写入数据时，从所有key中使用LFU算法进行淘汰。</li>
<li><strong>volatile-random</strong>：当内存不足以容纳新写入数据时，从设置了过期时间的key中，随机淘汰数据。</li>
<li><strong>allkeys-random</strong>：当内存不足以容纳新写入数据时，从所有key中随机淘汰数据。</li>
<li><strong>volatile-ttl</strong>：当内存不足以容纳新写入数据时，在设置了过期时间的key中，根据过期时间进行淘汰，越早过期的优先被淘汰。</li>
</ul>
<h2 id="redis的持久化机制"><a href="#redis的持久化机制" class="headerlink" title="redis的持久化机制"></a>redis的持久化机制</h2><p>redis是基于内存的，如果挂了数据便全部丢失，所以便需要做持久化，把数据存到磁盘中。redis有<strong>rdb</strong>跟<strong>aof</strong>两种机制。</p>
<h3 id="rdb"><a href="#rdb" class="headerlink" title="rdb"></a>rdb</h3><p>redis database，是把当前内存中的数据集快照写入磁盘，也就是 Snapshot 快照（数据库中所有键值对数据）。恢复时是将快照文件直接读到内存里。<br>rdb有2种触发机制，分别是自动触发和手动触发。</p>
<ul>
<li><strong>自动触发</strong>，在 redis.conf 配置文件中的 SNAPSHOTTING 下，可配置相关策略。<ul>
<li><strong>save：</strong>这里是用来配置触发 Redis的 RDB 持久化条件，也就是什么时候将内存中的数据保存到硬盘。比如“save m n”。表示m秒内数据集存在n次修改时，自动触发bgsave（这个命令下面会介绍，手动触发RDB持久化的命令），当然如果你只是用Redis的缓存功能，不需要持久化，那么你可以注释掉所有的 save 行来停用保存功能。可以直接一个空字符串来实现停用：save “”。</li>
<li><strong>stop-writes-on-bgsave-error ：</strong>默认值为yes。当启用了RDB且最后一次后台保存数据失败，Redis是否停止接收数据。这会让用户意识到数据没有正确持久化到磁盘上，否则没有人会注意到灾难（disaster）发生了。如果Redis重启了，那么又可以重新开始接收数据了。</li>
<li><strong>rdbcompression ；</strong>默认值是yes。对于存储到磁盘中的快照，可以设置是否进行压缩存储。如果是的话，redis会采用LZF算法进行压缩。如果你不想消耗CPU来进行压缩的话，可以设置为关闭此功能，但是存储在磁盘上的快照会比较大。</li>
<li><strong>rdbchecksum ：</strong>默认值是yes。在存储快照后，我们还可以让redis使用CRC64算法来进行数据校验，但是这样做会增加大约10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能。</li>
<li><strong>dir：</strong>设置快照文件的存放路径，这个配置项一定是个目录，而不能是文件名。默认是和当前配置文件保存在同一目录。</li>
</ul>
</li>
</ul>
<p>也就是说通过在配置文件中配置的 save 方式，当实际操作满足该配置形式时就会进行 RDB 持久化，将当前的内存快照保存在 dir 配置的目录中，文件名由配置的 dbfilename 决定。<br>​</p>
<ul>
<li><strong>手动触发</strong><ul>
<li>**save **该命令会阻塞当前Redis服务器，执行save命令期间，Redis不能处理其他命令，直到RDB过程完成为止。</li>
<li>**bgsave **执行该命令时，Redis会在后台异步进行快照操作，快照同时还可以响应客户端请求。具体操作是Redis进程执行fork操作创建子进程，RDB持久化过程由子进程负责，完成后自动结束。阻塞只发生在fork阶段，一般时间很短。</li>
</ul>
</li>
</ul>
<p>基本上 Redis 内部所有的RDB操作都是采用 bgsave 命令。<br>​</p>
<h4 id="rdb的优缺点"><a href="#rdb的优缺点" class="headerlink" title="rdb的优缺点"></a>rdb的优缺点</h4><p>1、rdb是一个非常紧凑的文件，保存了redis在某个时间点的数据集，非常适合备份，体积比aof小，因为是数据的快照，基本上就是数据的复制，不用重新读取再写入内存。<br>2、rdb的工作原理是父进程在保存文件就是 fork 出一个子进程，然后这个子进程就会处理接下来的所有保存工作，父进程无须执行任何磁盘 I/O 操作,这样可以最大化提升redis的性能，<strong>但是当数据比较大时这个fork进程可能会非常耗时，造成redis阻塞。</strong><br>3、rdb在恢复大数据集时比aof慢。<br>4、因为是根据时间来备份的，所以会有丢失数据的风险。<br>​</p>
<h3 id="aof"><a href="#aof" class="headerlink" title="aof"></a>aof</h3><p>append only file，将写操作追加到文件中，AOF 日志是写后日志，“写后”的意思是 redis 是先执行命令，把数据写入内存后，然后才记日志；里面记录的是指令执行的步骤，非常详细，描绘出了数据的变化过程。<br>在 redis.conf 配置文件中的 SNAPSHOTTING 下，可配置相关策略。</p>
<ul>
<li><strong>appendonly</strong>  no 是否开启AOF机制，yes 代表开启</li>
<li><strong>appendfilename</strong>  “appendonly.aof”   aof文件名</li>
<li><strong>appendfsync</strong> xxx   aof持久化策略的配置， xxx为alaways表示表示不执行同步，由操作系统自己选择时间保证数据同步到磁盘，速度最快；xxx为everysec表示每一秒执行一次同步，可能会导致丢失这1s数据；no表示每次写入内存后都执行同步，以保证数据同步到磁盘。</li>
<li><strong>no-appendfsync-on-rewrite</strong>  no  是否开启重写(当aof文件的大小超过所设定的阈值时，redis就会对aof文件的内容压缩。)</li>
<li>**auto-aof-rewrite-percentage ** 100   当目前aof文件大小超过上一次重写的aof文件大小的百分之多少进行重写</li>
<li><strong>auto-aof-rewrite-min-size</strong>  64mb    设置允许重写的最小aof文件大小</li>
<li><strong>aof-use-rdb-preamble</strong>  no      混合使用 aof和rdb的开关<h3 id="-2"><a href="#-2" class="headerlink" title=""></a></h3><h4 id="aof的优缺点"><a href="#aof的优缺点" class="headerlink" title="aof的优缺点"></a>aof的优缺点</h4>1、可最大限度地保证数据的完整性。<br>2、重写机制让日志文件更小。<br>3、因为记录的是执行过程，所以文件会比rdb大许多。<br>​</li>
</ul>
<h2 id="redis的高可用"><a href="#redis的高可用" class="headerlink" title="redis的高可用"></a>redis的高可用</h2><p>高可用的方案一般都是集群，redis有三种集群方式：<strong>主从模式，哨兵模式，集群模式</strong>。<br>​</p>
<h3 id="主从模式-master-slave"><a href="#主从模式-master-slave" class="headerlink" title="主从模式 master-slave"></a>主从模式 master-slave</h3><p>主从模式中，Redis部署了多台机器，有主节点，负责读写操作，有从节点，只负责读操作。从节点的数据来自主节点，实现原理就是<strong>主从复制机制，</strong>基本的步骤如下（蓝色代表slave发给master的命令，红色相反）<strong>：</strong></p>
<ul>
<li>slave发送psync2命令到master。（命令：psync2 <runid> <offset>）</li>
<li>master接收到SYNC命令后，执行bgsave命令，生成RDB全量文件,并生成缓冲区（缓冲复制先进先出队列，默认1M）记录从现在开始执行的所有写命令。（命令： fullresync <runid> <offset>）</li>
<li>master执行完bgsave后，向所有slave发送RDB快照文件。</li>
<li>slave收到RDB快照文件后，清空自己的数据，然后载入、解析收到的快照。</li>
<li>master快照发送完毕后，也就是<strong>全量复制</strong>结束后，会开始<strong>增量复制</strong>，向slave发送缓冲区中的写命令。</li>
<li>slave接受命令请求，并执行来自master缓冲区的写命令。</li>
<li>后续slave只需要携带id跟offset(上次复制的偏移量)发给master，便可进行<strong>增量复制</strong>。如果存在就会发送continue给slave，如果不存在就会执行全量复制。(命令 continue <runid> <offset>)</li>
</ul>
<p>​</p>
<h3 id="哨兵模式-sentinel"><a href="#哨兵模式-sentinel" class="headerlink" title="哨兵模式 sentinel"></a>哨兵模式 sentinel</h3><p>主从模式中，一旦主节点由于故障不能提供服务，需要人工将从节点晋升为主节点，同时还要通知应用方更新主节点地址。显然，多数业务场景都不能接受这种故障处理方式。redis从2.8开始正式提供了Redis Sentinel（哨兵）架构来解决这个问题。<br><strong>哨兵模式</strong>，由一个或多个Sentinel实例组成的Sentinel系统，它可以监视所有的redis主节点和从节点，并在被监视的主节点进入下线状态时，<strong>自动将下线主服务器属下的某个从节点升级为新的主节点</strong>。但是呢，一个哨兵进程对redis节点进行监控，就可能会出现问题（<strong>单点问题</strong>），因此，可以使用多个哨兵来进行监控redis节点，并且各个哨兵之间还会进行监控。下图是整体架构：<br><img data-src="https://gitee.com/littleeight/blog-images/raw/master/redis%E7%9A%84%E4%B8%80%E4%B8%87%E5%AD%97%E7%B2%BE%E5%8D%8E%E6%80%BB%E7%BB%93/6.png"></p>
<p>简单来说，哨兵模式就三个作用：</p>
<ul>
<li>发送命令，等待Redis服务器（包括主服务器和从服务器）返回监控其运行状态；</li>
<li>哨兵监测到主节点宕机，会自动将从节点切换成主节点，然后通过发布订阅模式通知其他的从节点，修改配置文件，让它们切换主机；</li>
<li>哨兵之间还会相互监控，从而达到高可用。</li>
</ul>
<p>哨兵的工作模式如下：</p>
<ol>
<li>每个哨兵以每秒钟一次的频率向它所知的master，slave以及其他哨兵实例发送一个 PING命令。</li>
<li>如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 选项所指定的值， 则这个实例会被哨兵标记为主观下线。</li>
<li>如果一个master被标记为主观下线，则正在监视这个master的所有哨兵要以每秒一次的频率确认master的确进入了主观下线状态。</li>
<li>当有足够数量的哨兵（大于等于配置文件指定的值）在指定的时间范围内确认master的确进入了主观下线状态， 则master会被标记为客观下线。</li>
<li>在一般情况下， 每个哨兵会以每10秒一次的频率向它已知的所有master，slave发送 INFO 命令,当master被哨兵标记为客观下线时，哨兵向下线的 master的所有 slave发送 INFO 命令的频率会从 10 秒一次改为每秒一次</li>
<li>若没有足够数量的哨兵同意master已经下线， master的客观下线状态就会被移除；若master重新向哨兵的 PING 命令返回有效回复， master的主观下线状态就会被移除。</li>
</ol>
<p>当master被判断客观下线以后，各个哨兵节点会进行协商，选举出一个领导者哨兵节点，并由该领导者节点对其进行故障转移操作。监视该主节点的所有哨兵都有可能被选为领导者，选举使用的算法是 Raft 算法，Raft 算法的基本思路是先到先得：即在一轮选举中，哨兵 A 向 B 发送成为领导者的申请，如果 B 没有同意过其他哨兵，则会同意 A 成为领导者。<br>选举出的领导者哨兵，开始进行<strong>故障转移操作</strong>，该操作大体可以分为 3 个步骤：</p>
<ol>
<li>在从节点中选择新的主节点：选择的原则是，首先过滤掉不健康的从节点，然后选择优先级最高的从节点(由 slave-priority 指定)。 如果优先级无法区分，则选择复制偏移量最大的从节点；如果仍无法区分，则选择 runid 最小的从节点。</li>
<li>更新主从状态：通过 slaveof no one 命令，让选出来的从节点成为主节点；并通过 slaveof 命令让其他节点成为其从节点。</li>
<li>将已经下线的主节点设置为新的主节点的从节点，当它重新上线后，它会成为新的主节点的从节点。</li>
</ol>
<p><strong>​</strong></p>
<p><strong>​</strong></p>
<h3 id="集群模式-cluster"><a href="#集群模式-cluster" class="headerlink" title="集群模式 cluster"></a>集群模式 cluster</h3><p>哨兵模式基于主从模式，实现读写分离，它还可以自动切换，系统可用性更高。但是它每个节点存储的数据是一样的，浪费内存，并且不好在线扩容。 因此，cluster集群应运而生，它在redis3加入的，实现了redis的<strong>分布式存储</strong>。对数据进行分片，也就是说<strong>每台redis节点上存储不同的内容</strong>，来解决在线扩容的问题。并且它也提供<strong>复制</strong>和<strong>故障转移</strong>的功能。<br>cluster集群通过Gossip协议进行通信，节点之前不断交换信息，交换的信息内容包括节点出现故障、新节点加入、主从节点变更信息、slot信息等等。常用的Gossip消息分为4种，分别是：ping、pong、meet、fail。</p>
<ul>
<li><strong>meet消息</strong>：通知新节点加入。消息发送者通知接收者加入到当前集群，meet消息通信正常完成后，接收节点会加入到集群中并进行周期性的ping、pong消息交换。</li>
<li> <strong>ping消息</strong>：集群内交换最频繁的消息，集群内每个节点每秒向多个其他节点发送ping消息，用于检测节点是否在线和交换彼此状态信息。</li>
<li> <strong>pong消息</strong>：当接收到ping、meet消息时，作为响应消息回复给发送方确认消息正常通信。pong消息内部封装了自身状态数据。节点也可以向集群内广播自身的pong消息来通知整个集群对自身状态进行更新。</li>
<li> <strong>fail消息</strong>：当节点判定集群内另一个节点下线时，会向集群内广播一个fail消息，其他节点接收到fail消息之后把对应节点更新为下线状态。</li>
</ul>
<h4 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h4><p>cluster如何做到每个节点存储不同数据的呢，它采用的是<strong>hash slot插槽算法，插槽算法</strong>把整个数据库被分为16384个slot（槽），每个进入redis的键值对，根据key进行散列，分配到这16384插槽中的一个。使用的哈希映射也比较简单，用CRC16算法计算出一个16 位的值，再对16384取模。数据库中的每个键都属于这16384个槽的其中一个，集群中的每个节点都可以处理这16384个槽。<br>集群中的每个节点负责一部分的hash槽，比如当前集群有A、B、C个节点，每个节点上的哈希槽数 =16384/3，那么就有：</p>
<ul>
<li>节点A负责0~5460号哈希槽</li>
<li>节点B负责5461~10922号哈希槽</li>
<li>节点C负责10923~16383号哈希槽</li>
</ul>
<p>如果新增节点，那就会把其他节点的头部部分哈希槽一起平分给新节点，如果删除节点的话就平分到其他节点。<br>    设计成16384个槽点是因为考虑到节点数不太可能超过1000，并且槽点越小，其压缩率就越高。</p>
<h4 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h4><p>cluster集群引入了主从复制，一个主节点对应一个或者多个从节点。当其它主节点 ping 一个主节点 A 时，如果半数以上的主节点与 A 通信超时，那么认为主节点 A 宕机了。如果主节点宕机时，就会启用从节点。<br>当集群内节点出现故障时，通过<strong>故障转移</strong>，以保证集群正常对外提供服务。<br>redis集群通过ping/pong消息，实现故障发现。这个环境包括<strong>主观下线和客观下线</strong>。</p>
<ul>
<li><strong>主观下线：</strong> 某个节点认为另一个节点不可用，即下线状态，这个状态并不是最终的故障判定，只能代表一个节点的意见，可能存在误判情况。</li>
</ul>
<p><img data-src="https://gitee.com/littleeight/blog-images/raw/master/redis%E7%9A%84%E4%B8%80%E4%B8%87%E5%AD%97%E7%B2%BE%E5%8D%8E%E6%80%BB%E7%BB%93/7.png"></p>
<ul>
<li><strong>客观下线：</strong> 指标记一个节点真正的下线，集群内多个节点都认为该节点不可用，从而达成共识的结果。如果是持有槽的主节点故障，需要为该节点进行故障转移。</li>
<li>假如节点A标记节点B为主观下线，一段时间后，节点A通过消息把节点B的状态发到其它节点，当节点C接受到消息并解析出消息体时，如果发现节点B的pfail状态时，会触发客观下线流程；</li>
<li>当下线为主节点时，此时Redis Cluster集群为统计持有槽的主节点投票，看投票数是否达到一半，当下线报告统计数大于一半时，被标记为<strong>客观下线</strong>状态。</li>
<li>​<strong>故障恢复</strong>：故障发现后，如果下线节点的是主节点，则需要在它的从节点中选一个替换它，以保证集群的高可用。流程如下：<ul>
<li>资格检查：检查从节点是否具备替换故障主节点的条件。</li>
<li>准备选举时间：资格检查通过后，更新触发故障选举时间。</li>
<li>发起选举：到了故障选举时间，进行选举。</li>
<li>选举投票：只有持有槽的<strong>主节点</strong>才有票，从节点收集到足够的选票（大于一半），触发<strong>替换主节点操作</strong></li>
<li><strong>​</strong></li>
</ul>
</li>
</ul>
<h2 id="mysql与redis保证双写一致性"><a href="#mysql与redis保证双写一致性" class="headerlink" title="mysql与redis保证双写一致性"></a>mysql与redis保证双写一致性</h2><h3 id="延时双删"><a href="#延时双删" class="headerlink" title="延时双删"></a>延时双删</h3><ol>
<li>先删除缓存</li>
<li>再更新数据库</li>
<li>休眠一会（比如1秒），再次删除缓存。</li>
</ol>
<p>​</p>
<p>这种方案还算可以，只有休眠那一会（比如就那1秒），可能有脏数据，一般业务也会接受的。但是如果<strong>第二次删除缓存失败</strong>呢？缓存和数据库的数据还是可能不一致。<br>​</p>
<h3 id="删除缓存重试机制"><a href="#删除缓存重试机制" class="headerlink" title="删除缓存重试机制"></a>删除缓存重试机制</h3><ol>
<li>写请求更新数据库</li>
<li>缓存因为某些原因，删除失败</li>
<li>把删除失败的key放到消息队列</li>
<li>消费消息队列的消息，获取要删除的key</li>
<li>重试删除缓存操作</li>
</ol>
<p>​</p>
<h3 id="读取binlog异步删除缓存"><a href="#读取binlog异步删除缓存" class="headerlink" title="读取binlog异步删除缓存"></a>读取binlog异步删除缓存</h3><ul>
<li>可以使用阿里的canal将binlog日志采集发送到MQ队列里面</li>
<li>然后通过ACK机制确认处理这条更新消息，删除缓存，保证数据缓存一致性</li>
</ul>
<p>​</p>
<h2 id="redis的分布式锁"><a href="#redis的分布式锁" class="headerlink" title="redis的分布式锁"></a>redis的分布式锁</h2><p>这个可用redisson实现，具体可查看<a href="https://www.yuque.com/xiaoba-t6gyt/mtab2v/hv2phx">redisson分布式锁详解</a>。</p>
<h2 id="redis对于缓存的三大问题的处理"><a href="#redis对于缓存的三大问题的处理" class="headerlink" title="redis对于缓存的三大问题的处理"></a>redis对于缓存的三大问题的处理</h2><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>缓存雪崩是指在某一个时间段，缓存集中过期失效。此刻无数的请求直接绕开缓存，直接请求数据库。<br>造成缓存雪崩的原因，有以下两种：<strong>redis宕机</strong>、<strong>大部分数据失效</strong>。<br>对于缓存雪崩的解决方案有以下两种：</p>
<ul>
<li>搭建高可用的集群，防止单机的redis宕机。</li>
<li>设置不同的过期时间，防止同一时间内大量的key失效。</li>
</ul>
<p>​</p>
<h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>缓存穿透是指查询一条数据库和缓存都没有的一条数据，就会一直查询数据库，对数据库的访问压力就会增大；<br>解决方案：</p>
<ul>
<li>缓存空对象</li>
<li>布隆过滤器</li>
</ul>
<p>​</p>
<h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>是指一个key非常热点，在不停的扛着大并发，<strong>大并发</strong>集中对这一个点进行访问，当这个key在失效的瞬间，持续的<strong>大并发</strong>就穿破缓存，直接请求数据库，瞬间对数据库的访问压力增大。<br>解决方案：</p>
<ul>
<li>将数据热点数据设置成永久的，不设置失效时间。</li>
<li>集群扩容，增加分片副本，均衡读流量。</li>
<li>使用分布式锁，a、当缓存不命中时，在查询数据库前使用redis分布式锁，使用查询的key值作为锁条件；b、获取锁的线程在查询数据库前，再查询一次缓存。这样做是因为高并发请求获取锁的时候造成排队，但第一次进来的线程在查询完数据库后会写入缓存，之后再获得锁的线程直接查询缓存就可以获得数据；c、读取完数据后释放分布式锁。</li>
</ul>
]]></content>
      <categories>
        <category>缓存</category>
      </categories>
      <tags>
        <tag>little_eight</tag>
      </tags>
  </entry>
  <entry>
    <title>十大基础排序算法</title>
    <url>/2019/01/30/%E5%8D%81%E5%A4%A7%E5%9F%BA%E7%A1%80%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="十大基础排序算法"><a href="#十大基础排序算法" class="headerlink" title="十大基础排序算法"></a>十大基础排序算法</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><ul>
<li><p>基本思路<br>对n个数进行排序，每次都是由前一个数跟后一个数比较，每循环一轮， 就可以将最大的数移到数组的最后， 总共循环n-1轮，完成对数组排序。</p>
</li>
<li><p>动图演示</p>
</li>
</ul>
<p><img data-src="https://user-gold-cdn.xitu.io/2019/1/17/1685c01b1a3ac5e8?imageslim" alt="这里写图片描述"></p>
<ul>
<li><p>编码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (arr == <span class="keyword">null</span>)</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">int</span> len = arr.length;</span><br><span class="line">		<span class="comment">// i控制循环次数，长度为len的数组只需要循环len-1次，i的起始值为0所以i&lt;len-1</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">				<span class="comment">// 如果前一个数比后一个数大，则交换位置将大的数往后放。</span></span><br><span class="line">				<span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">					<span class="keyword">int</span> temp = arr[j + <span class="number">1</span>];</span><br><span class="line">					arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">					arr[j] = temp;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3></li>
<li><p>基本思路<br>选择排序可以说是冒泡排序的改良版,通过循环对比，记录最小的数字下标与目标互换 这样相对于冒泡排序来说，比较的次数并没有改变，但是数据交换的次数大大减少。</p>
</li>
<li><p>动图演示</p>
</li>
</ul>
<p><img data-src="https://user-gold-cdn.xitu.io/2019/1/17/1685c01b2349fb70?imageslim" alt="这里写图片描述"></p>
<ul>
<li>编码<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (arr == <span class="keyword">null</span>)</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">int</span> len = arr.length;</span><br><span class="line">		<span class="comment">// 用来保存每次比较后较小数的下标</span></span><br><span class="line">		<span class="keyword">int</span> minIndex;</span><br><span class="line">		<span class="comment">// i控制循环次数，长度为len的数组只需要循环len-1次，i的起始值为0所以i&lt;len-1</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">			minIndex = i;</span><br><span class="line">			<span class="comment">//j控制比较次数，因为每次循环结束之后最小的数都已经放在了最前面，</span></span><br><span class="line">			<span class="comment">//所以下一次循环的时候就可以跳过这个数，所以j的初始值为i+1而不需要每次循环都从0开始，并且j&lt;len即可</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">				<span class="comment">// 每比较一次都需要将较小数的下标记录下来</span></span><br><span class="line">				<span class="keyword">if</span> (arr[minIndex] &gt; arr[j]) &#123;</span><br><span class="line">					minIndex = j;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 当完成一次循环时，就需要将本次循环选取的最小数移动到本次循环开始的位置。</span></span><br><span class="line">			<span class="keyword">if</span> (minIndex != i) &#123;</span><br><span class="line">				<span class="keyword">int</span> temp = arr[i];</span><br><span class="line">				arr[i] = arr[minIndex];</span><br><span class="line">				arr[minIndex] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><ul>
<li><p>基本思路<br>首先就默认数组中的第一个数的位置是正确的，即已经排序。然后取下一个数，与已经排序的数按从后向前的顺序依次比较， 如果该数比当前位置排好序的数小，则将排好序的数的位置向后移一位。 重复上一步骤，直到找到合适的位置。找到位置后就结束比较的循环，将该数放到相应的位置。</p>
</li>
<li><p>动图演示</p>
</li>
</ul>
<p><img data-src="https://user-gold-cdn.xitu.io/2019/1/17/1685c01b284a6b98?imageslim" alt="这里写图片描述"></p>
<ul>
<li>编码<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (arr == <span class="keyword">null</span>)</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">int</span> len = arr.length;</span><br><span class="line">		<span class="comment">// target用来记录即将要排序的那个数的值即目标值</span></span><br><span class="line">		<span class="keyword">int</span> target;</span><br><span class="line">		<span class="comment">// index用来记录要交换的那个值的下标</span></span><br><span class="line">		<span class="keyword">int</span> index;</span><br><span class="line">		<span class="comment">// i控制循环次数，因为已经默认第一个数的位置是正确的，所以i的起始值为1，i&lt;len，循环len-1次</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">			target = arr[i];</span><br><span class="line">			index = i;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">				<span class="comment">// 如果前一个数大于target，则设值成后一个数，并记录前一个数下标</span></span><br><span class="line">				<span class="keyword">if</span> (target &lt; arr[j - <span class="number">1</span>]) &#123;</span><br><span class="line">					arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">					index = j - <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 更目标数的位置。</span></span><br><span class="line">			arr[index] = target;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><ul>
<li><p>基本思路<br>希尔排序也称为”缩小增量排序”，原理是先将需要排的数组分成多个子序列，这样每个子序列的元素个数就很少，再分别对每个对子序列进行插入排序。在该数组基本有序后 再进行一次直接插入排序就能完成对整个数组的排序。所以，要采用跳跃分割的策略。这里引入“增量”的概念，将相距某个增量的记录两两组合成一个子序列，然后对每个子序列进行直接插入排序， 这样得到的结果才会使基本有序（即小的在前边，大的在后边，不大不小的在中间）。希尔排序就是 直接插入排序的升级版。</p>
</li>
<li><p>动图演示</p>
</li>
</ul>
<p><img data-src="https://user-gold-cdn.xitu.io/2019/1/17/1685c01b7d4cfe55?imageslim" alt="这里写图片描述"></p>
<ul>
<li>编码<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (arr == <span class="keyword">null</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">// 数组的长度</span></span><br><span class="line">	<span class="keyword">int</span> len = arr.length;</span><br><span class="line">	<span class="comment">// 初始的增量为数组长度的一半</span></span><br><span class="line">	<span class="keyword">int</span> k = len / <span class="number">2</span>;</span><br><span class="line">	<span class="comment">// while循环控制按增量的值来划不同分子序列，每完成一次增量就减少为原来的一半</span></span><br><span class="line">	<span class="comment">// 增量的最小值为1，即最后一次对整个数组做直接插入排序</span></span><br><span class="line">	<span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">// 里边其实就是升级版的直接插入排序了，是对每一个子序列进行直接插入排序，</span></span><br><span class="line">		<span class="comment">// 所以直接将直接插入排序中的‘1’变为‘k’就可以了。</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; len; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> j = i;</span><br><span class="line">			<span class="keyword">int</span> target = arr[i];</span><br><span class="line">			<span class="keyword">while</span> (j &gt;= k &amp;&amp; target &lt; arr[j - k]) &#123;</span><br><span class="line">				arr[j] = arr[j - k];</span><br><span class="line">				j -= k;</span><br><span class="line">			&#125;</span><br><span class="line">			arr[j] = target;</span><br><span class="line">		&#125;</span><br><span class="line">		k /= <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><ul>
<li><p>基本思路<br>总体概括就是从上到下递归拆分，然后从下到上逐步合并。</p>
</li>
<li><p>动图演示</p>
</li>
</ul>
<p><img data-src="https://user-gold-cdn.xitu.io/2019/1/17/1685c01b7f84849b?imageslim" alt="这里写图片描述"></p>
<ul>
<li>编码<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 递归拆分</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> arr   待拆分数组</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> left  待拆分数组最小下标</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> right 待拆分数组最大下标</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 中间下标</span></span><br><span class="line">		<span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">			<span class="comment">// 递归拆分左边</span></span><br><span class="line">			mergeSort(arr, left, mid);</span><br><span class="line">			<span class="comment">// 递归拆分右边</span></span><br><span class="line">			mergeSort(arr, mid + <span class="number">1</span>, right);</span><br><span class="line">			<span class="comment">// 合并左右</span></span><br><span class="line">			sort(arr, left, mid, right);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 合并两个有序子序列</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> arr   待合并数组</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> left  待合并数组最小下标</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> mid   待合并数组中间下标</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> right 待合并数组最大下标</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 临时数组，用来保存每次合并年之后的结果</span></span><br><span class="line">		<span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[right - left + <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">int</span> i = left;</span><br><span class="line">		<span class="keyword">int</span> j = mid + <span class="number">1</span>;</span><br><span class="line">		<span class="comment">// 临时数组的初始下标</span></span><br><span class="line">		<span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">// 这个while循环能够初步筛选出待合并的了两个子序列中的较小数</span></span><br><span class="line">		<span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[i] &lt;= arr[j]) &#123;</span><br><span class="line">				temp[k++] = arr[i++];</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				temp[k++] = arr[j++];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 将左边序列中剩余的数放入临时数组</span></span><br><span class="line">		<span class="keyword">while</span> (i &lt;= mid) &#123;</span><br><span class="line">			temp[k++] = arr[i++];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 将右边序列中剩余的数放入临时数组</span></span><br><span class="line">		<span class="keyword">while</span> (j &lt;= right) &#123;</span><br><span class="line">			temp[k++] = arr[j++];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 将临时数组中的元素位置对应到真真实的数组中</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>; m &lt; temp.length; m++) &#123;</span><br><span class="line">			arr[m + left] = temp[m];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><ul>
<li><p>基本思路<br>快速排序也采用了分治的策略，这里引入了‘基准数’的概念。</p>
<ul>
<li>找一个基准数（一般将待排序的数组的第一个数作为基准数）</li>
<li>对数组进行分区，将小于等于基准数的全部放在左边，大于基准数的全部放在右边。</li>
<li>重复1，2步骤，分别对左右两个子分区进行分区，一直到各分区只有一个数为止。</li>
</ul>
</li>
<li><p>动图演示</p>
</li>
</ul>
<p><img data-src="https://user-gold-cdn.xitu.io/2019/1/17/1685c01b83823cd8?imageslim" alt="这里写图片描述"></p>
<ul>
<li>编码<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 分区过程</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> arr   待分区数组</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> left  待分区数组最小下标</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> right 待分区数组最大下标</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">			<span class="keyword">int</span> temp = qSort(arr, left, right);</span><br><span class="line">			quickSort(arr, left, temp - <span class="number">1</span>);</span><br><span class="line">			quickSort(arr, temp + <span class="number">1</span>, right);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 排序过程</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> arr   待排序数组</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> left  待排序数组最小下标</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> right 待排序数组最大下标</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 排好序之后基准数的位置下标，方便下次的分区</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">qSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 定义基准数，默认为数组的第一个元素</span></span><br><span class="line">		<span class="keyword">int</span> temp = arr[left];</span><br><span class="line">		<span class="comment">// 循环执行的条件</span></span><br><span class="line">		<span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">			<span class="comment">// 因为默认的基准数是在最左边，所以首先从右边开始比较进入while循环的判断条件</span></span><br><span class="line">			<span class="comment">// 如果当前arr[right]比基准数大，则直接将右指针左移一位，当然还要保证left&lt;right</span></span><br><span class="line">			<span class="keyword">while</span> (left &lt; right &amp;&amp; arr[right] &gt; temp) &#123;</span><br><span class="line">				right--;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 跳出循环说明当前的arr[right]比基准数要小，那么直接将当前数移动到基准数所在的位置，并且左指针向右移一位（left++）</span></span><br><span class="line">			<span class="comment">// 这时当前数（arr[right]）所在的位置空出，需要从左边找一个比基准数大的数来填充。</span></span><br><span class="line">			<span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">				arr[left++] = arr[right];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 下面的步骤是为了在左边找到比基准数大的数填充到right的位置。</span></span><br><span class="line">			<span class="comment">// 因为现在需要填充的位置在右边，所以左边的指针移动，如果arr[left]小于或者等于基准数，则直接将左指针右移一位</span></span><br><span class="line">			<span class="keyword">while</span> (left &lt; right &amp;&amp; arr[left] &lt;= temp) &#123;</span><br><span class="line">				left++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 跳出上一个循环说明当前的arr[left]的值大于基准数，需要将该值填充到右边空出的位置，然后当前位置空出。</span></span><br><span class="line">			<span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">				arr[right--] = arr[left];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 当循环结束说明左指针和右指针已经相遇。并且相遇的位置是一个空出的位置，</span></span><br><span class="line">		<span class="comment">// 这时候将基准数填入该位置，并返回该位置的下标，为分区做准备。</span></span><br><span class="line">		arr[left] = temp;</span><br><span class="line">		<span class="keyword">return</span> left;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><ul>
<li><p>基本思路<br>堆是一种特殊的完全二叉树，分为大顶堆和小顶堆。大顶堆：每个结点的值都大于它的左右子结点的值，升序排序用大顶堆。小顶堆：每个结点的值都小于它的左右子结点的值，降序排序用小顶堆。<br>所以，需要先将待排序数组构造成大顶堆的格式，这时候该堆的顶结点就是最大的数，将其与堆的最后一个结点的元素交换。再将剩余的树重新调整成堆，再次首节点与尾结点交换，重复执行直到只剩下最后一个结点完成排序。</p>
</li>
<li><p>动图演示</p>
</li>
</ul>
<p><img data-src="https://user-gold-cdn.xitu.io/2019/1/17/1685c01bbe480b52?imageslim" alt="这里写图片描述"></p>
<ul>
<li>编码<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (arr == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> len = arr.length;</span><br><span class="line">	<span class="comment">// 初始化大顶堆（从最后一个非叶节点开始，从左到右，由下到上）</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = len / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">		adjustHeap(arr, i, len);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 将顶节点和最后一个节点互换位置，再将剩下的堆进行调整</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = len - <span class="number">1</span>; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">		swap(arr, <span class="number">0</span>, j);</span><br><span class="line">		adjustHeap(arr, <span class="number">0</span>, j);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 整理树让其变成堆</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr 待整理的数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i   开始的结点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> j   数组的长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">adjustHeap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 定义一个变量保存开始的结点</span></span><br><span class="line">	<span class="keyword">int</span> temp = arr[i];</span><br><span class="line">	<span class="comment">// k就是该结点的左子结点下标</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">2</span> * i + <span class="number">1</span>; k &lt; j; k = <span class="number">2</span> * k + <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="comment">// 比较左右两个子结点的大小，k始终记录两者中较大值的下标</span></span><br><span class="line">		<span class="keyword">if</span> (k + <span class="number">1</span> &lt; j &amp;&amp; arr[k] &lt; arr[k + <span class="number">1</span>]) &#123;</span><br><span class="line">			k++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 经子结点中的较大值和当前的结点比较，比较结果的较大值放在当前结点位置</span></span><br><span class="line">		<span class="keyword">if</span> (arr[k] &gt; temp) &#123;</span><br><span class="line">			arr[i] = arr[k];</span><br><span class="line">			i = k;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 说明已经是大顶堆</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	arr[i] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 交换数据</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr  待整理的数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> num1 开始的结点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> num2 交换的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp = arr[num1];</span><br><span class="line">	arr[num1] = arr[num2];</span><br><span class="line">	arr[num2] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><ul>
<li><p>基本思路<br>就是将待排序数据拆分成多个关键字进行排序，也就是说，基数排序的实质是多关键字排序。多关键字排序的思路是将待排数据里德排序关键字拆分成多个排序关键字；第1个排序关键字，第2个排序关键字，第3个排序关键字……然后，根据子关键字对待排序数据进行排序。</p>
</li>
<li><p>动图演示</p>
</li>
</ul>
<p><img data-src="https://user-gold-cdn.xitu.io/2019/1/17/1685c01bd10a5893?imageslim" alt="这里写图片描述"></p>
<ul>
<li>编码<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> radix, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 缓存数组  </span></span><br><span class="line">		<span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">		<span class="comment">// buckets用于记录待排序元素的信息  </span></span><br><span class="line">		<span class="comment">// buckets数组定义了max-min个桶  </span></span><br><span class="line">		<span class="keyword">int</span>[] buckets = <span class="keyword">new</span> <span class="keyword">int</span>[radix];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, rate = <span class="number">1</span>; i &lt; d; i++) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 重置count数组，开始统计下一个关键字  </span></span><br><span class="line">			java.util.Arrays.fill(buckets, <span class="number">0</span>);</span><br><span class="line">			<span class="comment">// 将data中的元素完全复制到tmp数组中  </span></span><br><span class="line">			System.arraycopy(arr, <span class="number">0</span>, tmp, <span class="number">0</span>, arr.length);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 计算每个待排序数据的子关键字  </span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">				<span class="keyword">int</span> subKey = (tmp[j] / rate) % radix;</span><br><span class="line">				buckets[subKey]++;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; radix; j++) &#123;</span><br><span class="line">				buckets[j] = buckets[j] + buckets[j - <span class="number">1</span>];</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 按子关键字对指定的数据进行排序  </span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> m = arr.length - <span class="number">1</span>; m &gt;= <span class="number">0</span>; m--) &#123;</span><br><span class="line">				<span class="keyword">int</span> subKey = (tmp[m] / rate) % radix;</span><br><span class="line">				arr[--buckets[subKey]] = tmp[m];</span><br><span class="line">			&#125;</span><br><span class="line">			rate *= radix;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><ul>
<li><p>基本思路<br>计数排序采用了一种全新的思路，不再是通过比较来排序，而是将待排序数组中的最大值+1作为一个临时数组的长度，然后用临时数组记录待排序数组中每个元素出现的次数。最后再遍历临时数组，因为是升序，所以从前到后遍历，将临时数组中值&gt;0的数的下标循环取出，依次放入待排序数组中，即可完成排序。计数排序的效率很高，但是实在牺牲内存的前提下，并且有着限制，那就是待排序数组的值必须 限制在一个确定的范围。</p>
</li>
<li><p>动图演示</p>
</li>
</ul>
<p><img data-src="https://user-gold-cdn.xitu.io/2019/1/17/1685c01bbf2b9faf?imageslim" alt="这里写图片描述"></p>
<ul>
<li>编码<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (arr == <span class="keyword">null</span>)</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">int</span> len = arr.length;</span><br><span class="line">		<span class="comment">// 保存待排序数组中的最大值，目的是确定临时数组的长度（必须）</span></span><br><span class="line">		<span class="keyword">int</span> maxNum = arr[<span class="number">0</span>];</span><br><span class="line">		<span class="comment">// 保存待排序数组中的最小值，目的是确定最终遍历临时数组时下标的初始值（非必需，只是这样可以加快速度，减少循环次数）</span></span><br><span class="line">		<span class="keyword">int</span> minNum = arr[<span class="number">0</span>];</span><br><span class="line">		<span class="comment">// for循环就是为了找到待排序数组的最大值和最小值</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">			maxNum = maxNum &gt; arr[i] ? maxNum : arr[i];</span><br><span class="line">			minNum = minNum &lt; arr[i] ? minNum : arr[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 创建一个临时数组</span></span><br><span class="line">		<span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[maxNum + <span class="number">1</span>];</span><br><span class="line">		<span class="comment">// for循环是为了记录待排序数组中每个元素出现的次数，并将该次数保存到临时数组中</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> anArr : arr) &#123;</span><br><span class="line">			temp[anArr]++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// k=0用来记录待排序数组的下标</span></span><br><span class="line">		<span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">// 遍历临时数组，重新为待排序数组赋值。</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = minNum; i &lt; temp.length; i++) &#123;</span><br><span class="line">			<span class="keyword">while</span> (temp[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				arr[k++] = i;</span><br><span class="line">				temp[i]--;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><ul>
<li><p>基本思路<br>桶排序其实就是计数排序的强化版，需要利用一个映射函数首先定义有限个数个桶，然后将待排序数组内的元素按照函数映射的关系分别放入不同的桶里边，现在不同的桶里边的数据已经做了区分，比如A桶里的数要么全部大于B桶，要么全部小于B桶里的数。但是A，B桶各自里边的数还是乱序的。所以要借助其他排序方式（快速，插入，归并）分别对每一个元素个数大于一的桶里边的数据进行排序。最后再将桶里边的元素按照顺序依次放入待排序数组中即可。</p>
</li>
<li><p>动图演示<br>无。。。。。</p>
</li>
<li><p>编码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (arr == <span class="keyword">null</span>)</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">int</span> len = arr.length;</span><br><span class="line">		<span class="comment">// 定义桶的个数，这里k的值要视情况而定，这里我们假设待排序数组里的数都是[0,100)之间的。</span></span><br><span class="line">		<span class="keyword">int</span> k = <span class="number">10</span>;</span><br><span class="line">		<span class="comment">// 用嵌套集合来模拟桶，外层集合表示桶，内层集合表示桶里边装的元素。</span></span><br><span class="line">		java.util.List&lt;java.util.List&lt;Integer&gt;&gt; bucket = <span class="keyword">new</span> java.util.ArrayList&lt;&gt;();</span><br><span class="line">		<span class="comment">// for循环初始化外层集合即初始化桶</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">			bucket.add(<span class="keyword">new</span> java.util.ArrayList&lt;&gt;());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 循环是为了将待排序数组中的元素通过映射函数分别放入不同的桶里边</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> anArr : arr) &#123;</span><br><span class="line">			bucket.get(anArr / <span class="number">10</span>).add(anArr);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 这个循环是为了将所有的元素个数大于1的桶里边的数据进行排序。</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (bucket.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">				<span class="comment">// 因为这里是用集合来模拟的桶所以用java写好的对集合排序的方法。</span></span><br><span class="line">				<span class="comment">// 其实应该自己写一个方法来排序的。</span></span><br><span class="line">				java.util.Collections.sort(bucket.get(i));</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 将排好序的数重新放入待排序数组中</span></span><br><span class="line">		<span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (java.util.List&lt;Integer&gt; list : bucket) &#123;</span><br><span class="line">			<span class="keyword">if</span> (list.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">for</span> (Integer a : list) &#123;</span><br><span class="line">					arr[m++] = a;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>little_eight</tag>
      </tags>
  </entry>
  <entry>
    <title>java.util.HashMap类解析</title>
    <url>/2019/04/16/java-util-HashMap%E7%B1%BB%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h2 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h2><p>Hash表也称为散列表，也有直接译作哈希表，Hash表是一种根据关键字值（key-value）而直接进行访问的数据结构。也就是说它通过把关键码值映射到表中的一个位置来访问记录，以此来加快查找的速度。在链表、数组等数据结构中，查找某个关键字，通常要遍历整个数据结构，也就是O(N)的时间级，但是对于哈希表来说，只是O(1)的时间级。（更多知识自行百度Google）</p>
<p>HashMap是一个利用哈希表原理来存储元素的无序不安全键值都可为空的集合。遇到冲突时，HashMap 是采用的链地址法来解决，在 JDK1.7 中，HashMap 是由 数组+链表构成的。但是在JDK1.8中，HashMap是由数组+链表+红黑树构成，新增了红黑树作为底层数据结构，结构变得复杂了，但是效率也变的更高效。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 继承 AbstractMap</span><br><span class="line"> *          AbstractMap也是实现了Map类的，既继承AbstractMap又实现Map，脱裤子放屁....</span><br><span class="line"> * 实现 Map 接口</span><br><span class="line"> *          这个接口是 Map 类集合的上层接口，定义了实现该接口的类都必须要实现的一组方法</span><br><span class="line"> * 实现 Cloneable 接口</span><br><span class="line"> *          这个类是 java.lang.Cloneable，前面我们讲解深拷贝和浅拷贝的原理时，</span><br><span class="line"> *          我们介绍了浅拷贝可以通过调用 Object.clone() 方法来实现，</span><br><span class="line"> *          但是调用该方法的对象必须要实现 Cloneable 接口，</span><br><span class="line"> *          否则会抛出 CloneNoSupportException异常。</span><br><span class="line"> * 实现 Serializable 接口</span><br><span class="line"> *          序列化</span><br><span class="line"> */</span><br><span class="line">public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;</span><br><span class="line">    implements Map&lt;K,V&gt;, Cloneable, Serializable &#123;&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">    * 初始容量为16，容量都必须是偶数</span><br><span class="line">    */</span><br><span class="line">   static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * 集合的最大容量，如果通过带参构造指定的最大容量超过此数，默认还是使用此数</span><br><span class="line">    */</span><br><span class="line">   static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * 默认的填充因子</span><br><span class="line">    */</span><br><span class="line">   static final float DEFAULT_LOAD_FACTOR = 0.75f;</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * 当桶(bucket)上的结点数大于这个值时会转成红黑树</span><br><span class="line">    */</span><br><span class="line">   static final int TREEIFY_THRESHOLD = 8;</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * 当桶(bucket)上的节点数小于这个值时会转成链表</span><br><span class="line">    */</span><br><span class="line">   static final int UNTREEIFY_THRESHOLD = 6;</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * 当集合中的容量大于这个值时，表中的桶才能进行树形化 ，否则桶内元素太多时会扩容，</span><br><span class="line">    * 而不是树形化 为了避免进行扩容、树形化选择的冲突，这个值不能小于 4 * TREEIFY_THRESHOLD</span><br><span class="line">    */</span><br><span class="line">   static final int MIN_TREEIFY_CAPACITY = 64;</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * 存链表的数组，初始化使用，长度总是 2的幂</span><br><span class="line">    */</span><br><span class="line">   transient Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * 保存缓存的entrySet（）</span><br><span class="line">    */</span><br><span class="line">   transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * 此映射中包含的键值映射的数量。（集合存储键值对的数量）</span><br><span class="line">    */</span><br><span class="line">   transient int size;</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * 跟前面ArrayList和LinkedList集合中的字段modCount一样，记录集合被修改的次数</span><br><span class="line">    * 主要用于迭代器中的快速失败</span><br><span class="line">    */</span><br><span class="line">   transient int modCount;</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * 调整大小的下一个大小值（容量*加载因子）,相当于阈值。计算公式：capacity * loadFactor。</span><br><span class="line">    * 这个值是当前已占用数组长度的最大值。过这个数目就重新resize(扩容)，</span><br><span class="line">    * 扩容后的 HashMap 容量是之前容量的两倍</span><br><span class="line">    */</span><br><span class="line">   int threshold;</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * 散列表的加载因子，是用来衡量HashMap满的程度，</span><br><span class="line">    * 计算HashMap的实时装载因子的方法为：size/capacity，而不是占用桶的数量去除以capacity。</span><br><span class="line">    * capacity 是桶的数量，也就是 table 的长度length。</span><br><span class="line">    */</span><br><span class="line">   final float loadFactor;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 链表的类</span><br><span class="line"> */</span><br><span class="line">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    // hash值</span><br><span class="line">    final int hash;</span><br><span class="line">    final K key;</span><br><span class="line">    V value;</span><br><span class="line">    // 下一个链表</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        this.hash = hash;</span><br><span class="line">        this.key = key;</span><br><span class="line">        this.value = value;</span><br><span class="line">        this.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final K getKey()        &#123; return key; &#125;</span><br><span class="line">    public final V getValue()      &#123; return value; &#125;</span><br><span class="line">    public final String toString() &#123; return key + &quot;=&quot; + value; &#125;</span><br><span class="line"></span><br><span class="line">    public final int hashCode() &#123;</span><br><span class="line">        return Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final V setValue(V newValue) &#123;</span><br><span class="line">        V oldValue = value;</span><br><span class="line">        value = newValue;</span><br><span class="line">        return oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final boolean equals(Object o) &#123;</span><br><span class="line">        if (o == this)</span><br><span class="line">            return true;</span><br><span class="line">        if (o instanceof Map.Entry) &#123;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">            if (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                Objects.equals(value, e.getValue()))</span><br><span class="line">                return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 默认构造函数，初始化加载因子loadFactor = 0.75</span><br><span class="line"> */</span><br><span class="line">public HashMap() &#123;</span><br><span class="line">    this.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 指定容量，实现看下一个方法</span><br><span class="line"> */</span><br><span class="line">public HashMap(int initialCapacity) &#123;</span><br><span class="line">    this(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 指定Map集合构造函数。</span><br><span class="line"> */</span><br><span class="line">public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123;</span><br><span class="line">    this.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    // 就是把这个集合put进去，后面再详细说</span><br><span class="line">    putMapEntries(m, false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 指定容量和加载因子</span><br><span class="line"> */</span><br><span class="line">public HashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">    if (initialCapacity &lt; 0)</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    // 最大容量只会设置为MAXIMUM_CAPACITY                                       </span><br><span class="line">    if (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    this.loadFactor = loadFactor;</span><br><span class="line">    // 调整下一个扩容值</span><br><span class="line">    this.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 返回给定目标容量的二次幂，</span><br><span class="line">     * | 位或运算</span><br><span class="line">     */</span><br><span class="line">  static final int tableSizeFor(int cap) &#123;</span><br><span class="line">    int n = cap - 1;</span><br><span class="line">    // 也就是 n = n | n &gt;&gt;&gt; xx</span><br><span class="line">    n |= n &gt;&gt;&gt; 1;</span><br><span class="line">    n |= n &gt;&gt;&gt; 2;</span><br><span class="line">    n |= n &gt;&gt;&gt; 4;</span><br><span class="line">    n |= n &gt;&gt;&gt; 8;</span><br><span class="line">    n |= n &gt;&gt;&gt; 16;</span><br><span class="line">    return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>位或运算  （|）<br>0|0=0；   0|1=1；   1|0=1；    1|1=1<br>即：两位只要有一个为1，其值为1，其它都为0。<br>扩展：异或运算符（^），后面计算hash值用到<br>0^0=0；  0^1=1；  1^0=1；   1^1=0；<br>即：参加运算的两个对象，如果两个相应位为“异”（值不同），则该位结果为1，否则为0。<br>扩展：位与运算（&amp;），后面的取模运算用到<br>0&amp;0=0;   0&amp;1=0;    1&amp;0=0;     1&amp;1=1<br>即：两位同时为1，结果才为1，否则为0。</p>
</blockquote>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="capacity"><a href="#capacity" class="headerlink" title="capacity"></a>capacity</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  返回当前容量</span><br><span class="line"> */</span><br><span class="line">final int capacity() &#123;</span><br><span class="line">    return (table != null) ? table.length :</span><br><span class="line">        (threshold &gt; 0) ? threshold :</span><br><span class="line">        DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 把所有链表都设置为null，清空hashMap</span><br><span class="line"> */</span><br><span class="line">public void clear() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab;</span><br><span class="line">    modCount++;</span><br><span class="line">    if ((tab = table) != null &amp;&amp; size &gt; 0) &#123;</span><br><span class="line">        size = 0;</span><br><span class="line">        for (int i = 0; i &lt; tab.length; ++i)</span><br><span class="line">            tab[i] = null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 浅拷贝</span><br><span class="line"> */</span><br><span class="line">    public Object clone() &#123;</span><br><span class="line">    HashMap&lt;K,V&gt; result;</span><br><span class="line">    try &#123;</span><br><span class="line">        result = (HashMap&lt;K,V&gt;)super.clone();</span><br><span class="line">    &#125; catch (CloneNotSupportedException e) &#123;</span><br><span class="line">        // this shouldn&#x27;t happen, since we are Cloneable</span><br><span class="line">        throw new InternalError(e);</span><br><span class="line">    &#125;</span><br><span class="line">    // 把关键成员变量都设置成null</span><br><span class="line">    result.reinitialize();</span><br><span class="line">    result.putMapEntries(this, false);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="containsKey"><a href="#containsKey" class="headerlink" title="containsKey"></a>containsKey</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 判断是否包含此key</span><br><span class="line"> */</span><br><span class="line">public boolean containsKey(Object key) &#123;</span><br><span class="line">    // 下面再详细说getNode</span><br><span class="line">    return getNode(hash(key), key) != null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="entrySet"><a href="#entrySet" class="headerlink" title="entrySet"></a>entrySet</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 返回this.entrySet，没有就new一个</span><br><span class="line"> */</span><br><span class="line">public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;</span><br><span class="line">    Set&lt;Map.Entry&lt;K,V&gt;&gt; es;</span><br><span class="line">    return (es = entrySet) == null ? (entrySet = new EntrySet()) : es;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 内部EntrySet类</span><br><span class="line"> */</span><br><span class="line">final class  extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; &#123;</span><br><span class="line">    public final int size()                 &#123; return size; &#125;</span><br><span class="line">    public final void clear()               &#123; HashMap.this.clear(); &#125;</span><br><span class="line">    public final Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123;</span><br><span class="line">        return new EntryIterator();</span><br><span class="line">    &#125;</span><br><span class="line">    public final boolean contains(Object o) &#123;</span><br><span class="line">        if (!(o instanceof Map.Entry))</span><br><span class="line">            return false;</span><br><span class="line">        Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;</span><br><span class="line">        Object key = e.getKey();</span><br><span class="line">        Node&lt;K,V&gt; candidate = getNode(hash(key), key);</span><br><span class="line">        return candidate != null &amp;&amp; candidate.equals(e);</span><br><span class="line">    &#125;</span><br><span class="line">    public final boolean remove(Object o) &#123;</span><br><span class="line">        if (o instanceof Map.Entry) &#123;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;</span><br><span class="line">            Object key = e.getKey();</span><br><span class="line">            Object value = e.getValue();</span><br><span class="line">            return removeNode(hash(key), key, value, true, true) != null;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    public final Spliterator&lt;Map.Entry&lt;K,V&gt;&gt; spliterator() &#123;</span><br><span class="line">        return new EntrySpliterator&lt;&gt;(HashMap.this, 0, -1, 0, 0);</span><br><span class="line">    &#125;</span><br><span class="line">    public final void forEach(Consumer&lt;? super Map.Entry&lt;K,V&gt;&gt; action) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab;</span><br><span class="line">        if (action == null)</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        if (size &gt; 0 &amp;&amp; (tab = table) != null) &#123;</span><br><span class="line">            int mc = modCount;</span><br><span class="line">            for (int i = 0; i &lt; tab.length; ++i) &#123;</span><br><span class="line">                for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next)</span><br><span class="line">                    action.accept(e);</span><br><span class="line">            &#125;</span><br><span class="line">            if (modCount != mc)</span><br><span class="line">                throw new ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="get、getNode、getOrDefault"><a href="#get、getNode、getOrDefault" class="headerlink" title="get、getNode、getOrDefault"></a>get、getNode、getOrDefault</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 根据key返回value</span><br><span class="line"> */</span><br><span class="line">public V get(Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    return (e = getNode(hash(key), key)) == null ? null : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 获取对应链表</span><br><span class="line"> */</span><br><span class="line">final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;</span><br><span class="line">    // 数组不为空，且hash对应的链表头也不为空</span><br><span class="line">    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">        (first = tab[(n - 1) &amp; hash]) != null) &#123;</span><br><span class="line">        // 校验是否是链表头的，不是的话，就next遍历下去找到对应的链表</span><br><span class="line">        if (first.hash == hash &amp;&amp; // always check first node</span><br><span class="line">            ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">            return first;</span><br><span class="line">        if ((e = first.next) != null) &#123;</span><br><span class="line">            // 如果是红黑树，就去getTreeNode，红黑树的部分看最后面TreeNode类解析</span><br><span class="line">            if (first instanceof TreeNode)</span><br><span class="line">                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            do &#123;</span><br><span class="line">                if (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                    return e;</span><br><span class="line">            &#125; while ((e = e.next) != null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 如果取到的链表为null，则返回设定的defaultValue，否则就返回链表的value</span><br><span class="line"> */</span><br><span class="line">public V getOrDefault(Object key, V defaultValue，) &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    return (e = getNode(hash(key), key)) == null ? defaultValue : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>取模运算 (n - 1) &amp; hash ，在计算机中 &amp; 的效率比 % 高很多，所以采用&amp;<br>且有这么一条结论，当 lenth = 2n 时，X % length = X &amp; (length - 1)<br>具体可以去看下这篇博客分析<a href="https://blog.csdn.net/ysvae/article/details/81090894">https://blog.csdn.net/ysvae/article/details/81090894</a></p>
</blockquote>
<h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 获取hash值，</span><br><span class="line"> * (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)，这段代码叫“扰动函数”，具体可以看这篇博客解析</span><br><span class="line"> * https://www.cnblogs.com/zhengwang/p/8136164.html</span><br><span class="line"> */</span><br><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">    int h;</span><br><span class="line">    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="isEmpty"><a href="#isEmpty" class="headerlink" title="isEmpty"></a>isEmpty</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 根据size判断集合是否为空</span><br><span class="line"> */</span><br><span class="line">public boolean isEmpty() &#123;</span><br><span class="line">    return size == 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="keySet"><a href="#keySet" class="headerlink" title="keySet"></a>keySet</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 返回所有key的Set集合</span><br><span class="line"> */</span><br><span class="line">public Set&lt;K&gt; keySet() &#123;</span><br><span class="line">    Set&lt;K&gt; ks = keySet;</span><br><span class="line">    if (ks == null) &#123;</span><br><span class="line">        ks = new KeySet();</span><br><span class="line">        keySet = ks;</span><br><span class="line">    &#125;</span><br><span class="line">    return ks;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 内部KeySet类</span><br><span class="line"> */</span><br><span class="line">final class KeySet extends AbstractSet&lt;K&gt; &#123;</span><br><span class="line">    public final int size()                 &#123; return size; &#125;</span><br><span class="line">    public final void clear()               &#123; HashMap.this.clear(); &#125;</span><br><span class="line">    public final Iterator&lt;K&gt; iterator()     &#123; return new KeyIterator(); &#125;</span><br><span class="line">    public final boolean contains(Object o) &#123; return containsKey(o); &#125;</span><br><span class="line">    public final boolean remove(Object key) &#123;</span><br><span class="line">        return removeNode(hash(key), key, null, false, true) != null;</span><br><span class="line">    &#125;</span><br><span class="line">    public final Spliterator&lt;K&gt; spliterator() &#123;</span><br><span class="line">        return new KeySpliterator&lt;&gt;(HashMap.this, 0, -1, 0, 0);</span><br><span class="line">    &#125;</span><br><span class="line">    public final void forEach(Consumer&lt;? super K&gt; action) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab;</span><br><span class="line">        if (action == null)</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        if (size &gt; 0 &amp;&amp; (tab = table) != null) &#123;</span><br><span class="line">            int mc = modCount;</span><br><span class="line">            for (int i = 0; i &lt; tab.length; ++i) &#123;</span><br><span class="line">                for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next)</span><br><span class="line">                    action.accept(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            if (modCount != mc)</span><br><span class="line">                throw new ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<h3 id="put、putIfAbsent、putVal"><a href="#put、putIfAbsent、putVal" class="headerlink" title="put、putIfAbsent、putVal"></a>put、putIfAbsent、putVal</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 设值</span><br><span class="line"> */</span><br><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    return putVal(hash(key), key, value, false, true);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 如果存在此key的值，那就不设值用原值</span><br><span class="line"> */</span><br><span class="line">public V putIfAbsent(K key, V value) &#123;</span><br><span class="line">    return putVal(hash(key), key, value, true, true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 设值</span><br><span class="line"> * @param onlyIfAbsent 为true，就不改动原值</span><br><span class="line"> * @param evict 如果为false，则表处于创建模式</span><br><span class="line"> */</span><br><span class="line">   final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">               boolean evict) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">    // 如果数组为null，也就是第一次put值，就resize进行扩容，这个方法后面再讲</span><br><span class="line">    if ((tab = table) == null || (n = tab.length) == 0)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    // 在数组中这个下标下如果这个链表为null，就根据传进的参数新建一个给它，也就是新建成链表头</span><br><span class="line">    if ((p = tab[i = (n - 1) &amp; hash]) == null)</span><br><span class="line">        tab[i] = newNode(hash, key, value, null);</span><br><span class="line">    else &#123;</span><br><span class="line">        // 链表头不为null，e、k会当做循环这条链表的暂时值</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        // 如果刚好就是链表头，那就是e等于链表头</span><br><span class="line">        if (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        // 红黑树的部分看TreeNode类解析</span><br><span class="line">        else if (p instanceof TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">        else &#123;</span><br><span class="line">            // 循环这条链表</span><br><span class="line">            for (int binCount = 0; ; ++binCount) &#123;</span><br><span class="line">                // next==null说明到链表尾了</span><br><span class="line">                if ((e = p.next) == null) &#123;</span><br><span class="line">                    // 根据参数新建一个链表，作为链表尾</span><br><span class="line">                    p.next = newNode(hash, key, value, null);</span><br><span class="line">                    // 如果链表长度不小于TREEIFY_THRESHOLD（8），就转换成红黑树</span><br><span class="line">                    if (binCount &gt;= TREEIFY_THRESHOLD - 1)</span><br><span class="line">                        // 如何转换的，这个后面再详解</span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                // 如果在循环过程中发现存在此key，那就不用新建链表尾了</span><br><span class="line">                if (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                    break;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果设值的key是已存在的</span><br><span class="line">        if (e != null) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            // onlyIfAbsent为false，或者原值等于null，就设置成传入参数的value</span><br><span class="line">            if (!onlyIfAbsent || oldValue == null)</span><br><span class="line">                e.value = value;</span><br><span class="line">            // 这里是空方法，在LinkedHashMap才会实现</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            // 返回的旧值哦</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    // 超过最大容量，进行扩容</span><br><span class="line">    if (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    // 这里是空方法，在LinkedHashMap才会实现</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="remove、removeNode"><a href="#remove、removeNode" class="headerlink" title="remove、removeNode"></a>remove、removeNode</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 移除某个对应的值（链表），返回对应的value，没的话就返回null</span><br><span class="line"> */</span><br><span class="line">public V remove(Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    return (e = removeNode(hash(key), key, null, false, true)) == null ?</span><br><span class="line">        null : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 移除某个对应的值（链表），有对应的value就返回true，没的话就返回false</span><br><span class="line"> */</span><br><span class="line">public boolean remove(Object key, Object value) &#123;</span><br><span class="line">    return removeNode(hash(key), key, value, true, true) != null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 移除某个对应的值（链表）</span><br><span class="line"> * @param matchValue 为true时，进行移除</span><br><span class="line"> * @param movable 如果为false，则在删除时不要移动其他节点</span><br><span class="line"> */</span><br><span class="line">final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value,</span><br><span class="line">                           boolean matchValue, boolean movable) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index;</span><br><span class="line">    // 数组不为空，且hash对应的链表头也不为空</span><br><span class="line">    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - 1) &amp; hash]) != null) &#123;</span><br><span class="line">        Node&lt;K,V&gt; node = null, e; K k; V v;</span><br><span class="line">        // 这里就是为了得到key对应的链表node</span><br><span class="line">        if (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">            node = p;</span><br><span class="line">        else if ((e = p.next) != null) &#123;</span><br><span class="line">            if (p instanceof TreeNode)</span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            else &#123;</span><br><span class="line">                do &#123;</span><br><span class="line">                    if (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                         (key != null &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125; while ((e = e.next) != null);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 是否符合移除该node的条件</span><br><span class="line">        if (node != null &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                             (value != null &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            // 如果是红黑树，就去TreeNode的方法处理</span><br><span class="line">            if (node instanceof TreeNode)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable);</span><br><span class="line">            // 两者相等，说明node刚好是链表头，直接等于next即可</span><br><span class="line">            else if (node == p)</span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            else</span><br><span class="line">                // 不是链表头，改p的next，相当于移除下一位的node</span><br><span class="line">                p.next = node.next;</span><br><span class="line">            ++modCount;</span><br><span class="line">            --size;</span><br><span class="line">            // 这里是空方法，在LinkedHashMap才会实现</span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            return node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="replace、replaceAll"><a href="#replace、replaceAll" class="headerlink" title="replace、replaceAll"></a>replace、replaceAll</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 根据key替换对应value，返回旧值</span><br><span class="line"> */</span><br><span class="line">public V replace(K key, V value) &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    if ((e = getNode(hash(key), key)) != null) &#123;</span><br><span class="line">        V oldValue = e.value;</span><br><span class="line">        e.value = value;</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">        return oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 根据key，newValue替换旧值</span><br><span class="line"> * 当旧值等于oldValue时，才会去替换，否则返回false</span><br><span class="line"> */</span><br><span class="line">public boolean replace(K key, V oldValue, V newValue) &#123;</span><br><span class="line">    Node&lt;K,V&gt; e; V v;</span><br><span class="line">    if ((e = getNode(hash(key), key)) != null &amp;&amp;</span><br><span class="line">        ((v = e.value) == oldValue || (v != null &amp;&amp; v.equals(oldValue)))) &#123;</span><br><span class="line">        e.value = newValue;</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 这个不常用，不解析了..</span><br><span class="line"> */</span><br><span class="line">public void replaceAll(BiFunction&lt;? super K, ? super V, ? extends V&gt; function) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab;</span><br><span class="line">    if (function == null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    if (size &gt; 0 &amp;&amp; (tab = table) != null) &#123;</span><br><span class="line">        int mc = modCount;</span><br><span class="line">        for (int i = 0; i &lt; tab.length; ++i) &#123;</span><br><span class="line">            for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) &#123;</span><br><span class="line">                e.value = function.apply(e.key, e.value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (modCount != mc)</span><br><span class="line">            throw new ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="resize"><a href="#resize" class="headerlink" title="resize"></a>resize</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 扩容</span><br><span class="line"> */</span><br><span class="line">final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    // 原数组的长度，也就是旧容量</span><br><span class="line">    int oldCap = (oldTab == null) ? 0 : oldTab.length;</span><br><span class="line">    // 旧阀值</span><br><span class="line">    int oldThr = threshold;</span><br><span class="line">    // 新容量、新阀值</span><br><span class="line">    int newCap, newThr = 0;</span><br><span class="line">    if (oldCap &gt; 0) &#123;</span><br><span class="line">        // 如果原数组已经是最大了，就不扩容了，返回原数组</span><br><span class="line">        if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            // 修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            return oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        // 否则就扩容一倍</span><br><span class="line">        else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; 1;</span><br><span class="line">    &#125;</span><br><span class="line">    // 旧阀值大于0，则将新容量直接等于就阀值 </span><br><span class="line">    else if (oldThr &gt; 0)</span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    // 旧容量、旧阀值都为0，也就是未初始化，就设置新容量、新阀值为默认值</span><br><span class="line">    else &#123;               </span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果新阀值为0，计算新的阀值上限</span><br><span class="line">    if (newThr == 0) &#123;</span><br><span class="line">        float ft = (float)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (int)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class="line">        // 新建扩容一倍的新数组</span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    if (oldTab != null) &#123;</span><br><span class="line">        // 遍历旧数组，把它们的链表搬到新数组</span><br><span class="line">        for (int j = 0; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            if ((e = oldTab[j]) != null) &#123;</span><br><span class="line">                // 便于gc回收</span><br><span class="line">                oldTab[j] = null;</span><br><span class="line">                // 这条链表只有一个链表头</span><br><span class="line">                if (e.next == null)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - 1)] = e;</span><br><span class="line">                // 是红黑树，就红黑树处理</span><br><span class="line">                else if (e instanceof TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</span><br><span class="line">                // 遍历链表条</span><br><span class="line">                else &#123;</span><br><span class="line">                    // loHead - loTail、hiHead - hiTail，分别对应 链表头 - 链表尾</span><br><span class="line">                    // 这样作为暂时值处理，得到链表尾</span><br><span class="line">                    Node&lt;K,V&gt; loHead = null, loTail = null;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = null, hiTail = null;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    do &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        // 原索引（没懂。。）</span><br><span class="line">                        if ((e.hash &amp; oldCap) == 0) &#123;</span><br><span class="line">                            if (loTail == null)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            else</span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        else &#123;</span><br><span class="line">                            if (hiTail == null)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            else</span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; while ((e = next) != null);</span><br><span class="line">                    // loTail链表尾不为null，</span><br><span class="line">                    // 就设链表头尾到新数组对应的下标（也就是转移对应的链表条）</span><br><span class="line">                    if (loTail != null) &#123;</span><br><span class="line">                        loTail.next = null;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    // hiTail链表尾不为null，</span><br><span class="line">                    // 就设链表头尾到新数组对应的下标（也就是转移对应的链表条）</span><br><span class="line">                    if (hiTail != null) &#123;</span><br><span class="line">                        hiTail.next = null;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="values"><a href="#values" class="headerlink" title="values"></a>values</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 返回所有value值的Collection集合，（莫名奇妙就有了这个值。。。）</span><br><span class="line"> */</span><br><span class="line">public Collection&lt;V&gt; values() &#123;</span><br><span class="line">    Collection&lt;V&gt; vs = values;</span><br><span class="line">    if (vs == null) &#123;</span><br><span class="line">        vs = new Values();</span><br><span class="line">        values = vs;</span><br><span class="line">    &#125;</span><br><span class="line">    return vs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="TreeNode"><a href="#TreeNode" class="headerlink" title="TreeNode"></a>TreeNode</h2><p>比较特殊，专门来讲的红黑树类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>然后看下LinkedHashMap.Entry&lt;K,V&gt;类，居然是继承回HashMap的Node类。。有点意思</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="基本知识-1"><a href="#基本知识-1" class="headerlink" title="基本知识"></a>基本知识</h3><p>红黑树的概念</p>
<ul>
<li>每个结点都是红色的或者是黑色的</li>
<li>根结点是黑色的</li>
<li>每个叶结点NIL是黑色的，但是通常我们不考虑NIL叶结点。</li>
<li>如果一个结点是红色的，它的两个子结点都是黑色的</li>
<li>每个结点到其他所有后代叶结点的简单路径上，均包含相同数目的黑色结点，这个属性被称为黑高，记作bh(x)</li>
</ul>
<h3 id="成员变量-1"><a href="#成员变量-1" class="headerlink" title="成员变量"></a>成员变量</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 父节点</span><br><span class="line">TreeNode&lt;K,V&gt; parent;</span><br><span class="line">// 左子节点</span><br><span class="line">TreeNode&lt;K,V&gt; left;</span><br><span class="line">// 右子节点</span><br><span class="line">TreeNode&lt;K,V&gt; right;</span><br><span class="line">// 前方节点</span><br><span class="line">TreeNode&lt;K,V&gt; prev;</span><br><span class="line">// 是否红色</span><br><span class="line">boolean red;</span><br></pre></td></tr></table></figure>

<h3 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 就是用HashMap.Node的构造函数</span><br><span class="line"> */</span><br><span class="line">TreeNode(int hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">    super(hash, key, val, next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里解析的方法从HashMap的get、put等入手</p>
<h3 id="getTreeNode"><a href="#getTreeNode" class="headerlink" title="getTreeNode"></a>getTreeNode</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 得到对应的节点</span><br><span class="line"> */</span><br><span class="line">final TreeNode&lt;K,V&gt; getTreeNode(int h, Object k) &#123;</span><br><span class="line">    return ((parent != null) ? root() : this).find(h, k, null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="root"><a href="#root" class="headerlink" title="root"></a>root</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 返回根节点</span><br><span class="line"> */</span><br><span class="line"> final TreeNode&lt;K,V&gt; root() &#123;</span><br><span class="line">        for (TreeNode&lt;K,V&gt; r = this, p;;) &#123;</span><br><span class="line">            if ((p = r.parent) == null)</span><br><span class="line">                return r;</span><br><span class="line">            r = p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 从根结点p开始根据hash和key值寻找指定的结点。二叉树的查找</span><br><span class="line"> */</span><br><span class="line">  final TreeNode&lt;K,V&gt; find(int h, Object k, Class&lt;?&gt; kc) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; p = this;</span><br><span class="line">        // 遍历红黑树</span><br><span class="line">        do &#123;</span><br><span class="line">            int ph, dir; K pk;</span><br><span class="line">            TreeNode&lt;K,V&gt; pl = p.left, pr = p.right, q;</span><br><span class="line">            // p.hash大于参数hash时，移向左子树</span><br><span class="line">            if ((ph = p.hash) &gt; h)</span><br><span class="line">                p = pl;</span><br><span class="line">            // p.hash小于参数hash时，移向右子树</span><br><span class="line">            else if (ph &lt; h)</span><br><span class="line">                p = pr;</span><br><span class="line">            // p.hash等于参数hash，且参数k也等于p.key，返回这个p，也就是根节点</span><br><span class="line">            else if ((pk = p.key) == k || (k != null &amp;&amp; k.equals(pk)))</span><br><span class="line">                return p;</span><br><span class="line">            // 若hash相等但key不等，向左右子树非空的一侧移动</span><br><span class="line">            else if (pl == null)</span><br><span class="line">                p = pr;</span><br><span class="line">            else if (pr == null)</span><br><span class="line">                p = pl;</span><br><span class="line">            else if ((kc != null ||</span><br><span class="line">                      (kc = comparableClassFor(k)) != null) &amp;&amp; // kc是否是一个可比较的类</span><br><span class="line">                     (dir = compareComparables(kc, k, pk)) != 0)  // 比较k和p.key</span><br><span class="line">                p = (dir &lt; 0) ? pl : pr;</span><br><span class="line">            else if ((q = pr.find(h, k, kc)) != null)</span><br><span class="line">                return q;</span><br><span class="line">            else</span><br><span class="line">                p = pl;</span><br><span class="line">        &#125; while (p != null);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="putTreeVal"><a href="#putTreeVal" class="headerlink" title="putTreeVal"></a>putTreeVal</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  /**</span><br><span class="line">   * </span><br><span class="line">   */</span><br><span class="line">final TreeNode&lt;K,V&gt; putTreeVal(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span><br><span class="line">                                     int h, K k, V v) &#123;</span><br><span class="line">          Class&lt;?&gt; kc = null;</span><br><span class="line">          boolean searched = false;</span><br><span class="line">          // 根节点</span><br><span class="line">          TreeNode&lt;K,V&gt; root = (parent != null) ? root() : this;</span><br><span class="line">          // </span><br><span class="line">          for (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">              int dir, ph; K pk;</span><br><span class="line">              if ((ph = p.hash) &gt; h)</span><br><span class="line">                  dir = -1;</span><br><span class="line">              else if (ph &lt; h)</span><br><span class="line">                  dir = 1;</span><br><span class="line">              else if ((pk = p.key) == k || (k != null &amp;&amp; k.equals(pk)))</span><br><span class="line">                  return p;</span><br><span class="line">              else if ((kc == null &amp;&amp;</span><br><span class="line">                        (kc = comparableClassFor(k)) == null) ||</span><br><span class="line">                       (dir = compareComparables(kc, k, pk)) == 0) &#123;</span><br><span class="line">                  if (!searched) &#123;</span><br><span class="line">                      TreeNode&lt;K,V&gt; q, ch;</span><br><span class="line">                      searched = true;</span><br><span class="line">                      if (((ch = p.left) != null &amp;&amp;</span><br><span class="line">                           (q = ch.find(h, k, kc)) != null) ||</span><br><span class="line">                          ((ch = p.right) != null &amp;&amp;</span><br><span class="line">                           (q = ch.find(h, k, kc)) != null))</span><br><span class="line">                          return q;</span><br><span class="line">                  &#125;</span><br><span class="line">                  dir = tieBreakOrder(k, pk);</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">              if ((p = (dir &lt;= 0) ? p.left : p.right) == null) &#123;</span><br><span class="line">                  Node&lt;K,V&gt; xpn = xp.next;</span><br><span class="line">                  TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn);</span><br><span class="line">                  if (dir &lt;= 0)</span><br><span class="line">                      xp.left = x;</span><br><span class="line">                  else</span><br><span class="line">                      xp.right = x;</span><br><span class="line">                  xp.next = x;</span><br><span class="line">                  x.parent = x.prev = xp;</span><br><span class="line">                  if (xpn != null)</span><br><span class="line">                      ((TreeNode&lt;K,V&gt;)xpn).prev = x;</span><br><span class="line">                  moveRootToFront(tab, balanceInsertion(root, x));</span><br><span class="line">                  return null;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<h3 id="treeifyBin"><a href="#treeifyBin" class="headerlink" title="treeifyBin"></a>treeifyBin</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  /**</span><br><span class="line">   * 转换成红黑树，但其实只是链表转成TreeNode，里面的treeify（）才是对链表条转换成红黑树</span><br><span class="line">   */</span><br><span class="line">final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) &#123;</span><br><span class="line">      int n, index; Node&lt;K,V&gt; e;</span><br><span class="line">      // 数组为空，或者数组长度小于64，只扩容不转换</span><br><span class="line">      if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">          resize();</span><br><span class="line">      // 跳到该链表条的链表头，准备循环</span><br><span class="line">      else if ((e = tab[index = (n - 1) &amp; hash]) != null) &#123;</span><br><span class="line">          // 定义头尾节点，因为一直遍历，尾节点的值会一直变化</span><br><span class="line">          TreeNode&lt;K,V&gt; hd = null, tl = null;</span><br><span class="line">          do &#123;</span><br><span class="line">              // 这里replacementTreeNode就是new TreeNode&lt;&gt;(e.hash, e.key, e.value, null)</span><br><span class="line">              // p为当前节点</span><br><span class="line">              TreeNode&lt;K,V&gt; p = replacementTreeNode(e, null);</span><br><span class="line">              // 尾节点为null，说明是初始化阶段，把头节点=p</span><br><span class="line">              if (tl == null)</span><br><span class="line">                  hd = p;</span><br><span class="line">              // 尾节点不为null，设置p的prev（上一个节点）为尾节点，尾节点的next为p，</span><br><span class="line">              // 也就是把p接到当前暂时的尾节点后面</span><br><span class="line">              else &#123;</span><br><span class="line">                  p.prev = tl;</span><br><span class="line">                  tl.next = p;</span><br><span class="line">              &#125;</span><br><span class="line">              // 把p设为暂时尾节点</span><br><span class="line">              tl = p;</span><br><span class="line">          &#125; while ((e = e.next) != null);</span><br><span class="line">          // 上面只是把链表转换成TreeNode，现在才进行链表条转换成红黑树</span><br><span class="line">          if ((tab[index] = hd) != null)</span><br><span class="line">              // 看下面解析</span><br><span class="line">              hd.treeify(tab);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="treeify"><a href="#treeify" class="headerlink" title="treeify"></a>treeify</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  /**</span><br><span class="line">   * 把链表条转换成红黑树</span><br><span class="line">   */</span><br><span class="line">final void treeify(Node&lt;K,V&gt;[] tab) &#123;</span><br><span class="line">          TreeNode&lt;K,V&gt; root = null;</span><br><span class="line">          // 从this开始遍历，x为当前节点，next为当前节点的下一节点</span><br><span class="line">          for (TreeNode&lt;K,V&gt; x = this, next; x != null; x = next) &#123;</span><br><span class="line">              next = (TreeNode&lt;K,V&gt;)x.next;</span><br><span class="line">              x.left = x.right = null;</span><br><span class="line">              // 如果还没有根节点，把x设为跟节点</span><br><span class="line">              if (root == null) &#123;</span><br><span class="line">                  x.parent = null;</span><br><span class="line">                  x.red = false;</span><br><span class="line">                  root = x;</span><br><span class="line">              &#125;</span><br><span class="line">              else &#123;</span><br><span class="line">                  K k = x.key;</span><br><span class="line">                  int h = x.hash;</span><br><span class="line">                  Class&lt;?&gt; kc = null;</span><br><span class="line">                  /*</span><br><span class="line">                   * 从根节点开始遍历，此遍历没有设置边界，只能从内部跳出</span><br><span class="line">                   * x为要插进的节点，p为遍历到的要进行对比的节点</span><br><span class="line">                   */</span><br><span class="line">                  for (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">                      // dir 标识方向（-1为左，1为右）、ph标识当前树节点的hash值</span><br><span class="line">                      int dir, ph;</span><br><span class="line">                      K pk = p.key;</span><br><span class="line">                      if ((ph = p.hash) &gt; h)</span><br><span class="line">                          dir = -1;</span><br><span class="line">                      else if (ph &lt; h)</span><br><span class="line">                          dir = 1;</span><br><span class="line">                      // 对比的两个节点x、p的hash值相等，判断hash碰撞再决定dir的值</span><br><span class="line">                      else if ((kc == null &amp;&amp;</span><br><span class="line">                                (kc = comparableClassFor(k)) == null) ||</span><br><span class="line">                               (dir = compareComparables(kc, k, pk)) == 0)</span><br><span class="line">                          dir = tieBreakOrder(k, pk);</span><br><span class="line">                      // 先保存好当前对比的p，可能要作为x即将插入的父节点</span><br><span class="line">                      TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">                      // 根据dir来决定下一个遍历的对比节点p，如果p为null说明到末节点了，把x插进去</span><br><span class="line">                    </span><br><span class="line">                      if ((p = (dir &lt;= 0) ? p.left : p.right) == null) &#123;</span><br><span class="line">                          // x的父节点</span><br><span class="line">                          x.parent = xp;</span><br><span class="line">                          // 决定x在左还是右节点</span><br><span class="line">                          if (dir &lt;= 0)</span><br><span class="line">                              xp.left = x;</span><br><span class="line">                          else</span><br><span class="line">                              xp.right = x;</span><br><span class="line">                          // 加入新的节点，要对红黑树进行重新平衡，这个下面分析</span><br><span class="line">                          root = balanceInsertion(root, x);</span><br><span class="line">                          break;</span><br><span class="line">                      &#125;</span><br><span class="line">                  // p不为null，就重新开始整个遍历</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          // 把红黑树的根节点设为其所在的链表条的链表头，下面会有分析</span><br><span class="line">          moveRootToFront(tab, root);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<h3 id="balanceInsertion"><a href="#balanceInsertion" class="headerlink" title="balanceInsertion"></a>balanceInsertion</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  /**</span><br><span class="line">   * 平衡红黑树，root为根节点，x为新插入的节点</span><br><span class="line">   * 有兴趣可以看这篇图文讲解，https://www.cnblogs.com/oldbai/p/9890808.html</span><br><span class="line">   * 还有这篇 https://blog.csdn.net/weixin_42340670/article/details/80550932</span><br><span class="line">   */</span><br><span class="line">static &lt;K,V&gt; TreeNode&lt;K,V&gt; balanceInsertion(TreeNode&lt;K,V&gt; root,</span><br><span class="line">                                                  TreeNode&lt;K,V&gt; x) &#123;</span><br><span class="line">          // 设x为红色</span><br><span class="line">          x.red = true;</span><br><span class="line">          // 循环依然只能内部跳出</span><br><span class="line">          // xp：x的父节点、xpp：x的爷爷节点、xppl：x的左叔叔节点、xppr：x的右叔叔节点</span><br><span class="line">          for (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) &#123;</span><br><span class="line">              // xp为x的父节点，为null说明x为根节点，设成黑色，返回x</span><br><span class="line">              if ((xp = x.parent) == null) &#123;</span><br><span class="line">                  x.red = false;</span><br><span class="line">                  return x;</span><br><span class="line">              &#125;</span><br><span class="line">              // xp为黑色或者x的爷爷节点xpp为null，返回root</span><br><span class="line">              else if (!xp.red || (xpp = xp.parent) == null)</span><br><span class="line">                  return root;</span><br><span class="line">              // xpp不为null，xp与xpp的左子节点相等，则说明xp在xpp的左子节点</span><br><span class="line">              if (xp == (xppl = xpp.left)) &#123;</span><br><span class="line">                  // 如果 xpp 的右子节点xppr不为空且为红色，进行变色操作</span><br><span class="line">                  // 这里直接变色可达到关于黑色数量规则，且无连续红色，</span><br><span class="line">                  // 然后继续往上循环判断</span><br><span class="line">                  if ((xppr = xpp.right) != null &amp;&amp; xppr.red) &#123;</span><br><span class="line">                      xppr.red = false;</span><br><span class="line">                      xp.red = false;</span><br><span class="line">                      xpp.red = true;</span><br><span class="line">                      // x设为xpp，作为下次循环的指定节点</span><br><span class="line">                      x = xpp;</span><br><span class="line">                  &#125;</span><br><span class="line">                  // 如果 xpp 的右子节点xppr为空，或者为黑色，变色已经不能满足红黑树规则</span><br><span class="line">                  else &#123;</span><br><span class="line">                      // 如果x为右子节点,左旋转</span><br><span class="line">                      if (x == xp.right) &#123;</span><br><span class="line">                          root = rotateLeft(root, x = xp);</span><br><span class="line">                          xpp = (xp = x.parent) == null ? null : xp.parent;</span><br><span class="line">                      &#125;</span><br><span class="line">                      if (xp != null) &#123;</span><br><span class="line">                          xp.red = false;</span><br><span class="line">                          if (xpp != null) &#123;</span><br><span class="line">                              xpp.red = true;</span><br><span class="line">                              root = rotateRight(root, xpp);</span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              else &#123;</span><br><span class="line">                  if (xppl != null &amp;&amp; xppl.red) &#123;</span><br><span class="line">                      xppl.red = false;</span><br><span class="line">                      xp.red = false;</span><br><span class="line">                      xpp.red = true;</span><br><span class="line">                      x = xpp;</span><br><span class="line">                  &#125;</span><br><span class="line">                  else &#123;</span><br><span class="line">                      if (x == xp.left) &#123;</span><br><span class="line">                          root = rotateRight(root, x = xp);</span><br><span class="line">                          xpp = (xp = x.parent) == null ? null : xp.parent;</span><br><span class="line">                      &#125;</span><br><span class="line">                      if (xp != null) &#123;</span><br><span class="line">                          xp.red = false;</span><br><span class="line">                          if (xpp != null) &#123;</span><br><span class="line">                              xpp.red = true;</span><br><span class="line">                              root = rotateLeft(root, xpp);</span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<h3 id="rotateLeft"><a href="#rotateLeft" class="headerlink" title="rotateLeft"></a>rotateLeft</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> /**</span><br><span class="line">  * 左旋转</span><br><span class="line">  */</span><br><span class="line">static &lt;K,V&gt; TreeNode&lt;K,V&gt; rotateLeft(TreeNode&lt;K,V&gt; root,</span><br><span class="line">                                           TreeNode&lt;K,V&gt; p) &#123;</span><br><span class="line">         TreeNode&lt;K,V&gt; r, pp, rl;</span><br><span class="line">         if (p != null &amp;&amp; (r = p.right) != null) &#123;</span><br><span class="line">             if ((rl = p.right = r.left) != null)</span><br><span class="line">                 rl.parent = p;</span><br><span class="line">             if ((pp = r.parent = p.parent) == null)</span><br><span class="line">                 (root = r).red = false;</span><br><span class="line">             else if (pp.left == p)</span><br><span class="line">                 pp.left = r;</span><br><span class="line">             else</span><br><span class="line">                 pp.right = r;</span><br><span class="line">             r.left = p;</span><br><span class="line">             p.parent = r;</span><br><span class="line">         &#125;</span><br><span class="line">         return root;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<h3 id="rotateRight"><a href="#rotateRight" class="headerlink" title="rotateRight"></a>rotateRight</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 右旋转</span><br><span class="line"> */</span><br><span class="line">static &lt;K,V&gt; TreeNode&lt;K,V&gt; rotateRight(TreeNode&lt;K,V&gt; root,</span><br><span class="line">                                           TreeNode&lt;K,V&gt; p) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; l, pp, lr;</span><br><span class="line">        if (p != null &amp;&amp; (l = p.left) != null) &#123;</span><br><span class="line">            if ((lr = p.left = l.right) != null)</span><br><span class="line">                lr.parent = p;</span><br><span class="line">            if ((pp = l.parent = p.parent) == null)</span><br><span class="line">                (root = l).red = false;</span><br><span class="line">            else if (pp.right == p)</span><br><span class="line">                pp.right = l;</span><br><span class="line">            else</span><br><span class="line">                pp.left = l;</span><br><span class="line">            l.right = p;</span><br><span class="line">            p.parent = l;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>方法有点难懂，深入研究红黑树后再补充。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>little_eight</tag>
      </tags>
  </entry>
  <entry>
    <title>java面试题（三）</title>
    <url>/2018/10/10/java%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="转发（forward）和重定向（redirect）的区别？"><a href="#转发（forward）和重定向（redirect）的区别？" class="headerlink" title="转发（forward）和重定向（redirect）的区别？"></a>转发（forward）和重定向（redirect）的区别？</h2><p>答：forward是容器中控制权的转向，是服务器请求资源，服务器直接访问目标地址的URL，把那个URL 的响应内容读取过来，然后把这些内容再发给浏览器，浏览器根本不知道服务器发送的内容是从哪儿来的，所以它的地址栏中还是原来的地址。redirect就是服务器端根据逻辑，发送一个状态码，告诉浏览器重新去请求那个地址，因此从浏览器的地址栏中可以看到跳转后的链接地址，很明显redirect无法访问到服务器保护起来资源，但是可以从一个网站redirect到其他网站。forward更加高效，所以在满足需要时尽量使用forward（通过调用RequestDispatcher对象的forward()方法，该对象可以通过ServletRequest对象的getRequestDispatcher()方法获得），并且这样也有助于隐藏实际的链接；在有些情况下，比如需要访问一个其它服务器上的资源，则必须使用重定向（通过HttpServletResponse对象调用其sendRedirect()方法实现）。</p>
<h2 id="JSP有哪些内置对象？作用分别是什么？"><a href="#JSP有哪些内置对象？作用分别是什么？" class="headerlink" title="JSP有哪些内置对象？作用分别是什么？"></a>JSP有哪些内置对象？作用分别是什么？</h2><p>答：JSP有9个内置对象： </p>
<ul>
<li>request：封装客户端的请求，其中包含来自GET或POST请求的参数； </li>
<li>response：封装服务器对客户端的响应； </li>
<li>pageContext：通过该对象可以获取其他对象； </li>
<li>session：封装用户会话的对象； </li>
<li>application：封装服务器运行环境的对象； </li>
<li>out：输出服务器响应的输出流对象； </li>
<li>config：Web应用的配置对象； </li>
<li>page：JSP页面本身（相当于Java程序中的this）； </li>
<li>exception：封装页面抛出异常的对象。</li>
</ul>
<blockquote>
<p>补充：如果用Servlet来生成网页中的动态内容无疑是非常繁琐的工作，另一方面，所有的文本和HTML标签都是硬编码，即使做出微小的修改，都需要进行重新编译。JSP解决了Servlet的这些问题，它是Servlet很好的补充，可以专门用作为用户呈现视图（View），而Servlet作为控制器（Controller）专门负责处理用户请求并转发或重定向到某个页面。基于Java的Web开发很多都同时使用了Servlet和JSP。JSP页面其实是一个Servlet，能够运行Servlet的服务器（Servlet容器）通常也是JSP容器，可以提供JSP页面的运行环境，Tomcat就是一个Servlet/JSP容器。第一次请求一个JSP页面时，Servlet/JSP容器首先将JSP页面转换成一个JSP页面的实现类，这是一个实现了JspPage接口或其子接口HttpJspPage的Java类。JspPage接口是Servlet的子接口，因此每个JSP页面都是一个Servlet。转换成功后，容器会编译Servlet类，之后容器加载和实例化Java字节码，并执行它通常对Servlet所做的生命周期操作。对同一个JSP页面的后续请求，容器会查看这个JSP页面是否被修改过，如果修改过就会重新转换并重新编译并执行。如果没有则执行内存中已经存在的Servlet实例。我们可以看一段JSP代码对应的Java程序就知道一切了，而且9个内置对象的神秘面纱也会被揭开。</p>
</blockquote>
<p>JSP页面：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;%@ page pageEncoding=&quot;UTF-8&quot;%&gt;</span><br><span class="line">&lt;%</span><br><span class="line">String path = request.getContextPath();</span><br><span class="line">String basePath = request.getScheme() + &quot;://&quot; + request.getServerName() + &quot;:&quot; + request.getServerPort() + path + &quot;/&quot;;</span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;base href=&quot;&lt;%=basePath%&gt;&quot;&gt;</span><br><span class="line">    &lt;title&gt;首页&lt;/title&gt;</span><br><span class="line">    &lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">        * &#123; font-family: &quot;Arial&quot;; &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line"></span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;h1&gt;Hello, World!&lt;/h1&gt;</span><br><span class="line">    &lt;hr/&gt;</span><br><span class="line">    &lt;h2&gt;Current time is: &lt;%= new java.util.Date().toString() %&gt;&lt;/h2&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>对应的Java代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.jsp.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">index_jsp</span> <span class="keyword">extends</span> <span class="title">org</span>.<span class="title">apache</span>.<span class="title">jasper</span>.<span class="title">runtime</span>.<span class="title">HttpJspBase</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">org</span>.<span class="title">apache</span>.<span class="title">jasper</span>.<span class="title">runtime</span>.<span class="title">JspSourceDependent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> javax.servlet.jsp.JspFactory _jspxFactory = javax.servlet.jsp.JspFactory</span><br><span class="line">            .getDefaultFactory();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> java.util.Map&lt;java.lang.String, java.lang.Long&gt; _jspx_dependants;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> javax.el.ExpressionFactory _el_expressionfactory;</span><br><span class="line">    <span class="keyword">private</span> org.apache.tomcat.InstanceManager _jsp_instancemanager;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> java.util.Map&lt;java.lang.String, java.lang.Long&gt; getDependants() &#123;</span><br><span class="line">        <span class="keyword">return</span> _jspx_dependants;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">_jspInit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        _el_expressionfactory = _jspxFactory.getJspApplicationContext(</span><br><span class="line">                getServletConfig().getServletContext()).getExpressionFactory();</span><br><span class="line">        _jsp_instancemanager = org.apache.jasper.runtime.InstanceManagerFactory</span><br><span class="line">                .getInstanceManager(getServletConfig());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">_jspDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">_jspService</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">final</span> javax.servlet.http.HttpServletRequest request,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">final</span> javax.servlet.http.HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> java.io.IOException, javax.servlet.ServletException </span>&#123;</span><br><span class="line">        <span class="comment">// 内置对象就是在这里定义的</span></span><br><span class="line">        <span class="keyword">final</span> javax.servlet.jsp.PageContext pageContext;</span><br><span class="line">        javax.servlet.http.HttpSession session = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">final</span> javax.servlet.ServletContext application;</span><br><span class="line">        <span class="keyword">final</span> javax.servlet.ServletConfig config;</span><br><span class="line">        javax.servlet.jsp.JspWriter out = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">final</span> java.lang.Object page = <span class="keyword">this</span>;</span><br><span class="line">        javax.servlet.jsp.JspWriter _jspx_out = <span class="keyword">null</span>;</span><br><span class="line">        javax.servlet.jsp.PageContext _jspx_page_context = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            response.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line">            pageContext = _jspxFactory.getPageContext(<span class="keyword">this</span>, request, response,</span><br><span class="line">                    <span class="keyword">null</span>, <span class="keyword">true</span>, <span class="number">8192</span>, <span class="keyword">true</span>);</span><br><span class="line">            _jspx_page_context = pageContext;</span><br><span class="line">            application = pageContext.getServletContext();</span><br><span class="line">            config = pageContext.getServletConfig();</span><br><span class="line">            session = pageContext.getSession();</span><br><span class="line">            out = pageContext.getOut();</span><br><span class="line">            _jspx_out = out;</span><br><span class="line"></span><br><span class="line">            out.write(<span class="string">&#x27;\r&#x27;</span>);</span><br><span class="line">            out.write(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"></span><br><span class="line">            String path = request.getContextPath();</span><br><span class="line">            String basePath = request.getScheme() + <span class="string">&quot;://&quot;</span></span><br><span class="line">                    + request.getServerName() + <span class="string">&quot;:&quot;</span> + request.getServerPort()</span><br><span class="line">                    + path + <span class="string">&quot;/&quot;</span>;</span><br><span class="line"><span class="comment">// 以下代码通过输出流将HTML标签输出到浏览器中</span></span><br><span class="line">            out.write(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">            out.write(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">            out.write(<span class="string">&quot;&lt;!DOCTYPE html&gt;\r\n&quot;</span>);</span><br><span class="line">            out.write(<span class="string">&quot;&lt;html&gt;\r\n&quot;</span>);</span><br><span class="line">            out.write(<span class="string">&quot;  &lt;head&gt;\r\n&quot;</span>);</span><br><span class="line">            out.write(<span class="string">&quot;    &lt;base href=\&quot;&quot;</span>);</span><br><span class="line">            out.print(basePath);</span><br><span class="line">            out.write(<span class="string">&quot;\&quot;&gt;\r\n&quot;</span>);</span><br><span class="line">            out.write(<span class="string">&quot;    &lt;title&gt;首页&lt;/title&gt;\r\n&quot;</span>);</span><br><span class="line">            out.write(<span class="string">&quot;    &lt;style type=\&quot;text/css\&quot;&gt;\r\n&quot;</span>);</span><br><span class="line">            out.write(<span class="string">&quot;    \t* &#123; font-family: \&quot;Arial\&quot;; &#125;\r\n&quot;</span>);</span><br><span class="line">            out.write(<span class="string">&quot;    &lt;/style&gt;\r\n&quot;</span>);</span><br><span class="line">            out.write(<span class="string">&quot;  &lt;/head&gt;\r\n&quot;</span>);</span><br><span class="line">            out.write(<span class="string">&quot;  \r\n&quot;</span>);</span><br><span class="line">            out.write(<span class="string">&quot;  &lt;body&gt;\r\n&quot;</span>);</span><br><span class="line">            out.write(<span class="string">&quot;    &lt;h1&gt;Hello, World!&lt;/h1&gt;\r\n&quot;</span>);</span><br><span class="line">            out.write(<span class="string">&quot;    &lt;hr/&gt;\r\n&quot;</span>);</span><br><span class="line">            out.write(<span class="string">&quot;    &lt;h2&gt;Current time is: &quot;</span>);</span><br><span class="line">            out.print(<span class="keyword">new</span> java.util.Date().toString());</span><br><span class="line">            out.write(<span class="string">&quot;&lt;/h2&gt;\r\n&quot;</span>);</span><br><span class="line">            out.write(<span class="string">&quot;  &lt;/body&gt;\r\n&quot;</span>);</span><br><span class="line">            out.write(<span class="string">&quot;&lt;/html&gt;\r\n&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (java.lang.Throwable t) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(t <span class="keyword">instanceof</span> javax.servlet.jsp.SkipPageException)) &#123;</span><br><span class="line">                out = _jspx_out;</span><br><span class="line">                <span class="keyword">if</span> (out != <span class="keyword">null</span> &amp;&amp; out.getBufferSize() != <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        out.clearBuffer();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (java.io.IOException e) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                <span class="keyword">if</span> (_jspx_page_context != <span class="keyword">null</span>)</span><br><span class="line">                    _jspx_page_context.handlePageException(t);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ServletException(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            _jspxFactory.releasePageContext(_jspx_page_context);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="get和post请求的区别？"><a href="#get和post请求的区别？" class="headerlink" title="get和post请求的区别？"></a>get和post请求的区别？</h2><p>答： </p>
<ul>
<li>get请求用来从服务器上获得资源，而post是用来向服务器提交数据； </li>
<li>get将表单中数据按照name=value的形式，添加到action 所指向的URL 后面，并且两者使用”?”连接，而各个变量之间使用”&amp;”连接；post是将表单中的数据放在HTTP协议的请求头或消息体中，传递到action所指向URL； </li>
<li>get传输的数据要受到URL长度限制（1024字节）；而post可以传输大量的数据，上传文件通常要使用post方式； </li>
<li>使用get时参数会显示在地址栏上，如果这些数据不是敏感数据，那么可以使用get；对于敏感数据还是应用使用post； </li>
<li>get使用MIME类型application/x-www-form-urlencoded的URL编码（也叫百分号编码）文本的格式传递参数，保证被传送的参数由遵循规范的文本组成，例如一个空格的编码是”%20”。</li>
</ul>
<h2 id="常用的Web服务器有哪些？"><a href="#常用的Web服务器有哪些？" class="headerlink" title="常用的Web服务器有哪些？"></a>常用的Web服务器有哪些？</h2><p>答：Unix和Linux平台下使用最广泛的免费HTTP服务器是Apache服务器，而Windows平台的服务器通常使用IIS作为Web服务器。选择Web服务器应考虑的因素有：性能、安全性、日志和统计、虚拟主机、代理服务器、缓冲服务和集成应用程序等。下面是对常见服务器的简介： </p>
<ul>
<li>IIS：Microsoft的Web服务器产品，全称是Internet Information Services。IIS是允许在公共Intranet或Internet上发布信息的Web服务器。IIS是目前最流行的Web服务器产品之一，很多著名的网站都是建立在IIS的平台上。IIS提供了一个图形界面的管理工具，称为Internet服务管理器，可用于监视配置和控制Internet服务。IIS是一种Web服务组件，其中包括Web服务器、FTP服务器、NNTP服务器和SMTP服务器，分别用于网页浏览、文件传输、新闻服务和邮件发送等方面，它使得在网络（包括互联网和局域网）上发布信息成了一件很容易的事。它提供ISAPI(Intranet Server API）作为扩展Web服务器功能的编程接口；同时，它还提供一个Internet数据库连接器，可以实现对数据库的查询和更新。 </li>
<li>Kangle：Kangle Web服务器是一款跨平台、功能强大、安全稳定、易操作的高性能Web服务器和反向代理服务器软件。此外，Kangle也是一款专为做虚拟主机研发的Web服务器。实现虚拟主机独立进程、独立身份运行。用户之间安全隔离，一个用户出问题不影响其他用户。支持PHP、ASP、ASP.NET、Java、Ruby等多种动态开发语言。 </li>
<li>WebSphere：WebSphere Application Server是功能完善、开放的Web应用程序服务器，是IBM电子商务计划的核心部分，它是基于Java的应用环境，用于建立、部署和管理Internet和Intranet Web应用程序，适应各种Web应用程序服务器的需要。 </li>
<li>WebLogic：WebLogic Server是一款多功能、基于标准的Web应用服务器，为企业构建企业应用提供了坚实的基础。针对各种应用开发、关键性任务的部署，各种系统和数据库的集成、跨Internet协作等Weblogic都提供了相应的支持。由于它具有全面的功能、对开放标准的遵从性、多层架构、支持基于组件的开发等优势，很多公司的企业级应用都选择它来作为开发和部署的环境。WebLogic Server在使应用服务器成为企业应用架构的基础方面一直处于领先地位，为构建集成化的企业级应用提供了稳固的基础。 </li>
<li>Apache：目前Apache仍然是世界上用得最多的Web服务器，其市场占有率很长时间都保持在60%以上（目前的市场份额约40%左右）。世界上很多著名的网站都是Apache的产物，它的成功之处主要在于它的源代码开放、有一支强大的开发团队、支持跨平台的应用（可以运行在几乎所有的Unix、Windows、Linux系统平台上）以及它的可移植性等方面。 </li>
<li>Tomcat：Tomcat是一个开放源代码、运行Servlet和JSP的容器。Tomcat实现了Servlet和JSP规范。此外，Tomcat还实现了Apache-Jakarta规范而且比绝大多数商业应用软件服务器要好，因此目前也有不少的Web服务器都选择了Tomcat。 </li>
<li>Nginx：读作”engine x”，是一个高性能的HTTP和反向代理服务器，也是一个IMAP/POP3/SMTP代理服务器。 Nginx是由Igor Sysoev为俄罗斯访问量第二的Rambler站点开发的，第一个公开版本0.1.0发布于2004年10月4日。其将源代码以类BSD许可证的形式发布，因它的稳定性、丰富的功能集、示例配置文件和低系统资源的消耗而闻名。在2014年下半年，Nginx的市场份额达到了14%。</li>
</ul>
<h2 id="JSP和Servlet是什么关系？"><a href="#JSP和Servlet是什么关系？" class="headerlink" title="JSP和Servlet是什么关系？"></a>JSP和Servlet是什么关系？</h2><p>答：其实这个问题在上面已经阐述过了，Servlet是一个特殊的Java程序，它运行于服务器的JVM中，能够依靠服务器的支持向浏览器提供显示内容。JSP本质上是Servlet的一种简易形式，JSP会被服务器处理成一个类似于Servlet的Java程序，可以简化页面内容的生成。Servlet和JSP最主要的不同点在于，Servlet的应用逻辑是在Java文件中，并且完全从表示层中的HTML分离开来。而JSP的情况是Java和HTML可以组合成一个扩展名为.jsp的文件。有人说，Servlet就是在Java中写HTML，而JSP就是在HTML中写Java代码，当然这个说法是很片面且不够准确的。JSP侧重于视图，Servlet更侧重于控制逻辑，在MVC架构模式中，JSP适合充当视图（view）而Servlet适合充当控制器（controller）。</p>
<h2 id="讲解JSP中的四种作用域。"><a href="#讲解JSP中的四种作用域。" class="headerlink" title="讲解JSP中的四种作用域。"></a>讲解JSP中的四种作用域。</h2><p>答：JSP中的四种作用域包括page、request、session和application，具体来说： </p>
<ul>
<li>page代表与一个页面相关的对象和属性。 </li>
<li>request代表与Web客户机发出的一个请求相关的对象和属性。一个请求可能跨越多个页面，涉及多个Web组件；需要在页面显示的临时数据可以置于此作用域。 </li>
<li>session代表与某个用户与服务器建立的一次会话相关的对象和属性。跟某个用户相关的数据应该放在用户自己的session中。 </li>
<li>application代表与整个Web应用程序相关的对象和属性，它实质上是跨越整个Web应用程序，包括多个页面、请求和会话的一个全局作用域。</li>
</ul>
<h2 id="说一下表达式语言（EL）的隐式对象及其作用。"><a href="#说一下表达式语言（EL）的隐式对象及其作用。" class="headerlink" title="说一下表达式语言（EL）的隐式对象及其作用。"></a>说一下表达式语言（EL）的隐式对象及其作用。</h2><p>答：EL的隐式对象包括：pageContext、initParam（访问上下文参数）、param（访问请求参数）、paramValues、header（访问请求头）、headerValues、cookie（访问cookie）、applicationScope（访问application作用域）、sessionScope（访问session作用域）、requestScope（访问request作用域）、pageScope（访问page作用域）。</p>
<p>用法如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$&#123;pageContext.request.method&#125;</span><br><span class="line">$&#123;pageContext[&quot;request&quot;][&quot;method&quot;]&#125;</span><br><span class="line">$&#123;pageContext.request[&quot;method&quot;]&#125;</span><br><span class="line">$&#123;pageContext[&quot;request&quot;].method&#125;</span><br><span class="line">$&#123;initParam.defaultEncoding&#125;</span><br><span class="line">$&#123;header[&quot;accept-language&quot;]&#125;</span><br><span class="line">$&#123;headerValues[&quot;accept-language&quot;][0]&#125;</span><br><span class="line">$&#123;cookie.jsessionid.value&#125;</span><br><span class="line">$&#123;sessionScope.loginUser.username&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>补充：表达式语言的.和[]运算作用是一致的，唯一的差别在于如果访问的属性名不符合Java标识符命名规则，例如上面的accept-language就不是一个有效的Java标识符，那么这时候就只能用[]运算符而不能使用.运算符获取它的值</p>
</blockquote>
<h2 id="解释一下网络应用的模式及其特点。"><a href="#解释一下网络应用的模式及其特点。" class="headerlink" title="解释一下网络应用的模式及其特点。"></a>解释一下网络应用的模式及其特点。</h2><p>答：典型的网络应用模式大致有三类：B/S、C/S、P2P。其中B代表浏览器（Browser）、C代表客户端（Client）、S代表服务器（Server），P2P是对等模式，不区分客户端和服务器。B/S应用模式中可以视为特殊的C/S应用模式，只是将C/S应用模式中的特殊的客户端换成了浏览器，因为几乎所有的系统上都有浏览器，那么只要打开浏览器就可以使用应用，没有安装、配置、升级客户端所带来的各种开销。P2P应用模式中，成千上万台彼此连接的计算机都处于对等的地位，整个网络一般来说不依赖专用的集中服务器。网络中的每一台计算机既能充当网络服务的请求者，又对其它计算机的请求作出响应，提供资源和服务。通常这些资源和服务包括：信息的共享和交换、计算资源（如CPU的共享）、存储共享（如缓存和磁盘空间的使用）等，这种应用模式最大的阻力安全性、版本等问题，目前有很多应用都混合使用了多种应用模型，最常见的网络视频应用，它几乎把三种模式都用上了。</p>
<blockquote>
<p>补充：此题要跟”电子商务模式”区分开，因为有很多人被问到这个问题的时候马上想到的是B2B（如阿里巴巴）、B2C（如当当、亚马逊、京东）、C2C（如淘宝、拍拍）、C2B（如威客）、O2O（如美团、饿了么）。对于这类问题，可以去百度上面科普一下。</p>
</blockquote>
<h2 id="什么是Web-Service（Web服务）？"><a href="#什么是Web-Service（Web服务）？" class="headerlink" title="什么是Web Service（Web服务）？"></a>什么是Web Service（Web服务）？</h2><p>答：从表面上看，Web Service就是一个应用程序，它向外界暴露出一个能够通过Web进行调用的API。这就是说，你能够用编程的方法透明的调用这个应用程序，不需要了解它的任何细节，跟你使用的编程语言也没有关系。例如可以创建一个提供天气预报的Web Service，那么无论你用哪种编程语言开发的应用都可以通过调用它的API并传入城市信息来获得该城市的天气预报。之所以称之为Web Service，是因为它基于HTTP协议传输数据，这使得运行在不同机器上的不同应用无须借助附加的、专门的第三方软件或硬件，就可相互交换数据或集成。</p>
<blockquote>
<p>补充：这里必须要提及的一个概念是SOA（Service-Oriented Architecture，面向服务的架构），SOA是一种思想，它将应用程序的不同功能单元通过中立的契约联系起来，独立于硬件平台、操作系统和编程语言，使得各种形式的功能单元能够更好的集成。显然，Web Service是SOA的一种较好的解决方案，它更多的是一种标准，而不是一种具体的技术。</p>
</blockquote>
<h2 id="概念解释：SOAP、WSDL、UDDI。"><a href="#概念解释：SOAP、WSDL、UDDI。" class="headerlink" title="概念解释：SOAP、WSDL、UDDI。"></a>概念解释：SOAP、WSDL、UDDI。</h2><ul>
<li>SOAP：简单对象访问协议（Simple Object Access Protocol），是Web Service中交换数据的一种协议规范。 </li>
<li>WSDL：Web服务描述语言（Web Service Description Language），它描述了Web服务的公共接口。这是一个基于XML的关于如何与Web服务通讯和使用的服务描述；也就是描述与目录中列出的Web服务进行交互时需要绑定的协议和信息格式。通常采用抽象语言描述该服务支持的操作和信息，使用的时候再将实际的网络协议和信息格式绑定给该服务。 </li>
<li>UDDI：统一描述、发现和集成（Universal Description, Discovery and Integration），它是一个基于XML的跨平台的描述规范，可以使世界范围内的企业在互联网上发布自己所提供的服务。简单的说，UDDI是访问各种WSDL的一个门面（可以参考设计模式中的门面模式）。</li>
</ul>
<h2 id="什么是ORM？"><a href="#什么是ORM？" class="headerlink" title="什么是ORM？"></a>什么是ORM？</h2><p>答：对象关系映射（Object-Relational Mapping，简称ORM）是一种为了解决程序的面向对象模型与数据库的关系模型互不匹配问题的技术；简单的说，ORM是通过使用描述对象和数据库之间映射的元数据（在Java中可以用XML或者是注解），将程序中的对象自动持久化到关系数据库中或者将关系数据库表中的行转换成Java对象，其本质上就是将数据从一种形式转换到另外一种形式。</p>
<h2 id="持久层设计要考虑的问题有哪些？你用过的持久层框架有哪些？"><a href="#持久层设计要考虑的问题有哪些？你用过的持久层框架有哪些？" class="headerlink" title="持久层设计要考虑的问题有哪些？你用过的持久层框架有哪些？"></a>持久层设计要考虑的问题有哪些？你用过的持久层框架有哪些？</h2><p>答：所谓”持久”就是将数据保存到可掉电式存储设备中以便今后使用，简单的说，就是将内存中的数据保存到关系型数据库、文件系统、消息队列等提供持久化支持的设备中。持久层就是系统中专注于实现数据持久化的相对独立的层面。</p>
<p>持久层设计的目标包括： </p>
<ul>
<li>数据存储逻辑的分离，提供抽象化的数据访问接口。 </li>
<li>数据访问底层实现的分离，可以在不修改代码的情况下切换底层实现。 </li>
<li>资源管理和调度的分离，在数据访问层实现统一的资源调度（如缓存机制）。 </li>
<li>数据抽象，提供更面向对象的数据操作。<br>持久层框架有： </li>
<li>Hibernate </li>
<li>MyBatis </li>
<li>TopLink </li>
<li>Guzz </li>
<li>jOOQ </li>
<li>Spring Data </li>
<li>ActiveJDBC<h2 id="Hibernate中SessionFactory是线程安全的吗？Session是线程安全的吗（两个线程能够共享同一个Session吗）？"><a href="#Hibernate中SessionFactory是线程安全的吗？Session是线程安全的吗（两个线程能够共享同一个Session吗）？" class="headerlink" title="Hibernate中SessionFactory是线程安全的吗？Session是线程安全的吗（两个线程能够共享同一个Session吗）？"></a>Hibernate中SessionFactory是线程安全的吗？Session是线程安全的吗（两个线程能够共享同一个Session吗）？</h2>答：SessionFactory对应Hibernate的一个数据存储的概念，它是线程安全的，可以被多个线程并发访问。SessionFactory一般只会在启动的时候构建。对于应用程序，最好将SessionFactory通过单例模式进行封装以便于访问。Session是一个轻量级非线程安全的对象（线程间不能共享session），它表示与数据库进行交互的一个工作单元。Session是由SessionFactory创建的，在任务完成之后它会被关闭。Session是持久层服务对外提供的主要接口。Session会延迟获取数据库连接（也就是在需要的时候才会获取）。为了避免创建太多的session，可以使用ThreadLocal将session和当前线程绑定在一起，这样可以让同一个线程获得的总是同一个session。Hibernate 3中SessionFactory的getCurrentSession()方法就可以做到。</li>
</ul>
<h2 id="Hibernate中Session的load和get方法的区别是什么？"><a href="#Hibernate中Session的load和get方法的区别是什么？" class="headerlink" title="Hibernate中Session的load和get方法的区别是什么？"></a>Hibernate中Session的load和get方法的区别是什么？</h2><p>答：主要有以下三项区别： </p>
<ul>
<li>如果没有找到符合条件的记录，get方法返回null，load方法抛出异常。 </li>
<li>get方法直接返回实体类对象，load方法返回实体类对象的代理。 </li>
<li>在Hibernate 3之前，get方法只在一级缓存中进行数据查找，如果没有找到对应的数据则越过二级缓存，直接发出SQL语句完成数据读取；load方法则可以从二级缓存中获取数据；从Hibernate 3开始，get方法不再是对二级缓存只写不读，它也是可以访问二级缓存的。</li>
</ul>
<blockquote>
<p>说明：对于load()方法Hibernate认为该数据在数据库中一定存在可以放心的使用代理来实现延迟加载，如果没有数据就抛出异常，而通过get()方法获取的数据可以不存在。</p>
</blockquote>
<h2 id="Session的save-、update-、merge-、lock-、saveOrUpdate-和persist-方法分别是做什么的？有什么区别？"><a href="#Session的save-、update-、merge-、lock-、saveOrUpdate-和persist-方法分别是做什么的？有什么区别？" class="headerlink" title="Session的save()、update()、merge()、lock()、saveOrUpdate()和persist()方法分别是做什么的？有什么区别？"></a>Session的save()、update()、merge()、lock()、saveOrUpdate()和persist()方法分别是做什么的？有什么区别？</h2><p>答：Hibernate的对象有三种状态：瞬时态（transient）、持久态（persistent）和游离态（detached），如第135题中的图所示。瞬时态的实例可以通过调用save()、persist()或者saveOrUpdate()方法变成持久态；游离态的实例可以通过调用 update()、saveOrUpdate()、lock()或者replicate()变成持久态。save()和persist()将会引发SQL的INSERT语句，而update()或merge()会引发UPDATE语句。save()和update()的区别在于一个是将瞬时态对象变成持久态，一个是将游离态对象变为持久态。merge()方法可以完成save()和update()方法的功能，它的意图是将新的状态合并到已有的持久化对象上或创建新的持久化对象。对于persist()方法，按照官方文档的说明：① persist()方法把一个瞬时态的实例持久化，但是并不保证标识符被立刻填入到持久化实例中，标识符的填入可能被推迟到flush的时间；② persist()方法保证当它在一个事务外部被调用的时候并不触发一个INSERT语句，当需要封装一个长会话流程的时候，persist()方法是很有必要的；③ save()方法不保证第②条，它要返回标识符，所以它会立即执行INSERT语句，不管是在事务内部还是外部。至于lock()方法和update()方法的区别，update()方法是把一个已经更改过的脱管状态的对象变成持久状态；lock()方法是把一个没有更改过的脱管状态的对象变成持久状态。</p>
<h2 id="阐述Session加载实体对象的过程。"><a href="#阐述Session加载实体对象的过程。" class="headerlink" title="阐述Session加载实体对象的过程。"></a>阐述Session加载实体对象的过程。</h2><p>答：Session加载实体对象的步骤是： </p>
<ul>
<li>Session在调用数据库查询功能之前，首先会在一级缓存中通过实体类型和主键进行查找，如果一级缓存查找命中且数据状态合法，则直接返回； </li>
<li>如果一级缓存没有命中，接下来Session会在当前NonExists记录（相当于一个查询黑名单，如果出现重复的无效查询可以迅速做出判断，从而提升性能）中进行查找，如果NonExists中存在同样的查询条件，则返回null； </li>
<li>如果一级缓存查询失败则查询二级缓存，如果二级缓存命中则直接返回； </li>
<li>如果之前的查询都未命中，则发出SQL语句，如果查询未发现对应记录则将此次查询添加到Session的NonExists中加以记录，并返回null； </li>
<li>根据映射配置和SQL语句得到ResultSet，并创建对应的实体对象； </li>
<li>将对象纳入Session（一级缓存）的管理； </li>
<li>如果有对应的拦截器，则执行拦截器的onLoad方法； </li>
<li>如果开启并设置了要使用二级缓存，则将数据对象纳入二级缓存； </li>
<li>返回数据对象。</li>
</ul>
<h2 id="Query接口的list方法和iterate方法有什么区别？"><a href="#Query接口的list方法和iterate方法有什么区别？" class="headerlink" title="Query接口的list方法和iterate方法有什么区别？"></a>Query接口的list方法和iterate方法有什么区别？</h2><p>答： </p>
<ul>
<li>list()方法无法利用一级缓存和二级缓存（对缓存只写不读），它只能在开启查询缓存的前提下使用查询缓存；iterate()方法可以充分利用缓存，如果目标数据只读或者读取频繁，使用iterate()方法可以减少性能开销。 </li>
<li>list()方法不会引起N+1查询问题，而iterate()方法可能引起N+1查询问题<h2 id="Hibernate如何实现分页查询？"><a href="#Hibernate如何实现分页查询？" class="headerlink" title="Hibernate如何实现分页查询？"></a>Hibernate如何实现分页查询？</h2>答：通过Hibernate实现分页查询，开发人员只需要提供HQL语句（调用Session的createQuery()方法）或查询条件（调用Session的createCriteria()方法）、设置查询起始行数（调用Query或Criteria接口的setFirstResult()方法）和最大查询行数（调用Query或Criteria接口的setMaxResults()方法），并调用Query或Criteria接口的list()方法，Hibernate会自动生成分页查询的SQL语句。</li>
</ul>
<h2 id="锁机制有什么用？简述Hibernate的悲观锁和乐观锁机制。"><a href="#锁机制有什么用？简述Hibernate的悲观锁和乐观锁机制。" class="headerlink" title="锁机制有什么用？简述Hibernate的悲观锁和乐观锁机制。"></a>锁机制有什么用？简述Hibernate的悲观锁和乐观锁机制。</h2><p>答：有些业务逻辑在执行过程中要求对数据进行排他性的访问，于是需要通过一些机制保证在此过程中数据被锁住不会被外界修改，这就是所谓的锁机制。<br>Hibernate支持悲观锁和乐观锁两种锁机制。悲观锁，顾名思义悲观的认为在数据处理过程中极有可能存在修改数据的并发事务（包括本系统的其他事务或来自外部系统的事务），于是将处理的数据设置为锁定状态。悲观锁必须依赖数据库本身的锁机制才能真正保证数据访问的排他性，关于数据库的锁机制和事务隔离级别在《Java面试题大全（上）》中已经讨论过了。乐观锁，顾名思义，对并发事务持乐观态度（认为对数据的并发操作不会经常性的发生），通过更加宽松的锁机制来解决由于悲观锁排他性的数据访问对系统性能造成的严重影响。最常见的乐观锁是通过数据版本标识来实现的，读取数据时获得数据的版本号，更新数据时将此版本号加1，然后和数据库表对应记录的当前版本号进行比较，如果提交的数据版本号大于数据库中此记录的当前版本号则更新数据，否则认为是过期数据无法更新。Hibernate中通过Session的get()和load()方法从数据库中加载对象时可以通过参数指定使用悲观锁；而乐观锁可以通过给实体类加整型的版本字段再通过XML或@Version注解进行配置。</p>
<blockquote>
<p>提示：使用乐观锁会增加了一个版本字段，很明显这需要额外的空间来存储这个版本字段，浪费了空间，但是乐观锁会让系统具有更好的并发性，这是对时间的节省。因此乐观锁也是典型的空间换时间的策略。</p>
</blockquote>
<h2 id="阐述实体对象的三种状态以及转换关系。"><a href="#阐述实体对象的三种状态以及转换关系。" class="headerlink" title="阐述实体对象的三种状态以及转换关系。"></a>阐述实体对象的三种状态以及转换关系。</h2><p>答：最新的Hibernate文档中为Hibernate对象定义了四种状态（原来是三种状态，面试的时候基本上问的也是三种状态），分别是：瞬时态（new, or transient）、持久态（managed, or persistent）、游状态（detached）和移除态（removed，以前Hibernate文档中定义的三种状态中没有移除态），如下图所示，就以前的Hibernate文档中移除态被视为是瞬时态。</p>
<ul>
<li>瞬时态：当new一个实体对象后，这个对象处于瞬时态，即这个对象只是一个保存临时数据的内存区域，如果没有变量引用这个对象，则会被JVM的垃圾回收机制回收。这个对象所保存的数据与数据库没有任何关系，除非通过Session的save()、saveOrUpdate()、persist()、merge()方法把瞬时态对象与数据库关联，并把数据插入或者更新到数据库，这个对象才转换为持久态对象。</li>
<li>持久态：持久态对象的实例在数据库中有对应的记录，并拥有一个持久化标识（ID）。对持久态对象进行delete操作后，数据库中对应的记录将被删除，那么持久态对象与数据库记录不再存在对应关系，持久态对象变成移除态（可以视为瞬时态）。持久态对象被修改变更后，不会马上同步到数据库，直到数据库事务提交。</li>
<li>游离态：当Session进行了close()、clear()、evict()或flush()后，实体对象从持久态变成游离态，对象虽然拥有持久和与数据库对应记录一致的标识值，但是因为对象已经从会话中清除掉，对象不在持久化管理之内，所以处于游离态（也叫脱管态）。游离态的对象与临时状态对象是十分相似的，只是它还含有持久化标识。</li>
</ul>
<h2 id="如何理解Hibernate的延迟加载机制？在实际应用中，延迟加载与Session关闭的矛盾是如何处理的？"><a href="#如何理解Hibernate的延迟加载机制？在实际应用中，延迟加载与Session关闭的矛盾是如何处理的？" class="headerlink" title="如何理解Hibernate的延迟加载机制？在实际应用中，延迟加载与Session关闭的矛盾是如何处理的？"></a>如何理解Hibernate的延迟加载机制？在实际应用中，延迟加载与Session关闭的矛盾是如何处理的？</h2><p>答：延迟加载就是并不是在读取的时候就把数据加载进来，而是等到使用时再加载。Hibernate使用了虚拟代理机制实现延迟加载，我们使用Session的load()方法加载数据或者一对多关联映射在使用延迟加载的情况下从一的一方加载多的一方，得到的都是虚拟代理，简单的说返回给用户的并不是实体本身，而是实体对象的代理。代理对象在用户调用getter方法时才会去数据库加载数据。但加载数据就需要数据库连接。而当我们把会话关闭时，数据库连接就同时关闭了。</p>
<p>延迟加载与session关闭的矛盾一般可以这样处理： </p>
<ul>
<li>关闭延迟加载特性。这种方式操作起来比较简单，因为Hibernate的延迟加载特性是可以通过映射文件或者注解进行配置的，但这种解决方案存在明显的缺陷。首先，出现”no session or session was closed”通常说明系统中已经存在主外键关联，如果去掉延迟加载的话，每次查询的开销都会变得很大。 </li>
<li>在session关闭之前先获取需要查询的数据，可以使用工具方法Hibernate.isInitialized()判断对象是否被加载，如果没有被加载则可以使用Hibernate.initialize()方法加载对象。 </li>
<li>使用拦截器或过滤器延长Session的生命周期直到视图获得数据。Spring整合Hibernate提供的OpenSessionInViewFilter和OpenSessionInViewInterceptor就是这种做法。</li>
</ul>
<h2 id="举一个多对多关联的例子，并说明如何实现多对多关联映射。"><a href="#举一个多对多关联的例子，并说明如何实现多对多关联映射。" class="headerlink" title="举一个多对多关联的例子，并说明如何实现多对多关联映射。"></a>举一个多对多关联的例子，并说明如何实现多对多关联映射。</h2><p>答：例如：商品和订单、学生和课程都是典型的多对多关系。可以在实体类上通过@ManyToMany注解配置多对多关联或者通过映射文件中的和标签配置多对多关联，但是实际项目开发中，很多时候都是将多对多关联映射转换成两个多对一关联映射来实现的。</p>
<h2 id="谈一下你对继承映射的理解。"><a href="#谈一下你对继承映射的理解。" class="headerlink" title="谈一下你对继承映射的理解。"></a>谈一下你对继承映射的理解。</h2><p>答：继承关系的映射策略有三种： </p>
<ul>
<li>每个继承结构一张表（table per class hierarchy），不管多少个子类都用一张表。 </li>
<li>每个子类一张表（table per subclass），公共信息放一张表，特有信息放单独的表。 </li>
<li>每个具体类一张表（table per concrete class），有多少个子类就有多少张表。<br>第一种方式属于单表策略，其优点在于查询子类对象的时候无需表连接，查询速度快，适合多态查询；缺点是可能导致表很大。后两种方式属于多表策略，其优点在于数据存储紧凑，其缺点是需要进行连接查询，不适合多态查询。</li>
</ul>
<h2 id="简述Hibernate常见优化策略。"><a href="#简述Hibernate常见优化策略。" class="headerlink" title="简述Hibernate常见优化策略。"></a>简述Hibernate常见优化策略。</h2><p>答：这个问题应当挑自己使用过的优化策略回答，常用的有： </p>
<ul>
<li>制定合理的缓存策略（二级缓存、查询缓存）。 </li>
<li>采用合理的Session管理机制。 </li>
<li>尽量使用延迟加载特性。 </li>
<li>设定合理的批处理参数。 </li>
<li>如果可以，选用UUID作为主键生成器。 </li>
<li>如果可以，选用基于版本号的乐观锁替代悲观锁。 </li>
<li>在开发过程中, 开启hibernate.show_sql选项查看生成的SQL，从而了解底层的状况；开发完成后关闭此选项。 </li>
<li>考虑数据库本身的优化，合理的索引、恰当的数据分区策略等都会对持久层的性能带来可观的提升，但这些需要专业的DBA（数据库管理员）提供支持。</li>
</ul>
<h2 id="谈一谈Hibernate的一级缓存、二级缓存和查询缓存。"><a href="#谈一谈Hibernate的一级缓存、二级缓存和查询缓存。" class="headerlink" title="谈一谈Hibernate的一级缓存、二级缓存和查询缓存。"></a>谈一谈Hibernate的一级缓存、二级缓存和查询缓存。</h2><p>答：Hibernate的Session提供了一级缓存的功能，默认总是有效的，当应用程序保存持久化实体、修改持久化实体时，Session并不会立即把这种改变提交到数据库，而是缓存在当前的Session中，除非显示调用了Session的flush()方法或通过close()方法关闭Session。通过一级缓存，可以减少程序与数据库的交互，从而提高数据库访问性能。<br>SessionFactory级别的二级缓存是全局性的，所有的Session可以共享这个二级缓存。不过二级缓存默认是关闭的，需要显示开启并指定需要使用哪种二级缓存实现类（可以使用第三方提供的实现）。一旦开启了二级缓存并设置了需要使用二级缓存的实体类，SessionFactory就会缓存访问过的该实体类的每个对象，除非缓存的数据超出了指定的缓存空间。<br>一级缓存和二级缓存都是对整个实体进行缓存，不会缓存普通属性，如果希望对普通属性进行缓存，可以使用查询缓存。查询缓存是将HQL或SQL语句以及它们的查询结果作为键值对进行缓存，对于同样的查询可以直接从缓存中获取数据。查询缓存默认也是关闭的，需要显示开启。</p>
<h2 id="MyBatis中使用-和-书写占位符有什么区别？"><a href="#MyBatis中使用-和-书写占位符有什么区别？" class="headerlink" title="MyBatis中使用#和$书写占位符有什么区别？"></a>MyBatis中使用#和$书写占位符有什么区别？</h2><p>答：#将传入的数据都当成一个字符串，会对传入的数据自动加上引号；$将传入的数据直接显示生成在SQL中。注意：使用$占位符可能会导致SQL注射攻击，能用#的地方就不要使用$，写order by子句的时候应该用$而不是#。</p>
<h2 id="解释一下MyBatis中命名空间（namespace）的作用。"><a href="#解释一下MyBatis中命名空间（namespace）的作用。" class="headerlink" title="解释一下MyBatis中命名空间（namespace）的作用。"></a>解释一下MyBatis中命名空间（namespace）的作用。</h2><p>答：在大型项目中，可能存在大量的SQL语句，这时候为每个SQL语句起一个唯一的标识（ID）就变得并不容易了。为了解决这个问题，在MyBatis中，可以为每个映射文件起一个唯一的命名空间，这样定义在这个映射文件中的每个SQL语句就成了定义在这个命名空间中的一个ID。只要我们能够保证每个命名空间中这个ID是唯一的，即使在不同映射文件中的语句ID相同，也不会再产生冲突了。</p>
<h2 id="MyBatis中的动态SQL是什么意思？"><a href="#MyBatis中的动态SQL是什么意思？" class="headerlink" title="MyBatis中的动态SQL是什么意思？"></a>MyBatis中的动态SQL是什么意思？</h2><p>答：对于一些复杂的查询，我们可能会指定多个查询条件，但是这些条件可能存在也可能不存在，例如在58同城上面找房子，我们可能会指定面积、楼层和所在位置来查找房源，也可能会指定面积、价格、户型和所在位置来查找房源，此时就需要根据用户指定的条件动态生成SQL语句。如果不使用持久层框架我们可能需要自己拼装SQL语句，还好MyBatis提供了动态SQL的功能来解决这个问题。MyBatis中用于实现动态SQL的元素主要有： </p>
<ul>
<li>if </li>
<li>choose / when / otherwise </li>
<li>trim </li>
<li>where </li>
<li>set </li>
<li>foreach</li>
</ul>
<p>下面是映射文件的片段。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> &lt;select id=&quot;foo&quot; parameterType=&quot;Blog&quot; resultType=&quot;Blog&quot;&gt;</span><br><span class="line">     select * from t_blog where 1 = 1</span><br><span class="line">     &lt;if test=&quot;title != null&quot;&gt;</span><br><span class="line">         and title = #&#123;title&#125;</span><br><span class="line">     &lt;/if&gt;</span><br><span class="line">     &lt;if test=&quot;content != null&quot;&gt;</span><br><span class="line">         and content = #&#123;content&#125;</span><br><span class="line">     &lt;/if&gt;</span><br><span class="line">     &lt;if test=&quot;owner != null&quot;&gt;</span><br><span class="line">         and owner = #&#123;owner&#125;</span><br><span class="line">     &lt;/if&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>
<p>当然也可以像下面这些书写。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;select id=&quot;foo&quot; parameterType=&quot;Blog&quot; resultType=&quot;Blog&quot;&gt;</span><br><span class="line">    select * from t_blog where 1 = 1 </span><br><span class="line">    &lt;choose&gt;</span><br><span class="line">        &lt;when test=&quot;title != null&quot;&gt;</span><br><span class="line">            and title = #&#123;title&#125;</span><br><span class="line">        &lt;/when&gt;</span><br><span class="line">        &lt;when test=&quot;content != null&quot;&gt;</span><br><span class="line">            and content = #&#123;content&#125;</span><br><span class="line">        &lt;/when&gt;</span><br><span class="line">        &lt;otherwise&gt;</span><br><span class="line">            and owner = &quot;owner1&quot;</span><br><span class="line">        &lt;/otherwise&gt;</span><br><span class="line">    &lt;/choose&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>
<h2 id="什么是IoC和DI？DI是如何实现的？"><a href="#什么是IoC和DI？DI是如何实现的？" class="headerlink" title="什么是IoC和DI？DI是如何实现的？"></a>什么是IoC和DI？DI是如何实现的？</h2><p> 答：IoC叫控制反转，是Inversion of Control的缩写，DI（Dependency Injection）叫依赖注入，是对IoC更简单的诠释。控制反转是把传统上由程序代码直接操控的对象的调用权交给容器，通过容器来实现对象组件的装配和管理。所谓的”控制反转”就是对组件对象控制权的转移，从程序代码本身转移到了外部容器，由容器来创建对象并管理对象之间的依赖关系。IoC体现了好莱坞原则 - “Don’t call me, we will call you”。依赖注入的基本原则是应用组件不应该负责查找资源或者其他依赖的协作对象。配置对象的工作应该由容器负责，查找资源的逻辑应该从应用组件的代码中抽取出来，交给容器来完成。DI是对IoC更准确的描述，即组件之间的依赖关系由容器在运行期决定，形象的来说，即由容器动态的将某种依赖关系注入到组件之中。</p>
<p> 举个例子：一个类A需要用到接口B中的方法，那么就需要为类A和接口B建立关联或依赖关系，最原始的方法是在类A中创建一个接口B的实现类C的实例，但这种方法需要开发人员自行维护二者的依赖关系，也就是说当依赖关系发生变动的时候需要修改代码并重新构建整个系统。如果通过一个容器来管理这些对象以及对象的依赖关系，则只需要在类A中定义好用于关联接口B的方法（构造器或setter方法），将类A和接口B的实现类C放入容器中，通过对容器的配置来实现二者的关联。</p>
<p> 依赖注入可以通过setter方法注入（设值注入）、构造器注入和接口注入三种方式来实现，Spring支持setter注入和构造器注入，通常使用构造器注入来注入必须的依赖关系，对于可选的依赖关系，则setter注入是更好的选择，setter注入需要类提供无参构造器或者无参的静态工厂方法来创建对象。</p>
<h2 id="解释一下什么叫AOP（面向切面编程）？"><a href="#解释一下什么叫AOP（面向切面编程）？" class="headerlink" title="解释一下什么叫AOP（面向切面编程）？"></a>解释一下什么叫AOP（面向切面编程）？</h2><p>答：AOP（Aspect-Oriented Programming）指一种程序设计范型，该范型以一种称为切面（aspect）的语言构造为基础，切面是一种新的模块化机制，用来描述分散在对象、类或方法中的横切关注点（crosscutting concern）。</p>
<h2 id="Spring中自动装配的方式有哪些？"><a href="#Spring中自动装配的方式有哪些？" class="headerlink" title="Spring中自动装配的方式有哪些？"></a>Spring中自动装配的方式有哪些？</h2><p>答： </p>
<ul>
<li>no：不进行自动装配，手动设置Bean的依赖关系。 </li>
<li>byName：根据Bean的名字进行自动装配。 </li>
<li>byType：根据Bean的类型进行自动装配。 </li>
<li>constructor：类似于byType，不过是应用于构造器的参数，如果正好有一个Bean与构造器的参数类型相同则可以自动装配，否则会导致错误。 </li>
<li>autodetect：如果有默认的构造器，则通过constructor的方式进行自动装配，否则使用byType的方式进行自动装配。</li>
</ul>
<h2 id="Spring-MVC的工作原理是怎样的？"><a href="#Spring-MVC的工作原理是怎样的？" class="headerlink" title="Spring MVC的工作原理是怎样的？"></a>Spring MVC的工作原理是怎样的？</h2><p>答：Spring MVC的工作原理如下所示：</p>
<ul>
<li>客户端的所有请求都交给前端控制器DispatcherServlet来处理，它会负责调用系统的其他模块来真正处理用户的请求。 </li>
<li>DispatcherServlet收到请求后，将根据请求的信息（包括URL、HTTP协议方法、请求头、请求参数、Cookie等）以及HandlerMapping的配置找到处理该请求的Handler（任何一个对象都可以作为请求的Handler）。 </li>
<li>在这个地方Spring会通过HandlerAdapter对该处理器进行封装。 </li>
<li>HandlerAdapter是一个适配器，它用统一的接口对各种Handler中的方法进行调用。 </li>
<li>Handler完成对用户请求的处理后，会返回一个ModelAndView对象给DispatcherServlet，ModelAndView顾名思义，包含了数据模型以及相应的视图的信息。 </li>
<li>ModelAndView的视图是逻辑视图，DispatcherServlet还要借助ViewResolver完成从逻辑视图到真实视图对象的解析工作。 </li>
<li>当得到真正的视图对象后，DispatcherServlet会利用视图对象对模型数据进行渲染。 </li>
<li>客户端得到响应，可能是一个普通的HTML页面，也可以是XML或JSON字符串，还可以是一张图片或者一个PDF文件。</li>
</ul>
<h2 id="选择使用Spring框架的原因（Spring框架为企业级开发带来的好处有哪些）？"><a href="#选择使用Spring框架的原因（Spring框架为企业级开发带来的好处有哪些）？" class="headerlink" title="选择使用Spring框架的原因（Spring框架为企业级开发带来的好处有哪些）？"></a>选择使用Spring框架的原因（Spring框架为企业级开发带来的好处有哪些）？</h2><p> 答：可以从以下几个方面作答： </p>
<ul>
<li>非侵入式：支持基于POJO的编程模式，不强制性的要求实现Spring框架中的接口或继承Spring框架中的类。 </li>
<li>IoC容器：IoC容器帮助应用程序管理对象以及对象之间的依赖关系，对象之间的依赖关系如果发生了改变只需要修改配置文件而不是修改代码，因为代码的修改可能意味着项目的重新构建和完整的回归测试。有了IoC容器，程序员再也不需要自己编写工厂、单例，这一点特别符合Spring的精神”不要重复的发明轮子”。 </li>
<li>AOP（面向切面编程）：将所有的横切关注功能封装到切面（aspect）中，通过配置的方式将横切关注功能动态添加到目标代码上，进一步实现了业务逻辑和系统服务之间的分离。另一方面，有了AOP程序员可以省去很多自己写代理类的工作。 </li>
<li>MVC：Spring的MVC框架是非常优秀的，从各个方面都可以甩Struts 2几条街，为Web表示层提供了更好的解决方案。 </li>
<li>事务管理：Spring以宽广的胸怀接纳多种持久层技术，并且为其提供了声明式的事务管理，在不需要任何一行代码的情况下就能够完成事务管理。 </li>
<li>其他：选择Spring框架的原因还远不止于此，Spring为Java企业级开发提供了一站式选择，你可以在需要的时候使用它的部分和全部，更重要的是，你甚至可以在感觉不到Spring存在的情况下，在你的项目中使用Spring提供的各种优秀的功能。</li>
</ul>
<h2 id="阐述Spring框架中Bean的生命周期？"><a href="#阐述Spring框架中Bean的生命周期？" class="headerlink" title="阐述Spring框架中Bean的生命周期？"></a>阐述Spring框架中Bean的生命周期？</h2><p>答： </p>
<ul>
<li>Spring IoC容器找到关于Bean的定义并实例化该Bean。 </li>
<li>Spring IoC容器对Bean进行依赖注入。 </li>
<li>如果Bean实现了BeanNameAware接口，则将该Bean的id传给setBeanName方法。 </li>
<li>如果Bean实现了BeanFactoryAware接口，则将BeanFactory对象传给setBeanFactory方法。 </li>
<li>如果Bean实现了BeanPostProcessor接口，则调用其postProcessBeforeInitialization方法。 </li>
<li>如果Bean实现了InitializingBean接口，则调用其afterPropertySet方法。 </li>
<li>如果有和Bean关联的BeanPostProcessors对象，则这些对象的postProcessAfterInitialization方法被调用。 </li>
<li>当销毁Bean实例时，如果Bean实现了DisposableBean接口，则调用其destroy方法。</li>
</ul>
<h2 id="你用过的网站前端优化的技术有哪些？"><a href="#你用过的网站前端优化的技术有哪些？" class="headerlink" title="你用过的网站前端优化的技术有哪些？"></a>你用过的网站前端优化的技术有哪些？</h2><p>答：<br>① 浏览器访问优化： </p>
<ul>
<li>减少HTTP请求数量：合并CSS、合并JavaScript、合并图片（CSS Sprite） </li>
<li>使用浏览器缓存：通过设置HTTP响应头中的Cache-Control和Expires属性，将CSS、JavaScript、图片等在浏览器中缓存，当这些静态资源需要更新时，可以更新HTML文件中的引用来让浏览器重新请求新的资源 </li>
<li>启用压缩 </li>
<li>CSS前置，JavaScript后置 </li>
<li>减少Cookie传输<br>② CDN加速：CDN（Content Distribute Network）的本质仍然是缓存，将数据缓存在离用户最近的地方，CDN通常部署在网络运营商的机房，不仅可以提升响应速度，还可以减少应用服务器的压力。当然，CDN缓存的通常都是静态资源。<br>③ 反向代理：反向代理相当于应用服务器的一个门面，可以保护网站的安全性，也可以实现负载均衡的功能，当然最重要的是它缓存了用户访问的热点资源，可以直接从反向代理将某些内容返回给用户浏览器。</li>
</ul>
<h2 id="什么是XSS攻击？什么是SQL注入攻击？什么是CSRF攻击？"><a href="#什么是XSS攻击？什么是SQL注入攻击？什么是CSRF攻击？" class="headerlink" title="什么是XSS攻击？什么是SQL注入攻击？什么是CSRF攻击？"></a>什么是XSS攻击？什么是SQL注入攻击？什么是CSRF攻击？</h2><p>答： </p>
<ul>
<li>XSS（Cross Site Script，跨站脚本攻击）是向网页中注入恶意脚本在用户浏览网页时在用户浏览器中执行恶意脚本的攻击方式。跨站脚本攻击分有两种形式：反射型攻击（诱使用户点击一个嵌入恶意脚本的链接以达到攻击的目标，目前有很多攻击者利用论坛、微博发布含有恶意脚本的URL就属于这种方式）和持久型攻击（将恶意脚本提交到被攻击网站的数据库中，用户浏览网页时，恶意脚本从数据库中被加载到页面执行，QQ邮箱的早期版本就曾经被利用作为持久型跨站脚本攻击的平台）。XSS虽然不是什么新鲜玩意，但是攻击的手法却不断翻新，防范XSS主要有两方面：消毒（对危险字符进行转义）和HttpOnly（防范XSS攻击者窃取Cookie数据）。 </li>
<li>SQL注入攻击是注入攻击最常见的形式（此外还有OS注入攻击（Struts 2的高危漏洞就是通过OGNL实施OS注入攻击导致的）），当服务器使用请求参数构造SQL语句时，恶意的SQL被嵌入到SQL中交给数据库执行。SQL注入攻击需要攻击者对数据库结构有所了解才能进行，攻击者想要获得表结构有多种方式：（1）如果使用开源系统搭建网站，数据库结构也是公开的（目前有很多现成的系统可以直接搭建论坛，电商网站，虽然方便快捷但是风险是必须要认真评估的）；（2）错误回显（如果将服务器的错误信息直接显示在页面上，攻击者可以通过非法参数引发页面错误从而通过错误信息了解数据库结构，Web应用应当设置友好的错误页，一方面符合最小惊讶原则，一方面屏蔽掉可能给系统带来危险的错误回显信息）；（3）盲注。防范SQL注入攻击也可以采用消毒的方式，通过正则表达式对请求参数进行验证，此外，参数绑定也是很好的手段，这样恶意的SQL会被当做SQL的参数而不是命令被执行，JDBC中的PreparedStatement就是支持参数绑定的语句对象，从性能和安全性上都明显优于Statement。 </li>
<li>CSRF攻击（Cross Site Request Forgery，跨站请求伪造）是攻击者通过跨站请求，以合法的用户身份进行非法操作（如转账或发帖等）。CSRF的原理是利用浏览器的Cookie或服务器的Session，盗取用户身份，其原理如下图所示。防范CSRF的主要手段是识别请求者的身份，主要有以下几种方式：（1）在表单中添加令牌（token）；（2）验证码；（3）检查请求头中的Referer（前面提到防图片盗链接也是用的这种方式）。令牌和验证都具有一次消费性的特征，因此在原理上一致的，但是验证码是一种糟糕的用户体验，不是必要的情况下不要轻易使用验证码，目前很多网站的做法是如果在短时间内多次提交一个表单未获得成功后才要求提供验证码，这样会获得较好的用户体验。<blockquote>
<p>补充：防火墙的架设是Web安全的重要保障，ModSecurity是开源的Web防火墙中的佼佼者。企业级防火墙的架设应当有两级防火墙，Web服务器和部分应用服务器可以架设在两级防火墙之间的DMZ，而数据和资源服务器应当架设在第二级防火墙之后。</p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>java杂记</category>
      </categories>
      <tags>
        <tag>little_eight</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm两万字详解</title>
    <url>/2021/06/06/jvm%E4%B8%A4%E4%B8%87%E5%AD%97%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p><img data-src="https://gitee.com/littleeight/blog-images/raw/master/java%E7%9A%84jvm/0.png"></p>
<p>运行一个 Java 应用程序，必须要先安装 JDK 或者 JRE 包。因为 Java 应用在编译后会变成字节码，通过字节码运行在 JVM 中，而 JVM 是 JRE 的核心组成部分。JVM 不仅承担了 Java 字节码的分析和执行，同时也内置了自动内存分配管理机制。这个机制可以大大降低手动分配回收机制可能带来的内存泄露和内存溢出风险，使 Java 开发人员不需要关注每个对象的内存分配以及回收，从而更专注于业务本身。<br>在 Java 中，JVM 内存模型主要分为<strong>堆、方法区、程序计数器、虚拟机栈和本地方法栈</strong>。其中，堆和方法区被所有线程共享，虚拟机栈、本地方法栈、程序计数器是线程私有的。<br>​</p>
<span id="more"></span>
<p><img data-src="https://gitee.com/littleeight/blog-images/raw/master/java%E7%9A%84jvm/1.png"></p>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>堆是 JVM 内存中最大的一块内存空间，该内存被所有线程共享，几乎所有对象和数组都被分配到了堆内存中。堆被划分为新生代和老年代，新生代又被进一步划分为 Eden 和 Survivor 区，最后 Survivor 由 From Survivor 和 To Survivor 组成。<br><img data-src="https://gitee.com/littleeight/blog-images/raw/master/java%E7%9A%84jvm/2.png"></p>
<p>但需要注意的是，这些区域的划分因不同的垃圾收集器而不同。大部分垃圾收集器都是基于分代收集理论设计的，就会采用这种分代模型。而一些新的垃圾收集器不采用分代设计，比如G1 收集器就是把堆内存拆分为多个大小相等的 Region，比如下图：<br><img data-src="https://gitee.com/littleeight/blog-images/raw/master/java%E7%9A%84jvm/3.png"></p>
<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>在 jdk8 之前，HotSopt 虚拟机的方法区又被称为永久代，由于永久代的设计容易导致内存溢出等问题，jdk8 之后就没有永久代了，取而代之的是元空间（MetaSpace）。元空间并没有处于堆内存上，而是直接占用的本地内存，因此元空间的最大大小受本地内存限制。<br>方法区与堆空间类似，是所有线程共享的。方法区主要是用来存放已被虚拟机加载的类型信息、常量、静态变量等数据。方法区是一个逻辑分区，包含元空间、运行时常量池、字符串常量池，元空间物理上使用的本地内存，运行时常量池和字符串常量池是在堆中开辟的一块特殊内存区域。这样做的好处之一是可以避免运行时动态生成的常量的复制迁移，可以直接使用堆中的引用。要注意的是，<strong>字符串常量池在 jvm 中只有一个，而运行时常量池是和类型数据绑定的，每个 Class 一个。</strong><br><img data-src="https://gitee.com/littleeight/blog-images/raw/master/java%E7%9A%84jvm/4.png"></p>
<ul>
<li><strong>类型信息（类或接口）</strong><ul>
<li>这个类型的全限定名</li>
<li>这个类型的直接超类的全限定名（只有 java.lang.Object 没有超类）</li>
<li>这个类型的访问修饰符（public、abstract、final）</li>
<li>这个类型是接口类型还是类类型</li>
<li>任何直接超接口的的全限定名的有序列表</li>
</ul>
</li>
<li><strong>运行时常量池</strong><ul>
<li>Class 文件被装载进虚拟机后，Class 常量池表中的字面量和符号引用都会存放到运行时常量池中，平时我们说的常量池一般指运行时常量池。</li>
<li>运行时常量池相比Class常量池具备动态性，运行时可以将新的常量放入池中，比如调用 String.intern() 方法使字符串驻留。</li>
<li>字段信息</li>
<li>字段名</li>
<li>字段的类型（包括 void）</li>
<li>字段的修饰符（public、private、protected、static、final、volatile、transient）</li>
</ul>
</li>
<li><strong>方法信息</strong><ul>
<li>方法名</li>
<li>方法的返回类型</li>
<li>方法参数的数量和类型</li>
<li>方法的修饰符（public、private、protected、static、final、synchronized、native、abstract）</li>
<li>方法的字节码</li>
<li>操作数栈和该方法的栈帧中的局部变量的大小</li>
<li>异常表</li>
</ul>
</li>
<li><strong>指向类加载器的引用</strong><ul>
<li>jvm 使用类加载器来加载一个类，这个类加载器是和这个类型绑定的，因此会在类型信息中存储这个类加载器的引用</li>
</ul>
</li>
<li><strong>指向 Class 类的引用</strong><ul>
<li>每一个被加载的类型，jvm 都会在堆中创建一个 java.lang.Class 的实例，类型信息中会存储 Class 实例的引用</li>
<li>在代码中，可以使用 Class 实例访问方法区保存的信息，如类加载器、类名、接口等<h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2>每当启动一个新的线程，虚拟机都会在虚拟机栈里为它分配一个线程栈，线程栈与线程同生共死。线程栈以 栈帧 为单位保存线程的运行状态，虚拟机只会对线程栈执行两种操作：以栈帧为单位的压栈或出栈。每个方法在执行的同时都会创建一个栈帧，每个方法从调用开始到结束，就对应着一个栈帧在线程栈中压栈和出栈的过程。方法可以通过两种方式结束，一种通过 return 正常返回，一种通过抛出异常而终止。方法返回后，虚拟机都会弹出当前栈帧然后释放掉。<br>当虚拟机调用一个Java方法时．它从对应类的类型信息中得到此方法的局部变量区和操作数栈的大小，并据此分配栈帧内存，然后压入Java栈中。<br>每个栈帧都包含了<strong>局部变量表、操作数栈、动态连接、方法出口和一些额外的附加信息</strong>。</li>
</ul>
</li>
</ul>
<p><img data-src="https://gitee.com/littleeight/blog-images/raw/master/java%E7%9A%84jvm/5.png"></p>
<h4 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h4><p>局部变量表是一组局部变量值存储空间，用于存放方法参数和方法内部定义的局部变量。在Java文件编译为Class文件时，就在方法表的Code属性的max_locals数据项中确定了该方法需要分配的最大局部变量表的容量。<br>局部变量表是以<strong>变量槽slot</strong>为最小单位，为了尽可能的节省空间，slot是可以重用的，但是可能会影响到系统的垃圾收集行为。</p>
<h4 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h4><p>操作数栈也常被称为操作栈，它是一个后入先出栈。JVM底层字节码指令集是基于栈类型的，所有的操作码都是对操作数栈上的数据进行操作，对于每一个方法的调用，JVM会建立一个操作数栈，以供计算使用。和局部变量一样。操作数栈的最大深度也是编译的时候写入到方法表的code属性的max_stacks数据项中。操作数栈的每一个元素可以是任意的Java数据类型，包括long、double。32位数据类型所占的栈容量为1，64位数据类型所占的栈容量为2。栈容量的单位为“字宽”，对于32位虚拟机来说，一个“字宽”占4个字节，64位虚拟机来说，一个“字宽”占8个字节。当一个方法刚刚执行的时候，这个方法的操作数栈是空的，在方法执行的过程中，会有各种字节码指向操作数栈中写入和提取值，也就是入栈与出栈操作。例如，在做算术运算的时候就是通过操作数栈来进行的，又或者调用其它方法的时候是通过操作数栈来行参数传递的。 另外，在概念模型中，两个栈帧作为虚拟机栈的元素，相互之间是完全独立的，但是大多数虚拟机的实现里都会作一些优化处理，令两个栈帧出现一部分重叠。让下栈帧的部分操作数栈与上面栈帧的部分局部变量表重叠在一起，这样在进行方法调用返回时就可以共用一部分数据，而无须进行额外的参数复制传递了。</p>
<h4 id="动态连接"><a href="#动态连接" class="headerlink" title="动态连接"></a>动态连接</h4><p>每个栈帧都包含一个指向运行时常量池中该栈帧所属性方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。在Class文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用为参数。这些符号引用一部分会在类加载阶段或第一次使用的时候转化为直接引用，这种转化称为<strong>静态解析</strong>。另外一部分将在每一次的运行期期间转化为直接引用，这部分称为<strong>动态连接</strong>。</p>
<h4 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h4><p>当一个方法被执行后，有两种方式退出这个方法。第一种方式是执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者(调用当前方法的的方法称为调用者)，是否有返回值和返回值的类型将根据遇到何种方法返回指令来决定，这种退出方法方式称为**正常完成出口(Normal Method Invocation Completion)<strong>。另外一种退出方式是，在方法执行过程中遇到了异常，并且这个异常没有在方法体内得到处理，无论是Java虚拟机内部产生的异常，还是代码中使用athrow字节码指令产生的异常，只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，这种退出方式称为</strong>异常完成出口(Abrupt Method Invocation Completion)**。一个方法使用异常完成出口的方式退出，是不会给它的调用都产生任何返回值的。     无论采用何种方式退出，在方法退出之前，都需要返回到方法被调用的位置，程序才能继续执行，方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态。一般来说，方法正常退出时，调用者PC计数器的值就可以作为返回地址，栈帧中很可能会保存这个计数器值。而方法异常退出时，返回地址是要通过异常处理器来确定的，栈帧中一般不会保存这部分信息。 方法退出的过程实际上等同于把当前栈帧出栈，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值(如果有的话)压入调用都栈帧的操作数栈中，调用PC计数器的值以指向方法调用指令后面的一条指令等。</p>
<h4 id="附加信息"><a href="#附加信息" class="headerlink" title="附加信息"></a>附加信息</h4><p>虚拟机规范允许具体的虚拟机实现增加一些规范里没有描述的信息到栈帧中，例如与高度相关的信息，这部分信息完全取决于具体的虚拟机实现。在实际开发中，一般会把动态连接，方法返回地址与其它附加信息全部归为一类，称为栈帧信息。</p>
<h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>本地方法栈与虚拟机栈所发挥的作用是相似的，当线程调用Java方法时，会创建一个栈帧并压入虚拟机栈；而调用本地方法时，虚拟机会保持栈不变，不会压入新的栈帧，虚拟机只是简单的动态链接并直接调用指定的本地方法，使用的是某种本地方法栈。比如某个虚拟机实现的本地方法接口是使用C连接模型，那么它的本地方法栈就是C栈。<br>本地方法可以通过本地方法接口来访问虚拟机的运行时数据区，它可以做任何他想做的事情，本地方法不受虚拟机控制。</p>
<h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>每一个运行的线程都会有它的程序计数器（PC寄存器），与线程的生命周期一样。执行某个方法时，PC寄存器的内容总是下一条将被执行的地址，这个地址可以是一个本地指针，也可以是在方法字节码中相对于该方法起始指令的偏移量。如果该线程正在执行一个本地方法，那么此时PC寄存器的值是 undefined。<br>程序计数器是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。多线程环境下，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储。</p>
<h2 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h2><ul>
<li><strong>方法区</strong>：运行时常量池,就是当你的class文件一旦编译后，你的class常量池就是确定了的，而运行时常量池在运行期间也可能有新的常量放入池中（如String类的intern（）方法）</li>
<li><strong>Class文件</strong>：常量池，.java文件经过编译后生成.class文件，常量池可以理解为class文件的资源仓库。<br>堆：String常量池</li>
</ul>
<h2 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h2><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>通过一个类的全限定名来获取其定义的二进制字节流，将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构，在堆中生成一个代表这个类的class对象，作为方法区这些数据的入口。</p>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>保证class文件是否安全，格式是否正确，<br>(1) 文件格式验证：验证字节流是否符合class文件的格式的规范，并且能够被当前版本的虚拟机处理。、<br>(2) 元数据验证：对字节码描述的信息进行语义分析，保证其描述的信息符合java语言规范的要求。比如这个类是否有父类、这个类的父类是否继承了不允许继承的类..<br>(3) 字节码验证：对数据流跟控制流进行分析，确定程序语义是合法并且符合逻辑的，主要是针对方法体的验证，如：方法中的类型转换是否正确等，跳转指令是否正确等。<br>(4) 符号引用验证：这个动作在后面的解析过程中发生，主要是为了确保解析动作能正确执行。</p>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>为类的静态变量（即 static 修饰的变量）分配内存并设置默认值</p>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>虚拟机将常量池内的符号引用替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符 7 类符号引用进行。<br>理解下符号引用和直接应用：</p>
<ul>
<li><strong>符号引用</strong>：java 文件在编译期间，class 文件并不知道它引用的那些类、方法、字段的具体地址，不能被class文件中的字节码直接引用。因此使用符号引用来代替，运行时再动态连接到具体引用上。符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。</li>
<li><strong>直接引用</strong>：直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局直接相关的。如果有了直接引用，那引用的目标必定已经在虚拟机的内存中存在。在运行时，Java虚拟机从常量池获得符号引用，然后在运行时解析引用项的实际地址。</li>
</ul>
<p>​</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>直到初始化阶段，Java虚拟机才真正开始执行类中编写的Java程序代码，初始化阶段就是执行类构造器 <clinit> 方法的过程。<br><clinit> 方法</p>
<ul>
<li><clinit> 方法是由编译器自动收集类中的所有类变量的赋值语句和静态代码块合并产生的，代码执行的顺序就是源文件中的顺序。</li>
<li>Java虚拟机会保证在子类的 <clinit> 方法执行前，父类的 <clinit> 方法会先执行完毕，即先初始化直接超类。</li>
<li><clinit> 方法对于类或接口来说不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成 <clinit> 方法。</li>
<li>接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成 <clinit> 方法。</li>
<li>执行接口的 <clinit> 方法不需要先执行父接口的 <clinit> 方法，因为只有当父接口中定义的变量被使用时，父接口才会被初始化。此外，接口的实现类在初始化时也一样不会执行接口的 <clinit> 方法。</li>
<li>Java虚拟机会保证一个类的 <clinit> 方法在多线程环境中被正确地加锁同步，<clinit> 一定是线程安全的。</li>
</ul>
<p>​</p>
<h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><p>Java 1.8 之前采用三层类加载器、双亲委派的类加载架构。三层类加载器包括启动类加载器、扩展类加载器、应用程序类加载器。</p>
<h4 id="三层类加载器"><a href="#三层类加载器" class="headerlink" title="三层类加载器"></a>三层类加载器</h4><ul>
<li>启动类加载器(Bootstrap ClassLoader)：负责将 $JAVA_HOME/lib 或者 -Xbootclasspath 参数指定路径下面的文件(按照文件名识别，如rt.jar、tools.jar，名字不符合的类库即使放在lib目录中也不会被加载) 加载到虚拟机内存中。它用来加载 Java 的核心库，是用原生代码实现的，并不继承自 java.lang.ClassLoader，启动类加载器无法直接被 java 代码引用。</li>
<li>扩展类加载器(Extension ClassLoader)：负责加载 $JAVA_HOME/lib/ext 目录中的文件，或者 java.ext.dirs 系统变量所指定的路径的类库，它用来加载 Java 的扩展库。</li>
<li>应用程序类加载器(Application ClassLoader)：一般是系统的默认加载器，也称为系统类加载器，它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般 Java 应用的类都是由它来完成加载的，可以通过 ClassLoader.getSystemClassLoader() 来获取它。<h4 id="双亲委派模型-1"><a href="#双亲委派模型-1" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h4>除了启动类加载器之外，所有的类加载器都有一个父类加载器。应用程序类加载器的父类加载器是扩展类加载器，扩展类加载器的父类加载器是启动类加载器。一般来说，开发人员自定义的类加载器的父类加载器一般是应用程序类加载器。<br>​</li>
</ul>
<p>先要明白，Java 虚拟机判定两个 Java 类是否相同，不仅要看类的全名是否相同，还要看加载此类的类加载器是否一样。只有两个类来源于同一个Class文件，并且被同一个类加载器加载，这两个类才相等。不同类加载器加载的类之间是不兼容的。<br>双亲委派模型就是为了保证 Java 核心库的类型安全的。所有 Java 应用都至少需要引用 java.lang.Object 类，也就是说在运行的时候，java.lang.Object 这个类需要被加载到 Java 虚拟机中。如果这个加载过程由 Java 应用自己的类加载器来完成或者自己定义了一个 java.lang.Object 类的话，很可能就存在多个版本的 java.lang.Object 类，而这些类之间是不兼容的。通过双亲委派模型，对于 Java 核心库的类加载工作由引导类加载器来统一完成，保证了 Java 应用所使用的都是同一个版本的 Java 核心库的类，是互相兼容的。有了双亲委派模型，就算自己定义了一个 java.lang.Object 类，也不会被加载。<br>​</p>
<h4 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h4><p>类加载器之间的父子关系一般不是以继承的关系来实现的，通常是使用组合、委托关系来复用父加载器的代码。ClassLoader 中有一个 parent 属性来表示父类加载器，如果 parent 为 null，就会调用本地方法直接使用启动类加载器来加载类。类加载器在成功加载某个类之后，会把得到的 java.lang.Class 类的实例缓存起来。下次再请求加载该类的时候，类加载器会直接使用缓存的类的实例，而不会尝试再次加载。<br>​</p>
<p>​</p>
<h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><p>在 HotSpot 虚拟机里，对象在堆内存中的存储布局可以划分为三个部分：<strong>对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）</strong>。</p>
<h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><p>对象头主要由两部分组成：<strong>Mark Word <strong>和 <strong>类型指针</strong>，如果是数组对象，还会包含一个</strong>数组长度</strong>。</p>
<ul>
<li>Mark Word：用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。synchronized 锁升级就依赖锁标志、偏向线程等锁信息，垃圾回收新生代对象转移到老年代则依赖于GC分代年龄。</li>
<li>类型指针：对象指向它的类型元数据的指针，Java虚拟机通过这个指针来确定该对象是哪个类的实例。</li>
<li>数组长度：有了数组长度，虚拟机就可以通过普通Java对象的元数据信息确定Java对象的大小，如果数组的长度是不确定的，将无法通过元数据中的信息推断出数组的大小。</li>
</ul>
<p>这三部分数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32个比特和64个比特。64 位虚拟机中，为    了节约内存可以使用选项 +UseCompressedOops 开启指针压缩，某些数据会由 64位压缩至32位。</p>
<h3 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h3><p>实例数据部分是对象真正存储的有效信息，即对象的各个字段数据，无论是从父类继承下来的，还是在子类中定义的字段都必须记录起来。</p>
<h3 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h3><p>对齐填充仅仅起着占位符的作用，由于HotSpot虚拟机的自动内存管理系统要求对象起始地址<strong>必须是 8字节 的整数倍</strong>，就是任何对象的大小都必须是8字节的整数倍。对象头部分已经被设计成正好是8字节的倍数，因此，如果对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。</p>
<h3 id="计算对象占用内存大小"><a href="#计算对象占用内存大小" class="headerlink" title="计算对象占用内存大小"></a>计算对象占用内存大小</h3><p>从上面的内容可以看出，一个对象对内存的占用主要分两部分：对象头和实例数据。在64位机器上，对象头中的 Mark Word 和类型指针各占 64 比特，就是16字节。实例数据部分，可以根据类型来判断，如 int 占 4 个字节，long 占 8 个字节，字符串中文占3个字节、数字或字母占1个字节来计算，就大概能计算出一个对象占用的内存大小。当然，如果是数组、Map、List 之类的对象，就会占用更多的内存。<br>​</p>
<h2 id="对象访问定位"><a href="#对象访问定位" class="headerlink" title="对象访问定位"></a>对象访问定位</h2><p>创建对象后，这个引用变量会压入栈中，即一个 <strong>reference</strong>，它是一个指向对象的引用，这个引用定位的方式主要有两种：<strong>使用句柄</strong>访问对象和<strong>直接指针</strong>访问对象。<br>​</p>
<h3 id="通过句柄访问对象"><a href="#通过句柄访问对象" class="headerlink" title="通过句柄访问对象"></a>通过句柄访问对象</h3><p>使用句柄访问的话，Java堆中将可能会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息。<br>使用句柄来访问的最大好处就是 reference 中存储的是稳定句柄地址，在对象被移动（垃圾收集时移动对象）时只会改变句柄中的实例数据指针，而 reference 本身不需要被修改。</p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>通过直接指针访问对象<br>如果使用直接指针访问的话，Java堆中对象的内存布局就必须放置访问类型数据的相关信息（Mark Word 中记录了类型指针），reference 中存储的直接就是对象地址，如果只是访问对象本身的话，就不需要多一次间接访问的开销。<br>使用直接指针来访问最大的好处就是速度更快，它节省了一次指针定位的时间开销，HotSpot 虚拟机主要就是使用这种方式进行对象访问。<br><strong>就HotSpot而言，他使用的是直接指针访问方式进行对象访问</strong>。</p>
<h2 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h2><p>最大年龄为15，因为Object header采用4bit来保存年龄，最大值为15<br>​</p>
<h3 id="Java的引用"><a href="#Java的引用" class="headerlink" title="Java的引用"></a>Java的引用</h3><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><h4 id="强引用（StrongReference）"><a href="#强引用（StrongReference）" class="headerlink" title="强引用（StrongReference）"></a>强引用（StrongReference）</h4><pre><code>强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。  ps：强引用其实也就是我们平时A a = new A()这个意思。
</code></pre>
<h4 id="软引用（SoftReference）"><a href="#软引用（SoftReference）" class="headerlink" title="软引用（SoftReference）"></a>软引用（SoftReference）</h4><pre><code>如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存（下文给出示例）。
</code></pre>
<p>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。</p>
<h4 id="弱引用（WeakReference）"><a href="#弱引用（WeakReference）" class="headerlink" title="弱引用（WeakReference）"></a>弱引用（WeakReference）</h4><pre><code>弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。
</code></pre>
<p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p>
<h4 id="-2"><a href="#-2" class="headerlink" title=""></a></h4><p>虚引用（PhantomReference）</p>
<pre><code>“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。
</code></pre>
<p>虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之 关联的引用队列中。<br>​</p>
<h3 id="识别垃圾方法"><a href="#识别垃圾方法" class="headerlink" title="识别垃圾方法"></a>识别垃圾方法</h3><p>​</p>
<h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p>对每个对象的引用进行计数，每当有一个地方引用它时计数器 +1、引用失效则 -1，引用的计数放到对象头中，大于 0 的对象被认为是存活对象。虽然循环引用的问题可通过 Recycler 算法解决，但是在多线程环境下，引用计数变更也要进行昂贵的同步操作，性能较低，早期的编程语言会采用此算法。<br>​</p>
<p>​</p>
<h4 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h4><p>又称引用链法（Tracing GC）： 从 GC Root 开始进行对象搜索，可以被搜索到的对象即为可达对象，此时还不足以判断对象是否存活/死亡，需要经过多次标记才能更加准确地确定，整个连通图之外的对象便可以作为垃圾被回收掉。目前 Java 中主流的虚拟机均采用此算法。<br>GC Root 包括：<br>1、虚拟机栈中引用的对象<br>2、方法区中类静态属性引用的对象<br>3、方法区中常量引用的对象<br>4、本地方法栈中JNI(一般说的Native方法)引用的对象<br>​</p>
<p>在可达性分析中不可达的对象里，它们会暂时处于一个缓刑的过程，要真正宣布一个对象的死亡，至少要再次经历标记过程，标记的前提是不可达对象。<br>第一次标记并进行筛选，当对象没有覆盖finalize方法或者已经被虚拟机执行过了，则该对象被回收<br>第二次标记，进行此过程的对象会被放到一个F-Queue的队列里，并由虚拟机建立的低优先级的Finalizer线程去执行相应的finalize方法，但不会承诺等待它运行结束，防止执行过程中一些问题导致F-Queque其他对象永久处于等待状态。稍后GC将对F-Queque中的对象进行第二次小规模标记，如果对象在finalize重新与引用链上任意对象建立关联，则逃脱被回收的命运。<br>​</p>
<h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><p>​</p>
<h4 id="Mark-Sweep（标记-清除）"><a href="#Mark-Sweep（标记-清除）" class="headerlink" title="Mark-Sweep（标记-清除）"></a>Mark-Sweep（标记-清除）</h4><p> 回收过程主要分为两个阶段，第一阶段为追踪（Tracing）阶段，即从 GC Root 开始遍历对象图，并标记（Mark）所遇到的每个对象，第二阶段为清除（Sweep）阶段，即回收器检查堆中每一个对象，并将所有未被标记的对象进行回收，整个过程不会发生对象移动。整个算法在不同的实现中会使用三色抽象（Tricolour Abstraction）、位图标记（BitMap）等技术来提高算法的效率，存活对象较多时较高效。<br>​</p>
<h4 id="Mark-Compact-（标记-整理）"><a href="#Mark-Compact-（标记-整理）" class="headerlink" title="Mark-Compact （标记-整理）"></a>Mark-Compact （标记-整理）</h4><pre><code> 这个算法的主要目的就是解决在非移动式回收器中都会存在的碎片化问题，也分为两个阶段，第一阶段与 Mark-Sweep 类似，第二阶段则会对存活对象按照整理顺序（Compaction Order）进行整理。主要实现有双指针（Two-Finger）回收算法、滑动回收（Lisp2）算法和引线整理（Threaded Compaction）算法等。
</code></pre>
<p>​</p>
<h4 id="Copying（复制）"><a href="#Copying（复制）" class="headerlink" title="Copying（复制）"></a>Copying（复制）</h4><p>将空间分为两个大小相同的 From 和 To 两个半区，同一时间只会使用其中一个，每次进行回收时将一个半区的存活对象通过复制的方式转移到另一个半区。有递归（Robert R. Fenichel 和 Jerome C. Yochelson提出）和迭代（Cheney 提出）算法，以及解决了前两者递归栈、缓存行等问题的近似优先搜索算法。复制算法可以通过碰撞指针的方式进行快速地分配内存，但是也存在着空间利用率不高的缺点，另外就是存活对象比较大时复制的成本比较高。<br>​</p>
<p><img data-src="https://gitee.com/littleeight/blog-images/raw/master/java%E7%9A%84jvm/6.png"></p>
<h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><h3 id="分代收集理论"><a href="#分代收集理论" class="headerlink" title="分代收集理论"></a>分代收集理论</h3><p>大部分虚拟机的垃圾回收器都是遵循<strong>分代收集</strong>的理论进行设计的，它的核心思想是根据对象存活的生命周期将内存划分为若干个不同的区域。一般至少将堆划分为新生代和老年代两个区域，然后可以根据不同代的特点采取最适合的回收算法。在新生代中，每次垃圾回收时都有大量对象死去，因为程序创建的绝大部分对象的生命周期都很短，朝生夕灭。而新生代每次回收后存活的少量对象，将会逐步晋升到老年代中存放。老年代每次垃圾收集时只有少量对象需要被回收，因为老年代的大部分对象一般都是全局变量引用的，生命周期一般都比较长。<br>在Java堆划分出不同的区域之后，垃圾回收器就可以每次只回收其中某一个或者某些部分的区域，因而也有了“Young GC”、“Old GC”、“Full GC”这样的回收类型的划分。也能够针对不同的区域安排与里面存储对象存亡特征相匹配的垃圾回收算法，因而发展出了“标记-复制算法”、“标记-清除算法”、“标记-整理算法”等针对性的垃圾回收算法。<br>GC类型：</p>
<ul>
<li>新生代收集（Minor GC/Young GC）：指目标只是新生代的垃圾收集。</li>
<li>老年代收集（Major GC/Old GC）：指目标只是老年代的垃圾收集。目前只有CMS收集器会有单独收集老年代的行为。</li>
<li>混合收集（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收集器会有这种行为。</li>
<li>整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集，包括新生代、老年代、方法区的回收，一般 Full GC 等价于 Old GC。</li>
</ul>
<p>​</p>
<h4 id="Serial"><a href="#Serial" class="headerlink" title="Serial"></a>Serial</h4><p>Serial 垃圾回收器是一个单线程回收器，它进行垃圾回收时，必须暂停其他所有用户线程，直到它回收结束。Serial 主要用于新生代垃圾回收，采用复制算法实现。<br>服务端程序几乎不会使用 Serial 回收器，服务端程序一般会分配较大的内存，可能几个G，如果使用 Serial 回收器，由于是单线程，标记、清理阶段就会花费很长的时间，就会导致系统较长时间的停顿。<br><strong>Serial 一般用在客户端程序或占用内存较小的微服务</strong>，因为客户端程序一般分配的内存都比较小，可能几十兆或一两百兆，回收时的停顿时间是完全可以接受的。而且 Serial 是所有回收器里额外消耗内存最小的，也没有线程切换的开销，非常简单高效。</p>
<h4 id="Serial-old"><a href="#Serial-old" class="headerlink" title="Serial old"></a>Serial old</h4><p>Serial Old 是 Serial 的老年代版本，它同样是一个单线程回收器，主要用于客户端程序。Serial Old 用于老年代垃圾回收，采用标记-整理算法实现。<br>Serial Old 也可以用在服务端程序，主要有两种用途：一种是与 Parallel Scavenge 回收器搭配使用，另外一种就是<strong>作为 CMS 回收器发生失败时的后备预案</strong>，在并发收集发生 <strong>Concurrent Mode Failure</strong> 时使用。</p>
<h4 id="Parnew"><a href="#Parnew" class="headerlink" title="Parnew"></a>Parnew</h4><p>ParNew 回收器实质上是 Serial 回收器的多线程并行版本，除了同时使用多条线程进行垃圾收集之外，其余的行为都与 Serial 回收完全一致，控制参数、回收算法、对象分配规则等都是一致的。除了 Serial 回收器外，目前只有 ParNew 回收器能与 CMS 回收器配合工作，ParNew 是激活CMS后的默认新生代回收器。<br>ParNew 默认开启的回收线程数与处理器核心数量相同，在处理器核心非常多的环境中，可以使用 **-XX: ParallelGCThreads **参数来限制垃圾回收的线程数。</p>
<h4 id="Parallel-Scanvenge"><a href="#Parallel-Scanvenge" class="headerlink" title="Parallel Scanvenge"></a>Parallel Scanvenge</h4><p>Parallel Scavenge 是新生代回收器，采用复制算法实现，也是能够并行回收的多线程回收器。Parallel Scavenge 主要关<strong>注可控制的吞吐量</strong>，其它回收器的关注点是尽可能地缩短垃圾回收时的停顿时间。吞吐量就是处理器用于运行程序代码的时间与处理器总消耗时间的比值，总消耗时间等于运行程序代码的时间加上垃圾回收的时间。<br>Parallel Scavenge 提供了两个参数用于精确控制吞吐量：</p>
<ul>
<li><strong>-XX: MaxGCPauseMillis</strong>：控制最大垃圾回收停顿时间，参数值是一个大于 0 的毫秒数，回收器将尽力保证垃圾回收花费的时间不超过这个值。</li>
<li><strong>-XX: GCTimeRatio</strong>：直接设置吞吐量大小，参数值是一个大于 0 小于 100 的整数，就是垃圾回收时间占总时间的比率。默认值为 99，即允许最大1%（即1/(1+99)）的垃圾收集时间。</li>
</ul>
<p>Parallel Scavenge 还有一个参数 <strong>-XX: +UseAdaptiveSizePolicy</strong>，当设置这个参数之后，就不需要人工指定新生代的大小、Eden与Survivor区的比例等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。</p>
<h4 id="Parallel-Old"><a href="#Parallel-Old" class="headerlink" title="Parallel Old"></a>Parallel Old</h4><p>Parallel Old 是 Parallel Scavenge 的老年代版本，支持多线程并发回收，采用标记-整理算法实现。在注重吞吐量或者处理器资源较为稀缺的场合，可以优先考虑 Parallel Scavenge 加 Parallel Old 这个组合。</p>
<h4 id="Cms"><a href="#Cms" class="headerlink" title="Cms"></a>Cms</h4><p>concurrent mark sweep是一种以<strong>获取最短回收停顿时间</strong>为目标的收集器。<br>CMS 垃圾回收总体分为四个步骤：</p>
<ul>
<li>1）<strong>初始标记（会STW）</strong>：初始标记需要 Stop The World，初始标记仅仅只是标记一下 <strong>GC Roots 能直接关联到的对象</strong>，速度很快。</li>
<li>2）<strong>并发标记</strong>：并发标记阶段就是从 GC Roots 的直接关联对象开始遍历整个对象引用链的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾回收线程一起并发运行。</li>
<li>3）<strong>重新标记（会STW）</strong>：重新标记需要 Stop The World，重新标记阶段是为了修正并发标记期间，因程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短。</li>
<li>4）<strong>并发清除</strong>：清除阶段是清理删除掉标记阶段判断的已经死亡的对象，由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发进行的。</li>
</ul>
<p>最耗时的并发标记和并发清除阶段是和用户线程并发进行的，总体上来说，CMS 回收过程是与用户线程一起并发执行的，是一款<strong>并发低停顿</strong>的回收器。<br>​</p>
<h5 id="触发cms的时机"><a href="#触发cms的时机" class="headerlink" title="触发cms的时机"></a>触发cms的时机</h5><p>CMS GC 在实现上分成 **foreground collector **和 <strong>background collector</strong>。</p>
<h5 id="foreground-collector"><a href="#foreground-collector" class="headerlink" title="foreground collector"></a>foreground collector</h5><p>foreground collector 触发条件比较简单，一般是遇到对象分配但空间不够，就会直接触发 GC，来立即进行空间回收。采用的算法是 mark sweep，不压缩。</p>
<h5 id="background-collector"><a href="#background-collector" class="headerlink" title="background collector"></a>background collector</h5><p>background collector 是通过 CMS 后台线程不断的去扫描，过程中主要是判断是否符合 background collector 的触发条件，一旦有符合的情况，就会进行一次 background 的 collect。每次扫描过程中，先等 CMSWaitDuration 时间（默认2秒），然后再判断是否满足 background collector 的触发条件。<br>background collector 的触发条件：</p>
<ul>
<li>并行 Full GC，如调用了 System.gc()</li>
<li>未配置 UseCMSInitiatingOccupancyOnly 时，会根据统计数据动态判断是否需要进行一次 CMS GC。如果预测 CMS GC 完成所需要的时间大于预计的老年代将要填满的时间，则进行 GC。这些判断是需要基于历史的 CMS GC 统计指标，第一次 CMS GC 时，统计数据还没有形成，是无效的，这时会跟据 Old Gen 的使用占比来判断是否要进行 GC。</li>
<li>未配置 UseCMSInitiatingOccupancyOnly 时，判断 CMS 的使用率大于 CMSBootstrapOccupancy（默认50%）时触发 Old GC。</li>
<li>老年代内存使用率阀值超过 CMSInitiatingOccupancyFraction（默认为92%）时触发 OldGC，CMSInitiatingOccupancyFraction 默认值为 -1，没有配置时默认阀值为 92%。</li>
<li>未配置 UseCMSInitiatingOccupancyOnly 时，因为分配对象时内存不足导致的扩容等触发GC</li>
</ul>
<pre><code>在没有配置 UseCMSInitiatingOccupancyOnly 参数的情况下，会多出很多种触发可能，一般在生产环境会配置 UseCMSInitiatingOccupancyOnly 参数，配了之后就不用设置 CMSBootstrapOccupancy 参数了。
</code></pre>
<p>CMSInitiatingOccupancyFraction 设置得太高将会很容易导致频繁的并发失败，性能反而降低；太低又可能频繁触发CMS background collector，一般在生产环境中应根据实际应用情况来权衡设置。<br><code>-XX:+UseConcMarkSweepGC  使用CMS       </code><br><code>-XX:CMSInitiatingOccupancyFraction=92      老年代内存使用率阀值超过指定比例时触发OldG </code><br><code>-XX:+UseCMSInitiatingOccupancyOnly  指定被使用的内存空间的阈值，达到该阈值则触发OldGC   </code><br><code>-XX:CMSBootstrapOccupancy=92  没配置上面那个参数时，老年代使用达到比较阈值触发OldGC </code><br><code>-xx:CMSWaitDuration=2000   每次扫描等待的毫秒时间</code></p>
<h5 id="CMS导致的问题"><a href="#CMS导致的问题" class="headerlink" title="CMS导致的问题"></a>CMS导致的问题</h5><p>1、并发回收导致CPU资源紧张<br>在并发阶段，它虽然不会导致用户线程停顿，但却会因为占用了一部分线程而导致应用程序变慢，降低程序总吞吐量。CMS默认启动的回收线程数是：<strong>（CPU核数 + 3）/ 4</strong>，当CPU核数不足四个时，CMS对用户程序的影响就可能变得很大。<br>2、无法清理浮动垃圾<br>在CMS的并发标记和并发清理阶段，用户线程还在继续运行，就还会伴随有新的垃圾对象不断产生，但这一部分垃圾对象是出现在标记过程结束以后，CMS无法在当次收集中处理掉它们，只好留到下一次垃圾收集时再清理掉。这一部分垃圾称为“浮动垃圾”。<br>3、并发失败（Concurrent Mode Failure）<br>由于在垃圾回收阶段用户线程还在并发运行，那就还需要预留足够的内存空间提供给用户线程使用，因此CMS不能像其他回收器那样等到老年代几乎完全被填满了再进行回收，必须预留一部分空间供并发回收时的程序运行使用。默认情况下，当老年代使用了 92% 的空间后就会触发 CMS 垃圾回收，这个值可以通过 -XX: CMSInitiatingOccupancyFraction 参数来设置。<br>这里会有一个风险：<strong>要是CMS运行期间预留的内存无法满足程序分配新对象的需要，就会出现一次“并发失败”（Concurrent Mode Failure）</strong> ，这时候虚拟机将不得不启动后备预案：Stop The World，**临时启用 Serial Old **来重新进行老年代的垃圾回收，这样一来停顿时间就很长了。<br>4、内存碎片问题<br>CMS是一款基于“标记-清除”算法实现的回收器，这意味着回收结束时会有内存碎片产生。内存碎片过多时，将会给大对象分配带来麻烦，往往会出现老年代还有很多剩余空间，但就是无法找到足够大的连续空间来分配当前对象，而不得不提前触发一次 Full GC 的情况。<br>为了解决这个问题，CMS收集器提供了一个 -XX:+UseCMSCompactAtFullCollection 开关参数（默认开启），用于在 Full GC 时开启内存碎片的合并整理过程，由于这个内存整理必须移动存活对象，是无法并发的，这样停顿时间就会变长。还有另外一个参数 -XX:CMSFullGCsBeforeCompaction，这个参数的作用是要求CMS在执行过若干次不整理空间的 Full GC 之后，下一次进入 Full GC 前会先进行碎片整理（默认值为0，表示每次进入 Full GC 时都进行碎片整理）。</p>
<h4 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h4><p><strong>G1 (Garbage First)</strong> 回收器采用面向局部收集的设计思路和基于Region的内存布局形式，是一款主要面向服务端应用的垃圾回收器。G1设计初衷就是替换 CMS，成为一种全功能收集器。<strong>G1 在JDK9 之后成为服务端模式下的默认垃圾回收器</strong>，取代了 Parallel Scavenge 加 Parallel Old 的默认组合，而 CMS 被声明为不推荐使用的垃圾回收器。G1从整体来看是基于 标记-整理 算法实现的回收器，但从局部（两个Region之间）上看又是基于 标记-复制 算法实现的。<br>G1 可以指定垃圾回收的停顿时间，通过 **-XX: MaxGCPauseMillis **参数指定，默认为 200 毫秒。这个值不宜设置过低，否则会导致每次回收只占堆内存很小的一部分，回收器的回收速度逐渐赶不上对象分配速度，导致垃圾慢慢堆积，最终占满堆内存导致 Full GC 反而降低性能。<br>G1之所以能建立可预测的停顿时间模型，是因为它将 Region 作为单次回收的最小单元，即每次回收到的内存空间都是 Region 大小的整数倍，这样可以有计划地避免在整个Java堆中进行全区域的垃圾回收。G1会去跟踪各个Region的垃圾回收价值，价值即回收所获得的空间大小以及回收所需时间的经验值，然后在后台维护一个优先级列表，每次根据用户设定允许的回收停顿时间，优先处理回收价值收益最大的那些 Region。这种使用 Region 划分内存空间，以及具有优先级的区域回收方式，保证了 G1 回收器在有限的时间内得到尽可能高的回收效率。<br>由于 Region 数量比传统回收器的分代数量明显要多得多，因此G1回收器要比其他的传统垃圾回收器有着更高的内存占用负担。G1至少要耗费大约相当于Java堆容量 10%至20% 的额外内存来维持回收器工作。<br>​</p>
<p>G1不再是固定大小以及固定数量的分代区域划分，而是把堆划分为多个大小相等的Region，<strong>每个Region的大小默认情况下是堆内存大小除以2048</strong>，因为JVM最多可以有2048个Region，而且每个Region的大小必须是2的N次冥。每个Region的大小也可以通过参数 -XX:G1HeapRegionSize 设定，取值范围为1MB～32MB，且应为2的N次幂。<br><img data-src="https://gitee.com/littleeight/blog-images/raw/master/java%E7%9A%84jvm/7.png"></p>
<p>G1 回收器的运作过程大致可分为四个步骤：</p>
<ul>
<li><strong>初始标记（会STW）</strong>：仅仅只是标记一下 GC Roots 能直接关联到的对象，并且修改 TAMS 指针的值，让下一阶段用户线程并发运行时，能正确地在可用的 Region 中分配新对象。这个阶段需要停顿线程，但耗时很短，而且是借用进行 Minor GC 的时候同步完成的，所以G1收集器在这个阶段实际并没有额外的停顿。</li>
<li><strong>并发标记：</strong>从 GC Roots 开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。当对象图扫描完成以后，还要重新处理在并发时有引用变动的对象。</li>
<li><strong>最终标记（会STW）</strong>：对用户线程做短暂的暂停，处理并发阶段结束后仍有引用变动的对象。</li>
<li><strong>清理阶段（会STW）</strong>：更新 Region 的统计数据，对各个 Region 的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个 Region 构成回收集，然后把决定回收的那一部分 Region 的存活对象复制到空的 Region 中，再清理掉整个旧 Region 的全部空间。这里的操作涉及存活对象的移动，必须暂停用户线程，由多条回收器线程并行完成的。</li>
</ul>
<p>​</p>
<p>G1有一个参数，**-XX:InitiatingHeapOccupancyPercent<strong>，它的默认值是 45%，就是如果老年代占堆内存 45% 的 Region 的时候，此时就会触发一次年轻代+老年代的</strong>混合回收<strong>。<br>混合回收阶段，因为我们设定了最大停顿时间，所以 G1 会从新生代、老年代、大对象里挑选一些 Region，保证指定的时间内回收尽可能多的垃圾。所以 G1 可能一次无法将所有Region回收完，它就会执行多次混合回收，先停止程序，执行一次混合回收回收掉一些Region，接着恢复系统运行，然后再次停止系统运行，再执行一次混合回收回收掉一些Region。可以通过参数 -XX:G1MixedGCCountTarget 设置一次回收的过程中，最后一个阶段最多执行几次混合回收，默认值是8次。通过这种反复回收的方式，避免系统长时间的停顿。<br>G1还有一个参数</strong> -XX:G1HeapWastePercent<strong>，默认值是 5%。就是在混合回收时，Region回收后，就会不断的有新的Region空出来，</strong>一旦空闲出来的Region数量超过堆内存的5%，就会立即停止混合回收<strong>，即本次混合回收就结束了。<br>G1还有一个参数</strong> -XX:G1MixedGCLiveThresholdPercent<strong>，默认值是85%。意思是回收Region的时候，必须存活对象低于Region大小的85%时才可以进行回收，</strong>一个Region存活对象超过85%，就不必回收它了**，因为要复制大部分存活对象到别的Region，这个成本是比较高的。</p>
<h5 id="Zgc"><a href="#Zgc" class="headerlink" title="Zgc"></a>Zgc</h5><p>分为<strong>Mark（标记）、Relocate（迁移）、Remap（重映射）</strong>三个阶段</p>
<ul>
<li>Mark: 所有活的对象都被记录在对应Page的Livemap（活对象表，bitmap实现）中，以及对象的Reference（引用）都改成已标记（Marked0或Marked1）状态</li>
<li>Relocate: 根据页面中活对象占用的大小选出的一组Page，将其中中的活对象都复制到新的Page, 并在额外的forward table（转移表）中记录对象原地址和新地址对应关系</li>
<li>Remap: 所有Relocated的活对象的引用都重新指向了新的正确的地址</li>
</ul>
<p>​</p>
<h3 id="新生代晋升条件"><a href="#新生代晋升条件" class="headerlink" title="新生代晋升条件"></a>新生代晋升条件</h3><p>1、Java 默认启用了分代 GC<br>2、启用分代 GC 的，在发生 Young GC，更准确地说是在 Survivor 区复制的时候，存活的对象的分代年龄会加1。<br>3、当分代年龄 = -XX:MaxTenuringThreshold 指定的大小时，对象进入老年代<br>4、还有动态晋升到老年代的机制，首先根据 -XX:TargetSurvivorRatio （默认 50，也就是 50%） 指定的比例，乘以 survivor 一个区的大小，得出目标晋升空间大小。然后将分代对象大小，按照分代年龄从小到大相加，直到大于目标晋升空间大小。之后，将得出的这个分代年龄以上的对象全部晋升。<br>对于一些的GC 算法，还可能直接在老年代上面分配，例如 G1 GC 中的 humongous allocations（大对象分配），就是对象在超过 Region 一半大小的时候，直接在老年代的连续空间分配。<br>​</p>
<h3 id="GC触发条件"><a href="#GC触发条件" class="headerlink" title="GC触发条件"></a>GC触发条件</h3><p>当 JVM 无法为一个新的对象分配空间时会触发 Young GC。<br>虚拟机在进行Young GC之前会判断老年代最大的可用连续空间是否大于新生代的所有对象总空间。<br>1、如果大于的话，直接执行Young GC<br>2、如果小于，判断是否开启HandlerPromotionFailure，没有开启直接FullGC<br>3、如果开启了HanlerPromotionFailure, JVM会判断老年代的最大连续内存空间是否大于历次晋升的大小，如果小于直接执行FullGC<br>4、如果大于的话，执行Young GC</p>
<h4 id="Full-GC触发条件"><a href="#Full-GC触发条件" class="headerlink" title="Full GC触发条件"></a>Full GC触发条件</h4><p>Full GC定义是相对明确的，就是针对整个新生代、老生代、元空间（metaspace，java8以上版本取代perm gen）的全局范围的GC；<br>1、调用System.gc()时，系统建议执行Full GC，但是不必然执行<br>2、老年代空间不足<br>3、方法区空间不足<br>4、通过Minor GC后进入老年代的平均大小大于老年代的可用内存<br>由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小<br>System.gc()这个东西提醒的是Full GC，不是Minor GC。</p>
<p>​</p>
<h3 id="GC调优"><a href="#GC调优" class="headerlink" title="GC调优"></a>GC调优</h3><h4 id="合理分配年轻代内存"><a href="#合理分配年轻代内存" class="headerlink" title="合理分配年轻代内存"></a>合理分配年轻代内存</h4><p>假设一个秒杀下单接口，估计一次成功下单创建的对象总和是30KB，那每秒30个下单的话就是900KB,半小时就是1.5GB左右，我们可以考虑增大新生代内存，同时使用内存大一点的机器，比如使用4核8G，那么JVM分4G，给堆空间分配3G，新生代给1.5G，老年代给1.5G，Eden 区差不多1.2G，Survivor区150M，这个时候Eden区差不多要半个小时才会占满，然后触发一次YoungGC，而其中99%都是垃圾对象，采用标记-复制算法基本上很能就能完成YoungGC，这就大大降低了YoungGC的频率。<br>如果业务量更大，还可以考虑横向多部署几台机器，这样分到每台机器的请求就更少了，压力也更小。<br>​</p>
<p>为了防止Young GC时复制对象到survivor，但因为它太小频繁把对象移到老年代，所以survivor区设置大一些。</p>
<h4 id="优化gc年龄阈值"><a href="#优化gc年龄阈值" class="headerlink" title="优化gc年龄阈值"></a>优化gc年龄阈值</h4><p>在5分钟左右就Young GC的情况下，可以通过** -XX:MaxTenuringThreshold=5** 参数降低年龄阀值，比如设置为 5，这样的话可减少那些长时间存活的比如bean对象直接进入老年代，不用在新生代来回复制。</p>
<h4 id="优化大对象阈值"><a href="#优化大对象阈值" class="headerlink" title="优化大对象阈值"></a>优化大对象阈值</h4><p>还有一种情况就是大对象将直接进入老年代，大对象阀值一般设置1M就够了，一般来说很少有一个对象超过1M的。如果我们确定系统中会频繁创建生命周期短的大对象，我们可以适当调大这个阀值，避免其进入老年代。<br>可以通过参数** -XX:PretenureSizeThreshold=1M** 来设置大对象阀值。<br>​</p>
<h4 id="选择合适的gc收集器"><a href="#选择合适的gc收集器" class="headerlink" title="选择合适的gc收集器"></a>选择合适的gc收集器</h4><p>如果关注的是可控制的吞吐量，则选择 paraller scanvenge + paraller old，如果是关注的是程序停顿时间（在高并发时）可选择 parnew + cms。</p>
<h2 id="Jvm一些参数"><a href="#Jvm一些参数" class="headerlink" title="Jvm一些参数"></a>Jvm一些参数</h2><p>-Xms525m，初始堆大小，默认为物理内存的1/64<br>-Xmx525m，最大堆大小，默认为物理内存的1/4<br>-Xmn252m，新生代的堆大小，通常为Xmx的1/3\1/4,<br>-Xss,每个线程堆栈大小，一般为1M<br>-XX：NewRatio：新生代与老年代的比例，如–XX:NewRatio=2，则新生代占整个堆空间的1/3，老年代占2/3<br>-XX：SurvivroRatio：新生代中Eden 与 Survivor 的比值。默认值为 8。即 Eden 占新生代空间的 8/10，另外两个 Survivor 各占 1/10<br>-XX：NewSize：新生代初始大小<br>-XX：MaxNewSize：新生代最大大小<br>-XX：PermSize：方法区的初始大小<br>-XX：MaxPermSize：方法区的最大大小<br>-XX：+PrintGCDetails：打印GC信息，java8已弃用，改成 -Xlog:gc*<br>-XX：HeapDumpOnOutOfMemoryError 虚拟机在发生内存溢出时Dump 出当前的内存堆转储快照，以便分析用<br>-XX:HeapDumpPath=/home/liuke/jvmlogs/ 生成堆文件地址<br>-XX：UserSerialGC<br>-XX:MaxTenuringThreshold=size：进入老年代的年龄<br>​</p>
<h2 id="jvm参数设置模板"><a href="#jvm参数设置模板" class="headerlink" title="jvm参数设置模板"></a>jvm参数设置模板</h2><p>对于一般的系统，我们可能使用4核8G的机器来部署，那么总结一套模板如下：</p>
<ul>
<li>堆内存分配4G，新生代3G，老年代1G，Eden区2.4G，Survivor区各300M，一般来说YoungGC后存活的对象小于150M就没太大问题</li>
<li>元空间给个 512M 一般就足够了，如果系统会运行时创建很多类，可以调大这个值</li>
<li>-XX:MaxTenuringThreshold 对象GC年龄调整为5岁，让长期存活的对象更快的进入老年代</li>
<li>-XX:PretenureSizeThreshold 大对象阀值设置为1M，如果有超过1M的大对象，可以调整下这个值</li>
<li>-XX:+UseParNewGC、-XX:+UseConcMarkSweepGC，垃圾回收器使用 ParNew + CMS 的组合</li>
<li>-XX:CMSFullGCsBeforeCompaction 设置为0，cms每次FullGC后都进行一次内存碎片整理</li>
<li>-XX:+CMSParallelInitialMarkEnabled，CMS初始标记阶段开启多线程并发执行，降低FullGC的时间</li>
<li>-XX:+CMSScavengeBeforeRemark，CMS重新标记阶段之前，先尽量执行一次Young GC</li>
<li>-XX:+DisableExplicitGC，禁止显示手动GC</li>
<li>-XX:+HeapDumpOnOutOfMemoryError，OOM时导出堆快照便于分析问题</li>
<li>-XX:+PrintGC，打印GC日志便于出问题时分析问题</li>
</ul>
<p>​</p>
<h2 id="Jvm工具"><a href="#Jvm工具" class="headerlink" title="Jvm工具"></a>Jvm工具</h2><h3 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h3><p>1、查看Java进程PID<br>命令：<strong>jps -l</strong><br>左边一列就是Java进程的PID。<br><img data-src="https://gitee.com/littleeight/blog-images/raw/master/java%E7%9A%84jvm/8.png"></p>
<p>2、输出传递给JVM的参数<br>命令：<strong>jps -vl</strong><br><strong>​</strong></p>
<h3 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h3><p>参数列表  jstat  xxx  pid</p>
<ul>
<li>-class：显示 ClassLoad 的相关信息；</li>
<li>-compiler：显示 JIT 编译的相关信息；</li>
<li>-gc：显示和 gc 相关的堆信息；</li>
<li>-gccapacity：显示各个代的容量以及使用情况；</li>
<li>-gcmetacapacity：显示 Metaspace 的大小；</li>
<li>-gcnew：显示新生代信息；</li>
<li>-gcnewcapacity：显示新生代大小和使用情况；</li>
<li>-gcold：显示老年代和永久代的信息；</li>
<li>-gcoldcapacity：显示老年代的大小；</li>
<li>-gcutil：显示垃圾收集信息；</li>
<li>-gccause：显示垃圾回收的相关信息（同 -gcutil），同时显示最后一次或当前正在发生的垃圾回收的诱因；</li>
<li>-printcompilation：输出 JIT 编译的方法信息</li>
</ul>
<p>​</p>
<p>其中** jstat -gc **是最完整、最常用、最实用的命令，基本足够分析jvm的运行情况了。</p>
<h3 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h3><p>使用 <strong>jmap</strong> 可查看堆内存初始化配置信息以及堆内存的使用情况，输出堆内存中的对象信息，包括产生了哪些对象，对象数量多少等。</p>
<h2 id="​"><a href="#​" class="headerlink" title="​"></a>​</h2><p>1、查看堆内存情况<br>命令：jmap -heap <PID><br>这个命令会打印出堆内存相关的一些参数设置以及各个区域的情况，要查看这些信息一般使用 jstat 命令就足够了。<br>2、查看系统运行时对象分布<br>命令：jmap -histo[:live] <PID>，带上 live 则只统计活对象<br>这个命令会按照各种对象占用内存空间的大小降序排列，把占用内存最多的对象放在最上面。通过这个命令可以简单的了解下当前jvm中的对象对内存占用的情况以及当前内存里到底是哪个对象占用了大量的内存空间。<br>生成堆内存转储快照<br>命令：jmap -dump:format=b,file=<path> <pid><br>命令：jmap -dump:live,format=b,file=<path> <pid><br>jmap -dump 是输出堆中所有对象；jmap -dump:live 是输出堆中所有活着的对象，而且 jmap -dump:live 会触发 FullGC，线上使用要注意。format=b 是以二进制格式输出；file 是文件路径，格式为 hrpof 后缀。<br>这个命令会在当前目录下生成一个 dump.hrpof 文件，这是个二进制的格式，无法直接打开，可以使用MAT等工具来分析。这个命令把这一时刻VM堆内存里所有对象的快照放到文件里去了，供你后续去分析。</p>
<h3 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h3><p><strong>jstack</strong> 是一种线程堆栈分析工具，最常用的功能就是使用 jstack pid 命令查看线程的堆栈信息，通常会结合 top -Hp pid 或 pidstat -p pid -t 一起查看具体线程的状态，也经常用来排查一些死锁的异常、CPU占用高的线程等。<br>​</p>
<h4 id="top"><a href="#top" class="headerlink" title="top"></a>top</h4><p>top 命令是我们在 Linux 下最常用的命令之一，它可以实时显示正在执行进程的 CPU 使用率、内存使用率以及系统负载等信息。其中上半部分显示的是系统的统计信息，下半部分显示的是进程的使用率统计信息。<br><img data-src="https://gitee.com/littleeight/blog-images/raw/master/java%E7%9A%84jvm/9.png"></p>
<p>看第一行：主要展示了CPU的负载情况</p>
<ul>
<li>02:37:55 ：指的是当前时间</li>
<li>up 4 min, 12:18：指的是机器已经运行了多长时间</li>
<li>1 user：当前机器有一个用户在使用</li>
<li>load average: 0.02, 0.10, 0.05：指 CPU 在1分钟、5分钟、15分钟内的负载情况。</li>
<li>Tasks:328 total 表示当前系统的进程总数。</li>
<li>2 running 表示当前系统中有 2 个正在运行的进程。</li>
<li>250 sleeping 表示当前系统中有 250个休眠的进程。</li>
<li>0 stopped 表示停止状态的进程数为 0。</li>
<li>0 zombie 表示处于僵死状态的进程数为 0。</li>
<li>us,进程在用户地址空间中消耗 CPU 时间的百分比。像 shell程序、各种语言的编译器、数据库应用、web 服务器和各种桌面应用都算是运行在用户地址空间的进程。这些程序如果不是处于 idle 状态，那么绝大多数的 CPU 时间都是运行在用户态。</li>
<li>sy,进程在内核地址空间中消耗 CPU 时间的百分比。所有进程要使用的系统资源都是由 Linux 内核处理的。当处于用户态(用户地址空间)的进程需要使用系统的资源时，比如需要分配一些内存、或是执行 IO 操作、再或者是去创建一个子进程，此时就会进入内核态(内核地址空间)运行。事实上，决定进程在下一时刻是否会被运行的进程调度程序就运行在内核态。对于操作系统的设计来说，消耗在内核态的时间应该是越少越好。在实践中有一类典型的情况会使 sy 变大，那就是大量的 IO 操作，因此在调查 IO 相关的问题时需要着重关注它。</li>
<li>ni，ni 是 nice 的缩写，可以通过 nice 值调整进程用户态的优先级。这里显示的 ni 表示调整过 nice 值的进程消耗掉的 CPU 时间。如果系统中没有进程被调整过 nice 值，那么 ni 就显示为 0。</li>
<li>id，CPU 处于 idle 状态的百分比。一般情况下， us + ni + id 应该接近 100%。</li>
<li>wa，CPU 等待磁盘 IO 操作的时间。和 CPU 的处理速度相比，磁盘 IO 操作是非常慢的。有很多这样的操作，比如：CPU 在启动一个磁盘读写操作后，需要等待磁盘读写操作的结果。在磁盘读写操作完成前，CPU 只能处于空闲状态。Linux 系统在计算系统平均负载时会把 CPU 等待 IO 操作的时间也计算进去，所以在我们看到系统平均负载过高时，可以通过 wa 来判断系统的性能瓶颈是不是过多的 IO 操作造成的。</li>
<li>hi &amp; si，这两个值表示系统处理中断消耗的时间。中断分为硬中断和软中断，hi 表示处理硬中断消耗的时间，si 表示处理软中断消耗的时间。硬中断是硬盘、网卡等硬件设备发送给 CPU 的中断消息，当 CPU 收到中断消息后需要进行适当的处理(消耗 CPU 时间)。软中断是由程序发出的中断，最终也会执行相应的处理程序(消耗 CPU 时间)。</li>
<li>st，只有 Linux 在作为虚拟机运行时 st 才是有意义的。它表示虚机等待 CPU 资源的时间(虚机分到的是虚拟 CPU，当需要真实的 CPU 时，可能真实的 CPU 正在运行其它虚机的任务，所以需要等待)。</li>
</ul>
<p>最重要的就是看** load average**，比如机器是4核CPU，那么0.02, 0.10, 0.05，说明4核中连一个核都没用满，4核CPU基本很空闲。如果CPU负载是1，说明有1个核被使用的比较繁忙了。如果负载是4，说明4核CPU都跑满了；如果超过4，说明4核CPU被繁忙的使用还不够处理当前的任务，很多进程可能一直在等待CPU去执行自己的任务。<br>​</p>
<h4 id="pidstat"><a href="#pidstat" class="headerlink" title="pidstat"></a>pidstat</h4><p>如果是监视某个应用的上下文切换，可以使用 <strong>pidstat</strong> 命令监控指定进程的上下文切换。<br>pidstat 是 Sysstat 中的一个组件，也是一款功能强大的性能监测工具，我们可以通过命令：yum install sysstat 安装该监控组件。top 和 vmstat 两个命令都是监测进程的内存、CPU 以及 I/O 使用情况，而 pidstat 命令则是深入到线程级别。<br>查看所有进程的 CPU 使用情况<br>命令：pidstat -u -p ALL<br>​</p>
<p>​</p>
<h3 id="arthas工具"><a href="#arthas工具" class="headerlink" title="arthas工具"></a>arthas工具</h3><p>Arthas 是一款开源在线 Java 诊断工具，采用命令行交互模式，支持 web 端在线诊断，同时提供丰富的 Tab 自动补全功能，进一步方便进行问题的定位和诊断。得益于 Arthas 强大且丰富的功能，让 Arthas 能做的事情超乎想象。<br>它可以帮你解决这些问题：</p>
<ol>
<li>这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？</li>
<li>我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？</li>
<li>遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？</li>
<li>线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！</li>
<li>是否有一个全局视角来查看系统的运行状况？</li>
<li>有什么办法可以监控到 JVM 的实时运行状态？</li>
<li>怎么快速定位应用的热点，生成火焰图？<h4 id="运行原理"><a href="#运行原理" class="headerlink" title="运行原理"></a>运行原理</h4><img data-src="https://gitee.com/littleeight/blog-images/raw/master/java%E7%9A%84jvm/10.png"></li>
</ol>
<h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><p>1、sc 和 sm<br>通过sc可以查看已加载类的相关信息，比如该类是从哪个jar包加载的，被哪个类加载器加载的，以及是否是接口等等。<br>sm查看已加载类的方法详情。<br>2、dashboard<br>进入当前系统的实时数据面板，按 ctrl+c 退出。这个面板会实时刷新，其中包括线程信息、内存信息、gc信息、还有一些运行时的数据。<br>    另外，当运行在Ali-tomcat时，会显示当前tomcat的实时信息，如HTTP请求的qps, rt, 错误数, 线程池信息等等。<br>​</p>
<p>3、thread<br>通过thread命令可以查看当前jvm进程的线程详情。可以查看线程的cpu使用时间占比，通过指定各种参数可以找出最忙的几个线程，以及阻塞其他线程的线程。具体如何使用这里不多做介绍，大家可以去看arthas的官方文档。<br>​</p>
<p>4、jvm<br>通过jvm命令直接输出当前jvm的各种信息。<br>5、getstatic<br>通过getstatic命令可以方便的查看类的静态属性。<br>​</p>
<p>6、sysprop和sysenv<br>通过sysprop可以查看所有的系统变量，也可以设置某个系统变量。<br>同理，通过sysenv可以查看所有的操作系统环境变量，也可以查看设置某个环境变量。<br>​</p>
<p>7、jad<br>有时我们经常会不确定线上或者测试环境的包是否是我们修改过的，这时候就可以通过jad反编译来看下。<br>​</p>
<p>8、watch<br>让你能方便的观察到指定方法的调用情况。能观察到的范围为：返回值、抛出异常、入参，通过编写 OGNL 表达式进行对应变量的查看。<br>watch的使用姿势比较丰富，可以在四个不同的场景观察方法的执行。比如方法调用之前、方法调用之后、方法异常之后、方法结束之后。默认观察的是方法结束之后。<br>如果观察的是方法结束之后的场景，由于入参可能在执行方法时被改变，所以此时输出的可能不是真正的入参。因此，要看真正的入参，要看方法调用之前的，也就是加上-b的参数。<br>另外，使用-b参数观察的话，则观察不到方法返回的结果以及抛出的异常了。<br>9、monitor<br>monitor命令可以监控方法的执行情况。比如调用成功次数，失败次数，失败率、平均执行时间等等。默认120秒输出一次，也就是说，当我们输入monitor命令之后，每120秒就会输出一次统计结果。<br>​</p>
<p>10、trace<br>方法内部调用路径，并输出方法路径上的每个节点上耗时，tt命令会记录每次方法调用的各种信息。它和watch有些相似但是它能记录下各个时间点的调用信息，之后随时查看，甚至replay这次调用。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>little_eight</tag>
      </tags>
  </entry>
  <entry>
    <title>java面试题（二）</title>
    <url>/2018/10/03/java%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h2 id="面向对象的特征有哪些方面"><a href="#面向对象的特征有哪些方面" class="headerlink" title="面向对象的特征有哪些方面?"></a>面向对象的特征有哪些方面?</h2><p>答：面向对象的特征主要有以下几个方面：</p>
<ul>
<li>抽象：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。</li>
<li>继承：继承是从已有类得到继承信息创建新类的过程。提供继承信息的类被称为父类（超类、基类）；得到继承信息的类被称为子类（派生类）。继承让变化中的软件系统有了一定的延续性，同时继承也是封装程序中可变因素的重要手段（如果不能理解请阅读阎宏博士的《Java与模式》或《设计模式精解》中关于桥梁模式的部分）。</li>
<li>封装：通常认为封装是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。面向对象的本质就是将现实世界描绘成一系列完全自治、封闭的对象。我们在类中编写的方法就是对实现细节的一种封装；我们编写一个类就是对数据和数据操作的封装。可以说，封装就是隐藏一切可隐藏的东西，只向外界提供最简单的编程接口（可以想想普通洗衣机和全自动洗衣机的差别，明显全自动洗衣机封装更好因此操作起来更简单；我们现在使用的智能手机也是封装得足够好的，因为几个按键就搞定了所有的事情）。</li>
<li>多态性：多态性是指允许不同子类型的对象对同一消息作出不同的响应。简单的说就是用同样的对象引用调用同样的方法但是做了不同的事情。多态性分为编译时的多态性和运行时的多态性。如果将对象的方法视为对象向外界提供的服务，那么运行时的多态性可以解释为：当A系统访问B系统提供的服务时，B系统有多种提供服务的方式，但一切对A系统来说都是透明的（就像电动剃须刀是A系统，它的供电系统是B系统，B系统可以使用电池供电或者用交流电，甚至还有可能是太阳能，A系统只会通过B类对象调用供电的方法，但并不知道供电系统的底层实现是什么，究竟通过何种方式获得了动力）。方法重载（overload）实现的是编译时的多态性（也称为前绑定），而方法重写（override）实现的是运行时的多态性（也称为后绑定）。运行时的多态是面向对象最精髓的东西，要实现多态需要做两件事：<ul>
<li>方法重写（子类继承父类并重写父类中已有的或抽象的方法）</li>
<li>对象造型（用父类型引用引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。<h2 id="访问修饰符public-private-protected-以及不写（默认）时的区别？"><a href="#访问修饰符public-private-protected-以及不写（默认）时的区别？" class="headerlink" title="访问修饰符public,private,protected,以及不写（默认）时的区别？"></a>访问修饰符public,private,protected,以及不写（默认）时的区别？</h2>答：区别如下：</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>作用域</th>
<th align="right">当前类</th>
<th align="center">同包</th>
<th align="right">子类</th>
<th align="center">其他</th>
</tr>
</thead>
<tbody><tr>
<td>public</td>
<td align="right">√</td>
<td align="center">√</td>
<td align="right">√</td>
<td align="center">√</td>
</tr>
<tr>
<td>protected</td>
<td align="right">√</td>
<td align="center">√</td>
<td align="right">√</td>
<td align="center">×</td>
</tr>
<tr>
<td>default</td>
<td align="right">√</td>
<td align="center">√</td>
<td align="right">×</td>
<td align="center">×</td>
</tr>
<tr>
<td>private</td>
<td align="right">√</td>
<td align="center">×</td>
<td align="right">×</td>
<td align="center">×</td>
</tr>
<tr>
<td>类的成员不写访问修饰时默认为default。默认对于同一个包中的其他类相当于公开（public），对于不是同一个包中的其他类相当于私有（private）。受保护（protected）对子类相当于公开，对不是同一包中的没有父子关系的类相当于私有。</td>
<td align="right"></td>
<td align="center"></td>
<td align="right"></td>
<td align="center"></td>
</tr>
</tbody></table>
<h2 id="String-是最基本的数据类型吗"><a href="#String-是最基本的数据类型吗" class="headerlink" title="String 是最基本的数据类型吗?"></a>String 是最基本的数据类型吗?</h2><p>答：不是。Java中的基本数据类型只有8个：byte、short、int、long、float、double、char、boolean；除了基本类型（primitive type）和枚举类型（enumeration type），剩下的都是引用类型（reference type）。</p>
<h2 id="float-f-3-4-是否正确"><a href="#float-f-3-4-是否正确" class="headerlink" title="float f=3.4;是否正确?"></a>float f=3.4;是否正确?</h2><p>答:不正确。3.4是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成精度损失，因此需要强制类型转换float f =(float)3.4; 或者写成float f =3.4F;。</p>
<h2 id="short-s1-1-s1-s1-1-有错吗-short-s1-1-s1-1-有错吗"><a href="#short-s1-1-s1-s1-1-有错吗-short-s1-1-s1-1-有错吗" class="headerlink" title="short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗?"></a>short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗?</h2><p>答：对于short s1 = 1; s1 = s1 + 1;由于1是int类型，因此s1+1运算结果也是int 型，需要强制转换类型才能赋值给short型。而short s1 = 1; s1 += 1;可以正确编译，因为s1+= 1;相当于s1 = (short)(s1 + 1);其中有隐含的强制类型转换。</p>
<span id="more"></span>
<h2 id="Java-有没有goto"><a href="#Java-有没有goto" class="headerlink" title="Java 有没有goto?"></a>Java 有没有goto?</h2><p>答：goto 是Java中的保留字，在目前版本的Java中没有使用。（根据James Gosling（Java之父）编写的《The Java Programming Language》一书的附录中给出了一个Java关键字列表，其中有goto和const，但是这两个是目前无法使用的关键字，因此有些地方将其称之为保留字，其实保留字这个词应该有更广泛的意义，因为熟悉C语言的程序员都知道，在系统类库中使用过的有特殊意义的单词或单词的组合都被视为保留字）</p>
<h2 id="int-和Integer-有什么区别"><a href="#int-和Integer-有什么区别" class="headerlink" title="int 和Integer 有什么区别?"></a>int 和Integer 有什么区别?</h2><p>答：Java是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入不是对象的基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java为每一个基本数据类型都引入了对应的包装类型（wrapper class），int的包装类就是Integer，从JDK 1.5开始引入了自动装箱/拆箱机制，使得二者可以相互转换。<br>Java 为每个原始类型提供了包装类型：<br>原始类型: boolean，char，byte，short，int，long，float，double<br>包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double</p>
<p>补充：最近还遇到一个面试题，也是和自动装箱和拆箱相关的，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Integer f1 = <span class="number">100</span>, f2 = <span class="number">100</span>, f3 = <span class="number">150</span>, f4 = <span class="number">150</span>;</span><br><span class="line">        System.out.println(f1 == f2);</span><br><span class="line">        System.out.println(f3 == f4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果不明就里很容易认为两个输出要么都是true要么都是false。首先需要注意的是f1、f2、f3、f4四个变量都是Integer对象，所以下面的==运算比较的不是值而是引用。装箱的本质是什么呢？当我们给一个Integer对象赋一个int值的时候，会调用Integer类的静态方法valueOf，如果看看valueOf的源代码就知道发生了什么。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span>(i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)&#123;</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>IntegerCache类就不贴出了，简单的说，如果字面量的值在-128到127之间，那么不会new新的Integer对象，而是直接引用常量池中的Integer对象，所以上面的面试题中f1==f2的结果是true，而f3==f4的结果是false。越是貌似简单的面试题其中的玄机就越多，需要面试者有相当深厚的功力。</p>
<h2 id="amp-和-amp-amp-的区别？"><a href="#amp-和-amp-amp-的区别？" class="headerlink" title="&amp;和&amp;&amp;的区别？"></a>&amp;和&amp;&amp;的区别？</h2><p>答：&amp;运算符有两种用法：(1)按位与；(2)逻辑与。&amp;&amp;运算符是短路与运算。逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true整个表达式的值才是true。&amp;&amp;之所以称为短路运算是因为，如果&amp;&amp;左边的表达式的值是false，右边的表达式会被直接短路掉，不会进行运算。很多时候我们可能都需要用&amp;&amp;而不是&amp;，例如在验证用户登录时判定用户名不是null而且不是空字符串，应当写为：username != null &amp;&amp;!username.equals(“”)，二者的顺序不能交换，更不能用&amp;运算符，因为第一个条件如果不成立，根本不能进行字符串的equals比较，否则会产生NullPointerException异常。注意：逻辑或运算符（|）和短路或运算符（||）的差别也是如此。</p>
<h2 id="解释内存中的栈（stack）、堆-heap-和静态存储区的用法。"><a href="#解释内存中的栈（stack）、堆-heap-和静态存储区的用法。" class="headerlink" title="解释内存中的栈（stack）、堆(heap)和静态存储区的用法。"></a>解释内存中的栈（stack）、堆(heap)和静态存储区的用法。</h2><p>答：通常我们定义一个基本数据类型的变量，一个对象的引用，还有就是函数调用的现场保存都使用内存中的栈空间；而通过new关键字和构造器创建的对象放在堆空间；程序中的字面量（literal）如直接书写的100、“hello”和常量都是放在静态存储区中。栈空间操作最快但是也很小，通常大量的对象都是放在堆空间，整个内存包括硬盘上的虚拟内存都可以被当成堆空间来使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> String(“hello”);</span><br></pre></td></tr></table></figure>
<p>上面的语句中str放在栈上，用new创建出来的字符串对象放在堆上，而“hello”这个字面量放在静态存储区。<br>补充：较新版本的Java中使用了一项叫“逃逸分析“的技术，可以将一些局部对象放在栈上以提升对象的操作性能。
 </p>
<h2 id="Math-round-11-5-等于多少-Math-round-11-5-等于多少"><a href="#Math-round-11-5-等于多少-Math-round-11-5-等于多少" class="headerlink" title="Math.round(11.5) 等于多少? Math.round(-11.5)等于多少?"></a>Math.round(11.5) 等于多少? Math.round(-11.5)等于多少?</h2><p>答：Math.round(11.5)的返回值是12，Math.round(-11.5)的返回值是-11。四舍五入的原理是在参数上加0.5然后进行下取整。<br>Math的其他方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Math.sqrt(a); <span class="comment">//计算平方根</span></span><br><span class="line">Math.cbrt(a); <span class="comment">//计算立方根</span></span><br><span class="line">Math.pow(a, b); <span class="comment">//计算a的b次方</span></span><br><span class="line">Math.max(a, b); <span class="comment">//计算最大值</span></span><br><span class="line">Math.min(a, b); <span class="comment">//计算最小值</span></span><br><span class="line">Math.abs(a); <span class="comment">//绝对值</span></span><br><span class="line">Math.ceil(-<span class="number">10.1</span>); <span class="comment">//-10.0，ceil天花板，返回最大值</span></span><br><span class="line">Math.floor(-<span class="number">10.1</span>)); <span class="comment">//-11.0，同理，返回最小值</span></span><br><span class="line">Math.random(); <span class="comment">// 取得一个大于或者等于0.0小于不等于1.0的随机数</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="swtich-是否能作用在byte-上，是否能作用在long-上，是否能作用在String上"><a href="#swtich-是否能作用在byte-上，是否能作用在long-上，是否能作用在String上" class="headerlink" title="swtich 是否能作用在byte 上，是否能作用在long 上，是否能作用在String上?"></a>swtich 是否能作用在byte 上，是否能作用在long 上，是否能作用在String上?</h2><p>答：早期的JDK中，switch（expr）中，expr可以是byte、short、char、int。从1.5版开始，Java中引入了枚举类型（enum），expr也可以是枚举，从JDK 1.7版开始，还可以是字符串（String）。长整型（long）是不可以的。</p>
<h2 id="用最有效率的方法计算2乘以8"><a href="#用最有效率的方法计算2乘以8" class="headerlink" title="用最有效率的方法计算2乘以8?"></a>用最有效率的方法计算2乘以8?</h2><p>答： 2 &lt;&lt; 3（左移3位相当于乘以2的3次方，右移3位相当于除以2的3次方）。<br>补充：我们为编写的类重写hashCode方法时，可能会看到如下所示的代码，其实我们不太理解为什么要使用这样的乘法运算来产生哈希码（散列码），而且为什么这个数是个素数，为什么通常选择31这个数？前两个问题的答案你可以自己百度一下，选择31是因为可以用移位和减法运算来代替乘法，从而得到更好的性能。说到这里你可能已经想到了：31 * num &lt;==&gt; (num &lt;&lt; 5) - num，左移5位相当于乘以2的5次方（32）再减去自身就相当于乘以31。现在的VM都能自动完成这个优化。</p>
<h2 id="数组有没有length-方法-String-有没有length-方法？"><a href="#数组有没有length-方法-String-有没有length-方法？" class="headerlink" title="数组有没有length()方法?String 有没有length()方法？"></a>数组有没有length()方法?String 有没有length()方法？</h2><p>答：数组没有length()方法，有length 的属性。String 有length()方法。JavaScript中，获得字符串的长度是通过length属性得到的，这一点容易和Java混淆。
 </p>
<h2 id="在Java-中，如何跳出当前的多重嵌套循环？"><a href="#在Java-中，如何跳出当前的多重嵌套循环？" class="headerlink" title="在Java 中，如何跳出当前的多重嵌套循环？"></a>在Java 中，如何跳出当前的多重嵌套循环？</h2><p>答：在最外层循环前加一个标记如A，然后用break A;可以跳出多重循环。（Java中支持带标签的break和continue语句，作用有点类似于C和C++中的goto语句，但是就像要避免使用goto一样，应该避免使用带标签的break和continue，因为它不会让你的程序变得更优雅，很多时候甚至有相反的作用，所以这种语法其实不知道更好）</p>
<h2 id="构造器（constructor）是否可被重写（override）"><a href="#构造器（constructor）是否可被重写（override）" class="headerlink" title="构造器（constructor）是否可被重写（override）?"></a>构造器（constructor）是否可被重写（override）?</h2><p>答：构造器不能被继承，因此不能被重写，但可以被重载。</p>
<h2 id="两个对象值相同-x-equals-y-true-，但却可有不同的hash-code，这句话对不对？"><a href="#两个对象值相同-x-equals-y-true-，但却可有不同的hash-code，这句话对不对？" class="headerlink" title="两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对？"></a>两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对？</h2><p>答：不对，如果两个对象x和y满足x.equals(y) == true，它们的哈希码（hash code）应当相同。Java对于eqauls方法和hashCode方法是这样规定的：(1)如果两个对象相同（equals方法返回true），那么它们的hashCode值一定要相同；(2)如果两个对象的hashCode相同，它们并不一定相同。当然，你未必要按照要求去做，但是如果你违背了上述原则就会发现在使用容器时，相同的对象可以出现在Set集合中，同时增加新元素的效率会大大下降（对于使用哈希存储的系统，如果哈希码频繁的冲突将会造成存取性能急剧下降）。<br>补充：关于equals和hashCode方法，很多Java程序都知道，但很多人也就是仅仅知道而已，在Joshua Bloch的大作《Effective Java》（很多软件公司，《Effective Java》、《Java编程思想》以及《重构：改善既有代码质量》是Java程序员必看书籍）中是这样介绍equals方法的：首先equals方法必须满足自反性（x.equals(x)必须返回true）、对称性（x.equals(y)返回true时，y.equals(x)也必须返回true）、传递性（x.equals(y)和y.equals(z)都返回true时，x.equals(z)也必须返回true）和一致性（当x和y引用的对象信息没有被修改时，多次调用x.equals(y)应该得到同样的返回值），而且对于任何非null值的引用x，x.equals(null)必须返回false。实现高质量的equals方法的诀窍包括：</p>
<ul>
<li>使用==操作符检查“参数是否为这个对象的引用”</li>
<li>使用instanceof操作符检查“参数是否为正确的类型”</li>
<li>对于类中的关键属性，检查参数传入对象的属性是否与之相匹配</li>
<li>编写完equals方法后，问自己它是否满足对称性、传递性、一致性</li>
<li>重写equals时总是要重写hashCode</li>
<li>不要将equals方法参数中的Object对象替换为其他的类型，在重写时不要忘掉@Override注解。<h2 id="是否可以继承String-类"><a href="#是否可以继承String-类" class="headerlink" title="是否可以继承String 类?"></a>是否可以继承String 类?</h2>答：String 类是final类，不可以被继承。<br>补充：继承String本身就是一个错误的行为，对String类型最好的重用方式是关联（HAS-A）而不是继承（IS-A）。</li>
</ul>
<p> </p>
<h2 id="当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递"><a href="#当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递" class="headerlink" title="当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递?"></a>当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递?</h2><p>答：是值传递。Java 编程语言只有值传递参数。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的属性可以在被调用过程中被改变，但对象的引用是永远不会改变的。C++和C#中可以通过传引用或传输出参数来改变传入的参数的值。<br>补充：Java中没有传引用实在是非常的不方便，这一点在Java 8中仍然没有得到改进，正是如此在Java编写的代码中才会出现大量的Wrapper类（将需要通过方法调用修改的引用置于一个Wrapper类中，再将Wrapper对象传入方法），这样的做法只会让代码变得臃肿，尤其是让从C和C++转型为Java程序员的开发者无法容忍。</p>
<h2 id="19、String-和StringBuilder、StringBuffer-的区别"><a href="#19、String-和StringBuilder、StringBuffer-的区别" class="headerlink" title="19、String 和StringBuilder、StringBuffer 的区别?"></a>19、String 和StringBuilder、StringBuffer 的区别?</h2><p>Java 平台提供了两种类型的字符串：String和StringBuffer / StringBuilder，它们可以储存和操作字符串。其中String是只读字符串，也就意味着String引用的字符串内容是不能被改变的。而StringBuffer和StringBuilder类表示的字符串对象可以直接进行修改。StringBuilder是JDK 1.5中引入的，它和StringBuffer的方法完全相同，区别在于它是在单线程环境下使用的，因为它的所有方面都没有被synchronized修饰，因此它的效率也比StringBuffer略高。<br>补充1：有一个面试题问：有没有哪种情况用+做字符串连接比调用StringBuffer / StringBuilder对象的append方法性能更好？如果连接后得到的字符串在静态存储区中是早已存在的，那么用+做字符串连接是优于StringBuffer / StringBuilder的append方法的。<br>补充2：下面也是一个面试题，问程序的输出，看看自己能不能说出正确答案。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String a = <span class="string">&quot;aaabbb&quot;</span>;</span><br><span class="line">String b = <span class="keyword">new</span> String(<span class="string">&quot;aaabbb&quot;</span>);</span><br><span class="line">String c = <span class="string">&quot;aaa&quot;</span> + <span class="string">&quot;bbb&quot;</span>;</span><br><span class="line">System.out.println(a == b);</span><br><span class="line">System.out.println(a == c);</span><br><span class="line">System.out.println(a.equals(b));</span><br><span class="line">System.out.println(a.equals(c));</span><br><span class="line">System.out.println(a.intern() == b.intern());</span><br></pre></td></tr></table></figure>
<h2 id="重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分"><a href="#重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分" class="headerlink" title="重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分?"></a>重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分?</h2><p>答：方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。重载对返回类型没有特殊的要求。<br>补充：华为的面试题中曾经问过这样一个问题：为什么不能根据返回类型来区分重载，说出你的答案吧！
 </p>
<h2 id="描述一下JVM-加载class文件的原理机制"><a href="#描述一下JVM-加载class文件的原理机制" class="headerlink" title="描述一下JVM 加载class文件的原理机制?"></a>描述一下JVM 加载class文件的原理机制?</h2><p>答：JVM 中类的装载是由类加载器（ClassLoader） 和它的子类来实现的，Java中的类加载器是一个重要的Java 运行时系统组件，它负责在运行时查找和装入类文件中的类。<br>补充：</p>
<ul>
<li>由于Java的跨平台性，经过编译的Java源程序并不是一个可执行程序，而是一个或多个类文件。当Java程序需要使用某个类时，JVM会确保这个类已经被加载、连接(验证、准备和解析)和初始化。类的加载是指把类的.class文件中的数据读入到内存中，通常是创建一个字节数组读入.class文件，然后产生与所加载类对应的Class对象。加载完成后，Class对象还不完整，所以此时的类还不可用。当类被加载后就进入连接阶段，这一阶段包括验证、准备(为静态变量分配内存并设置默认的初始值)和解析(将符号引用替换为直接引用)三个步骤。最后JVM对类进行初始化，包括：<ul>
<li>如果类存在直接的父类并且这个类还没有被初始化，那么就先初始化父类</li>
<li>如果类中存在初始化语句，就依次执行这些初始化语句。</li>
</ul>
</li>
<li>类的加载是由类加载器完成的，类加载器包括：根加载器（BootStrap）、扩展加载器（Extension）、系统加载器（System）和用户自定义类加载器（java.lang.ClassLoader的子类）。从JDK 1.2开始，类加载过程采取了父亲委托机制(PDM)。PDM更好的保证了Java平台的安全性，在该机制中，JVM自带的Bootstrap是根加载器，其他的加载器都有且仅有一个父类加载器。类的加载首先请求父类加载器加载，父类加载器无能为力时才由其子类加载器自行加载。JVM不会向Java程序提供对Bootstrap的引用。下面是关于几个类加载器的说明：<ul>
<li>Bootstrap：一般用本地代码实现，负责加载JVM基础核心类库（rt.jar）；</li>
<li>Extension：从java.ext.dirs系统属性所指定的目录中加载类库，它的父加载器是Bootstrap；</li>
<li>System：又叫应用类加载器，其父类是Extension。它是应用最广泛的类加载器。它从环境变量classpath或者系统属性java.class.path所指定的目录中记载类，是用户自定义加载器的默认父加载器。<h2 id="char-型变量中能不能存贮一个中文汉字-为什么"><a href="#char-型变量中能不能存贮一个中文汉字-为什么" class="headerlink" title="char 型变量中能不能存贮一个中文汉字?为什么?"></a>char 型变量中能不能存贮一个中文汉字?为什么?</h2>答：char类型可以存储一个中文汉字，因为Java中使用的编码是Unicode（不选择任何特定的编码，直接使用字符在字符集中的编号，这是统一的唯一方法），一个char类型占2个字节（16bit），所以放一个中文是没问题的。<br>补充：使用Unicode意味着字符在JVM内部和外部有不同的表现形式，在JVM内部都是Unicode，当这个字符被从JVM内部转移到外部时（例如存入文件系统中），需要进行编码转换。所以Java中有字节流和字符流，以及在字符流和字节流之间进行转换的转换流，如InputStreamReader和OutputStreamReader，这两个类是字节流和字符流之间的适配器类，承担了编码转换的任务；对于C程序员来说，要完成这样的编码转换恐怕要依赖于union（联合体/共用体）共享内存的特征来实现了。</li>
</ul>
</li>
</ul>
<p> </p>
<h2 id="抽象类（abstract-class）和接口（interface）有什么异同"><a href="#抽象类（abstract-class）和接口（interface）有什么异同" class="headerlink" title="抽象类（abstract class）和接口（interface）有什么异同?"></a>抽象类（abstract class）和接口（interface）有什么异同?</h2><p>答：抽象类和接口都不能够实例化，但可以定义抽象类和接口类型的引用。一个类如果继承了某个抽象类或者实现了某个接口都需要对其中的抽象方法全部进行实现，否则该类仍然需要被声明为抽象类。接口比抽象类更加抽象，因为抽象类中可以定义构造器，可以有抽象方法和具体方法，而接口中不能定义构造器而且其中的方法全部都是抽象方法。抽象类中的成员可以是private、默认、protected、public的，而接口中的成员全都是public的。抽象类中可以定义成员变量，而接口中定义的成员变量实际上都是常量。有抽象方法的类必须被声明为抽象类，而抽象类未必要有抽象方法。</p>
<h2 id="Java-中会存在内存泄漏吗，请简单描述。"><a href="#Java-中会存在内存泄漏吗，请简单描述。" class="headerlink" title="Java 中会存在内存泄漏吗，请简单描述。"></a>Java 中会存在内存泄漏吗，请简单描述。</h2><p>答：理论上Java因为有垃圾回收机制（GC）不会存在内存泄露问题（这也是Java被广泛使用于服务器端编程的一个重要原因）；然而在实际开发中，可能会存在无用但可达的对象，这些对象不能被GC回收也会发生内存泄露。一个例子就是Hibernate的Session（一级缓存）中的对象属于持久态，垃圾回收器是不会回收这些对象的，然而这些对象中可能存在无用的垃圾对象。下面的例子也展示了Java中发生内存泄露的情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T[] elements;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INIT_CAPACITY = <span class="number">16</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        elements = (T[])<span class="keyword">new</span> Object[INIT_CAPACITY];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T elem)</span></span>&#123;</span><br><span class="line">        ensureCapacity();</span><br><span class="line">        elements[size++] = elem;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</span><br><span class="line">        &#125;</span><br><span class="line">        retrun elements[--size];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(elements.length == size)&#123;</span><br><span class="line">            elements = Arrays.copyOf(elements, <span class="number">2</span> * size + <span class="number">1</span>)；</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面的代码实现了一个栈（先进后出（FILO））结构，乍看之下似乎没有什么明显的问题，它甚至可以通过你编写的各种单元测试。然而其中的pop方法却存在内存泄露的问题，当我们用pop方法弹出栈中的对象时，该对象不会被当作垃圾回收，即使使用栈的程序不再引用这些对象，因为栈内部维护着对这些对象的过期引用（obsolete reference）。在支持垃圾回收的语言中，内存泄露是很隐蔽的，这种内存泄露其实就是无意识的对象保持。如果一个对象引用被无意识的保留起来了，那么垃圾回收器不会处理这个对象，也不会处理该对象引用的其他对象，即使这样的对象只有少数几个，也可能会导致很多的对象被排除在垃圾回收之外，从而对性能造成重大影响，极端情况下会引发Disk Paging（物理内存与硬盘的虚拟内存交换数据），甚至造成OutOfMemoryError。
 </p>
<h2 id="抽象的（abstract）方法是否可同时是静态的（static）-是否可同时是本地方法（native），是否可同时被synchronized修饰"><a href="#抽象的（abstract）方法是否可同时是静态的（static）-是否可同时是本地方法（native），是否可同时被synchronized修饰" class="headerlink" title="抽象的（abstract）方法是否可同时是静态的（static）,是否可同时是本地方法（native），是否可同时被synchronized修饰?"></a>抽象的（abstract）方法是否可同时是静态的（static）,是否可同时是本地方法（native），是否可同时被synchronized修饰?</h2><p>答：都不能。抽象方法需要子类重写，而静态的方法是无法被重写的，因此二者是矛盾的。本地方法是由本地代码（如C代码）实现的方法，而抽象方法是没有实现的，也是矛盾的。synchronized和方法的实现细节有关，抽象方法不涉及实现细节，因此也是相互矛盾的。</p>
<h2 id="静态变量和实例变量的区别？"><a href="#静态变量和实例变量的区别？" class="headerlink" title="静态变量和实例变量的区别？"></a>静态变量和实例变量的区别？</h2><p>答：静态变量是被static修饰符修饰的变量，也称为类变量，它属于类，不属于类的任何一个对象，一个类不管创建多少个对象，静态变量在内存中有且仅有一个拷贝；实例变量必须依存于某一实例，需要先创建对象然后通过对象才能访问到它。静态变量可以实现让多个对象共享内存。在Java开发中，上下文类和工具类中通常会有大量的静态成员。</p>
<h2 id="是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？"><a href="#是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？" class="headerlink" title="是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？"></a>是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？</h2><p>答：不可以，静态方法只能访问静态成员，因为非静态方法的调用要先创建对象，因此在调用静态方法时可能对象并没有被初始化。</p>
<h2 id="如何实现对象克隆？"><a href="#如何实现对象克隆？" class="headerlink" title="如何实现对象克隆？"></a>如何实现对象克隆？</h2><p>答：有两种方式：</p>
<ul>
<li><p>实现Cloneable接口并重写Object类中的clone()方法；</p>
</li>
<li><p>实现Serializable接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆，代码如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MyUtil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Serializable&gt; <span class="function">T <span class="title">clone</span><span class="params">(T obj)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ByteArrayOutputStream bout = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(bout);</span><br><span class="line">        oos.writeObject(obj);</span><br><span class="line"></span><br><span class="line">        ByteArrayInputStream bin = <span class="keyword">new</span> ByteArrayInputStream(bout.toByteArray());</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(bin);</span><br><span class="line">        <span class="keyword">return</span> (T) ois.readObject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 说明：调用ByteArrayInputStream或ByteArrayOutputStream对象的close方法没有任何意义</span></span><br><span class="line">        <span class="comment">// 这两个基于内存的流只要垃圾回收器清理对象就能够释放资源，这一点不同于对外部资源（如文件流）的释放</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：基于序列化和反序列化实现的克隆不仅仅是深度克隆，更重要的是通过泛型限定，可以检查出要克隆的对象是否支持序列化，这项检查是编译器完成的，不是在运行时抛出异常，这种是方案明显优于使用Object类的clone方法克隆对象。</p>
<h2 id="GC-是什么？为什么要有GC？"><a href="#GC-是什么？为什么要有GC？" class="headerlink" title="GC 是什么？为什么要有GC？"></a>GC 是什么？为什么要有GC？</h2><p>答：GC是垃圾收集的意思，内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java语言没有提供释放已分配内存的显示操作方法。Java程序员不用担心内存管理，因为垃圾收集器会自动进行管理。要请求垃圾收集，可以调用下面的方法之一：System.gc() 或Runtime.getRuntime().gc() ，但JVM可以屏蔽掉显示的垃圾回收调用。<br>垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存。垃圾回收器通常是作为一个单独的低优先级的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。在Java诞生初期，垃圾回收是Java最大的亮点之一，因为服务器端的编程需要有效的防止内存泄露问题，然而时过境迁，如今Java的垃圾回收机制已经成为被诟病的东西。移动智能终端用户通常觉得iOS的系统比Android系统有更好的用户体验，其中一个深层次的原因就在于Android系统中垃圾回收的不可预知性。<br>补充：垃圾回收机制有很多种，包括：分代复制垃圾回收、标记垃圾回收、增量垃圾回收等方式。标准的Java进程既有栈又有堆。栈保存了原始型局部变量，堆保存了要创建的对象。Java平台对堆内存回收和再利用的基本算法被称为标记和清除，但是Java对其进行了改进，采用“分代式垃圾收集”。这种方法会跟Java对象的生命周期将堆内存划分为不同的区域，在垃圾收集过程中，可能会将对象移动到不同区域：</p>
</li>
<li><p>伊甸园（Eden）：这是对象最初诞生的区域，并且对大多数对象来说，这里是它们唯一存在过的区域。</p>
</li>
<li><p>幸存者乐园（Survivor）：从伊甸园幸存下来的对象会被挪到这里。</p>
</li>
<li><p>终身颐养园（Tenured）：这是足够老的幸存对象的归宿。年轻代收集（Minor-GC）过程是不会触及这个地方的。当年轻代收集不能把对象放进终身颐养园时，就会触发一次完全收集（Major-GC），这里可能还会牵扯到压缩，以便为大对象腾出足够的空间。<br>与垃圾回收相关的JVM参数：</p>
<ul>
<li>-Xms / -Xmx — 堆的初始大小 / 堆的最大大小</li>
<li>-Xmn — 堆中年轻代的大小</li>
<li>-XX:-DisableExplicitGC — 让System.gc()不产生任何作用</li>
<li>-XX:+PrintGCDetail — 打印GC的细节</li>
<li>-XX:+PrintGCDateStamps — 打印GC操作的时间戳<h2 id="String-s-new-String-“xyz”-创建了几个字符串对象？"><a href="#String-s-new-String-“xyz”-创建了几个字符串对象？" class="headerlink" title="String s=new String(“xyz”);创建了几个字符串对象？"></a>String s=new String(“xyz”);创建了几个字符串对象？</h2>答：两个对象，一个是静态存储区的”xyz”,一个是用new创建在堆上的对象。<h2 id="接口是否可继承（extends）接口-抽象类是否可实现（implements）接口-抽象类是否可继承具体类（concrete-class）"><a href="#接口是否可继承（extends）接口-抽象类是否可实现（implements）接口-抽象类是否可继承具体类（concrete-class）" class="headerlink" title="接口是否可继承（extends）接口? 抽象类是否可实现（implements）接口? 抽象类是否可继承具体类（concrete class）?"></a>接口是否可继承（extends）接口? 抽象类是否可实现（implements）接口? 抽象类是否可继承具体类（concrete class）?</h2>答：接口可以继承接口。抽象类可以实现(implements)接口，抽象类可继承具体类，但前提是具体类必须有明确的构造函数。<h2 id="一个“-java”源文件中是否可以包含多个类（不是内部类）？有什么限制？"><a href="#一个“-java”源文件中是否可以包含多个类（不是内部类）？有什么限制？" class="headerlink" title="一个“.java”源文件中是否可以包含多个类（不是内部类）？有什么限制？"></a>一个“.java”源文件中是否可以包含多个类（不是内部类）？有什么限制？</h2>答：可以，但一个源文件中最多只能有一个公开类（public class）而且文件名必须和公开类的类名完全保持一致。<h2 id="Anonymous-Inner-Class-匿名内部类-是否可以继承其它类？是否可以实现接口？"><a href="#Anonymous-Inner-Class-匿名内部类-是否可以继承其它类？是否可以实现接口？" class="headerlink" title="Anonymous Inner Class(匿名内部类)是否可以继承其它类？是否可以实现接口？"></a>Anonymous Inner Class(匿名内部类)是否可以继承其它类？是否可以实现接口？</h2>答：可以继承其他类或实现其他接口，在Swing编程中常用此方式来实现事件监听和回调。<h2 id="内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？"><a href="#内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？" class="headerlink" title="内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？"></a>内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？</h2>答：一个内部类对象可以访问创建它的外部类对象的成员，包括私有成员。<h2 id="Java-中的final关键字有哪些用法？"><a href="#Java-中的final关键字有哪些用法？" class="headerlink" title="Java 中的final关键字有哪些用法？"></a>Java 中的final关键字有哪些用法？</h2>答：</li>
</ul>
</li>
<li><p>修饰类：表示该类不能被继承</p>
</li>
<li><p>修饰方法：表示方法不能被重写</p>
</li>
<li><p>修饰变量：表示变量只能一次赋值以后值不能被修改（常量）。</p>
<h2 id="指出下面程序的运行结果"><a href="#指出下面程序的运行结果" class="headerlink" title="指出下面程序的运行结果:"></a>指出下面程序的运行结果:</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestA</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestA</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestB</span> <span class="title">extend</span> <span class="title">TestA</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestB</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;b&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        TestA a = <span class="keyword">new</span> TestB();</span><br><span class="line">        a = <span class="keyword">new</span> TestB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>答：执行结果：1a2b2b。创建对象时构造器的调用顺序是：先初始化静态成员，然后调用父类构造器，再初始化非静态成员，最后调用自身构造器。</p>
<h2 id="数据类型之间的转换"><a href="#数据类型之间的转换" class="headerlink" title="数据类型之间的转换:"></a>数据类型之间的转换:</h2></li>
<li><p>如何将字符串转换为基本数据类型？</p>
</li>
<li><p>如何将基本数据类型转换为字符串？<br>答：</p>
</li>
<li><p>调用基本数据类型对应的包装类中的方法parseXXX(String)或valueOf(String)即可返回相应基本类型；</p>
</li>
<li><p>一种方法是将基本数据类型与空字符串（””）连接（+）即可获得其所对应的字符串；另一种方法是调用String 类中的valueOf(…)方法返回相应字符串</p>
</li>
</ul>
<p> </p>
<h2 id="如何实现字符串的反转及替换？"><a href="#如何实现字符串的反转及替换？" class="headerlink" title="如何实现字符串的反转及替换？"></a>如何实现字符串的反转及替换？</h2><p>答：方法很多，可以自己写实现也可以使用String或StringBuffer / StringBuilder中的方法。有一道很常见的面试题是用递归实现字符串反转，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">reverse</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str == <span class="keyword">null</span> || str.length() &lt; = <span class="number">1</span>)&#123;</span><br><span class="line">        retrun str;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> reverse(str.substring(<span class="number">1</span>)) + str.charAt(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串？"><a href="#怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串？" class="headerlink" title="怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串？"></a>怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串？</h2><p>答：代码如下所示:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s1 = <span class="string">&quot;你好&quot;</span>;</span><br><span class="line">String s2 = newString(s1.getBytes(<span class="string">&quot;GB2312&quot;</span>), <span class="string">&quot;ISO-8859-1&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="日期和时间："><a href="#日期和时间：" class="headerlink" title="日期和时间："></a>日期和时间：</h2><ul>
<li>如何取得年月日、小时分钟秒？</li>
<li>如何取得从1970年1月1日0时0分0秒到现在的毫秒数？</li>
<li>如何格式化日期？<br>答：操作方法如下所示：</li>
<li>创建java.util.Calendar 实例，调用其get()方法传入不同的参数即可获得参数所对应的值</li>
<li>以下方法均可获得该毫秒数:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Calendar.getInstance().getTimeInMillis();</span><br><span class="line">System.currentTimeMillis();</span><br></pre></td></tr></table></figure></li>
<li>利用java.text.DataFormat 的子类（如SimpleDateFormat类）中的format(Date)方法可将日期格式化。</li>
</ul>
<h2 id="比较一下Java-和JavaSciprt。"><a href="#比较一下Java-和JavaSciprt。" class="headerlink" title="比较一下Java 和JavaSciprt。"></a>比较一下Java 和JavaSciprt。</h2><p>答：JavaScript 与Java是两个公司开发的不同的两个产品。Java 是原Sun 公司推出的面向对象的程序设计语言，特别适合于互联网应用程序开发；而JavaScript是Netscape公司的产品，为了扩展Netscape浏览器的功能而开发的一种可以嵌入Web页面中运行的基于对象和事件驱动的解释性语言，它的前身是LiveScript；而Java 的前身是Oak语言。<br>下面对两种语言间的异同作如下比较：</p>
<ul>
<li>基于对象和面向对象：Java是一种真正的面向对象的语言，即使是开发简单的程序，必须设计对象；JavaScript是种脚本语言，它可以用来制作与网络无关的，与用户交互作用的复杂软件。它是一种基于对象（Object-Based）和事件驱动（Event-Driven）的编程语言。因而它本身提供了非常丰富的内部对象供设计人员使用；</li>
<li>解释和编译：Java 的源代码在执行之前，必须经过编译；JavaScript 是一种解释性编程语言，其源代码不需经过编译，由浏览器解释执行；</li>
<li>强类型变量和类型弱变量：Java采用强类型变量检查，即所有变量在编译之前必须作声明；JavaScript中变量声明，采用其弱类型。即变量在使用前不需作声明，而是解释器在运行时检查其数据类型；</li>
<li>代码格式不一样。<br>补充：上面列出的四点是原来所谓的标准答案中给出的。其实Java和JavaScript最重要的区别是一个是静态语言，一个是动态语言。目前的编程语言的发展趋势是函数式语言和动态语言。在Java中类（class）是一等公民，而JavaScript中函数（function）是一等公民。对于这种问题，在面试时还是用自己的语言回答会更加靠谱。</li>
</ul>
<p> </p>
<h2 id="什么时候用assert？"><a href="#什么时候用assert？" class="headerlink" title="什么时候用assert？"></a>什么时候用assert？</h2><p>答：assertion(断言)在软件开发中是一种常用的调试方式，很多开发语言中都支持这种机制。一般来说，assertion用于保证程序最基本、关键的正确性。assertion检查通常在开发和测试时开启。为了提高性能，在软件发布后， assertion检查通常是关闭的。在实现中，断言是一个包含布尔表达式的语句，在执行这个语句时假定该表达式为true；如果表达式计算为false，那么系统会报告一个AssertionError。<br>断言用于调试目的：<br>assert(a &gt; 0); // throws an AssertionError if a &lt;= 0<br>断言可以有两种形式：<br>assert Expression1;<br>assert Expression1 : Expression2 ;<br>Expression1 应该总是产生一个布尔值。<br>Expression2 可以是得出一个值的任意表达式；这个值用于生成显示更多调试信息的字符串消息。<br>断言在默认情况下是禁用的，要在编译时启用断言，需使用source 1.4 标记：<br>javac -source 1.4 Test.java<br>要在运行时启用断言，可使用-enableassertions 或者-ea 标记。<br>要在运行时选择禁用断言，可使用-da 或者-disableassertions 标记。<br>要在系统类中启用断言，可使用-esa 或者-dsa 标记。还可以在包的基础上启用或者禁用断言。可以在预计正常情况下不会到达的任何位置上放置断言。断言可以用于验证传递给私有方法的参数。不过，断言不应该用于验证传递给公有方法的参数，因为不管是否启用了断言，公有方法都必须检查其参数。不过，既可以在公有方法中，也可以在非公有方法中利用断言测试后置条件。另外，断言不应该以任何方式改变程序的状态。</p>
<h2 id="Error-和Exception-有什么区别"><a href="#Error-和Exception-有什么区别" class="headerlink" title="Error 和Exception 有什么区别?"></a>Error 和Exception 有什么区别?</h2><p>答：Error 表示系统级的错误和程序不必处理的异常，是恢复不是不可能但很困难的情况下的一种严重问题；比如内存溢出，不可能指望程序能处理这样的情况；Exception 表 示需要捕捉或者需要程序进行处理的异常，是一种设计或实现问题；也就是说，它表示如果程序运行正常，从不会发生的情况。<br>补充：2005年摩托罗拉的面试中曾经问过这么一个问题“If a process reports a stack overflow run-time error, what’s the most possible cause?”，给了四个选项</p>
<ul>
<li>a. lack of memory</li>
<li>b. write on an invalid memory space</li>
<li>c. recursive function calling</li>
<li>d. array index out of boundary<br>Java程序在运行时也可能会遭遇StackOverflowError，这是一个错误无法恢复，只能重新修改代码了，这个面试题的答案是c。如果写了不能迅速收敛的递归，则很有可能引发栈溢出的错误，如下所示：</li>
</ul>
<p>因此，用递归编写程序时一定要牢记两点：</p>
<ul>
<li><p>递归公式</p>
</li>
<li><p>收敛条件（什么时候就不再递归而是回溯了）。</p>
<h2 id="try-里有一个return语句，那么紧跟在这个try后的finally-里的code会不会被执行，什么时候被执行，在return前还是后"><a href="#try-里有一个return语句，那么紧跟在这个try后的finally-里的code会不会被执行，什么时候被执行，在return前还是后" class="headerlink" title="try{}里有一个return语句，那么紧跟在这个try后的finally{}里的code会不会被执行，什么时候被执行，在return前还是后?"></a>try{}里有一个return语句，那么紧跟在这个try后的finally{}里的code会不会被执行，什么时候被执行，在return前还是后?</h2><p>答：会执行，在方法返回调用者前执行。Java允许在finally中改变返回值的做法是不好的，因为如果存在finally代码块，try中的return语句不会立马返回调用者，而是记录下返回值待finally代码块执行完毕之后再向调用者返回其值，然后如果在finally中修改了返回值，这会对程序造成很大的困扰，C#中就从语法上规定不能做这样的事。</p>
<h2 id="Java-语言如何进行异常处理，关键字：throws、throw、try、catch、finally分别如何使用？"><a href="#Java-语言如何进行异常处理，关键字：throws、throw、try、catch、finally分别如何使用？" class="headerlink" title="Java 语言如何进行异常处理，关键字：throws、throw、try、catch、finally分别如何使用？"></a>Java 语言如何进行异常处理，关键字：throws、throw、try、catch、finally分别如何使用？</h2><p>Java 通过面向对象的方法进行异常处理，把各种不同的异常进行分类，并提供了良好的接口。在Java 中，每个异常都是一个对象，它是Throwable 类或其子类的实例。当一个方法出现异常后便抛出一个异常对象，该对象中包含有异常信息，调用这个对象的方法可以捕获到这个异常并进行处理。Java 的异常处理是通过5 个关键词来实现的：try、catch、throw、throws和finally。一般情况下是用try来执行一段程序，如果出现异常，系统会抛出（throw）一个异常，这时候你可以通过它的类型来捕捉（catch）它，或最后（finally）由缺省处理器来处理；try用来指定一块预防所有“异常”的程序；catch 子句紧跟在try块后面，用来指定你想要捕捉的“异常”的类型；throw 语句用来明确地抛出一个“异常”；throws用来标明一个成员函数可能抛出的各种“异常”；finally 为确保一段代码不管发生什么“异常”都被执行一段代码；可以在一个成员函数调用的外面写一个try语句，在这个成员函数内部写另一个try语句保护其他代码。每当遇到一个try 语句，“异常”的框架就放到栈上面，直到所有的try语句都完成。如果下一级的try语句没有对某种“异常”进行处理，栈就会展开，直到遇到有处理这种“异常”的try 语句。</p>
<h2 id="运行时异常与受检异常有何异同？"><a href="#运行时异常与受检异常有何异同？" class="headerlink" title="运行时异常与受检异常有何异同？"></a>运行时异常与受检异常有何异同？</h2><p>答：异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误，只要程序设计得没有问题通常就不会发生。受检异常跟程序运行的上下文环境有关，即使程序设计无误，仍然可能因使用的问题而引发。Java编译器要求方法必须声明抛出可能发生的受检异常，但是并不要求必须声明抛出未被捕获的运行时异常。异常和继承一样，是面向对象程序设计中经常被滥用的东西，神作《Effective Java》中对异常的使用给出了以下指导原则：</p>
</li>
<li><p>不要将异常处理用于正常的控制流（设计良好的API不应该强迫它的调用者为了正常的控制流而使用异常）</p>
</li>
<li><p>对可以恢复的情况使用受检异常，对编程错误使用运行时异常</p>
</li>
<li><p>避免不必要的使用受检异常（可以通过一些状态检测手段来避免异常的发生）</p>
</li>
<li><p>优先使用标准的异常</p>
</li>
<li><p>每个方法抛出的异常都要有文档</p>
</li>
<li><p>保持异常的原子性</p>
</li>
<li><p>不要在catch中忽略掉捕获到的异常</p>
<h2 id="列出一些你常见的运行时异常？"><a href="#列出一些你常见的运行时异常？" class="headerlink" title="列出一些你常见的运行时异常？"></a>列出一些你常见的运行时异常？</h2></li>
<li><p>ArithmeticException（算术异常）</p>
</li>
<li><p>ClassCastException （类转换异常）</p>
</li>
<li><p>IllegalArgumentException （非法参数异常）</p>
</li>
<li><p>IndexOutOfBoundsException （下表越界异常）</p>
</li>
<li><p>NullPointerException （空指针异常）</p>
</li>
<li><p>SecurityException （安全异常）</p>
<h2 id="final-finally-finalize-的区别"><a href="#final-finally-finalize-的区别" class="headerlink" title="final, finally, finalize 的区别?"></a>final, finally, finalize 的区别?</h2><p>答：</p>
</li>
<li><p>final：修饰符（关键字）有三种用法：如果一个类被声明为final，意味着它不能再派生出新的子类，即不能被继承，因此它和abstract是反义词。将变量声明为final，可以保证它们在使用中不被改变，被声明为final 的变量必须在声明时给定初值，而在以后的引用中只能读取不可修改。被声明为final 的方法也同样只能使用，不能在子类中被重写。finally：通常放在try…catch的后面构造总是执行代码块，这就意味着程序无论正常执行还是发生异常，这里的代码只要JVM不关闭都能执行，可以将释放外部资源的代码写在finally块中。finalize：Object类中定义的方法，Java中允许使用finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在销毁对象时调用的，通过重写finalize() 方法可以整理系统资源或者执行其他清理工作。</p>
</li>
<li><p>finally：通常放在try…catch…的后面构造总是执行代码块，这就意味着程序无论正常执行还是发生异常，这里的代码只要JVM不关闭都能执行，可以将释放外部资源的代码写在finally块中。 </p>
</li>
<li><p>finalize：Object类中定义的方法，Java中允许使用finalize()方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在销毁对象时调用的，通过重写finalize()方法可以整理系统资源或者执行其他清理工作。</p>
</li>
</ul>
<h2 id="List、Set、Map是否继承自Collection接口？"><a href="#List、Set、Map是否继承自Collection接口？" class="headerlink" title="List、Set、Map是否继承自Collection接口？"></a>List、Set、Map是否继承自Collection接口？</h2><p>答：List、Set 是，Map 不是。Map是键值对映射容器，与List和Set有明显的区别，而Set存储的零散的元素且不允许有重复元素（数学中的集合也是如此），List是线性结构的容器，适用于按数值索引访问元素的情形。</p>
<h2 id="阐述ArrayList、Vector、LinkedList的存储性能和特性。"><a href="#阐述ArrayList、Vector、LinkedList的存储性能和特性。" class="headerlink" title="阐述ArrayList、Vector、LinkedList的存储性能和特性。"></a>阐述ArrayList、Vector、LinkedList的存储性能和特性。</h2><p>答：ArrayList 和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector中的方法由于添加了synchronized修饰，因此Vector是线程安全的容器，但性能上较ArrayList差，因此已经是Java中的遗留容器。LinkedList使用双向链表实现存储（将内存中零散的内存单元通过附加的引用关联起来，形成一个可以按序号索引的线性结构，这种链式存储方式与数组的连续存储方式相比，内存的利用率更高），按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。Vector属于遗留容器（Java早期的版本中提供的容器，除此之外，Hashtable、Dictionary、BitSet、Stack、Properties都是遗留容器），已经不推荐使用，但是由于ArrayList和LinkedListed都是非线程安全的，如果遇到多个线程操作同一个容器的场景，则可以通过工具类Collections中的synchronizedList方法将其转换成线程安全的容器后再使用（这是对装潢模式的应用，将已有对象传入另一个类的构造器中创建新的对象来增强实现）。</p>
<blockquote>
<p>补充：遗留容器中的Properties类和Stack类在设计上有严重的问题，Properties是一个键和值都是字符串的特殊的键值对映射，在设计上应该是关联一个Hashtable并将其两个泛型参数设置为String类型，但是Java API中的Properties直接继承了Hashtable，这很明显是对继承的滥用。这里复用代码的方式应该是Has-A关系而不是Is-A关系，另一方面容器都属于工具类，继承工具类本身就是一个错误的做法，使用工具类最好的方式是Has-A关系（关联）或Use-A关系（依赖）。同理，Stack类继承Vector也是不正确的。Sun公司的工程师们也会犯这种低级错误，让人唏嘘不已。</p>
</blockquote>
<h2 id="Collection和Collections的区别？"><a href="#Collection和Collections的区别？" class="headerlink" title="Collection和Collections的区别？"></a>Collection和Collections的区别？</h2><p>答：Collection是一个接口，它是Set、List等容器的父接口；Collections是个一个工具类，提供了一系列的静态方法来辅助容器操作，这些方法包括对容器的搜索、排序、线程安全化等等。</p>
<h2 id="List、Map、Set三个接口存取元素时，各有什么特点？"><a href="#List、Map、Set三个接口存取元素时，各有什么特点？" class="headerlink" title="List、Map、Set三个接口存取元素时，各有什么特点？"></a>List、Map、Set三个接口存取元素时，各有什么特点？</h2><p>答：List以特定索引来存取元素，可以有重复元素。Set不能存放重复元素（用对象的equals()方法来区分元素是否重复）。Map保存键值对（key-value pair）映射，映射关系可以是一对一或多对一。Set和Map容器都有基于哈希存储和排序树的两种实现版本，基于哈希存储的版本理论存取时间复杂度为O(1)，而基于排序树版本的实现在插入或删除元素时会按照元素或元素的键（key）构成排序树从而达到排序和去重的效果。</p>
<h2 id="TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort-方法如何比较元素？"><a href="#TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort-方法如何比较元素？" class="headerlink" title="TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort()方法如何比较元素？"></a>TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort()方法如何比较元素？</h2><p>答：TreeSet要求存放的对象所属的类必须实现Comparable接口，该接口提供了比较元素的compareTo()方法，当插入元素时会回调该方法比较元素的大小。TreeMap要求存放的键值对映射的键必须实现Comparable接口从而根据键对元素进行排序。Collections工具类的sort方法有两种重载的形式，第一种要求传入的待排序容器中存放的对象比较实现Comparable接口以实现元素的比较；第二种不强制性的要求容器中的元素必须可比较，但是要求传入第二个参数，参数是Comparator接口的子类型（需要重写compare方法实现元素的比较），相当于一个临时定义的排序规则，其实就是通过接口注入比较元素大小的算法，也是对回调模式的应用（Java中对函数式编程的支持）。<br>例子代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Student</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;        <span class="comment">// 姓名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;            <span class="comment">// 年龄</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student [name=&quot;</span> + name + <span class="string">&quot;, age=&quot;</span> + age + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Student o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age - o.age; <span class="comment">// 比较年龄(年龄的升序)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Set&lt;Student&gt; set = <span class="keyword">new</span> TreeSet&lt;&gt;();     <span class="comment">// Java 7的钻石语法(构造器后面的尖括号中不需要写类型)</span></span><br><span class="line">        set.add(<span class="keyword">new</span> Student(<span class="string">&quot;Hao LUO&quot;</span>, <span class="number">33</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> Student(<span class="string">&quot;XJ WANG&quot;</span>, <span class="number">32</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> Student(<span class="string">&quot;Bruce LEE&quot;</span>, <span class="number">60</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> Student(<span class="string">&quot;Bob YANG&quot;</span>, <span class="number">22</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(Student stu : set) &#123;</span><br><span class="line">            System.out.println(stu);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//      输出结果: </span></span><br><span class="line"><span class="comment">//      Student [name=Bob YANG, age=22]</span></span><br><span class="line"><span class="comment">//      Student [name=XJ WANG, age=32]</span></span><br><span class="line"><span class="comment">//      Student [name=Hao LUO, age=33]</span></span><br><span class="line"><span class="comment">//      Student [name=Bruce LEE, age=60]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Thread类的sleep-方法和对象的wait-方法都可以让线程暂停执行，它们有什么区别"><a href="#Thread类的sleep-方法和对象的wait-方法都可以让线程暂停执行，它们有什么区别" class="headerlink" title="Thread类的sleep()方法和对象的wait()方法都可以让线程暂停执行，它们有什么区别?"></a>Thread类的sleep()方法和对象的wait()方法都可以让线程暂停执行，它们有什么区别?</h2><p>答：sleep()方法（休眠）是线程类（Thread）的静态方法，调用此方法会让当前线程暂停执行指定的时间，将执行机会（CPU）让给其他线程，但是对象的锁依然保持，因此休眠时间结束后会自动恢复（线程回到就绪状态，请参考第66题中的线程状态转换图）。wait()是Object类的方法，调用对象的wait()方法导致当前线程放弃对象的锁（线程暂停执行），进入对象的等待池（wait pool），只有调用对象的notify()方法（或notifyAll()方法）时才能唤醒等待池中的线程进入等锁池（lock pool），如果线程重新获得对象的锁就可以进入就绪状态。</p>
<blockquote>
<p>补充：可能不少人对什么是进程，什么是线程还比较模糊，对于为什么需要多线程编程也不是特别理解。简单的说：进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，是操作系统进行资源分配和调度的一个独立单位；线程是进程的一个实体，是CPU调度和分派的基本单位，是比进程更小的能独立运行的基本单位。线程的划分尺度小于进程，这使得多线程程序的并发性高；进程在执行时通常拥有独立的内存单元，而线程之间可以共享内存。使用多线程的编程通常能够带来更好的性能和用户体验，但是多线程的程序对于其他程序是不友好的，因为它可能占用了更多的CPU资源。当然，也不是线程越多，程序的性能就越好，因为线程之间的调度和切换也会浪费CPU时间。时下很时髦的Node.js就采用了单线程异步I/O的工作模式。</p>
</blockquote>
<h2 id="线程的sleep-方法和yield-方法有什么区别？"><a href="#线程的sleep-方法和yield-方法有什么区别？" class="headerlink" title="线程的sleep()方法和yield()方法有什么区别？"></a>线程的sleep()方法和yield()方法有什么区别？</h2><p>答： </p>
<ul>
<li>sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会； </li>
<li>线程执行sleep()方法后转入阻塞（blocked）状态，而执行yield()方法后转入就绪（ready）状态； </li>
<li>sleep()方法声明抛出InterruptedException，而yield()方法没有声明任何异常； </li>
<li>sleep()方法比yield()方法（跟操作系统CPU调度相关）具有更好的可移植性。</li>
</ul>
<h2 id="当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B？"><a href="#当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B？" class="headerlink" title="当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B？"></a>当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B？</h2><p> 答：不能。其它线程只能访问该对象的非同步方法，同步方法则不能进入。因为非静态方法上的synchronized修饰符要求执行方法时要获得对象的锁，如果已经进入A方法说明对象锁已经被取走，那么试图进入B方法的线程就只能在等锁池（注意不是等待池哦）中等待对象的锁。</p>
<h2 id="请说出与线程同步以及线程调度相关的方法"><a href="#请说出与线程同步以及线程调度相关的方法" class="headerlink" title="请说出与线程同步以及线程调度相关的方法"></a>请说出与线程同步以及线程调度相关的方法</h2><ul>
<li>wait()：使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁； </li>
<li>sleep()：使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要处理InterruptedException异常； </li>
<li>notify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且与优先级无关； </li>
<li>notityAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态；</li>
</ul>
<h2 id="编写多线程程序有几种实现方式？"><a href="#编写多线程程序有几种实现方式？" class="headerlink" title="编写多线程程序有几种实现方式？"></a>编写多线程程序有几种实现方式？</h2><p>一种是继承Thread类；另一种是实现Runnable接口。两种方式都要通过重写run()方法来定义线程的行为，推荐使用后者，因为Java中的继承是单继承，一个类有一个父类，如果继承了Thread类就无法再继承其他类了，显然使用Runnable接口更为灵活。</p>
<blockquote>
<p>补充：还有就是实现Callable接口，该接口中的call方法可以在线程执行结束时产生一个返回值，代码如下所示：</p>
</blockquote>
<h2 id="什么是线程池（thread-pool）？"><a href="#什么是线程池（thread-pool）？" class="headerlink" title="什么是线程池（thread pool）？"></a>什么是线程池（thread pool）？</h2><p>在面向对象编程中，创建和销毁对象是很费时间的，因为创建一个对象要获取内存资源或者其它更多资源。在Java中更是如此，虚拟机将试图跟踪每一个对象，以便能够在对象销毁后进行垃圾回收。所以提高服务程序效率的一个手段就是尽可能减少创建和销毁对象的次数，特别是一些很耗资源的对象创建和销毁，这就是”池化资源”技术产生的原因。线程池顾名思义就是事先创建若干个可执行的线程放入一个池（容器）中，需要的时候从池中获取线程不用自行创建，使用完毕不需要销毁线程而是放回池中，从而减少创建和销毁线程对象的开销。<br>一些常用的线程池，如下所示：</p>
<ul>
<li>newSingleThreadExecutor：创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。 </li>
<li>newFixedThreadPool：创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。 </li>
<li>newCachedThreadPool：创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。 </li>
<li>newScheduledThreadPool：创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。 </li>
<li>newSingleThreadExecutor：创建一个单线程的线程池。此线程池支持定时以及周期性执行任务的需求。</li>
</ul>
<h2 id="简述synchronized-和java-util-concurrent-locks-Lock的异同？"><a href="#简述synchronized-和java-util-concurrent-locks-Lock的异同？" class="headerlink" title="简述synchronized 和java.util.concurrent.locks.Lock的异同？"></a>简述synchronized 和java.util.concurrent.locks.Lock的异同？</h2><p>Lock 能完成synchronized所实现的所有功能；主要不同点：Lock有比synchronized更精确的线程语义和更好的性能，而且不强制性的要求一定要获得锁。synchronized会自动释放锁，而Lock一定要求程序员手工释放，并且最好在finally 块中释放（这是释放外部资源的最好的地方）。</p>
<h2 id="Java中如何实现序列化，有什么意义？"><a href="#Java中如何实现序列化，有什么意义？" class="headerlink" title="Java中如何实现序列化，有什么意义？"></a>Java中如何实现序列化，有什么意义？</h2><p>答：序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。序列化是为了解决对象流读写操作时可能引发的问题（如果不进行序列化可能会存在数据乱序的问题）。<br>要实现序列化，需要让一个类实现Serializable接口，该接口是一个标识性接口，标注该类对象是可被序列化的，然后使用一个输出流来构造一个对象输出流并通过writeObject(Object)方法就可以将实现对象写出（即保存其状态）；如果需要反序列化则可以用一个输入流建立对象输入流，然后通过readObject方法从流中读取对象。序列化除了能够实现对象的持久化之外，还能够用于对象的深度克隆</p>
<h2 id="Java中有几种类型的流？"><a href="#Java中有几种类型的流？" class="headerlink" title="Java中有几种类型的流？"></a>Java中有几种类型的流？</h2><p>答：字节流和字符流。字节流继承于InputStream、OutputStream，字符流继承于Reader、Writer。在java.io 包中还有许多其他的流，主要是为了提高性能和使用方便。关于Java的I/O需要注意的有两点：一是两种对称性（输入和输出的对称性，字节和字符的对称性）；二是两种设计模式（适配器模式和装潢模式）。另外Java中的流不同于C#的是它只有一个维度一个方向。</p>
<h2 id="如何用Java代码列出一个目录下所有的文件？"><a href="#如何用Java代码列出一个目录下所有的文件？" class="headerlink" title="如何用Java代码列出一个目录下所有的文件？"></a>如何用Java代码列出一个目录下所有的文件？</h2><p>如果只要求列出当前文件夹下的文件，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">&quot;/Users/Downloads&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(File temp : f.listFiles()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(temp.isFile()) &#123;</span><br><span class="line">                System.out.println(temp.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果需要对文件夹继续展开，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        showDirectory(<span class="keyword">new</span> File(<span class="string">&quot;/Users/Downloads&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showDirectory</span><span class="params">(File f)</span> </span>&#123;</span><br><span class="line">        _walkDirectory(f, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">_walkDirectory</span><span class="params">(File f, <span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(f.isDirectory()) &#123;</span><br><span class="line">            <span class="keyword">for</span>(File temp : f.listFiles()) &#123;</span><br><span class="line">                _walkDirectory(temp, level + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; level - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(f.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="什么是DAO模式？"><a href="#什么是DAO模式？" class="headerlink" title="什么是DAO模式？"></a>什么是DAO模式？</h2><p>答：DAO（Data Access Object）顾名思义是一个为数据库或其他持久化机制提供了抽象接口的对象，在不暴露底层持久化方案实现细节的前提下提供了各种数据访问操作。在实际的开发中，应该将所有对数据源的访问操作进行抽象化后封装在一个公共API中。用程序设计语言来说，就是建立一个接口，接口中定义了此应用程序中将会用到的所有事务方法。在这个应用程序中，当需要和数据源进行交互的时候则使用这个接口，并且编写一个单独的类来实现这个接口，在逻辑上该类对应一个特定的数据存储。DAO模式实际上包含了两个模式，一是Data Accessor（数据访问器），二是Data Object（数据对象），前者要解决如何访问数据的问题，而后者要解决的是如何用对象封装数据。</p>
<h2 id="事务的ACID是指什么？"><a href="#事务的ACID是指什么？" class="headerlink" title="事务的ACID是指什么？"></a>事务的ACID是指什么？</h2><p>答： </p>
<ul>
<li>原子性(Atomic)：事务中各项操作，要么全做要么全不做，任何一项操作的失败都会导致整个事务的失败； </li>
<li>一致性(Consistent)：事务结束后系统状态是一致的； </li>
<li>隔离性(Isolated)：并发执行的事务彼此无法看到对方的中间状态； </li>
<li>持久性(Durable)：事务完成后所做的改动都会被持久化，即使发生灾难性的失败。通过日志和同步备份可以在故障发生后重建数据。<blockquote>
<p>补充：关于事务，在面试中被问到的概率是很高的，可以问的问题也是很多的。首先需要知道的是，只有存在并发数据访问时才需要事务。当多个事务访问同一数据时，可能会存在5类问题，包括3类数据读取问题（脏读、不可重复读和幻读）和2类数据更新问题（第1类丢失更新和第2类丢失更新）。</p>
</blockquote>
</li>
</ul>
<h2 id="简述正则表达式及其用途。"><a href="#简述正则表达式及其用途。" class="headerlink" title="简述正则表达式及其用途。"></a>简述正则表达式及其用途。</h2><p>答：在编写处理字符串的程序时，经常会有查找符合某些复杂规则的字符串的需要。正则表达式就是用于描述这些规则的工具。换句话说，正则表达式就是记录文本规则的代码。</p>
<blockquote>
<p>说明：计算机诞生初期处理的信息几乎都是数值，但是时过境迁，今天我们使用计算机处理的信息更多的时候不是数值而是字符串，正则表达式就是在进行字符串匹配和处理的时候最为强大的工具，绝大多数语言都提供了对正则表达式的支持。</p>
</blockquote>
<h2 id="Java中是如何支持正则表达式操作的？"><a href="#Java中是如何支持正则表达式操作的？" class="headerlink" title="Java中是如何支持正则表达式操作的？"></a>Java中是如何支持正则表达式操作的？</h2><p>答：Java中的String类提供了支持正则表达式操作的方法，包括：matches()、replaceAll()、replaceFirst()、split()。此外，Java中可以用Pattern类表示正则表达式对象，它提供了丰富的API进行各种正则表达式操作，请参考下面面试题的代码。</p>
<blockquote>
<p>面试题： - 如果要从字符串中截取第一个英文左括号之前的字符串，例如：北京市(朝阳区)(西城区)(海淀区)，截取结果为：北京市，那么正则表达式怎么写？</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RegExpTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">&quot;北京市(朝阳区)(西城区)(海淀区)&quot;</span>;</span><br><span class="line">        Pattern p = Pattern.compile(<span class="string">&quot;.*?(?=\\()&quot;</span>);</span><br><span class="line">        Matcher m = p.matcher(str);</span><br><span class="line">        <span class="keyword">if</span>(m.find()) &#123;</span><br><span class="line">            System.out.println(m.group());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="获得一个类的类对象有哪些方式？"><a href="#获得一个类的类对象有哪些方式？" class="headerlink" title="获得一个类的类对象有哪些方式？"></a>获得一个类的类对象有哪些方式？</h2><p>答： </p>
<ul>
<li>类型.class，例如：String.class </li>
<li>对象.getClass()，例如：”hello”.getClass() </li>
<li>Class.forName()，例如：Class.forName(“java.lang.String”)<h2 id="如何通过反射创建对象？"><a href="#如何通过反射创建对象？" class="headerlink" title="如何通过反射创建对象？"></a>如何通过反射创建对象？</h2>答： </li>
<li>通过类对象调用newInstance()方法，例如：String.class.newInstance() </li>
<li>通过类对象的getConstructor()或getDeclaredConstructor()方法获得构造器（Constructor）对象并调用其newInstance()方法创建对象，例如：String.class.getConstructor(String.class).newInstance(“Hello”);</li>
</ul>
<h2 id="如何通过反射调用对象的方法？"><a href="#如何通过反射调用对象的方法？" class="headerlink" title="如何通过反射调用对象的方法？"></a>如何通过反射调用对象的方法？</h2><p>答：请看下面的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MethodInvokeTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        Method m = str.getClass().getMethod(<span class="string">&quot;toUpperCase&quot;</span>);</span><br><span class="line">        System.out.println(m.invoke(str));  <span class="comment">// HELLO</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="简述一下你了解的设计模式。"><a href="#简述一下你了解的设计模式。" class="headerlink" title="简述一下你了解的设计模式。"></a>简述一下你了解的设计模式。</h2><p>答：所谓设计模式，就是一套被反复使用的代码设计经验的总结（情境中一个问题经过证实的一个解决方案）。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。设计模式使人们可以更加简单方便的复用成功的设计和体系结构。将已证实的技术表述成设计模式也会使新系统开发者更加容易理解其设计思路。<br>在GoF的《Design Patterns: Elements of Reusable Object-Oriented Software》中给出了三类（创建型[对类的实例化过程的抽象化]、结构型[描述如何将类或对象结合在一起形成更大的结构]、行为型[对在不同的对象之间划分责任和算法的抽象化]）共23种设计模式，包括：Abstract Factory（抽象工厂模式），Builder（建造者模式），Factory Method（工厂方法模式），Prototype（原始模型模式），Singleton（单例模式）；Facade（门面模式），Adapter（适配器模式），Bridge（桥梁模式），Composite（合成模式），Decorator（装饰模式），Flyweight（享元模式），Proxy（代理模式）；Command（命令模式），Interpreter（解释器模式），Visitor（访问者模式），Iterator（迭代子模式），Mediator（调停者模式），Memento（备忘录模式），Observer（观察者模式），State（状态模式），Strategy（策略模式），Template Method（模板方法模式）， Chain Of Responsibility（责任链模式）。<br>面试被问到关于设计模式的知识时，可以拣最常用的作答，例如： </p>
<ul>
<li>工厂模式：工厂类可以根据条件生成不同的子类实例，这些子类有一个公共的抽象父类并且实现了相同的方法，但是这些方法针对不同的数据进行了不同的操作（多态方法）。当得到子类的实例后，开发人员可以调用基类中的方法而不必考虑到底返回的是哪一个子类的实例。 </li>
<li>代理模式：给一个对象提供一个代理对象，并由代理对象控制原对象的引用。实际开发中，按照使用目的的不同，代理可以分为：远程代理、虚拟代理、保护代理、Cache代理、防火墙代理、同步化代理、智能引用代理。 </li>
<li>适配器模式：把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起使用的类能够一起工作。 </li>
<li>模板方法模式：提供一个抽象类，将部分逻辑以具体方法或构造器的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法（多态实现），从而实现不同的业务逻辑。<br>除此之外，还可以讲讲上面提到的门面模式、桥梁模式、单例模式、装潢模式（Collections工具类和I/O系统中都使用装潢模式）等，反正基本原则就是拣自己最熟悉的、用得最多的作答，以免言多必失。</li>
</ul>
<h2 id="用Java写一个单例类。"><a href="#用Java写一个单例类。" class="headerlink" title="用Java写一个单例类。"></a>用Java写一个单例类。</h2><p>饿汉式单例:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>懒汉式单例:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) instance ＝ <span class="keyword">new</span> Singleton();</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="什么是UML？"><a href="#什么是UML？" class="headerlink" title="什么是UML？"></a>什么是UML？</h2><p>答：UML是统一建模语言（Unified Modeling Language）的缩写，它发表于1997年，综合了当时已经存在的面向对象的建模语言、方法和过程，是一个支持模型化和软件系统开发的图形化语言，为软件开发的所有阶段提供模型化和可视化支持。使用UML可以帮助沟通与交流，辅助应用设计和文档的生成，还能够阐释系统的结构和行为。</p>
<h2 id="UML中有哪些常用的图？"><a href="#UML中有哪些常用的图？" class="headerlink" title="UML中有哪些常用的图？"></a>UML中有哪些常用的图？</h2><p>UML定义了多种图形化的符号来描述软件系统部分或全部的静态结构和动态结构，包括：用例图（use case diagram）、类图（class diagram）、时序图（sequence diagram）、协作图（collaboration diagram）、状态图（statechart diagram）、活动图（activity diagram）、构件图（component diagram）、部署图（deployment diagram）等。在这些图形化符号中，有三种图最为重要，分别是：用例图（用来捕获需求，描述系统的功能，通过该图可以迅速的了解系统的功能模块及其关系）、类图（描述类以及类与类之间的关系，通过该图可以快速了解系统）、时序图（描述执行特定任务时对象之间的交互关系以及执行顺序，通过该图可以了解对象能接收的消息也就是说对象能够向外界提供的服务）。</p>
<h2 id="用Java写一个折半查找。"><a href="#用Java写一个折半查找。" class="headerlink" title="用Java写一个折半查找。"></a>用Java写一个折半查找。</h2><p>答：折半查找，也称二分查找、二分搜索，是一种在有序数组中查找某一特定元素的搜索算法。搜素过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜素过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组已经为空，则表示找不到指定的元素。这种搜索算法每一次比较都使搜索范围缩小一半，其时间复杂度是O(logN)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&lt;T&gt;&gt; <span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(T[] x, T key)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> binarySearch(x, <span class="number">0</span>, x.length- <span class="number">1</span>, key);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 使用循环实现的二分查找</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(T[] x, T key, Comparator&lt;T&gt; comp)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> high = x.length - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">          <span class="keyword">int</span> mid = (low + high) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">int</span> cmp = comp.compare(x[mid], key);</span><br><span class="line">          <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            low= mid + <span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            high= mid - <span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 使用递归实现的二分查找</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span>&lt;T extends Comparable&lt;T&gt;&gt; <span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(T[] x, <span class="keyword">int</span> low, <span class="keyword">int</span> high, T key)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(low &lt;= high) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = low + ((high -low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(key.compareTo(x[mid])== <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(key.compareTo(x[mid])&lt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> binarySearch(x,low, mid - <span class="number">1</span>, key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> binarySearch(x,mid + <span class="number">1</span>, high, key);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>java杂记</category>
      </categories>
      <tags>
        <tag>little_eight</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql两万字精华总结</title>
    <url>/2021/08/09/mysql%E4%B8%A4%E4%B8%87%E5%AD%97%E7%B2%BE%E5%8D%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="基础架构"><a href="#基础架构" class="headerlink" title="基础架构"></a>基础架构</h2><p>这是官网的一个架构图，总体是可以分为四层的。<br><img data-src="https://gitee.com/littleeight/blog-images/raw/master/mysql%E4%B8%A4%E4%B8%87%E5%AD%97%E7%B2%BE%E5%8D%8E%E6%80%BB%E7%BB%93/1.png"></p>
<ul>
<li><strong>连接层</strong>：最上层是一些客户端和连接服务。<strong>主要完成一些类似于连接处理、授权认证、及相关的安全方案</strong>。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。</li>
<li><strong>服务层</strong>：第二层服务层，主要完成大部分的核心服务功能， 包括查询解析、分析、优化、缓存、以及所有的内置函数，所有跨存储引擎的功能也都在这一层实现，包括触发器、存储过程、视图等</li>
<li><strong>引擎层</strong>：第三层存储引擎层，存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API与存储引擎进行通信。不同的存储引擎具有的功能不同，这样我们可以根据自己的实际需要进行选取</li>
<li><strong>存储层</strong>：第四层为数据存储层，主要是将数据存储在运行于该设备的文件系统之上，并完成与存储引擎的交互<span id="more"></span> 
​</li>
</ul>
<p>可以从sql的执行过程分析总体的架构，比如下图：<br>![]</p>
<h3 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h3><p>客户端请求连接数据库时，连接器就会负责跟客户端建立连接、获取权限、维持和管理连接。MySQL服务器端也会有一个连接池，因为一般都会有多个系统与MySQL建立很多个连接，MySQL通过这个连接池去维护与客户端的数据库连接。<br>除此之外，连接器还会根据请求的账号和密码，进行安全认证，库表权限认证。如果用户名或密码不对，就会收到一个”Access denied for user”的错误。如果用户名密码认证通过，连接器会到权限表里面查出你拥有的权限。之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限。这也意味着，一个用户成功建立连接后，即使你用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。<br>连接完成后，如果没有后续的动作，这个连接就处于空闲状态。客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数 wait_timeout 控制的，默认值是 8 小时。<br>对于一个 MySQL连接，任何时刻都有一个状态，该状态表示了MySQL当前正在做什么。可以使用 **SHOW FULL PROCESSLIST **命令查看当前连接的状态（Command列）。在一个查询的生命周期中，状态会变化很多次。<br>MySQL官方手册中给出了如下状态：</p>
<ul>
<li><strong>Sleep</strong>：处于空闲状态，线程正在等待客户端发送新的请求。</li>
<li><strong>Query</strong>：线程正在执行查询或者正在将结果发送给客户端。</li>
<li><strong>Locked</strong>：在MySQL服务器层，该线程正在等待表锁。在存储引擎级别实现的锁，例如InnoDB的行锁，并不会体现在线程状态中。对于MyISAM来说这是一个比较典型的状态。</li>
<li><strong>Analyzing and statistics</strong>：线程正在收集存储引擎的统计信息，并生成查询的执行计划。</li>
<li>**Copying to tmp table [on disk]**：线程正在执行查询，并且将其结果集都复制到一个临时表中，这种状态一般要么是在做 GROUP BY 操作，要么是文件排序操作，或者是 UNION 操作。如果这个状态后面还有“on disk”标记，那表示MySQL正在将一个内存临时表放到磁盘上。</li>
<li><strong>Sorting result</strong>：线程正在对结果集进行排序。</li>
<li><strong>Sending data</strong>：线程可能在多个状态之间传送数据，或者在生成结果集，或者在向客户端返回数据。</li>
</ul>
<p>​</p>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>在解析一个查询语句之前，如果查询缓存是打开的，那么MySQL会优先检查这个查询是否命中查询缓存中的数据。之前执行过的语句及其结果可能会以 key-value 对的形式，被直接缓存在内存中。key 是查询的语句，value 是查询的结果。查询和缓存中的查询即使只有一个字节不同，那也不会匹配缓存结果，这种情况下查询就会进入下一阶段的处理。<br>如果当前的查询恰好命中了查询缓存，那么在返回查询结果之前MySQL会检查一次用户权限。这仍然是无须解析查询SQL语句的，因为在查询缓存中已经存放了当前查询需要访问的表信息。如果权限没有问题，MySQL会跳过所有其他阶段，直接从缓存中拿到结果并返回给客户端。这种情况下，查询不会被解析，不用生成执行计划，不会被执行，这个效率会很高。<br>但大多数情况下建议不要使用查询缓存，因为查询缓存往往弊大于利。查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。因此很可能缓存起来的结果还没使用，就被一个更新全清空了。对于更新压力大的数据库来说，查询缓存的命中率会非常低。<br>需要注意的是，<strong>MySQL 8.0 版本直接将查询缓存的整块功能删掉了</strong>，也就是说 8.0 开始彻底没有这个功能了。</p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>查询解析器<br>解析器来拆解这个SQL，生成一棵对应的<strong>解析树</strong>，将其变成MySQL能理解的东西。<br>首先会进行词法分析，SQL语句是由多个字符串和空格组成的，MySQL 需要识别出里面的字符串分别是什么，代表什么。接着进行语法分析，根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这SQL语句是否满足 MySQL 语法。<br>例如，它将验证是否使用错误的关键字，使用关键字的顺序是否正确，引号是否能前后正确匹配等。如果你的语句不对，就会收到“You have an error in your SQL syntax”的错误提醒。<br>预处理器则根据一些MySQL规则进一步检查解析树是否合法，这里将检查数据表和数据列是否存在，解析名字和别名，看看它们是否有歧义。下一步预处理器会验证是否有表权限、字段权限。<br>​</p>
<h3 id="查询优化器"><a href="#查询优化器" class="headerlink" title="查询优化器"></a>查询优化器</h3><p>一条查询可以有很多种执行方式，最后都返回相同的结果。优化器的作用就是找到这其中最好的执行计划。MySQL使用基于成本的优化器，它将尝试预测一个查询使用某种执行计划时的成本，并选择其中成本最小的一个。</p>
<h4 id="查询成本"><a href="#查询成本" class="headerlink" title="查询成本"></a>查询成本</h4><p>无论是执行单表查询，还是多表关联查询，都有多种执行计划可以选择，比如有的表可以全表扫描，也可以用索引A，也可以用索引B，那么到底是选择哪个执行计划呢?<br>MySQL使用基于成本的优化器，它将尝试预测一个查询使用某种执行计划时的成本，并选择其中成本最小的一个。<br>一条SQL查询语句的成本主要有两块：<br><strong>I/O成本</strong><br>首先数据都是存储在磁盘文件中的，需要先把数据从磁盘读到内存中才能操作。这个从磁盘读数据到内存所损耗的时间就是I/O成本。对于InnoDB来说，页是磁盘和内存之间交互的最小单位，MySQL 约定读一页的IO成本是1.0。<br><strong>CPU成本</strong><br>拿到数据之后，接着就会对数据做一些运算，比如验证是否满足条件，做一些分组排序的事情，这些都是耗费CPU资源，属于CPU成本。MySQL 约定读取和检测一条数据是否符合条件的CPU成本是0.2。<br>这个所谓 1.0 和 0.2 就是MySQL自定义的一个成本值，也称为成本常数，代表的意思就是一个数据页IO成本就是 1.0，一条数据检测的CPU成本就是 0.2。<br>举个例子，一条sql查出的表的记录数为1000，它的索引的字节数大小为64436B，则可算出数据页为64436/1024/16=4个（数据页默认为16k），所以全表扫描io的成本为：4<em>1=4，cpu成本为1000</em>2=2000，总成本为2004。<br>在计算出全表扫描、使用各个索引查询的成本之后，就会对比各个执行计划的成本，然后找出成本最低的一个执行计划。经过计算，全表扫描的成本显示是最大的，使用索引的成本最低。<br>​</p>
<h2 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h2><ul>
<li>整数类型：BIT、BOOL、<strong>TINYINT</strong>、SMALLINT、MEDIUMINT、 <strong>INT</strong>、 <strong>BIGINT</strong></li>
<li>浮点数类型：FLOAT、DOUBLE、DECIMAL</li>
<li>字符串类型：CHAR、<strong>VARCHAR</strong>、TINY TEXT、TEXT、MEDIUM TEXT、LONGTEXT、TINY BLOB、BLOB、MEDIUM BLOB、LONG BLOB</li>
<li>日期类型：<strong>Date</strong>、<strong>DateTime</strong>、TimeStamp、Time、Year</li>
<li>其他数据类型：BINARY、VARBINARY、ENUM、SET、Geometry、Point、MultiPoint、LineString、MultiLineString、Polygon、GeometryCollection等</li>
</ul>
<p>​</p>
<p><img data-src="https://gitee.com/littleeight/blog-images/raw/master/mysql%E4%B8%A4%E4%B8%87%E5%AD%97%E7%B2%BE%E5%8D%8E%E6%80%BB%E7%BB%93/3.png"></p>
<p><img data-src="https://gitee.com/littleeight/blog-images/raw/master/mysql%E4%B8%A4%E4%B8%87%E5%AD%97%E7%B2%BE%E5%8D%8E%E6%80%BB%E7%BB%93/add1.png"></p>
<p><img data-src="https://gitee.com/littleeight/blog-images/raw/master/mysql%E4%B8%A4%E4%B8%87%E5%AD%97%E7%B2%BE%E5%8D%8E%E6%80%BB%E7%BB%93/4.png"></p>
<p><strong>字段类型后面括号的数字作用</strong>：</p>
<ul>
<li>Char跟varchar，表示字符的最长长度</li>
<li>数据类型，表示显示数据的最小长度，但需要指定某个字符才能填充，比如zerofill（拿0来填充）</li>
</ul>
<p>​</p>
<p>​</p>
<h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><p>存储引擎是MySQL的组件，用于处理不同表类型的SQL操作。不同的存储引擎提供不同的存储机制、索引技巧、锁定水平等功能，使用不同的存储引擎，还可以获得特定的功能。<br>使用哪一种引擎可以灵活选择，<strong>一个数据库中多个表可以使用不同引擎以满足各种性能和实际需求</strong>，使用合适的存储引擎，将会提高整个数据库的性能 。<br>MySQL服务器使用<strong>可插拔</strong>的存储引擎体系结构，可以从运行中的 MySQL 服务器加载或卸载存储引擎 。<br>常见的存储引擎就 MyISAM、InnoDB。<br>​</p>
<h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><p>在mysql5.5版之前MyISAM是MySQL的默认数据库引擎，由早期的ISAM所改良。虽然性能极佳，但却有一个缺点：不支持事务处理。<br>每个MyISAM表，皆由存储在硬盘上的3个文件所组成，每个文件都以表名称为文件主名，并搭配不同扩展名区分文件类型：<br>.frm－－存储资料表定义，此文件非MyISAM引擎的一部分。.<br>.MYD－－存放真正的数据。.<br>.MYI－－存储索引信息。</p>
<h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><p>InnoDB 现在是 MySQL 默认的存储引擎，支持<strong>事务、行级锁定和外键。</strong>其物理文件结构为<strong>：</strong></p>
<ul>
<li>.frm ：与表相关的元数据信息都存放在frm文件，包括表结构的定义信息等。</li>
<li>.ibd 或 .ibdata ： 这两种文件都是存放 InnoDB 数据的文件，之所以有两种文件形式存放 InnoDB 的数据，是因为 InnoDB 的数据存储方式能够通过配置来决定是使用<strong>共享表空间</strong>存放存储数据，还是用<strong>独享表空间</strong>存放存储数据。</li>
</ul>
<p>​</p>
<p>独享表空间存储方式使用.ibd文件，并且每个表一个.ibd文件 共享表空间存储方式使用.ibdata文件，所有表共同使用一个.ibdata文件（或多个，可自己配置。<br>​</p>
<h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><p>事务的acid：</p>
<ul>
<li><strong>atomicity</strong> 原子性，一个事务要么全部提交成功要么全部失败回滚。</li>
<li><strong>consistency</strong>一致性，数据库总是从一个一致性的状态转换到另一个一致性的状态（成功全部提交，失败全部回滚）。</li>
<li><strong>isolation</strong>隔离性，一个事务在提交时对其他事务是不可见的。</li>
<li><strong>durability</strong>持久性，一旦事务提交，其修改就会保存到数据库。</li>
</ul>
<p>每一种特性，innodb都有自己的方式去实现，具体如下图：<br><img data-src="https://gitee.com/littleeight/blog-images/raw/master/mysql%E4%B8%A4%E4%B8%87%E5%AD%97%E7%B2%BE%E5%8D%8E%E6%80%BB%E7%BB%93/5.png"></p>
<h4 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h4><ul>
<li>未提交读read uncommitted，事务可读取未提交的数据，可出现脏读、不可重复读、幻读</li>
<li>提交读read committed，事务可读取已提交的数据，可出现不可重复读、幻读</li>
<li>可重复读repeatable read，同个事务多次读取同样的记录结果是一致的，可能出现幻读</li>
<li>可串行化serializable，会在读取每一行数据时加上锁</li>
</ul>
<p>​</p>
<p><strong>为什么默认RR级别？</strong><br>1、越高的隔离级别，能解决的数据一致性问题越多，理论上性能损耗更大，可并发性越低。<br>2、在mysql5.0版本之前，binlog在读已提交这个隔离级别的主从复制是有bug的，因此把可重复读作为默认3、原因其实很简单，就是主机的执行顺序是先删除和插入！此时，binlog 是 STATEMENT 格式的，其记录的顺序首先插入和删除！同步来自(从属)是 binlog，所以从属的执行顺序与主机不一致！主人和奴隶之间会有矛盾！如何解决？有两个解决方案！<br>(1)将隔离级别设置为可重复读，并在此隔离级别引入间隙锁。当会话1执行 delete 语句时，间隙被锁定。然后，Ssession 2将阻止 insert 语句的执行！<br>(2)将 binglog 格式改为行格式。在这个时候，它是一个基于行的副本。当然，sql 的执行顺序不会有问题！这种格式是在 mysql5.1版本开始时引入的。因此，由于历史原因，mysql 将默认隔离级别设置为 Repeatable Read (Repeatable Read) ，以确保主从复制不会导致问题！</p>
<h4 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h4><p><strong>innodb基于索引来实现行级锁的，条件里无索引的话则为表锁。</strong><br>innodb实现了如下两种标准的行级锁：</p>
<ul>
<li><strong>共享锁</strong>(读锁 S Lock)，又称读锁，若事务T对数据对象A加上S锁，则事务T可以读A但是不能修改，其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。这保证了其他事务可以读A，不可以修改A。</li>
<li><strong>排它锁</strong>(写锁 X Lock)，又称写锁，若事务T对数据对象A加上X锁，则事务T可以读A也可以修改，其他事务不能对A进行加锁，直到T释放A上的X锁。</li>
</ul>
<p>举几个例子说明：</p>
<ul>
<li>SELECT … 语句正常情况下为快照读，不加锁；（快照读的意思是，数据有多个版本，当事务并发执行时，某一事务读取的数据来    自其中一个版本（快照））</li>
<li>SELECT … LOCK IN SHARE MODE：加共享(S)锁</li>
<li>SELECT … FOR UPDATE：加排他(X)锁</li>
<li>INSERT / UPDATE / DELETE：加排他(X)锁</li>
</ul>
<p>​</p>
<p>InnoDB 支持两种<strong>意向锁</strong>(即为表级别的锁)：</p>
<ul>
<li><strong>意向共享锁</strong>(读锁 IS Lock)，事务想要获取一张表的几行数据的共享锁，事务在给一个数据行加共享锁前必须先取得该表的 IS 锁。</li>
<li><strong>意向排他锁</strong>(写锁 IX Lock)，事务想要获取一张表中几行数据的排它锁，事务在给一个数据行加排它锁前必须先取得该表的 IX 锁。</li>
</ul>
<p>​</p>
<p>加意向锁为了表明某个事务正在锁定一行或者将要锁定一行数据。首先申请意向锁的动作是InnoDB 完成的，怎么理解意向锁呢?例如：事务 A 要对一行记录 R 进行上 X 锁，那么 InnoDB 会先申请表的 IX 锁，再锁定记录 R 的 X 锁。在事务 A 完成之前，事务 B 想要来个全表操作，此时直接在表级别的 IX 就告诉事务 B 需要等待而不需要在表上判断每一行是否有锁。意向排它锁存在的价值在于节约 InnoDB 对于锁的定位和处理性能。另外注意了，除了全表扫描以外意向锁都不会阻塞。<br>[​</p>
<p>](<a href="https://blog.csdn.net/yue_2018/article/details/89047758">https://blog.csdn.net/yue_2018/article/details/89047758</a>)<br>InnoDB 有 3 种行锁的算法：</p>
<ul>
<li><strong>Record Lock</strong>：记录锁，存在于包括主键的唯一索引，单个行记录上的锁。</li>
<li><strong>Gap Lock</strong>：间隙锁，存在于非唯一索引，对索引项之间的“间隙”加锁，锁定记录的范围（对第一条记录前的间隙或最后一条将记录后的间隙加锁），不包含索引项本身。这种锁只会存在于<strong>范围查询，而对于单个条件的查询则会用临键锁。</strong></li>
<li><strong>Next-Key Lock</strong>：临键锁，存在于非唯一索引，锁定一个范围，并且锁定记录本身。主要解决的问题是 RR 隔离级别下的幻读。</li>
</ul>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>锁之间的互相等待，就会造成死锁，比如以下例子：<br>事务a                                               事务b<br>Begin;                                                        begin;<br>Select * from user where id = 1 for update;                        Select * from user where id = 2 for update;<br>Insert into user(“name”) value(“哈哈”)      where id = 1;        Insert into user(“name”) value(“哈哈”)  where id =2;<br>Commit;                                                              Commit;<br>此时a、b就会互相等待死锁。<br>​</p>
<p><strong>检测死锁</strong>：数据库系统实现了各种死锁检测和死锁超时的机制。InnoDB存储引擎能检测到死锁的循环依赖并立即返回一个错误。<br><strong>死锁恢复</strong>：死锁发生以后，只有部分或完全回滚其中一个事务，才能打破死锁，InnoDB目前处理死锁的方法是，<strong>将持有最少行级排他锁的事务进行回滚</strong>。所以事务型应用程序在设计时必须考虑如何处理死锁，多数情况下只需要重新执行因死锁回滚的事务即可。<br><strong>外部锁的死锁检测</strong>：发生死锁后，InnoDB 一般都能自动检测到，并使一个事务释放锁并回退，另一个事务获得锁，继续完成事务。但在涉及外部锁，或涉及表锁的情况下，InnoDB 并不能完全自动检测到死锁， 这需要通过设置锁等待超时参数 innodb_lock_wait_timeout 来解决<br><strong>死锁影响性能</strong>：死锁会影响性能而不是会产生严重错误，因为InnoDB会自动检测死锁状况并回滚其中一个受影响的事务。在高并发系统上，当许多线程等待同一个锁时，死锁检测可能导致速度变慢。 有时当发生死锁时，禁用死锁检测（使用innodb_deadlock_detect配置选项）可能会更有效，这时可以依赖innodb_lock_wait_timeout设置进行事务回滚。<br>​</p>
<p><strong>如何避免死锁</strong></p>
<ul>
<li>为了在单个InnoDB表上执行多个并发写入操作时避免死锁，可以在事务开始时通过为预期要修改的每个元祖（行）使用<strong>SELECT … FOR UPDATE</strong>语句来获取必要的锁，即使这些行的更改语句是在之后才执行的。</li>
<li>在事务中，如果要更新记录，应该直接申请足够级别的锁，即排他锁，而不应先申请共享锁、更新时再申请排他锁，因为这时候当用户再申请排他锁时，其他事务可能又已经获得了相同记录的共享锁，从而造成锁冲突，甚至死锁</li>
<li>如果事务需要修改或锁定多个表，则应在每个事务中以相同的顺序使用加锁语句。 在应用中，如果不同的程序会并发存取多个表，应尽量约定以相同的顺序来访问表，这样可以大大降低产生死锁的机会</li>
<li>改变事务隔离级别，改成串行化</li>
</ul>
<p>​</p>
<p>如果出现死锁，可以用** show engine innodb status**命令来确定最后一个死锁产生的原因。返回结果中包括死锁相关事务的详细信息，如引发死锁的 SQL 语句，事务已经获得的锁，正在等待什么锁，以及被回滚的事务等。据此可以分析死锁产生的原因和改进措施。<br>​</p>
<p>​</p>
<h4 id="mvcc多版本并发控制"><a href="#mvcc多版本并发控制" class="headerlink" title="mvcc多版本并发控制"></a>mvcc多版本并发控制</h4><p>在内部，innodb会为每一行数据添加三个额外的字段</p>
<ul>
<li><strong>db_trx _ id</strong>：一个6字节的 db_trx _ id 字段表示插入或更新行的最后一个事务的事务标识符。此外，删除在内部被视为更新，其中行中的一个特殊位被设置为将其标记为 deleted。</li>
<li><strong>db_roll _ ptr</strong>：一个7字节的 db_roll _ ptr 字段称为滚动指针。滚动指针指向写入回滚段的 undo log记录。如果更新了行，则 undo log记录包含在更新行之前重新生成其内容所必需的信息。</li>
<li><strong>db_row _ ID</strong> ：一个6字节的 db_row _ ID 字段包含一个行 ID，该行 ID 随着插入新行而单调增加。如果 InnoDB 自动生成聚集索引，则索引包含行 ID 值。否则，db_row _ id 列不会出现在任何索引中。</li>
</ul>
<p>​</p>
<p>innodb在select的时候，创建新的<strong>read view</strong>时，会把全局读写事务id（活跃的事务id）拷贝到本地descriptors，设置up_limit_id为这个descriptors里最小的值作为低水位，设置low_limit_id为创建readview时应该分给下一个事务的id作为高水位。<br>1、当db_trx_id（记录的事务id）小于低水位时，说明这条记录的修改是在创建rv之前，可见状态。<br>2、当该id大于高水位，说明这条记录的修改是在创建rv之后，不可见状态。<br>3、当该id处于两者之间时，当不在descripors里时，说明是已提交的事务而可见，而在descripors里时说明被其他事务修改中不可见。<br>4、当不可见状态时，会根据db_roll_ptr来获取undo log的有关上一个版本的数据并重新进行比较，直到找到一个能够被当前事务能够看到的版本返回具体数据。<br>read commited与repeatable read的区别在于，前者在每次select都会新建一个readview，后者会在每次事务新建并共用一个readview，所以能够解决幻读问题。<br><img data-src="https://gitee.com/littleeight/blog-images/raw/master/mysql%E4%B8%A4%E4%B8%87%E5%AD%97%E7%B2%BE%E5%8D%8E%E6%80%BB%E7%BB%93/6.png"></p>
<h3 id="MYISAM与InnoDB的区别"><a href="#MYISAM与InnoDB的区别" class="headerlink" title="MYISAM与InnoDB的区别"></a>MYISAM与InnoDB的区别</h3><h4 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h4><p><strong>MyISAM：</strong>每个MyISAM在磁盘上存储成三个文件。分别为：<strong>表定义文件、数据文件、索引文件。</strong>第一个文件的名字以表的名字开始，扩展名指出文件类型。.frm文件存储表定义。数据文件的扩展名为.MYD (MYData)。索引文件的扩展名是.MYI (MYIndex)。<br><strong>InnoDB：</strong>所有的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间文件），InnoDB表的大小只受限于操作系统文件的大小，一般为2GB。</p>
<h4 id="存储空间"><a href="#存储空间" class="headerlink" title="存储空间"></a>存储空间</h4><p><strong>MyISAM：</strong> MyISAM支持支持三种不同的存储格式：静态表(默认，但是注意数据末尾不能有空格，会被去掉)、动态表、压缩表。当表在创建之后并导入数据之后，不会再进行修改操作，可以使用压缩表，极大的减少磁盘的空间占用。<br><strong>InnoDB：</strong> 需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引。</p>
<h4 id="可移植性、备份及恢复"><a href="#可移植性、备份及恢复" class="headerlink" title="可移植性、备份及恢复"></a>可移植性、备份及恢复</h4><p><strong>MyISAM：</strong>数据是以文件的形式存储，所以在跨平台的数据转移中会很方便。在备份和恢复时可单独针对某个表进行操作。<br><strong>InnoDB：</strong>免费的方案可以是拷贝数据文件、备份 binlog，或者用 mysqldump，在数据量达到几十G的时候就相对痛苦了。</p>
<h4 id="事务支持"><a href="#事务支持" class="headerlink" title="事务支持"></a>事务支持</h4><p><strong>MyISAM：</strong>强调的是性能，每次查询具有原子性,其执行数度比InnoDB类型更快，但是不提供事务支持。<br><strong>InnoDB：</strong>提供事务支持事务，外部键等高级数据库功能。 具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。</p>
<h4 id="表锁差异"><a href="#表锁差异" class="headerlink" title="表锁差异"></a>表锁差异</h4><p><strong>MyISAM：</strong> 只支持表级锁，用户在操作myisam表时，select，update，delete，insert语句都会给表自动加锁，如果加锁以后的表满足insert并发的情况下，可以在表的尾部插入新的数据。<br><strong>InnoDB：</strong> 支持事务和行级锁，是innodb的最大特色。行锁大幅度提高了多用户并发操作的新能。但是InnoDB的行锁，只是在WHERE的主键是有效的，非主键的WHERE都会锁全表的。</p>
<h4 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h4><p><strong>MyISAM：</strong>支持 FULLTEXT类型的全文索引<br><strong>InnoDB：</strong>不支持FULLTEXT类型的全文索引，但是innodb可以使用sphinx插件支持全文索引，并且效果更好。</p>
<h4 id="表主键"><a href="#表主键" class="headerlink" title="表主键"></a>表主键</h4><p><strong>MyISAM：</strong>允许没有任何索引和主键的表存在，索引都是保存行的地址。<br><strong>InnoDB：</strong>如果没有设定主键或者非空唯一索引，就会自动生成一个6字节的主键(用户不可见)，数据是主索引的一部分，附加索引保存的是主索引的值。</p>
<h4 id="表的具体行数"><a href="#表的具体行数" class="headerlink" title="表的具体行数"></a>表的具体行数</h4><p><strong>MyISAM：</strong> 保存有表的总行数，如果select count(<em>) from table;会直接取出出该值。</em><br><strong>InnoDB：</strong> 没有保存表的总行数，如果使用select count(*) from table；就会遍历整个表，消耗相当大，但是在<strong>加了wehre条件</strong>后，myisam和innodb处理的方式都一样。</p>
<h4 id="CRUD操作"><a href="#CRUD操作" class="headerlink" title="CRUD操作"></a>CRUD操作</h4><p><strong>MyISAM：</strong>如果执行大量的SELECT，MyISAM是更好的选择。<br><strong>InnoDB：</strong>如果你的数据执行大量的INSERT或UPDATE，出于性能方面的考虑，应该使用InnoDB表。</p>
<h4 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h4><p><strong>MyISAM：</strong>不支持<br><strong>InnoDB：</strong>支持<br>​</p>
<p>​</p>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h3><p>下图为hash跟b+树的数据结构中被支持的存储引擎：<br><img data-src="https://gitee.com/littleeight/blog-images/raw/master/mysql%E4%B8%A4%E4%B8%87%E5%AD%97%E7%B2%BE%E5%8D%8E%E6%80%BB%E7%BB%93/7.png"></p>
<ul>
<li>数据结构类型<ul>
<li>B+树索引</li>
<li>Hash索引</li>
<li>Full-Text全文索引，</li>
<li>R-Tree索引，空间索引是MyISAM的一种特殊索引类型，主要用于地理空间数据类型。</li>
</ul>
</li>
<li>物理存储类型<ul>
<li>聚集索引（clustered index）</li>
<li>非聚集索引（non-clustered index），也叫辅助索引（secondary index）聚集索引和非聚集索引都是B+树结构</li>
</ul>
</li>
<li>逻辑类型<ul>
<li>主键索引：主键索引是一种特殊的唯一索引，不允许有空值</li>
<li>普通索引或者单列索引：每个索引只包含单个列，一个表可以有多个单列索引</li>
<li>多列索引（复合索引、联合索引）：复合索引指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用复合索引时遵循最左前缀集合</li>
<li>唯一索引或者非唯一索引</li>
<li>空间索引：空间索引是对空间数据类型的字段建立的索引，MYSQL中的空间数据类型有4种，分别是GEOMETRY、POINT、LINESTRING、POLYGON。 MYSQL使用SPATIAL关键字进行扩展，使得能够用于创建正规索引类型的语法创建空间索引。创建空间索引的列，必须将其声明为NOT NULL，空间索引只能在存储引擎为MYISAM的表中创建</li>
</ul>
</li>
</ul>
<h3 id="b-树索引"><a href="#b-树索引" class="headerlink" title="b+树索引"></a>b+树索引</h3><p>首先来看图了解它的构造：<br><img data-src="https://gitee.com/littleeight/blog-images/raw/master/mysql%E4%B8%A4%E4%B8%87%E5%AD%97%E7%B2%BE%E5%8D%8E%E6%80%BB%E7%BB%93/8.png"></p>
<p>对于b树来讲，它不需要在每个节点中都存储相关的数据，反而把数据都放到了叶子节点（<strong>myisam叶子节点存储的是数据记录的地址</strong>，如下图）。所以b树有明显的2个缺点：</p>
<ul>
<li>插入删除新的数据记录会破坏b树的性质，因此在插入删除时，需要对树进行一个分裂、合并、转移等操作以保持b树性质。造成IO操作频繁。</li>
<li>区间查找可能需要返回上层节点重复遍历，IO操作繁琐。</li>
</ul>
<p>​</p>
<p><img data-src="https://gitee.com/littleeight/blog-images/raw/master/mysql%E4%B8%A4%E4%B8%87%E5%AD%97%E7%B2%BE%E5%8D%8E%E6%80%BB%E7%BB%93/9.png"></p>
<h4 id="如何从磁盘读取数据？"><a href="#如何从磁盘读取数据？" class="headerlink" title="如何从磁盘读取数据？"></a>如何从磁盘读取数据？</h4><p>磁盘IO时间 = 寻道 + 磁盘旋转 + 数据传输时间，从磁盘读取数据时，系统会将逻辑地址发给磁盘，磁盘将逻辑地址转换为物理地址(哪个磁道，哪个扇区)。 磁头进行机械运动，先找到相应磁道，再找该磁道的对应扇区，扇区是磁盘的最小存储单元。<br>myisam每次都会先一次性加载索引到内存中，然后根据查到的物理地址去一次获取对应地址所在的扇区的数据到操作系统的缓存中存储起来，用来减少磁盘读取。<br>而innodb的话定义了一个树的节点为一个数据页，每访问一个节点就需要去磁盘读取加载到内存中，一次取一个数据页缓存起来，如果没有符合条件的再进行下次磁盘读取，如下图所示：<br><img data-src="https://gitee.com/littleeight/blog-images/raw/master/mysql%E4%B8%A4%E4%B8%87%E5%AD%97%E7%B2%BE%E5%8D%8E%E6%80%BB%E7%BB%93/10.png"></p>
<p>数据页由7大部分组成：</p>
<ul>
<li>file header，文件头部，38字节</li>
<li>page header，页面头部，56字节</li>
<li>Infimum + Supremum， Infimum记录是比该页中任何主键值都要小的记录，Supremum记录 是比改页中何主键值都要大的记录。</li>
<li>user records, 行记录</li>
<li>free space，空闲空间</li>
<li>page directory，页面目录</li>
<li>file trailer，文件尾部，8字节</li>
</ul>
<p>​</p>
<p>在myisam的索引文件中（MYI），连续的单元组成一个Block，索引块index block的大小等于该索引节点的大小，为了最小化磁盘I/O，myisam将最频繁访问的索引块都放在内存中，这样的内存缓冲区我们称之为Key Cache，它的大小可以通过参数<strong>key_buffer_size</strong>来控制，Key Cache就是以Block为单位的。至于数据的话由操作系统的缓存来存储的。<br>而innodb在mysql启动一段时间后,将经常访问的innodb引擎表的数据放入innodb_buffer_pool.<strong>即innodb_buffer_pool</strong>保存的是热数据.然后根据一定算法淘汰不常访问的数据。在5.6版本之后，mysql支持关闭mysql服务时将内存中的热数据保存到硬盘，MySQL重启后首先将硬盘中的如数据加载到Innodb缓冲池中，以便缩短warmup进程的时间，提高业务繁忙高并发时的效率。</p>
<h4 id="千万级的数据对于innodb需要几次查询？"><a href="#千万级的数据对于innodb需要几次查询？" class="headerlink" title="千万级的数据对于innodb需要几次查询？"></a>千万级的数据对于innodb需要几次查询？</h4><p>在b+树里一个节点存储的内容是：</p>
<ul>
<li>非叶子节点：主键+指针</li>
<li>叶子节点：数据</li>
</ul>
<p>​</p>
<p>一个数据页大小默认是16k，假设我们一行数据大小为1K，那么<strong>一页就能存16条数据</strong>，也就是一个叶子节点能存16条数据；再看非叶子节点，假设主键ID为bigint类型，那么长度为8B，指针大小在Innodb源码中为6B，一共就是14B，那么一页里就可以存储16K/14=1170个(主键+指针)，那么一颗高度为2的b+树能存储的数据为：1170<em>16=18720条，一颗高度为3的B+树能存储的数据为：11701170</em>16=21902400（千万级条）。所以在innodb中B+树高度一般为1-3层，它就能满足千万级的数据存储。在查找数据时一次页的查找代表一次IO，所以通过主键索引查询通常只需要1-3次IO操作即可查找到数据。</p>
<h4 id="-1"><a href="#-1" class="headerlink" title="["></a>[</h4><p>](<a href="https://blog.csdn.net/z2516305651/article/details/100107560)%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88">https://blog.csdn.net/z2516305651/article/details/100107560)索引的优化方案</a></p>
<ul>
<li>尽量使用主键索引查询。</li>
<li>多建立联合索引，根据最左匹配原则，比如(a,b,c)，那么其实我们可利用的索引就有(a), (a,b), (a,b,c)，这样就减少了冗余索引。</li>
<li>不在索引列上做任何操作（计算、函数、(自动or手动)类型转换），会导致索引失效而转向全表扫描。</li>
<li>存储引擎不能使用索引中范围条件右边的列。</li>
<li>尽量使用覆盖索引(只访问索引的查询(索引列和查询列一致))，减少select。</li>
<li>is null ,is not null 也无法使用索引。</li>
<li>还是最左匹配原则，like “xxxx%” 是可以用到索引的，like “%xxxx” 则不行(like “%xxx%” 同理)。like以通配符开头(‘%abc…’)索引失效会变成全表扫描的操作，</li>
<li>字符串不加单引号索引失效。</li>
<li>少用or，用它来连接时会索引失效。</li>
<li>&lt;，&lt;=，=，&gt;，&gt;=，BETWEEN，IN 可用到索引，&lt;&gt;，not in ，!= 则不行，会导致全表扫描。</li>
</ul>
<p>​</p>
<h2 id="innodb的缓存"><a href="#innodb的缓存" class="headerlink" title="innodb的缓存"></a>innodb的缓存</h2><h3 id="缓冲池"><a href="#缓冲池" class="headerlink" title="缓冲池"></a>缓冲池</h3><p>我们知道对于内存与磁盘，肯定是内存的速度更快，所以在业务上使用缓存来加快读取速度，而mysql也有这种东西，称之为缓冲池。<br>InnoDB 的缓冲池叫buffer pool，当需要访问某个页时，就会把这一页的数据全部加载到缓冲池中，这样就可以在内存中进行读写访问了。对于数据库中页的修改操作，也是先修改在缓冲池中的页，然后再以一定的频率刷新到磁盘上。有了缓冲池，就可以省去很多磁盘IO的开销了，从而提升数据库性能。<br>注意即使只访问页中的一条记录，也需要把整个页的数据加载到内存中。通过索引可以定位到磁盘中的页，将页加载到内存后，就可以通过页目录（Page Directory）去定位到某条具体的记录。<br>buffer pool是mysql在启动的时候就会向操作系统申请的一块内存，其大小可由<strong>innodb_buffer_pool_size</strong>控制<strong>，</strong>默认为128M，官方建议配置为物理内存的50%-60%<strong>。</strong><br>buffer pool也是按页来划分的，默认和磁盘上的页一样大小。buffer pool 中不只缓存了数据页，还包括索引页、undo页、插入缓冲、自适应哈希索引、InnoDB存储的锁信息、数据字典信息等。<br>为了管理buffer pool中的缓存页，InnoDB 为每一个缓存页都创建了一些描述信息（元数据），用来描述这个缓存页。描述信息主要包括该页所属的<strong>表空间编号、页号、缓存页的地址、链表节点信息、锁信息、LSN信息</strong>等等。<br>另外需要注意下，每个描述数据大约相当于缓存页大小的 5%，也就是800字节左右的样子。而我们设置的 innodb_buffer_pool_size 并不包含描述数据的大小，实际上 Buffer Pool 的大小会超出这个值。比如默认配置 128MB，那么InnoDB在为 buffer pool 申请连续的内存空间时，会申请差不多 128 + 128*5% ≈ 134MB 大小的空间。<br>mysql启动时就会为buffer pool申请一片连续的内存空间，然后按照默认的数据页的大小划分出一个个的页来，还会按照800字节左右的大小划分出页对应的描述数据来。划分完成后， buffer pool  中的缓存页都是空的，等执行增删改查等操作时，才会把数据对应的页从磁盘加载到  buffer pool  中的页来。</p>
<h3 id="缓存页hash表"><a href="#缓存页hash表" class="headerlink" title="缓存页hash表"></a>缓存页hash表</h3><p>innodb设计了一个hash表(表空间号+数据页号为key值)，当执行增删改查等操作时会先去这个hash表里查该页是否被缓存了，来判断是从buffer pool获取还是从磁盘获取。当需要从磁盘获取获取并加载到buffer pool时，就会用到了free链表。</p>
<h3 id="free链表"><a href="#free链表" class="headerlink" title="free链表"></a>free链表</h3><p>innodb设计了一个<strong>free链表，</strong>来展示buffer pool里对于空闲页的信息。它是一个双向链表数据结构，这个链表的每个节点就是一个空闲缓存页的描述信息。<br>实际上，每个描述信息中有 **free_pre、free_next **两个指针，free链表 就是由这两个指针连接起来形成的一个双向链表。然后 free链表 有一个基础节点，这个基础节点存放了链表的头节点地址、尾节点地址，以及当前链表中节点数的信息。free链表 看起来就像下图这样：<br><img data-src="https://gitee.com/littleeight/blog-images/raw/master/mysql%E4%B8%A4%E4%B8%87%E5%AD%97%E7%B2%BE%E5%8D%8E%E6%80%BB%E7%BB%93/11.png"></p>
<p>需要注意的是，链表的基础节点占用的内存空间并不包含在 buffer pool  之内，而是单独申请的一块内存空间，每个基节点只占用40字节大小。后边介绍的其它链表的基础节点也是一样的，都是单独申请的一块40字节大小的内存空间。<br>有了这个 free链表 之后，当需要从磁盘加载一个页到 buffer pool  时，就从 free链表 中取出一个描述数据块，然后将页写入这个描述数据块对应的空闲缓存页中。并把一些描述数据写入描述数据块中，比如页的表空间号、页号之类的。最后，把缓存页对应的描述数据块从 free链表 中移除，表示该缓存页已被使用了。<br>​</p>
<h3 id="flush链表"><a href="#flush链表" class="headerlink" title="flush链表"></a>flush链表</h3><p>当我们执行增删改的时候，肯定是去更新了 buffer pool 中的某些缓存页，那这些被更新了的缓存页就和磁盘上的数据页不一致了，就变成了脏页。这些脏页最终肯定会被刷回到磁盘中，但并不是所有的缓存页都需要刷回到磁盘，因为有些页只是被查询了，但并没有被增删改过。于是flush链表就是这样被设计出来的，专门存储那些被修改的缓存页，在合适的时机将数据页刷回磁盘。<br>其描述信息有两个指针** flush_pre、flush_next。**<br>​</p>
<h3 id="LRU链表"><a href="#LRU链表" class="headerlink" title="LRU链表"></a>LRU链表</h3><p>为了最大化利用内存，一些不常用的数据当然希望是尽早清除掉，于是就有了LRU链表<strong>Least Recently Used</strong>，意思就是最近最少使用的链表，用来清除掉一些不常用的缓存数据页。LRU链表与 free链表的结构是类似的，都会有一个基础节点来指向链表的首、尾描述信息块，加入LRU链表中的描述信息块就通过 free_pre 和 free_next 两个指针连接起来行程一个双向链表。<br><img data-src="https://gitee.com/littleeight/blog-images/raw/master/mysql%E4%B8%A4%E4%B8%87%E5%AD%97%E7%B2%BE%E5%8D%8E%E6%80%BB%E7%BB%93/12.png"></p>
<p>mysql有个预读机制，如果顺序访问了一个区里的多个数据页，就会触发预读机制，把下一个区中所有的数据页都加载到缓存页里，由<strong>innodb_read_ahead_threshold</strong>控制，默认是56，而是否开启通过参数<strong>innodb_random_read_ahead</strong>控制，默认是off。为了最大化利用内存，LRU链表采用了冷热数据分离的思想，LRU链表会被拆成两部分，一部分是<strong>热数据</strong>（又称new列表），一部分是<strong>冷数据</strong>（又称old列表）。<br>这个冷热数据的位置并不固定，是一个比例，由参数 <strong>innodb_old_blocks_pct <strong>来控制，默认比例是 37，也就是冷数据占 37%，大约占 LRU链表 3/8 的样子。<br>基于冷热分离的LRU链表，这时新加载一个缓存页时，就不是直接放到LRU的头部了，而是放到冷数据区域的头部。 InnoDB 设置了一个规则，在第一次访问冷数据区域的缓存页的时候，就在它对应的描述信息块中记录第一次访问的时间，默认要间隔1秒后再访问这个页，才会被移到热数据区域的头部。也就是从第一次加载到冷数据区域后，1秒内多次访问都不会移动到热数据区域，基本上全表扫描查询缓存页的操作1秒内就结束了。<br>这个间隔时间是由参数</strong> innodb_old_blocks_time</strong> 控制的，默认是 1000毫秒。如果我们把这个参数值设置为0，那么每次访问一个页面时就会把该页面放到热数据区域的头部。<br>之后缓存页不够用的时候，就会优先从冷数据区域的尾部进行刷盘清空，频繁访问的数据页还是会留在热数据区域，不会受到影响。而冷数据区域停留超过1秒的页，被再次访问时就会移到热数据区域的头部。<br>热数据区域中的页是每访问一次就移到头部吗？也不是的，热数据区域是最频繁访问的数据，如果频繁的对LRU链表进行节点移动操作也是不合理的。所以 InnoDB 就规定只有在访问了热数据区域的 后3/4 的缓存页才会被移动到链表头部，访问 前1/4 中的缓存页是不会移动的。<br>​</p>
<h3 id="脏数据刷盘"><a href="#脏数据刷盘" class="headerlink" title="脏数据刷盘"></a>脏数据刷盘</h3><h4 id="内存不足"><a href="#内存不足" class="headerlink" title="内存不足"></a>内存不足</h4><p>当buffer pool无法为新的缓存页添加数据时，就会去清除LRU链表里的数据页，如果清理过程中发现该数据页在flush链表存在的话，就进行刷盘。</p>
<h4 id="page-cleaner"><a href="#page-cleaner" class="headerlink" title="page cleaner"></a>page cleaner</h4><p>在mysql中会有<strong>page cleaner</strong>的线程，每秒一次专门把flush链表和LRU链表里的数据刷盘。有2个关联主要参数：</p>
<ul>
<li><strong>innodb_io_capacity</strong>，计算机存储设备每秒的读写次数，默认200</li>
<li><strong>innodb_io_capacity_max</strong>，当刷新活动比较慢时，innodb就把读写次数提升，默认取innodb_io_capacity的2倍跟2000中较大的值。</li>
</ul>
<p>LRU链表有个参数是<strong>innodb_lru_scan_depth，默认1024k，</strong>该参数表示从LRU链表扫描的深度，调大该值有助于多释放些空闲页，避免用户线程去做<strong>single page flush</strong>。<br>在5.7.4版本里引入了多个page cleaner线程，从而达到并行刷脏的效果。<br>​</p>
<h3 id="缓冲池的优化"><a href="#缓冲池的优化" class="headerlink" title="缓冲池的优化"></a>缓冲池的优化</h3><p>多线程访问 buffer pool 的时候，会涉及到对同一个 free、lru、flush 等链表的操作，例如节点的移动、缓存页的刷新等，那必然是会涉及到加锁的。<br>首先要知道，就算只有一个 buffer pool ，多线程访问要加锁、释放锁，由于基本都是内存操作，所以性能也是很高的。但在一些高并发的生产环境中，配置多个 buffer Pool，还是能极大地提高数据库并发性能的。<br>可以通过参数 <strong>innodb_buffer_pool_instances</strong> 来配置 buffer pool 实例数，通过参数** innodb_buffer_pool_size** 设置所有 buffer pool 的总大小（单位字节），每个 buffer pool 的大小就是 innodb_buffer_pool_size / innodb_buffer_pool_instances。注意的是，InnoDB 规定，当 innodb_buffer_pool_size** 小于1GB<strong>的时候，设置多个实例是无效的，会默认把innodb_buffer_pool_instances 的值修改为1。<br>我们可以在运行时动态调整 innodb_buffer_pool_size 这个参数，但 InnoDB 并不是一次性申请 pool_size 大小的内存空间，而是以 chunk 为单位申请。</strong>一个 chunk 默认就是 128M<strong>，代表一片连续的空间，申请到这片内存空间后，就会被分为若干缓存页与其对应的描述信息块。每个chunk 的大小由参数 <strong>innodb_buffer_pool_chunk_size</strong> 控制，这个参数只能在服务器启动时指定，不能在运行时动态修改。<br>合理设置buffer pool的大小，一般建议是物理机内存的</strong>50%-60%<strong>，</strong>innodb_buffer_pool_size 必须是 innodb_buffer_pool_chunk_size × innodb_buffer_pool_instances 的倍数**，主要是保证每一个Buffer Pool实例中包含的chunk数量相同。<br>​</p>
<h2 id="重要的三个日志"><a href="#重要的三个日志" class="headerlink" title="重要的三个日志"></a>重要的三个日志</h2><h3 id="redo日志"><a href="#redo日志" class="headerlink" title="redo日志"></a>redo日志</h3><p>redo日志主要是为了恢复数据用，因为当数据还在buffer pool的时候就宕机了会导致丢失，于是设计了redo log，在提交事务的时候，<strong>先把对缓存页的修改以日志的形式，写到 redo log 文件里去</strong>，而且保证写入文件成功才算事务提交成功。而且redo log是顺序写入磁盘文件，每次都是追加到磁盘文件末尾去，速度是非常快的。之后再在某个时机将修改的缓存页刷入磁盘，这时就算数据库宕机，也可以利用redo log来恢复数据。这就是mysql里提到的<strong>write-ahead-logging</strong>，<strong>先写日志再写磁盘</strong>。<br>redo log 本质上记录的就是对某个表空间的某个数据页的某个偏移量的地方修改了几个字节的值，它需要记录的其实就是 <strong>日志类型 + 表空间号+数据页号+偏移量+修改的长度+具体的值</strong>，所以 redo log 占用的空间非常小，一条 redo log 也就几个字节到几十个字节的样子。<br>​</p>
<p>一个事务中可能有多个增删改的SQL语句，而一个SQL语句在执行过程中可能修改若干个页面，会有多个操作。以InnoDB将执行语句的过程中产生的redo log划分成了若干个不可分割的组，一组redo log就是对底层页面的一次原子访问，这个原子访问也称为 <strong>Mini-Transaction</strong>，简称 mtr。一个 mtr 就包含一组redo log，在崩溃恢复时这一组redo log就是一个不可分割的整体。<br>一个事务可以包含若干条SQL语句，每一条SQL语句其实是由若干个mtr组成，每一个mtr又可以包含若干条redo log。<br>redo log 并不是一条一条写入磁盘的日志文件中的，而且一个原子操作的 mtr 包含一组 redo log，一条一条的写就无法保证写磁盘的原子性了。<br>InnoDB设计了一个 <strong>redo log block</strong> 的数据结构，称为<strong>重做日志块（block）</strong>，重做日志块跟缓存页有点类似，只不过日志块记录的是一条条 redo log。一个 mtr 中的 redo log 实际上是先写到一个地方，然后再将一个 mtr 的日志记录复制到block中，最后在一些时机将block<strong>刷新到磁盘日志文件</strong>中。<br>一个 redo log block 固定 512字节 大小，由三个部分组成：<strong>header块头（12字节） + body块体（496字节） + trailer块尾（4字节）</strong>。redo log 就是存放在 body 块体中，也就是一个块实际只有 496字节 用来存储 redo log。<br>**header **块头记录了四个信息：</p>
<ul>
<li>LOG_BLOCK_HDR_NO：表示块的唯一编号。</li>
<li>LOG_BLOCK_HDR_DATA_LEN：表示 block 中已经使用了多少字节，初始值为12，因为body从第12个字节处开始。如果block body已经被全部写满，那么本属性的值就被设置为512。</li>
<li>LOG_BLOCK_FIRST_REC_GROUP：表示block中第一个mtr日志组中的第一条 redo log 的偏移量。</li>
<li>LOG_BLOCK_CHECKPOINT_NO：表示 checkpoint 的序号，后面会介绍。</li>
</ul>
<p><strong>trailer</strong> 只记录了一个信息：</p>
<ul>
<li>LOG_BLOCK_CHECKSUM：表示block的校验值。</li>
</ul>
<p>跟 buffer pool 类似的，服务器启动时，就会申请一块连续的内存空间，作为 redo log block 的缓冲区也就是 <strong>redo log buffer</strong>。然后这片内存空间会被划分成若干个连续的 redo log block，redo log 就是先写到 redo log buffer 中的 redo log block 中的。<br>可以通过启动参数<strong>innodb_log_buffer_size</strong>来指定log buffer的大小，该参数的默认值为16MB。<br>​</p>
<p>redo log buffer跟buffer pool一样，都会在一些时机里<strong>刷盘，</strong>主要有以下几个时机：</p>
<ul>
<li><strong>log buffer 空间不足时</strong>，如果写入 log buffer 的日志占据了 log buffer 总容量的一半了，默认情况下也就是超过8MB的时候，此时就会把他们刷入到磁盘文件里去。这种情况一般在高并发的场景下可能会出现，每秒执行了很多增删改SQL语句，产生的redo log 瞬间超过了8M，然后就立马触发刷新 log block 到磁盘。不过这种情况一般比较少。</li>
<li><strong>事务提交时</strong>，一个事务提交的时候，必须把它的redo log都刷入到磁盘文件里去，只有这样，才能保证事务的持久性，才算事务提交成功了（这就是force log at commit机制，即在事务提交的时候，必须先将该事务的所有事务日志写入到磁盘上的日志文件中进行持久化）。如果在写入的过程中MySQL宕机了，那事务也就失败了。</li>
<li><strong>后台线程刷盘</strong>，后台有一个线程会每隔1秒，把redo log block刷到磁盘文件里去。</li>
<li><strong>MySQL关闭的时候</strong>，redo log block都会刷入到磁盘里去。</li>
<li><strong>做 checkpoint 的时候</strong>。这个后面会说。</li>
</ul>
<p>需要注意的是，不管什么时机刷盘，redo log block 始终是<strong>顺序刷盘</strong>的，比如事务提交的时候，会把这个事务mtr之前的block都刷入磁盘。<br>​</p>
<p>比较重要的是，在提交事务的时候，InnoDB会根据配置的策略来将 redo log 刷盘，这个参数可以通过<strong>innodb_flush_log_at_trx_commit</strong> （默认值为1）来配置。<br>可以配置如下几个值：</p>
<ul>
<li>0：事务提交时不会立即向磁盘中同步 redo log，而是由后台线程来刷。这种策略可以提升数据库的性能，但事务的持久性无法保证。</li>
<li>1：事务提交时会将 redo log 刷到磁盘，这可以保证事务的持久性，这也是默认值。其实数据会先写到操作系统的缓冲区（os cache），这种策略会调用 fsync 强制将 os cache 中的数据刷到磁盘。</li>
<li>2：事务提交时会将 redo log 写到操作系统的缓冲区中，可能隔一小段时间后才会从系统缓冲区同步到磁盘文件。这种情况下，如果机器宕机了，而系统缓冲区中的数据还没同步到磁盘的话，就会丢失数据。</li>
</ul>
<p>为了保证事务的持久性，一般使用默认值，将 innodb_flush_log_at_trx_commit 设置为1即可。<br>​</p>
<p>mysql设定了一个文件组的形式来持久化redo log，文件名的格式为 **ib_logfile[x]**（x 为从0开始的数字），由以下参数控制：</p>
<ul>
<li><strong>innodb_log_group_home_dir</strong>：指定redo log文件所在的目录，默认值就是当前的数据目录。</li>
<li><strong>innodb_log_file_size</strong>：指定每个redo log文件的大小，默认值为48MB。</li>
<li><strong>innodb_log_files_in_group</strong>：指定redo log文件的个数，默认值为2，最大值为100。</li>
</ul>
<p>​</p>
<p>在将 redo log 写入日志文件组时，是从 ib_logfile0 开始写，如果 ib_logfile0 写满了，就接着ib_logfile1 写，ib_logfile1 写满了就去写 ib_logfile2，依此类推。如果写到最后一个文件也满了，就会重新转到ib_logfile0覆盖写入。<br>​</p>
<p>log block 固定为512字节大小，redo log 文件也是一样按512字节来划分的，每个 redo log 文件的格式也是一样的，都由若干个512字节的块组成。<br>每个 redo log 文件由两部分组成：</p>
<ul>
<li>前2048字节，也就是前4个block是用来存储一些管理信息。其中第1个 block 存储header，第2个和第4个存储checkpoint，第3个block保留未没用。</li>
<li>从第2048字节往后是用来存储 redo log block 的。</li>
</ul>
<p>所以在循环写日志文件的时候，其实是从每个日志文件的第2048字节 开始的。但需要注意的是，一组日志文件中，<strong>只有第1个日志文件的前4个block才会存储管理信息</strong>，其余的日志文件只是保留这些空间，不存储信息。<br>​</p>
<p>**header **中的各个属性：</p>
<ul>
<li>LOG_HEADER_FORMAT：redo日志的版本</li>
<li>LOG_HEADER_PAD1：做字节填充用的，没什么实际意义</li>
<li>LOG_HEADER_START_LSN：标记本日志文件开始的LSN值，初始值就2048，指向文件偏移量2048字节处。</li>
<li>LOG_HEADER_CREATOR：标记本日志文件的创建者。</li>
<li>LOG_BLOCK_CHECKSUM：本block的校验值</li>
</ul>
<p>**checkpoint **中的各个属性：</p>
<ul>
<li>LOG_CHECKPOINT_NO：服务器做checkpoint的编号，每做一次checkpoint，该值就加1。</li>
<li>LOG_CHECKPOINT_LSN：服务器做checkpoint结束时对应的LSN值，系统崩溃恢复时将从该值开始。</li>
<li>LOG_CHECKPOINT_OFFSET：上个属性中的LSN值在redo日志文件组中的偏移量。</li>
<li>LOG_CHECKPOINT_LOG_BUF_SIZE：服务器在做checkpoint操作时对应的log buffer的大小。</li>
<li>LOG_BLOCK_CHECKSUM：本block的校验值。</li>
</ul>
<p>​</p>
<h4 id="LSN"><a href="#LSN" class="headerlink" title="LSN"></a>LSN</h4><p>上面可以看到出现了2次<strong>LSN，</strong>mysql设计了一个全局变量：日志序列号<strong>log sequence number，代表了写入的日志总量，初始值是8704，占用8个字节，且是单调递增的。</strong><br>在每次写入<strong>redo log buffer</strong>时<strong>，</strong>LSN都会叠加记录下已写入的数据量，如下图所示：<br><img data-src="https://gitee.com/littleeight/blog-images/raw/master/mysql%E4%B8%A4%E4%B8%87%E5%AD%97%E7%B2%BE%E5%8D%8E%E6%80%BB%E7%BB%93/13.png"></p>
<p>事务产生的mtr写入log block后，会将修改的脏页加入到Flush链表头部，Flush链表对应的描述信息块中会有两个属性来记录LSN信息：</p>
<ul>
<li><strong>oldest_modification</strong>：记录mtr开始的LSN值。</li>
<li><strong>newest_modification</strong>：记录mtr结束时的LSN值。</li>
</ul>
<p>接着另一个mtr写入后，可能Flush链表中已经存在了对应的脏页，此时会将mtr结束时的LSN值写入newest_modification，原本的oldest_modification则保持不变。<br>实际上Flush链表中的脏页就是按照修改发生的时间顺序进行排序，也就是按照oldest_modification代表的LSN值进行排序的。链表靠近尾部的是最早修改的，链表头部则是最新修改的。<br>​</p>
<h4 id="checkpoint"><a href="#checkpoint" class="headerlink" title="checkpoint"></a>checkpoint</h4><p>redo log 只是为了系统崩溃后恢复脏页用的，如果对应的脏页已经刷新到了磁盘，那么就算崩溃后也用不着这部分 redo log 了，那么它占用的磁盘空间就可以被覆盖重用。如果脏页没有刷入磁盘，那么对应的 redo log 就必须保留着。<br>InnoDB 设计了一个全局变量 <strong>checkpoint_lsn <strong>来代表当前系统中可以被覆盖的redo log总量是多少，这个变量初始值也是8704。当脏页被刷入磁盘时，就会做一次 checkpoint 来计算 checkpoint_lsn 的值，并写入 redo log 文件中。<br>脏页只要已经刷入磁盘，那他们对应的redo log就可以被覆盖，那如何判断哪些脏页已经刷入磁盘呢？<br>前面说过 Flush链表 中的脏页是按修改时间，也就是oldest_modification代表的LSN值排序的，链表尾部的脏页就是最早修改的，它所对应的oldest_modification就是最小的一个LSN值，那这个LSN之前的脏页就是已经刷入磁盘的。<br>在做 checkpoint 时，其实就是将Flush链表尾部的脏页的</strong>oldest_modification赋值给checkpoint_lsn</strong>。<br>接着根据checkpoint_lsn计算对应的redo log文件日志偏移量checkpoint_offset。<br>InnoDB还设计了一个全局变量checkpoint_no，代表checkpoint的次数，每做一次checkpoint，这个值就会加1。<br>然后就会将这些信息写入日志文件组中的第一个日志文件的checkpoint中。至于存到 checkpoint1 还是 checkpoint2，则根据checkpoint_no来计算，如果是偶数，就写到checkpoint1，如果是奇数，就写入checkpoint2。<br>可以看到checkpoint中就有三个属性来存储这些信息：</p>
<ul>
<li>checkpoint_no 写入 LOG_CHECKPOINT_NO</li>
<li>checkpoint_lsn 写入 LOG_CHECKPOINT_LSN</li>
<li>checkpoint_offset 写入 LOG_CHECKPOINT_OFFSET</li>
</ul>
<p><img data-src="https://gitee.com/littleeight/blog-images/raw/master/mysql%E4%B8%A4%E4%B8%87%E5%AD%97%E7%B2%BE%E5%8D%8E%E6%80%BB%E7%BB%93/14.png"></p>
<h4 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h4><p>InnoDB在启动时不管上次数据库是否正常关闭，都会尝试进行恢复操作。如果数据库是正常关闭，redo log 其实没什么用，但如果数据库宕机，redo log 就可以用来恢复数据了。<br><strong>恢复的起点</strong><br>首先要读取日志组中的第一个 redo log 文件头部的两个 checkpoint，先比较其中的 checkpoint_no，哪个大就使用哪个 checkpoint。<br>然后读取 checkpoint_lsn，这个值之前的都是已经刷盘了的，但之后的可能刷盘了，也可能没有刷盘。所以恢复的起点就是 checkpoint_lsn 对应的文件偏移量，从这个偏移量开始读取 redo log 来恢复页面。<br><strong>恢复的终点</strong><br>redo log block 的头部header中有一个属性 LOG_BLOCK_HDR_DATA_LEN 记录了当前block里使用了多少字节的空间，对于被写满的block来说，该属性就是512。如果该属性的值不为512，说明这个block还没写满，那终点就是这个block了。<br><strong>使用哈希表</strong><br>读取到内存中的 redo log，并不是直接就按顺序去重做页的。而是使用了一个哈希表来加快恢复的速度。<br>它会根据 redo log 的表空间ID和页号计算出散列值，以此作为哈希表的 Key，哈希表的 Value 则是一个链表，相同表空间ID和页号的 redo log 就会挨个按顺序加入这个链表中。<br>之后就遍历哈希表来恢复页，因为对同一个页面修改的 redo log 都在一个链表中，所以可以一次性将一个页面修复好（避免了很多读取页面的随机IO），这样可以加快恢复速度。<br><strong>跳过已经刷新到磁盘的页面</strong><br>checkpoint_lsn 之前的可以保证 redo log 对应的脏页已经刷盘了，但是之后的就不能确定了。因为在做 checkpoint 之后，可能一些脏页会不断的被刷到磁盘中，那这部分 redo log 就不能在页中重做一遍。<br>这个时候就会用到前面说过的页中的FIL_PAGE_LSN属性，这个属性记录了最近一次修改页面对应的LSN值。<br>如果在做了某次checkpoint之后有脏页被刷新到磁盘中，那么该页对应的FIL_PAGE_LSN代表的LSN值肯定大于checkpoint_lsn的值，对于这种页面就不需要在应用 redo log 了。<br>​</p>
<h3 id="undo日志"><a href="#undo日志" class="headerlink" title="undo日志"></a>undo日志</h3><p>事务的第一个特性就是原子性，原子性就是要保证一个事务中的增删改操作要么都成功，要么都不做。这时就需要 undo log，在对数据库进行修改前，会先记录对应的 undo log，然后在事务失败或回滚的时候，就可以用这些 undo log 来将数据回滚到修改之前的样子。<br>事务执行过程中在对某个表执行增、删、改操作时，InnoDB就会给这个事务分配一个唯一的事务ID。如果一个事务中没有执行增删改操作，就不会分配事务ID。行记录中会有三个隐藏列：</p>
<ul>
<li>DB_ROW_ID：如果没有为表显式的定义主键，并且表中也没有定义唯一索引，那么InnoDB会自动为表添加一个row_id的隐藏列作为主键。</li>
<li>DB_TRX_ID：事务中对某条记录做增删改时，就会将这个事务的事务ID写入trx_id中。</li>
<li>DB_ROLL_PTR：回滚指针，本质上就是指向 undo log 的指针。</li>
</ul>
<p>​</p>
<p>每对一条记录做一次改动，就会产生1条或者2条 undo log。一个事务中可能会有多个增删改SQL语句，一个SQL语句可能会产生多条 undo log，一个事务中的这些 undo log 会被从 0 开始递增编号，这个编号称为 undo no。<br>​</p>
<p>事务提交前需要将 undo log 写磁盘，这会造成多次磁盘 IO。</p>
<h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p>分为两个大类来存储：</p>
<ul>
<li>TRX_UNDO_INSERT</li>
</ul>
<p>类型为 TRX_UNDO_INSERT_REC 的 undo log 属于此大类，一般由 INSERT 语句产生，或者在 UPDATE 更新主键的时候也会产生。</p>
<ul>
<li>TRX_UNDO_UPDATE</li>
</ul>
<p>除了类型为 TRX_UNDO_INSERT_REC 的 undo log，其他类型的 undo log 都属于这个大类，比如 TRX_UNDO_DEL_MARK_REC 、 TRX_UNDO_UPD_EXIST_REC ，一般由 DELETE、UPDATE 语句产生。<br>之所以要分成两个大类，是因为不同大类的 undo log 不能混着存储，因为类型为TRX_UNDO_INSERT_REC的 undo log 在事务提交后可以直接删除掉，而其他类型的 undo log 还需要提供MVCC功能，不能直接删除。<br>​</p>
<h4 id="insert-undo"><a href="#insert-undo" class="headerlink" title="insert undo"></a>insert undo</h4><p>插入一条数据对应的undo操作其实就是根据主键删除这条数据就行了。所以 insert 对应的 undo log 主要是把这条记录的主键记录上。<br>INSERT 产生的 undo log 类型为 <strong>TRX_UNDO_INSERT_REC</strong>，大致结构如下图所示：</p>
<ul>
<li>start、end：指向记录开始和结束的位置。</li>
<li>undo type：undo log 的类型，也就是 TRX_UNDO_INSERT_REC。</li>
<li>undo no：在当前事务中 undo log 的编号。</li>
<li>table id：表空间ID。</li>
<li>主键列信息：这一块就需要记录INSERT这行数据的主键ID信息，或者唯一列信息。</li>
</ul>
<p><img data-src="https://gitee.com/littleeight/blog-images/raw/master/mysql%E4%B8%A4%E4%B8%87%E5%AD%97%E7%B2%BE%E5%8D%8E%E6%80%BB%E7%BB%93/15.png"></p>
<h4 id="delete-undo"><a href="#delete-undo" class="headerlink" title="delete undo"></a>delete undo</h4><p>删除一条数据大致可以分为两个阶段：</p>
<ul>
<li>阶段一</li>
</ul>
<p>首先是用户线程执行删除时，会先将记录头信息中的 delete_mask 标记为 1，而不是直接从页中删除，因为可能其它并发的事务还需要读取这条数据。（后面讲MVCC的时候就知道为什么了）</p>
<ul>
<li>阶段二</li>
</ul>
<p>提交事务后，后台有一个 purge 线程会将数据真正删除。<br>首先要知道，页中的数据是通过记录头信息中的 netx_record 连接起来的单向链表（假设这个链表称为数据链表）。页中还有另一个链表，称为垃圾链表，记录真正删除后，会从数据链表中移除，然后加入到垃圾链表的头部，以便重用空间。<br>所以阶段二就是将记录从数据链表移除，加入到垃圾链表的头部。<br>也就是说，删除操作在事务提交前，只会经历阶段一，就是将记录的 delete_mask 标记为 1。<br>DELETE 对应的 undo log 类型为 <strong>TRX_UNDO_DEL_MARK_REC</strong>，它的结构大致如下图所示，与 TRX_UNDO_INSERT_REC 类型相比，主要多了三个部分：</p>
<ul>
<li>old trx_id：这个属性会保存记录中的隐藏列trx_id，这个属性在MVCC并发读的时候就会起作用了。</li>
<li>old roll_pointer：这个属性保存记录中的隐藏列roll_pointer，这样就可以通过这个属性找到之前的 undo log。</li>
<li>索引列信息：这部分主要是在第二阶段事务提交后用来真正删除记录的。</li>
</ul>
<p><img data-src="https://gitee.com/littleeight/blog-images/raw/master/mysql%E4%B8%A4%E4%B8%87%E5%AD%97%E7%B2%BE%E5%8D%8E%E6%80%BB%E7%BB%93/16.png"></p>
<h4 id="update-undo"><a href="#update-undo" class="headerlink" title="update undo"></a>update undo</h4><p>在执行UPDATE语句时，InnoDB对更新主键和不更新主键这两种情况有截然不同的处理方案，对应中两种不同的 undo log 类型。</p>
<h5 id="不更新主键"><a href="#不更新主键" class="headerlink" title="不更新主键"></a>不更新主键</h5><p>在不更新主键的情况下，又可以细分为被更新的列占用的存储空间不发生变化和发生变化的情况。</p>
<ul>
<li>存储空间未发生变化</li>
</ul>
<p>更新记录时，对于被更新的每个列来说，如果更新后的列和更新前的列占用的字节数都一样大，那么就可以进行<strong>就地更新</strong>，也就是直接在原记录的基础上修改对应列的值。</p>
<ul>
<li>存储空间发生变化</li>
</ul>
<p>如果有任何一个被更新的列更新前和更新后占用的字节数大小不一致，那么就会先把这条旧的记录从聚簇索引页面中删除掉，然后再根据更新后列的值创建一条新的记录插入到页面中。注意这里的删除并不是将 delete_mask 标记为 1，而是真正的删除，从数据链表中移除加入到垃圾链表的头部。<br>如果新的记录占用的存储空间大小不超过旧记录占用的空间，就可以直接重用刚加入垃圾链表头部的那条旧记录所占用的空间，否就会在页面中新申请一段空间来使用。<br>不更新主键的这两种情况生成的 undo log 类型为 <strong>TRX_UNDO_UPD_EXIST_REC</strong>，大致结构如下图所示，与 TRX_UNDO_DEL_MARK_REC 相比主要是多了更新列的信息。<br><img data-src="https://gitee.com/littleeight/blog-images/raw/master/mysql%E4%B8%A4%E4%B8%87%E5%AD%97%E7%B2%BE%E5%8D%8E%E6%80%BB%E7%BB%93/17.png"></p>
<h5 id="更新主键"><a href="#更新主键" class="headerlink" title="更新主键"></a>更新主键</h5><p>要知道记录是按主键大小连成一个单向链表的，如果更新了某条记录的主键值，这条记录的位置也将发生改变，也许就被更新到其它页中了。<br>这种情况下的更新分为两步：</p>
<ul>
<li>首先将原记录做标记删除，就是将 delete_mask 改为 1，还没有真正删除。</li>
<li>然后再根据更新后各列的值创建一条新记录，并将其插入到聚簇索引中。</li>
</ul>
<p>所以这种情况下，会产生两条 undo log：</p>
<ul>
<li>第一步标记删除时会创建一条 TRX_UNDO_DEL_MARK_REC 类型的 undo log。</li>
<li>第二步插入记录时会创建一条 TRX_UNDO_INSERT_REC 类型的 undo log。<h4 id="undo-回滚"><a href="#undo-回滚" class="headerlink" title="undo 回滚"></a>undo 回滚</h4>前面在一个事务中增删改产生的一系列 undo log，都有 undo no 编号的。在回滚的时候，就可以应用这个事务中的 undo log，根据 undo no 从大到小开始进行撤销操作。<br>但需要注意的是，undo log 是逻辑日志，只是将数据库逻辑地恢复到原来的样子。所有修改都被逻辑地取消了，但是数据结构和页本身在回滚之后可能大不相同。因为同时可能很多并发事务在对数据库进行修改，因此不能将一个页回滚到事务开始的样子，因为这样会影响其他事务正在进行的工作。<br>​</li>
</ul>
<h4 id="undo-恢复"><a href="#undo-恢复" class="headerlink" title="undo 恢复"></a>undo 恢复</h4><p>undo log 写入 undo 页后，这个页就变成脏页了，也会加入 Flush 链表中，然后在某个时机刷到磁盘中。<br>事务提交时会将 undo log 放入一个链表中，是否可以最终删除 undo log 及 undo log 所在页，是由后台的一个 purge 线程来完成的。<br>最后也是最为重要的一点是，undo log 写入 undo 页的时候也会产生 redo log，因为 undo log 也需要持久性的保护。</p>
<h3 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h3><p>binlog是一种二进制日志，其主要是用来记录对mysql数据更新或潜在发生更新的SQL语句，并以”事务”的形式保存在磁盘中，作用主要有：</p>
<ul>
<li>复制：在master端开启binlog，master把它的二进制日志传递给slaves并回放来达到master-slave数据一致的目的</li>
<li>数据恢复：通过mysqlbinlog工具恢复数据</li>
<li>增量备份</li>
</ul>
<p>​</p>
<p>​</p>
<h2 id="分区、分表、分库"><a href="#分区、分表、分库" class="headerlink" title="分区、分表、分库"></a>分区、分表、分库</h2><p>一般情况下我们创建的表对应一组存储文件，使用MyISAM存储引擎时是一个.MYI和.MYD文件，使用Innodb存储引擎时是一个.ibd和.frm（表结构）文件。当数据量较大时（一般千万条记录级别以上），MySQL的性能就会开始下降，这时我们就需要将数据进行分片，保证mysql的执行性能，有三种方式可实现。</p>
<h3 id="mysql分区"><a href="#mysql分区" class="headerlink" title="mysql分区"></a>mysql分区</h3><p>​</p>
<p>分区类型由以下几种：</p>
<ul>
<li><strong>RANGE分区</strong>：基于属于一个给定连续区间的列值，把多行分配给分区。mysql将会根据指定的拆分策略，,把数据放在不同的表文件上。相当于在文件上,被拆成了小块.但是,对外给客户的感觉还是一张表，透明的。按照 range 来分，就是每个库一段连续的数据，这个一般是按比如<strong>时间范围</strong>来的，比如交易表啊，销售表啊等，可以根据年月来存放数据。可能会产生热点问题，大量的流量都打在最新的数据上了。range 来分，好处在于说，扩容的时候很简单。</li>
<li><strong>LIST分区</strong>：类似于按RANGE分区，每个分区必须明确定义。它们的主要区别在于，LIST分区中每个分区的定义和选择是基于某列的值从属于一个值列表集中的一个值，而RANGE分区是从属于一个连续区间值的集合。</li>
<li><strong>HASH分区</strong>：基于用户定义的表达式的返回值来进行选择的分区，该表达式使用将要插入到表中的这些行的列值进行计算。这个函数可以包含MySQL 中有效的、产生非负整数值的任何表达式。hash 分发，好处在于说，可以平均分配每个库的数据量和请求压力；坏处在于说扩容起来比较麻烦，会有一个数据迁移的过程，之前的数据需要重新计算 hash 值重新分配到不同的库或表</li>
<li><strong>KEY分区</strong>：类似于按HASH分区，区别在于KEY分区只支持计算一列或多列，且MySQL服务器提供其自身的哈希函数。必须有一列或多列包含整数值。</li>
</ul>
<p>​</p>
<p>但是一般情况下都不会采用分区来水平扩展，而是自己实现分表分库来做，有几个原因：</p>
<ul>
<li>分区表，分区键设计不太灵活，如果不走分区键，很容易出现全表锁</li>
<li>一旦数据并发量上来，如果在分区表实施关联，就是一个灾难</li>
<li>自己分库分表，自己掌控业务场景与访问模式，可控。分区表，研发写了一个sql，都不确定mysql是怎么玩的，不太可控。</li>
</ul>
<p>​</p>
<h3 id="mysql分表"><a href="#mysql分表" class="headerlink" title="mysql分表"></a>mysql分表</h3><p>分表有两种分割方式，一种垂直拆分，另一种水平拆分。</p>
<ul>
<li><strong>垂直拆分</strong>垂直分表，通常是按照业务功能的使用频次，把主要的、热门的字段放在一起做为主要表。然后把不常用的，按照各自的业务属性进行聚集，拆分到不同的次要表中；主要表和次要表的关系一般都是一对一的。</li>
<li>**水平拆分(数据分片)**单表的容量不超过500W，否则建议水平拆分。是把一个表复制成同样表结构的不同表，然后把数据按照一定的规则划分，分别存储到这些表中，从而保证单表的容量不会太大，提升性能；当然这些结构一样的表，可以放在一个或多个数据库中。水平分割的几种方法：<ul>
<li>使用MD5哈希，做法是对UID进行md5加密，然后取前几位（我们这里取前两位），然后就可以将不同的UID哈希到不同的用户表（user_xx）中了。</li>
<li>还可根据时间放入不同的表，比如：article_201601，article_201602。</li>
<li>按热度拆分，高点击率的词条生成各自的一张表，低热度的词条都放在一张大表里，待低热度的词条达到一定的贴数后，再把低热度的表单独拆分成一张表。</li>
<li>根据ID的值放入对应的表，第一个表user_0000，第二个100万的用户数据放在第二 个表user_0001中，随用户增加，直接添加用户表就行了。</li>
</ul>
</li>
</ul>
<p>​</p>
<h3 id="mysql分库"><a href="#mysql分库" class="headerlink" title="mysql分库"></a>mysql分库</h3><p>一个库里表太多了，导致了海量数据，系统性能下降，把原本存储于一个库的表拆分存储到多个库上， 通常是将表按照功能模块、关系密切程度划分出来，部署到不同库上。<br>优点：</p>
<ul>
<li>减少增量数据写入时的锁对查询的影响</li>
<li>由于单表数量下降，常见的查询操作由于减少了需要扫描的记录，使得单表单次查询所需的检索行数变少，减少了磁盘IO，时延变短。<h2 id="mysql优化方案"><a href="#mysql优化方案" class="headerlink" title="mysql优化方案"></a>mysql优化方案</h2><h3 id="性能瓶颈定位"><a href="#性能瓶颈定位" class="headerlink" title="性能瓶颈定位"></a>性能瓶颈定位</h3>我们可以通过 show 命令查看 MySQL 状态及变量，找到系统的瓶颈：<br>​</li>
</ul>
<ul>
<li>show status ——显示状态信息（扩展show status like ‘XXX’）</li>
<li>show variables ——显示系统变量（扩展show variables like ‘XXX’）</li>
<li>show innodb status ——显示InnoDB存储引擎的状态</li>
<li>show processlist ——查看当前SQL执行，包括执行状态、是否锁表等 </li>
<li>mysqladmin variables -u username -p password——显示系统变量 </li>
<li>mysqladmin extended-status -u username -p password——显示状态信息</li>
</ul>
<p>​</p>
<h3 id="explain执行计划"><a href="#explain执行计划" class="headerlink" title="explain执行计划"></a>explain执行计划</h3><p>使用 <strong>Explain</strong> 关键字可以模拟优化器执行sql 查询语句，从而知道 mysql 是如何处理你的 sql 语句的，分析你的查询语句或是表结构的性能瓶颈，它可以为我们带来：</p>
<ul>
<li>表的读取顺序</li>
<li>数据读取操作的操作类型</li>
<li>哪些索引可以使用</li>
<li>哪些索引被实际使用</li>
<li>表之间的引用</li>
<li>每张表有多少行被优化器查询</li>
</ul>
<p><img data-src="https://gitee.com/littleeight/blog-images/raw/master/mysql%E4%B8%A4%E4%B8%87%E5%AD%97%E7%B2%BE%E5%8D%8E%E6%80%BB%E7%BB%93/18.png"></p>
<p>各字段解释</p>
<ul>
<li><strong>id</strong>（select 查询的序列号，包含一组数字，表示查询中执行select子句或操作表的顺序）<ul>
<li>id相同，执行顺序从上往下</li>
<li>id全不同，如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行</li>
<li>id部分相同，执行顺序是先按照数字大的先执行，然后数字相同的按照从上往下的顺序执行</li>
</ul>
</li>
<li><strong>select_type</strong>（查询类型，用于区别普通查询、联合查询、子查询等复杂查询）<ul>
<li><strong>SIMPLE</strong> ：简单的select查询，查询中不包含子查询或UNION</li>
<li><strong>PRIMARY</strong>：查询中若包含任何复杂的子部分，最外层查询被标记为PRIMARY</li>
<li><strong>SUBQUERY</strong>：在select或where列表中包含了子查询</li>
<li><strong>DERIVED</strong>：在from列表中包含的子查询被标记为DERIVED，MySQL会递归执行这些子查询，把结果放在临时表里</li>
<li><strong>UNION</strong>：若第二个select出现在UNION之后，则被标记为UNION，若UNION包含在from子句的子查询中，外层select将被标记为DERIVED</li>
<li><strong>UNION RESULT</strong>：从UNION表获取结果的select</li>
</ul>
</li>
<li><strong>table</strong>（显示这一行的数据是关于哪张表的）</li>
<li><strong>type</strong>（显示查询使用了那种类型，从最好到最差依次排列    <strong>system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</strong> ）tip: 一般来说，得保证查询至少达到range级别，最好到达ref<ul>
<li>system：表只有一行记录（等于系统表），是 const 类型的特例，平时不会出现</li>
<li>const：表示通过索引一次就找到了，const 用于比较 primary key 或 unique 索引，因为只要匹配一行数据，所以很快，如将主键置于 where 列表中，mysql 就能将该查询转换为一个常量</li>
<li>eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配，常见于主键或唯一索引扫描</li>
<li>ref：非唯一性索引扫描，范围匹配某个单独值得所有行。本质上也是一种索引访问，他返回所有匹配某个单独值的行，然而，它可能也会找到多个符合条件的行，多以他应该属于查找和扫描的混合体</li>
<li>range：只检索给定范围的行，使用一个索引来选择行。key列显示使用了哪个索引，一般就是在你的where语句中出现了between、&lt;、&gt;、in等的查询，这种范围扫描索引比全表扫描要好，因为它只需开始于索引的某一点，而结束于另一点，不用扫描全部索引</li>
<li>index：Full Index Scan，index于ALL区别为index类型只遍历索引树。通常比ALL快，因为索引文件通常比数据文件小。（<strong>也就是说虽然all和index都是读全表，但index是从索引中读取的，而all是从硬盘中读的</strong>）</li>
<li>ALL：Full Table Scan，将遍历全表找到匹配的行</li>
</ul>
</li>
<li><strong>possible_keys</strong>（显示可能应用在这张表中的索引，一个或多个，查询涉及到的字段若存在索引，则该索引将被列出，但不一定被查询实际使用）</li>
<li><strong>key</strong><ul>
<li>实际使用的索引，如果为NULL，则没有使用索引</li>
<li><strong>查询中若使用了覆盖索引，则该索引和查询的 select 字段重叠，仅出现在key列表中</strong></li>
</ul>
</li>
<li><strong>key_len</strong><ul>
<li>表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。在不损失精确性的情况下，长度越短越好</li>
<li>key_len显示的值为索引字段的最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出的</li>
</ul>
</li>
<li><strong>ref</strong> （显示索引的哪一列被使用了，如果可能的话，是一个常数。哪些列或常量被用于查找索引列上的值）</li>
<li><strong>rows</strong> （根据表统计信息及索引选用情况，大致估算找到所需的记录所需要读取的行数）</li>
<li><strong>Extra</strong>（包含不适合在其他列中显示但十分重要的额外信息）<ol>
<li>using filesort: 说明mysql会对数据使用一个外部的索引排序，不是按照表内的索引顺序进行读取。mysql中无法利用索引完成的排序操作称为“文件排序”。常见于order by和group by语句中</li>
<li>Using temporary：使用了临时表保存中间结果，mysql在对查询结果排序时使用临时表。常见于排序order by和分组查询group by。</li>
<li>using index：表示相应的select操作中使用了覆盖索引，避免访问了表的数据行，效率不错，如果同时出现using where，表明索引被用来执行索引键值的查找；否则索引被用来读取数据而非执行查找操作</li>
<li>using where：使用了where过滤</li>
<li>using join buffer：使用了连接缓存</li>
<li>impossible where：where子句的值总是false，不能用来获取任何元祖</li>
<li>select tables optimized away：在没有group by子句的情况下，基于索引优化操作或对于MyISAM存储引擎优化COUNT(*)操作，不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化</li>
<li>distinct：优化distinct操作，在找到第一匹配的元祖后即停止找同样值的动作</li>
</ol>
</li>
</ul>
<p>​</p>
<p>​</p>
<h3 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h3><p>mysql 的慢查询日志是 mysql 提供的一种日志记录，它用来记录在 mysql 中响应时间超过阈值的语句，具体指运行时间超过 long_query_time 值的 sql，则会被记录到慢查询日志中。<br>默认情况下，mysql 数据库没有开启慢查询日志，需要手动设置参数开启：</p>
<ul>
<li>set global slow_query_log=’ON’  是否开启慢查询日志</li>
<li>set global slow_query_log_file=’/var/lib/mysql/hostname-slow.log’ 日志存储地方</li>
<li>set global long_query_time=10 运行10秒以上的sql才被记录</li>
</ul>
<p>在生产环境中，如果手工分析日志，查找、分析SQL，还是比较费劲的，所以mysql 提供了日志分析工具<strong>mysqldumpslow</strong>，比如：</p>
<ul>
<li>mysqldumpslow -s r -t 10 /var/lib/mysql/slow.log  得到返回记录集最多的10个sql </li>
<li>mysqldumpslow -s c -t 10  /var/lib/mysql/slow  得到访问次数最多的10个sql .log</li>
<li>也可以和管道配合使用   mysqldumpslow -s r -t 10  /var/lib/mysql/slow.log | more</li>
</ul>
<p>​</p>
<h3 id="Show-Profile-分析查询"><a href="#Show-Profile-分析查询" class="headerlink" title="Show Profile 分析查询"></a>Show Profile 分析查询</h3><p>通过慢日志查询可以知道哪些 sql 语句执行效率低下，通过 explain 我们可以得知 sql  语句的具体执行情况，索引使用等，还可以结合Show Profile命令查看执行状态。<br>Show Profile 是 mysql提供可以用来分析当前会话中语句执行的资源消耗情况，可以用于sql 的调优的测量。默认情况下，参数处于关闭状态，并保存最近15次的运行结果。<br>确认是否开启：<strong>Show variables like ‘profiling’</strong><br>开启 ：** set profiling=1**<br>诊断<strong>：</strong>show profile cpu,block io for “query_id”, 诊断结果一般需要注意的如下：</p>
<ul>
<li>converting HEAP to MyISAM 查询结果太大，内存都不够用了往磁盘上搬了。</li>
<li>create tmp table 创建临时表，这个要注意</li>
<li>Copying to tmp table on disk 把内存临时表复制到磁盘</li>
<li>locked</li>
</ul>
<h2 id="mysql高可用"><a href="#mysql高可用" class="headerlink" title="mysql高可用"></a>mysql高可用</h2><h3 id="MHA"><a href="#MHA" class="headerlink" title="MHA"></a>MHA</h3><p>对主节点进行监控，可实现自动故障转移至其它从节点；通过提升某一从节点为新的主节点，基于主从复制实现，还需要客户端配合实现，目前MHA主要支持一主多从的架构，要搭建MHA,要求一个复制集群中必须最少有三台数据库服务器，一主二从，即一台充当master，一台充当备用master，另外一台充当从库。工作原理：MHA Manager会定时探测集群中的master节点，当master出现故障时，它可以自动将最新数据的slave提升为新的master，然后将所有其他的slave重新指向新的master，整个故障转移过程对应用程序完全透明。<br><strong>优点：</strong></p>
<ol>
<li>可以进行故障的自动检测和转移。</li>
<li>可扩展性较好，可以根据需要扩展MySQL的节点数量和结构;</li>
<li>相比于双节点的MySQL复制，三节点/多节点的MySQL发生不可用的概率更低​</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li>至少需要三节点，相对于双节点需要更多的资源;</li>
<li>逻辑较为复杂，发生故障后排查问题，定位问题更加困难;</li>
<li>数据一致性仍然靠原生半同步复制保证，仍然存在数据不一致的风险;</li>
<li>可能因为网络分区发生脑裂现象;<h3 id="Galera"><a href="#Galera" class="headerlink" title="Galera"></a>Galera</h3>基于Galera的MySQL高可用集群， 是多主数据同步的MySQL集群解决方案，使用简单，没有单点故障，可用性高。常见架构如下：<br><img data-src="https://gitee.com/littleeight/blog-images/raw/master/mysql%E4%B8%A4%E4%B8%87%E5%AD%97%E7%B2%BE%E5%8D%8E%E6%80%BB%E7%BB%93/19.png"></li>
</ol>
<p><strong>优点：</strong></p>
<ol>
<li>多主写入，无延迟复制，能保证数据强一致性；</li>
<li>有成熟的社区，有互联网公司在大规模的使用；</li>
<li>自动故障转移，自动添加、剔除节点；</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li>需要为原生MySQL节点打wsrep补丁</li>
<li>只支持innodb储存引擎</li>
<li>至少三节点；</li>
</ol>
<p>​</p>
<h3 id="主从复制原理"><a href="#主从复制原理" class="headerlink" title="主从复制原理"></a>主从复制原理</h3><p><img data-src="https://gitee.com/littleeight/blog-images/raw/master/mysql%E4%B8%A4%E4%B8%87%E5%AD%97%E7%B2%BE%E5%8D%8E%E6%80%BB%E7%BB%93/20.png"></p>
<ol>
<li>主库对所有DDL和DML产生的日志写进binlog；</li>
<li>主库生成一个 log dump 线程，用来给从库I/O线程读取binlog；</li>
<li>从库的I/O Thread去请求主库的binlog，并将得到的binlog日志写到relay log文件中；</li>
<li>从库的SQL Thread会读取relay log文件中的日志解析成具体操作，将主库的DDL和DML操作事件重放。</li>
</ol>
<p>​</p>
<p>在5.7版本以后，可使用<strong>并行复制</strong>来提升效率。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>little_eight</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux命令大全</title>
    <url>/2018/12/28/Linux%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/</url>
    <content><![CDATA[<h1 id="Linux命令大全"><a href="#Linux命令大全" class="headerlink" title="Linux命令大全"></a>Linux命令大全</h1><h2 id="linux-系统管理命令"><a href="#linux-系统管理命令" class="headerlink" title="linux 系统管理命令"></a>linux 系统管理命令</h2><h3 id="adduser"><a href="#adduser" class="headerlink" title="adduser"></a>adduser</h3><p><strong>功能说明</strong>：新增用户帐号。<br><strong>语 法</strong>：adduser<br><strong>补充说明</strong>：在 Slackware 中，adduser 指令是个 script 程序，利用交谈的方式取得<br>输入的用户帐号资料，然后再交由真正建立帐号的 useradd 指令建立新用户，如<br>此可方便管理员建立用户帐号。在 Red Hat Linux 中，adduser 指令则是 useradd<br>指令的符号连接，两者实际上是同一个指令。</p>
<h3 id="chfn-change-finger-information"><a href="#chfn-change-finger-information" class="headerlink" title="chfn(change finger information)"></a>chfn(change finger information)</h3><p><strong>功能说明</strong>：改变 finger 指令显示的信息。<br><strong>语 法</strong>：chfn [-f &lt;真实姓名&gt;][-h &lt;家中电话&gt;][-o &lt;办公地址&gt;][-p &lt;办公电话&gt;][-uv][帐号名称]<br><strong>补充说明</strong>：chfn 指令可用来更改执行 finger 指令时所显示的信息，这些信息都存<br>放在/etc 目录里的 asswd 文件里。若不指定任何参数，则 chfn 指令会进入问答式<br>界面。<br><strong>参 数</strong>：</p>
<ul>
<li><p>-f&lt;真实姓名&gt;或–full-name&lt;真实姓名&gt; 设置真实姓名。</p>
</li>
<li><p>-h&lt;家中电话&gt;或–home-phone&lt;家中电话&gt; 设置家中的电话号码。</p>
</li>
<li><p>-o&lt;办公地址&gt;或–office&lt;办公地址&gt; 设置办公室的地址。</p>
</li>
<li><p>-p&lt;办公电话&gt;或–office-phone&lt;办公电话&gt; 设置办公室的电话号码。</p>
</li>
<li><p>-u 或–help 在线帮助。</p>
</li>
<li><p>-v 或-version 显示版本信息。</p>
<h3 id="chsh-change-shell"><a href="#chsh-change-shell" class="headerlink" title="chsh(change shell)"></a>chsh(change shell)</h3></li>
<li><p>*功能说明**：更换登入系统时使用的 shell。</p>
</li>
<li><p>*语 法**：chsh [-luv][-s &lt;shell 名称&gt;][用户名称]</p>
</li>
<li><p>*补充说明**：每位用户在登入系统时，都会拥有预设的 shell 环境，这个指令可更<br>改其预设值。若不指定任何参数与用户名称，则 chsh 会以应答的方式进行设置。</p>
</li>
<li><p>*参 数**：</p>
</li>
<li><p>-s&lt;shell 名称&gt;或–shell&lt;shell 名称&gt; 更改系统预设的 shell 环境。</p>
</li>
<li><p>-l 或–list-shells 列出目前系统可用的 shell 清单。</p>
</li>
<li><p>-u 或–help 在线帮助。</p>
</li>
<li><p>-v 或-version 显示版本信息。</p>
</li>
</ul>
<span id="more"></span>
<h3 id="date"><a href="#date" class="headerlink" title="date"></a>date</h3><p><strong>功能说明</strong>：显示或设置系统时间与日期。</p>
<p><strong>语 法</strong>：<br>date [-d &lt; 字符串&gt;][-u][+%H%I%K%l%M%P%r%s%S%T%X%Z%a%A%b%B%c%d%D%j%m%U<br>%w%x%y%Y%n%t] 或 date [-s &lt; 字符串&gt;][-u][MMDDhhmmCCYYss] 或 date [–help][–version]</p>
<p><strong>补充说明</strong>：第一种语法可用来显示系统日期或时间，以%为开头的参数为格式参<br>数，可指定日期或时间的显示格式。第二种语法可用来设置系统日期与时间。只<br>有管理员才有设置日期与时间的权限。若不加任何参数，data 会显示目前的日期<br>与时间。</p>
<p><strong>参 数</strong>：</p>
<ul>
<li>%H 小时(以 00-23 来表示)。</li>
<li>%I 小时(以 01-12 来表示)。</li>
<li>%K 小时(以 0-23 来表示)。</li>
<li>%l 小时(以 0-12 来表示)。</li>
<li>%M 分钟(以 00-59 来表示)。</li>
<li>%P AM 或 PM。</li>
<li>%r 时间(含时分秒，小时以 12 小时 AM/PM 来表示)。</li>
<li>%s 总秒数。起算时间为 1970-01-01 00:00:00 UTC。</li>
<li>%S 秒(以本地的惯用法来表示)。</li>
<li>%T 时间(含时分秒，小时以 24小时制来表示)。</li>
<li>%X 时间(以本地的惯用法来表示)。</li>
<li>%Z 市区。</li>
<li>%a 星期的缩写。</li>
<li>%A 星期的完整名称。</li>
<li>%b 月份英文名的缩写。</li>
<li>%B 月份的完整英文名称。</li>
<li>%c 日期与时间。只输入 date 指令也会显示同样的结果。</li>
<li>%d 日期(以 01-31 来表示)。</li>
<li>%D 日期(含年月日)。</li>
<li>%j 该年中的第几天。</li>
<li>%m 月份(以 01-12 来表示)。</li>
<li>%U 该年中的周数。</li>
<li>%w 该周的天数，0 代表周日，1 代表周一，异词类推。</li>
<li>%x 日期(以本地的惯用法来表示)。</li>
<li>%y 年份(以 00-99 来表示)。</li>
<li>%Y 年份(以四位数来表示)。</li>
<li>%n 在显示时，插入新的一行。</li>
<li>%t 在显示时，插入 tab。</li>
<li>MM 月份(必要)。</li>
<li>DD 日期(必要)。</li>
<li>hh 小时(必要)。</li>
<li>mm 分钟(必要)。</li>
<li>CC 年份的前两位数(选择性)。</li>
<li>YY 年份的后两位数(选择性)。</li>
<li>ss 秒(选择性)。</li>
<li>-d&lt;字符串&gt; 显示字符串所指的日期与时间。字符串前后必须加上双引号。</li>
<li>-s&lt;字符串&gt; 根据字符串来设置日期与时间。字符串前后必须加上双引号。</li>
<li>-u 显示 GMT。</li>
<li>–help 在线帮助。</li>
<li>–version 显示版本信息。</li>
<li><h3 id="exit"><a href="#exit" class="headerlink" title="exit"></a>exit</h3></li>
<li>*功能说明**：退出目前的 shell。</li>
</ul>
<p><strong>语 法</strong>：exit [状态值]<br><strong>补充说明</strong>：执行 exit 可使 shell 以指定的状态值退出。若不设置状态值参数，则<br>shell 以预设值退出。状态值 0 代表执行成功，其他值代表执行失败。exit 也可用<br>在 script，离开正在执行的 script，回到 shell。</p>
<h3 id="finger"><a href="#finger" class="headerlink" title="finger"></a>finger</h3><p><strong>功能说明</strong>：查找并显示用户信息。<br><strong>语 法</strong>：finger [-lmsp][帐号名称…]<br><strong>补充说明</strong>：finger 指令会去查找，并显示指定帐号的用户相关信息，<br>包括本地与远端主机的用户皆可，帐号名称没有大小写的差别。单独<br>执行 finger 指令，它会显示本地主机现在所有的用户的登陆信息，包<br>括帐号名称，真实姓名，登入终端机，闲置时间，登入时间以及地址<br>和电话。<br><strong>参 数</strong>：</p>
<ul>
<li>-l 列出该用户的帐号名称，真实姓名，用户专属目录，登入所用<br>的 Shell，登入时间，转信地址，电子邮件状态，还有计划文件和方<br>案文件内容。</li>
<li>-m 排除查找用户的真实姓名。</li>
<li>-s 列出该用户的帐号名称，真实姓名，登入终端机，闲置时间，<br>登入时间以及地址和电话。</li>
<li>-p 列出该用户的帐号名称，真实姓名，用户专属目录，登入所用<br>的 Shell，登入时间，转信地址，电子邮件状态，但不显示该用户的<br>计划文件和方案文件内容。</li>
</ul>
<h3 id="free"><a href="#free" class="headerlink" title="free"></a>free</h3><p><strong>功能说明</strong>：显示内存状态。<br><strong>语 法</strong>： free [-bkmotV][-s &lt;间隔秒数&gt;]<br><strong>补充说明</strong>：free 指令会显示内存的使用情况，包括实体内存，虚拟的交换文件内<br>存，共享内存区段，以及系统核心使用的缓冲区等。<br><strong>参 数</strong>：</p>
<ul>
<li>-b 以 Byte 为单位显示内存使用情况。</li>
<li>-k 以 KB 为单位显示内存使用情况。</li>
<li>-m 以 MB 为单位显示内存使用情况。</li>
<li>-o 不显示缓冲区调节列。</li>
<li>-s&lt;间隔秒数&gt; 持续观察内存使用状况。</li>
<li>-t 显示内存总和列。</li>
<li>-V 显示版本信息。</li>
</ul>
<h3 id="gitps-gnu-interactive-tools-process-status"><a href="#gitps-gnu-interactive-tools-process-status" class="headerlink" title="gitps(gnu interactive tools process status)"></a>gitps(gnu interactive tools process status)</h3><p><strong>功能说明</strong>：报告程序状况。<br><strong>语 法</strong>：gitps [acefgjlnrsSTuvwxX][p &lt;程序识别码&gt;][t &lt;终端机编号&gt;][U &lt;帐号<br>名称&gt;]<br><strong>补充说明</strong>：gitps 是用来报告并管理程序执行的指令，基本上它就是通过 ps 指令<br>来报告，管理程序，也能通过 gitps 指令随时中断，删除不必要的程序。因为 gitps<br>指令会去执行 ps 指令，所以其参数和 ps 指令相当类似。<br><strong>参 数</strong>：</p>
<ul>
<li>a 显示 现行终端机下的所有程序，包括其他用户的程序。 </li>
<li>c 列出程序时，显示每个程序真正的指令名称，而不包含路径，参数或是常</li>
<li>驻服务的标示．</li>
<li>e 列出程序时，显示每个程序所使用的环境变量。</li>
<li>f 用 ASCII 字符显示树状结构，表达程序间的相互关系。</li>
<li>g 显示现行终端机下的所有程序，包括群组领导者的程序。</li>
<li>j 采用工作控制的格式来显示程序状况。</li>
<li>l 采用纤细的格式来显示程序状况。</li>
<li>n 以数字来表示 USER 和 WCHAN 栏位。</li>
<li>p&lt;程序识别码&gt; 指定程序识别码，并列出该程序的状况。</li>
<li>r 只列出现行终端机正在执行中的程序。</li>
<li>s 采用程序信号的格式显示程序状况。</li>
<li>S 列出程序时，包括已中断的子程序信息。</li>
<li>t&lt;终端机机标号&gt; 指定终端机编号，并列出属于该终端机的程序的状况。</li>
<li>T 显示现行终端机下的所有程序。</li>
<li>u 以用户为主的格式来显示程序状况。</li>
<li>U&lt;帐号名称&gt; 列出属于该用户的程序的状况。</li>
<li>v 采用虚拟内存的格式显示程序状况。</li>
<li>w 采用宽阔的格式来显示程序状况。</li>
<li>x 显示所有程序，不以终端机来区分。</li>
<li>X 采用旧试的 Linux i386 登陆格式显示程序状况。</li>
</ul>
<h3 id="groupdel-group-delete"><a href="#groupdel-group-delete" class="headerlink" title="groupdel(group delete)"></a>groupdel(group delete)</h3><p><strong>功能说明</strong>：删除群组。<br><strong>语 法</strong>：groupdel [群组名称]<br><strong>补充说明</strong>：需要从系统上删除群组时，可用 groupdel 指令来完成这项工作。倘若<br>该群组中仍包括某些用户，则必须先删除这些用户后，方能删除群组。</p>
<h3 id="groupmod-group-modify"><a href="#groupmod-group-modify" class="headerlink" title="groupmod(group modify)"></a>groupmod(group modify)</h3><p><strong>功能说明</strong>：更改群组识别码或名称。<br><strong>语 法</strong>：<code>groupmod [-g &lt;群组识别码&gt; &lt;-o&gt; ][-n &lt;新群组名称&gt;][群组名称]</code><br><strong>补充说明</strong>：需要更改群组的识别码或名称时，可用 groupmod 指令来完成这项工作。<br><strong>参 数</strong>：</p>
<ul>
<li>-g &lt;群组识别码&gt; 设置欲使用的群组识别码。</li>
<li>-o 重复使用群组识别码。</li>
<li>-n &lt;新群组名称&gt; 设置欲使用的群组名称。</li>
</ul>
<h3 id="id"><a href="#id" class="headerlink" title="id"></a>id</h3><p><strong>功能说明</strong>：显示用户的 ID，以及所属群组的 ID。<br><strong>语 法</strong>：id [-gGnru][–help][–version][用户名称]<br><strong>补充说明</strong>：id 会显示用户以及所属群组的实际与有效 ID。若两个 ID 相同，则仅<br>显示实际 ID。若仅指定用户名称，则显示目前用户的 ID。<br><strong>参 数</strong>：</p>
<ul>
<li>-g 或–group 显示用户所属群组的 ID。</li>
<li>-G 或–groups 显示用户所属附加群组的 ID。</li>
<li>-n 或–name 显示用户，所属群组或附加群组的名称。</li>
<li>-r 或–real 显示实际 ID。</li>
<li>-u 或–user 显示用户 ID。</li>
<li>-help 显示帮助。 </li>
<li>-version 显示版本信息。</li>
</ul>
<h3 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h3><p><strong>功能说明</strong>：删除执行中的程序或工作。<br><strong>语 法</strong>：kill [-s &lt;信息名称或编号&gt;][程序] 或 kill [-l &lt;信息编号&gt;]<br><strong>补充说明</strong>：kill 可将指定的信息送至程序。预设的信息为 SIGTERM(15)，可将指<br>定程序终止。若仍无法终止该程序，可使用 SIGKILL(9)信息尝试强制删除程序。<br>程序或工作的编号可利用 ps 指令或 jobs 指令查看。<br><strong>参 数</strong>：</p>
<ul>
<li>-l &lt;信息编号&gt; 若不加&lt;信息编号&gt;选项，则-l 参数会列出全部的信息名称。</li>
<li>-s &lt;信息名称或编号&gt; 指定要送出的信息。<br>[程序] [程序]可以是程序的 PID 或是 PGID，也可以是工作编号。</li>
</ul>
<h3 id="ps-process-status"><a href="#ps-process-status" class="headerlink" title="ps(process status)"></a>ps(process status)</h3><p><strong>功能说明</strong>：报告程序状况。<br><strong>语 法</strong>：ps [-aAcdefHjlmNVwy][acefghLnrsSTuvxX][-C &lt;指令名称&gt;][-g &lt;群组<br>名称&gt;][-G &lt;群组识别码&gt;][-p &lt;程序识别码&gt;][p &lt;程序识别码&gt;][-s &lt;阶段作业&gt;][-t &lt;终端机编号&gt;][t &lt;终端机编号&gt;][-u &lt;用户识别码&gt;][-U &lt;用户识别码&gt;][U &lt;<br>用户名称&gt;][-&lt;程序识别码&gt;][–cols &lt;每列字符数&gt;][–columns &lt;每列字符数&gt;][–cumulative][–deselect][–forest][–headers][–help][–info][–lines &lt; 显示列数&gt;][–no-headers][–group &lt;群组名称&gt;][-Group &lt;群组识别码&gt;][–pid &lt;程序识别码&gt;][–rows &lt;显示列数&gt;][–sid &lt;阶段作业&gt;][–tty &lt;终端机编号&gt;][–user &lt;用户名称&gt;][–User &lt;用户识别码&gt;][–version][–width &lt;每列字符数&gt;]<br><strong>补充说明</strong>：ps 是用来报告程序执行状况的指令，您可以搭配 kill 指令随时中断，<br>删除不必要的程序。<br><strong>参 数</strong>：</p>
<ul>
<li>-a 显示所有终端机下执行的程序，除了阶段作业领导者之外。</li>
<li>a 显示现行终端机下的所有程序，包括其他用户的程序。</li>
<li>-A 显示所有程序。</li>
<li>-c 显示 CLS 和 PRI 栏位。</li>
<li>c 列出程序时，显示每个程序真正的指令名称，而不包含路径，参数或常驻<br>服务的标示。</li>
<li>-C&lt;指令名称&gt; 指定执行指令的名称，并列出该指令的程序的状况。</li>
<li>-d 显示所有程序，但不包括阶段作业领导者的程序。</li>
<li>-e 此参数的效果和指定”A”参数相同。</li>
<li>e 列出程序时，显示每个程序所使用的环境变量。</li>
<li>-f 显示 UID,PPIP,C 与 STIME 栏位。</li>
<li>f 用 ASCII 字符显示树状结构，表达程序间的相互关系。</li>
<li>-g&lt;群组名称&gt; 此参数的效果和指定”-G”参数相同，当亦能使用阶段作业领导<br>者的名称来指定。</li>
<li>g 显示现行终端机下的所有程序，包括群组领导者的程序。</li>
<li>-G&lt;群组识别码&gt; 列出属于该群组的程序的状况，也可使用群组名称来指<br>定。</li>
<li>h 不显示标题列。</li>
<li>-H 显示树状结构，表示程序间的相互关系。</li>
<li>-j 或 j 采用工作控制的格式显示程序状况。</li>
<li>-l 或 l 采用详细的格式来显示程序状况。</li>
<li>L 列出栏位的相关信息。</li>
<li>-m 或 m 显示所有的执行绪。</li>
<li>n 以数字来表示 USER 和 WCHAN 栏位。</li>
<li>-N 显示所有的程序，除了执行 ps 指令终端机下的程序之外。</li>
<li>-p&lt;程序识别码&gt; 指定程序识别码，并列出该程序的状况。</li>
<li>p&lt;程序识别码&gt; 此参数的效果和指定”-p”参数相同，只在列表格式方面稍有<br>差异。</li>
<li>r 只列出现行终端机正在执行中的程序。</li>
<li>-s&lt;阶段作业&gt; 指定阶段作业的程序识别码，并列出隶属该阶段作业的程序的<br>状况。</li>
<li>s 采用程序信号的格式显示程序状况。</li>
<li>S 列出程序时，包括已中断的子程序资料。</li>
<li>-t&lt;终端机编号&gt; 指定终端机编号，并列出属于该终端机的程序的状况。</li>
<li>t&lt;终端机编号&gt; 此参数的效果和指定”-t”参数相同，只在列表格式方面稍有差<br>异。</li>
<li>-T 显示现行终端机下的所有程序。</li>
<li>-u&lt;用户识别码&gt; 此参数的效果和指定”-U”参数相同。</li>
<li>u 以用户为主的格式来显示程序状况。</li>
<li>-U&lt;用户识别码&gt; 列出属于该用户的程序的状况，也可使用用户名称来指<br>定。</li>
<li>U&lt;用户名称&gt; 列出属于该用户的程序的状况。</li>
<li>v 采用虚拟内存的格式显示程序状况。</li>
<li>-V 或 V 显示版本信息。</li>
<li>-w 或 w 采用宽阔的格式来显示程序状况。</li>
<li>x 显示所有程序，不以终端机来区分。</li>
<li>X 采用旧式的 Linux i386 登陆格式显示程序状况。</li>
<li>-y 配合参数”-l”使用时，不显示 F(flag)栏位，并以 RSS 栏位取代 ADDR 栏<br>位 。</li>
<li>-&lt;程序识别码&gt; 此参数的效果和指定”p”参数相同。</li>
<li>–cols&lt;每列字符数&gt; 设置每列的最大字符数。</li>
<li>–columns&lt;每列字符数&gt; 此参数的效果和指定”–cols”参数相同。<br>13</li>
<li>–cumulative 此参数的效果和指定”S”参数相同。</li>
<li>–deselect 此参数的效果和指定”-N”参数相同。</li>
<li>–forest 此参数的效果和指定”f”参数相同。</li>
<li>–headers 重复显示标题列。</li>
<li>–help 在线帮助。</li>
<li>–info 显示排错信息。</li>
<li>–lines&lt;显示列数&gt; 设置显示画面的列数。</li>
<li>–no-headers 此参数的效果和指定”h”参数相同，只在列表格式方面稍有差<br>异。</li>
<li>–group&lt;群组名称&gt; 此参数的效果和指定”-G”参数相同。</li>
<li>–Group&lt;群组识别码&gt; 此参数的效果和指定”-G”参数相同。</li>
<li>–pid&lt;程序识别码&gt; 此参数的效果和指定”-p”参数相同。</li>
<li>–rows&lt;显示列数&gt; 此参数的效果和指定”–lines”参数相同。</li>
<li>–sid&lt;阶段作业&gt; 此参数的效果和指定”-s”参数相同。</li>
<li>–tty&lt;终端机编号&gt; 此参数的效果和指定”-t”参数相同。</li>
<li>–user&lt;用户名称&gt; 此参数的效果和指定”-U”参数相同。</li>
<li>–User&lt;用户识别码&gt; 此参数的效果和指定”-U”参数相同。</li>
<li>–version 此参数的效果和指定”-V”参数相同。</li>
<li>–widty&lt;每列字符数&gt; 此参数的效果和指定”-cols”参数相同。</li>
</ul>
<h3 id="pstree-process-status-tree"><a href="#pstree-process-status-tree" class="headerlink" title="pstree(process status tree)"></a>pstree(process status tree)</h3><p><strong>功能说明</strong>：以树状图显示程序。<br><strong>语 法</strong>：pstree [-acGhlnpuUV][-H &lt;程序识别码&gt;][&lt;程序识别码&gt;/&lt;用户名称&gt;]<br><strong>补充说明</strong>：pstree 指令用 ASCII 字符显示树状结构，清楚地表达程序间的相互关<br>系。如果不指定程序识别码或用户名称，则会把系统启动时的第一个程序视为基<br>层，并显示之后的所有程序。若指定用户名称，便会以隶属该用户的第一个程序<br>当作基层，然后显示该用户的所有程序。<br><strong>参 数</strong>：</p>
<ul>
<li>-a 显示每个程序的完整指令，包含路径，参数或是常驻服务的标示。</li>
<li>-c 不使用精简标示法。 </li>
<li>-G 使用 VT100 终端机的列绘图字符。</li>
<li>-h 列出树状图时，特别标明现在执行的程序。</li>
<li>-H&lt;程序识别码&gt; 此参数的效果和指定”-h”参数类似，但特别标明指定的程<br>序。</li>
<li>-l 采用长列格式显示树状图。</li>
<li>-n 用程序识别码排序。预设是以程序名称来排序。</li>
<li>-p 显示程序识别码。</li>
<li>-u 显示用户名称。</li>
<li>-U 使用 UTF-8 列绘图字符。</li>
<li>-V 显示版本信息。</li>
</ul>
<h3 id="su-super-user"><a href="#su-super-user" class="headerlink" title="su(super user)"></a>su(super user)</h3><p><strong>功能说明</strong>：变更用户身份。<br><strong>语 法</strong>：su [-flmp][–help][–version][-][-c &lt;指令&gt;][-s <shell>][用户帐号]<br><strong>补充说明</strong>：su 可让用户暂时变更登入的身份。变更时须输入所要变更的用户帐<br>号与密码。<br><strong>参 数</strong>：</p>
<ul>
<li>-c&lt;指令&gt;或–command=&lt;指令&gt; 执行完指定的指令后，即恢复原来的身份。</li>
<li>-f 或–fast 适用于 csh 与 tsch，使 shell 不用去读取启动文件。</li>
<li>-.-l 或 –login 改变身份时，也同时变更工作目录，以及HOME,SHELL,USER,LOGNAME。此外，也会变更 PATH 变量。</li>
<li>-m,-p 或–preserve-environment 变更身份时，不要变更环境变量。</li>
<li>-s<shell>或–shell=<shell> 指定要执行的 shell。</li>
<li>–help 显示帮助。</li>
<li>–version 显示版本信息。<br>[用户帐号] 指定要变更的用户。若不指定此参数，则预设变更为 root。</li>
</ul>
<h3 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h3><p><strong>功能说明：以其他身份来执行指令。</strong><br><strong>语 法</strong>：sudo [-bhHpV][-s <shell>][-u &lt;用户&gt;][指令] 或 sudo [-klv]<br><strong>补充说明</strong>：sudo 可让用户以其他的身份来执行指定的指令，预设的身份为 root。<br>在/etc/sudoers 中设置了可执行 sudo 指令的用户。若其未经授权的用户企图使用<br>sudo，则会发出警告的邮件给管理员。用户使用 sudo 时，必须先输入密码，之<br>后有 5 分钟的有效期限，超过期限则必须重新输入密码。<br><strong>参 数</strong>：</p>
<ul>
<li>-b 在后台执行指令。</li>
<li>-h 显示帮助。</li>
<li>-H 将 HOME 环境变量设为新身份的 HOME 环境变量。</li>
<li>-k 结束密码的有效期限，也就是下次再执行 sudo 时便需要输入密码。</li>
<li>-l 列出目前用户可执行与无法执行的指令。</li>
<li>-p 改变询问密码的提示符号。</li>
<li>-s<shell> 执行指定的 shell。</li>
<li>-u&lt;用户&gt; 以指定的用户作为新的身份。若不加上此参数，则预设以 root 作<br>为新的身份。</li>
<li>-v 延长密码有效期限 5 分钟。</li>
<li>-V 显示版本信息。</li>
</ul>
<h3 id="uname"><a href="#uname" class="headerlink" title="uname"></a>uname</h3><p><strong>功能说明</strong>：显示系统信息。<br><strong>语 法</strong>：uname [-amnrsv][–help][–version]<br><strong>补充说明</strong>：uname 可显示电脑以及操作系统的相关信息。<br><strong>参 数</strong>：</p>
<ul>
<li><p>-a 或–all 显示全部的信息。</p>
</li>
<li><p>-m 或–machine 显示电脑类型。</p>
</li>
<li><p>-n 或-nodename 显示在网络上的主机名称。</p>
</li>
<li><p>-r 或–release 显示操作系统的发行编号。</p>
</li>
<li><p>-s 或–sysname 显示操作系统名称。</p>
</li>
<li><p>-v 显示操作系统的版本。 </p>
</li>
<li><p>–help 显示帮助。</p>
</li>
<li><p>–version 显示版本信息。</p>
<h3 id="useradd"><a href="#useradd" class="headerlink" title="useradd"></a>useradd</h3></li>
<li><p>*功能说明**：建立用户帐号。</p>
</li>
<li><p>*语 法**：useradd [-mMnr][-c &lt;备注&gt;][-d &lt;登入目录&gt;][-e &lt;有效期限&gt;][-f &lt;缓冲<br>天 数 &gt;][-g &lt; 群 组 &gt;][-G &lt; 群 组 &gt;][-s <shell>][-u <uid>][ 用户帐<br>号] 或 useradd -D [-b][-e &lt; 有效期限&gt;][-f &lt; 缓冲天数&gt;][-g &lt; 群组&gt;][-G &lt; 群组&gt;][-s <shell>]</p>
</li>
<li><p>*补充说明**：useradd 可用来建立用户帐号。帐号建好之后，再用 passwd 设定帐号<br>的密码．而可用 userdel 删除帐号。使用 useradd 指令所建立的帐号，实际上是保<br>存在/etc/passwd 文本文件中。</p>
</li>
<li><p>*参 数**：</p>
</li>
<li><p>-c&lt;备注&gt; 加上备注文字。备注文字会保存在 passwd 的备注栏位中。</p>
</li>
<li><p>-d&lt;登入目录&gt; 指定用户登入时的启始目录。</p>
</li>
<li><p>-D 变更预设值．</p>
</li>
<li><p>-e&lt;有效期限&gt; 指定帐号的有效期限。</p>
</li>
<li><p>-f&lt;缓冲天数&gt; 指定在密码过期后多少天即关闭该帐号。</p>
</li>
<li><p>-g&lt;群组&gt; 指定用户所属的群组。</p>
</li>
<li><p>-G&lt;群组&gt; 指定用户所属的附加群组。</p>
</li>
<li><p>-m 自动建立用户的登入目录。</p>
</li>
<li><p>-M 不要自动建立用户的登入目录。</p>
</li>
<li><p>-n 取消建立以用户名称为名的群组．</p>
</li>
<li><p>-r 建立系统帐号。</p>
</li>
<li><p>-s<shell> 指定用户登入后所使用的 shell。</p>
</li>
<li><p>-u<uid> 指定用户 ID。</p>
</li>
</ul>
<h3 id="who"><a href="#who" class="headerlink" title="who"></a>who</h3><p><strong>功能说明</strong>：显示目前登入系统的用户信息。<br><strong>语 法</strong>：who [-Himqsw][–help][–version][am i][记录文件]<br><strong>补充说明</strong>：执行这项指令可得知目前有那些用户登入系统，单独执行 who 指令<br>会列出登入帐号，使用的 终端机，登入时间以及从何处登入或正在使用哪个 X<br>显示器。<br><strong>参 数</strong>：</p>
<ul>
<li>-H 或–heading 显示各栏位的标题信息列。</li>
<li>-i 或-u 或–idle 显示闲置时间，若该用户在前一分钟之内有进行任何动作，<br>将标示成”.”号，如果该用户已超过 24小时没有任何动作，则标示出”old”字符串。</li>
<li>-m 此参数的效果和指定”am i”字符串相同。</li>
<li>-q 或–count 只显示登入系统的帐号名称和总人数。</li>
<li>-s 此参数将忽略不予处理，仅负责解决 who 指令其他版本的兼容性问题。</li>
<li>-w 或-T 或–mesg 或–message 或–writable 显示用户的信息状态栏。</li>
<li>–help 在线帮助。</li>
<li>–version 显示版本信息。</li>
</ul>
<h2 id="linux-系统设置命令"><a href="#linux-系统设置命令" class="headerlink" title="linux 系统设置命令"></a>linux 系统设置命令</h2><h3 id="crontab"><a href="#crontab" class="headerlink" title="crontab"></a>crontab</h3><p><strong>功能说明</strong>：设置计时器。<br><strong>语 法</strong>：crontab [-u &lt;用户名称&gt;][配置文件] 或 crontab [-u &lt;用户名称&gt;][-elr]<br><strong>补充说明</strong>：cron 是一个常驻服务，它提供计时器的功能，让用户在特定的时间得<br>以执行预设的指令或程序。只要用户会编辑计时器的配置文件，就可以使用计时<br>器的功能。其配置文件格式如下：<br> Minute Hour Day Month DayOFWeek Command<br><strong>参 数</strong>：</p>
<ul>
<li>-e 编辑该用户的计时器设置。</li>
<li>-l 列出该用户的计时器设置。</li>
<li>-r 删除该用户的计时器设置。</li>
<li>-u&lt;用户名称&gt; 指定要设定计时器的用户名称。</li>
</ul>
<h3 id="dircolors"><a href="#dircolors" class="headerlink" title="dircolors"></a>dircolors</h3><p><strong>功能说明</strong>：设置 ls 指令在显示目录或文件时所用的色彩。<br><strong>语 法</strong>：dircolors [色彩配置文件] 或 dircolors [-bcp][–help][–version]<br><strong>补充说明</strong>：dircolors 可根据[色彩配置文件]来设置 LS_COLORS 环境变量或是显<br>示设置 LS_COLORS 环境变量的 shell 指令。<br><strong>参 数</strong>：</p>
<ul>
<li>-b 或–sh 或–bourne-shell 显示在 Boume shell 中，将 LS_COLORS 设为目前<br>预设置的 shell 指令。</li>
<li>-c 或–csh 或–c-shell 显示在 C shell 中，将 LS_COLORS 设为目前预设置的<br>shell 指令。</li>
<li>-p 或–print-database 显示预设置</li>
<li>-help 显示帮助。</li>
<li>-version 显示版本信息。</li>
</ul>
<h3 id="rpm-redhat-package-manager"><a href="#rpm-redhat-package-manager" class="headerlink" title="rpm(redhat package manager)"></a>rpm(redhat package manager)</h3><p><strong>功能说明</strong>：管理套件。<br><strong>补充说明</strong>：rmp 原本是 Red Hat Linux 发行版专门用来管理 Linux 各项套件的程<br>序，由于它遵循 GPL 规则且功能强大方便，因而广受欢迎。逐渐受到其他发行<br>版的采用。RPM 套件管理方式的出现，让 Linux 易于安装，升级，间接提升了<br>Linux 的适用度。<br><strong>参 数</strong>：省略。</p>
<h2 id="linux-文档编辑命令"><a href="#linux-文档编辑命令" class="headerlink" title="linux 文档编辑命令"></a>linux 文档编辑命令</h2><h3 id="comm-common"><a href="#comm-common" class="headerlink" title="comm(common)"></a>comm(common)</h3><p><strong>功能说明</strong>：比较两个已排过序的文件。<br><strong>语 法</strong>：comm [-123][–help][–version][第 1 个文件][第 2 个文件]<br><strong>补充说明</strong>：这项指令会一列列地比较两个已排序文件的差异，并将其结果显示出<br>来，如果没有指定任何参数，则会把结果分成 3 行显示：第 1 行仅是在第 1 个文<br>件中出现过的列，第 2 行是仅在第 2 个文件中出现过的列，第 3 行则是在第 1<br>与第 2 个文件里都出现过的列。若给予的文件名称为”-“，则 comm 指令会从标<br>准输入设备读取数据。<br><strong>参 数</strong>：</p>
<ul>
<li>-1 不显示只在第 1 个文件里出现过的列。</li>
<li>-2 不显示只在第 2 个文件里出现过的列。</li>
<li>-3 不显示只在第 1 和第 2 个文件里出现过的列。</li>
<li>–help 在线帮助。</li>
<li>–version 显示版本信息。</li>
</ul>
<h3 id="egrep"><a href="#egrep" class="headerlink" title="egrep"></a>egrep</h3><p><strong>功能说明</strong>：在文件内查找指定的字符串。egrep 执行效果如 grep -E，使用的语法<br>及参数可参照 grep 指令，与 grep 不同点在于解读字符串的方法，egrep 是用<br>extended regular expression 语法来解读，而 grep 则用 basic regular expression 语法，extended regular expression 比 basic regular expression 有更完整的表达规范。</p>
<h3 id="fgrep-fixed-regexp"><a href="#fgrep-fixed-regexp" class="headerlink" title="fgrep(fixed regexp)"></a>fgrep(fixed regexp)</h3><p><strong>功能说明</strong>：查找文件里符合条件的字符串。<br><strong>语 法</strong>：fgrep [范本样式][文件或目录…]<br><strong>补充说明</strong>：本指令相当于执行 grep 指令加上参数”-F”，详见 grep 指令说明。</p>
<h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><p><strong>功能说明</strong>：查找文件里符合条件的字符串。<br><strong>语 法</strong>：grep [-abcEFGhHilLnqrsvVwxy][-A&lt;显示列数&gt;][-B&lt;显示列数&gt;][-C&lt;<br>显示列数&gt;][-d&lt;进行动作&gt;][-e&lt;范本样式&gt;][-f&lt;范本文件&gt;][–help][范本样式][文件<br>或目录…]<br><strong>补充说明</strong>：grep 指令用于查找内容包含指定的范本样式的文件，如果发现某文件<br>的内容符合所指定的范本样式，预设 grep 指令会把含有范本样式的那一列显示<br>出来。若不指定任何文件名称，或是所给予的文件名为“-”，则 grep 指令会从标<br>准输入设备读取数据。<br><strong>参 数</strong>：</p>
<ul>
<li>-a 或–text 不要忽略二进制的数据。</li>
<li>-A&lt;显示列数&gt;或–after-context=&lt;显示列数&gt; 除了显示符合范本样式的那一列<br>之外，并显示该列之后的内容。</li>
<li>-b 或–byte-offset 在显示符合范本样式的那一列之前，标示出该列第一个字符<br>的位编号。</li>
<li>-B&lt;显示列数&gt;或–before-context=&lt;显示列数&gt; 除了显示符合范本样式的那一列<br>之外，并显示该列之前的内容。</li>
<li>-c 或–count 计算符合范本样式的列数。</li>
<li>-C&lt;显示列数&gt;或–context=&lt;显示列数&gt;或-&lt;显示列数&gt; 除了显示符合范本样式<br>的那一列之外，并显示该列之前后的内容。</li>
<li>-d&lt;进行动作&gt;或–directories=&lt;进行动作&gt; 当指定要查找的是目录而非文件时，<br>必须使用这项参数，否则 grep 指令将回报信息并停止动作。</li>
<li>-e&lt;范本样式&gt;或–regexp=&lt;范本样式&gt; 指定字符串做为查找文件内容的范本样<br>式。</li>
<li>-E 或–extended-regexp 将范本样式为延伸的普通表示法来使用。</li>
<li>-f&lt;范本文件&gt;或–file=&lt;范本文件&gt; 指定范本文件，其内容含有一个或多个范本<br>样式，让 grep 查找符合范本条件的文件内容，格式为每列一个范本样式。</li>
<li>-F 或–fixed-regexp 将范本样式视为固定字符串的列表。</li>
<li>-G 或–basic-regexp 将范本样式视为普通的表示法来使用。</li>
<li>-h 或–no-filename 在显示符合范本样式的那一列之前，不标示该列所属的文件<br>名称。</li>
<li>-H 或–with-filename 在显示符合范本样式的那一列之前，表示该列所属的文件<br>名称。</li>
<li>-i 或–ignore-case 忽略字符大小写的差别。<br>56</li>
<li>-l 或–file-with-matches 列出文件内容符合指定的范本样式的文件名称。</li>
<li>-L 或–files-without-match 列出文件内容不符合指定的范本样式的文件名称。</li>
<li>-n 或–line-number 在显示符合范本样式的那一列之前，标示出该列的列数编<br>号。</li>
<li>-q 或–quiet 或–silent 不显示任何信息。</li>
<li>-r 或–recursive 此参数的效果和指定“-d recurse”参数相同。</li>
<li>-s 或–no-messages 不显示错误信息。</li>
<li>-v 或–revert-match 反转查找。</li>
<li>-V 或–version 显示版本信息。</li>
<li>-w 或–word-regexp 只显示全字符合的列。</li>
<li>-x 或–line-regexp 只显示全列符合的列。</li>
<li>-y 此参数的效果和指定“-i”参数相同。</li>
<li>–help 在线帮助。</li>
</ul>
<h3 id="look"><a href="#look" class="headerlink" title="look"></a>look</h3><p><strong>功能说明</strong>：查询单字。<br><strong>语 法</strong>：look [-adf][-t&lt;字尾字符串&gt;][字首字符串][字典文件]<br><strong>补充说明</strong>：look 指令用于英文单字的查询。您仅需给予它欲查询的字首字符串，<br>它会显示所有开头字符串符合该条件的单字。<br><strong>参 数</strong>：</p>
<ul>
<li>-a 使用另一个字典文件 web2，该文件也位于/usr/dict 目录下。</li>
<li>-d 只对比英文字母和数字，其余一慨忽略不予比对。</li>
<li>-f 忽略字符大小写差别。</li>
<li>-t&lt;字尾字符串&gt; 设置字尾字符串。</li>
</ul>
<h3 id="wc-word-count"><a href="#wc-word-count" class="headerlink" title="wc(word count)"></a>wc(word count)</h3><p><strong>功能说明</strong>：计算字数。<br><strong>语 法</strong>：wc [-clw][–help][–version][文件…]<br><strong>补充说明</strong>：利用 wc 指令我们可以计算文件的 Byte 数、字数、或是列数，若不指<br>定文件名称、或是所给予的文件名为“-”，则 wc 指令会从标准输入设备读取数据。<br><strong>参 数</strong>：</p>
<ul>
<li>-c 或–bytes 或–chars 只显示 Bytes 数。</li>
<li>-l 或–lines 只显示列数。</li>
<li>-w 或–words 只显示字数。</li>
<li>–help 在线帮助。</li>
<li>–version 显示版本信息。</li>
</ul>
<h2 id="linux-压缩备份命令"><a href="#linux-压缩备份命令" class="headerlink" title="linux 压缩备份命令"></a>linux 压缩备份命令</h2><h3 id="gunzip-gnu-unzip"><a href="#gunzip-gnu-unzip" class="headerlink" title="gunzip(gnu unzip)"></a>gunzip(gnu unzip)</h3><p><strong>功能说明</strong>：解压文件。<br><strong>语 法</strong>： gunzip [-acfhlLnNqrtvV][-s &lt; 压缩字尾字符串 &gt;][ 文<br>件…] 或 gunzip [-acfhlLnNqrtvV][-s &lt;压缩字尾字符串&gt;][目录]<br><strong>补充说明</strong>：gunzip 是个使用广泛的解压缩程序，它用于解开被 gzip 压缩过的文件，这些<br>压缩文件预设最后的扩展名为”.gz”。事实上 gunzip 就是 gzip 的硬连接，因此不论是压缩<br>或解压缩，都可通过 gzip 指令单独完成。<br><strong>参 数</strong>：</p>
<ul>
<li>-a 或–ascii 使用 ASCII 文字模式。</li>
<li>-c 或–stdout 或–to-stdout 把解压后的文件输出到标准输出设备。</li>
<li>-f 或-force 强行解开压缩文件，不理会文件名称或硬连接是否存在以及该文件是否为<br>符号连接。</li>
<li>-h 或–help 在线帮助。</li>
<li>-l 或–list 列出压缩文件的相关信息。</li>
<li>-L 或–license 显示版本与版权信息。</li>
<li>-n 或–no-name 解压缩时，若压缩文件内含有远来的文件名称及时间戳记，则将其忽<br>略不予处理。</li>
<li>-N 或–name 解压缩时，若压缩文件内含有原来的文件名称及时间戳记，则将其回存到<br>解开的文件上。</li>
<li>-q 或–quiet 不显示警告信息。</li>
<li>-r 或–recursive 递归处理，将指定目录下的所有文件及子目录一并处理。</li>
<li>-S&lt;压缩字尾字符串&gt;或–suffix&lt;压缩字尾字符串&gt; 更改压缩字尾字符串。</li>
<li>-t 或–test 测试压缩文件是否正确无误。</li>
<li>-v 或–verbose 显示指令执行过程。</li>
<li>-V 或–version 显示版本信息。</li>
</ul>
<h3 id="gzexe-gzip-executable"><a href="#gzexe-gzip-executable" class="headerlink" title="gzexe(gzip executable)"></a>gzexe(gzip executable)</h3><p><strong>功能说明</strong>：压缩执行文件。<br><strong>语 法</strong>：gzexe [-d][执行文件…]<br><strong>补充说明</strong>：gzexe 是用来压缩执行文件的程序。当您去执行被压缩过的执行文件时，该文件会自动解压然后继续执行，和使用一般的执行文件相同。<br><strong>参 数</strong>：</p>
<ul>
<li>-d 解开压缩文件。</li>
</ul>
<h3 id="gzip-gnu-zip"><a href="#gzip-gnu-zip" class="headerlink" title="gzip(gnu zip)"></a>gzip(gnu zip)</h3><p><strong>功能说明</strong>：压缩文件。<br><strong>语 法</strong>： gzip [-acdfhlLnNqrtvV][-S &lt; 压缩字尾字符串 &gt;][-&lt; 压缩效率&gt;][–best/fast][文件…] 或 gzip [-acdfhlLnNqrtvV][-S &lt;压缩字尾字符串&gt;][-&lt;压缩效率&gt;][–best/fast][目录]<br><strong>补充说明</strong>：gzip 是个使用广泛的压缩程序，文件经它压缩过后，其名称后面会多出”.gz”的扩展名。<br><strong>参 数</strong>：</p>
<ul>
<li>-a 或–ascii 使用 ASCII 文字模式。</li>
<li>-c 或–stdout 或–to-stdout 把压缩后的文件输出到标准输出设备，不去更动原始文件。</li>
<li>-d 或–decompress 或—-uncompress 解开压缩文件。</li>
<li>-f 或–force 强行压缩文件。不理会文件名称或硬连接是否存在以及该文件是否为符号<br>连接。</li>
<li>-h 或–help 在线帮助。</li>
<li>-l 或–list 列出压缩文件的相关信息。</li>
<li>-L 或–license 显示版本与版权信息。</li>
<li>-n 或–no-name 压缩文件时，不保存原来的文件名称及时间戳记。</li>
<li>-N 或–name 压缩文件时，保存原来的文件名称及时间戳记。</li>
<li>-q 或–quiet 不显示警告信息。</li>
<li>-r 或–recursive 递归处理，将指定目录下的所有文件及子目录一并处理。</li>
<li>-S&lt;压缩字尾字符串&gt;或—-suffix&lt;压缩字尾字符串&gt; 更改压缩字尾字符串。</li>
<li>-t 或–test 测试压缩文件是否正确无误。</li>
<li>-v 或–verbose 显示指令执行过程。</li>
<li>-V 或–version 显示版本信息。</li>
<li>-&lt;压缩效率&gt; 压缩效率是一个介于 1－9 的数值，预设值为”6”，指定愈大的数值，压<br>缩效率就会愈高。</li>
<li>–best 此参数的效果和指定”-9”参数相同。</li>
<li>–fast 此参数的效果和指定”-1”参数相同。</li>
</ul>
<h3 id="tar-tape-archive"><a href="#tar-tape-archive" class="headerlink" title="tar(tape archive)"></a>tar(tape archive)</h3><p><strong>功能说明</strong>：备份文件。<br><strong>语 法</strong>：tar [-ABcdgGhiklmMoOpPrRsStuUvwWxzZ][-b &lt;区块数目&gt;][-C &lt;目的目<br>录&gt;][-f &lt;备份文件&gt;][-F &lt;Script文件&gt;][-K &lt;文件&gt;][-L &lt;媒体容量&gt;][-N &lt;日期时间&gt;][-T &lt; 范本文件 &gt;][-V &lt; 卷册名称 &gt;][-X &lt; 范本文件 &gt;][-&lt; 设备编号 &gt;&lt; 存储密度&gt;][–after-date=&lt; 日期时间 &gt;][–atime-preserve][–backuup=&lt; 备份方式&gt;][–checkpoint][–concatenate][–confirmation][–delete][–exclude=&lt; 范本样式&gt;][–force-local][–group=&lt; 群组名称&gt;][–help][–ignore-failed-read][–new-volume-script=&lt;Script文件&gt;][–newer-mtime][–no-recursion][–null][–numeric-owner][–owner=&lt; 用户名称&gt;][–posix][–erve][–preserve-order][–preserve-permissions][–record-size=&lt;区块数目&gt;][–recursive-unlink][–remove-files][–rsh-command=&lt; 执行指令&gt;][–same-owner][–suffix=&lt;备份字尾字符串&gt;][–totals][–use-compress-program=&lt;执行指令&gt;][–version][–volno-file=&lt;编号文件&gt;][文件或目录…]<br><strong>补充说明</strong>：tar 是用来建立，还原备份文件的工具程序，它可以加入，解开备份文件内的文件。<br> <strong>参数</strong>：</p>
<ul>
<li>-A 或–catenate 新增温暖件到已存在的备份文件。</li>
<li>-b&lt;区块数目&gt;或–blocking-factor=&lt;区块数目&gt; 设置每笔记录的区块数目，每个区块大小为 12Bytes。</li>
<li>-B 或–read-full-records 读取数据时重设区块大小。</li>
<li>-c 或–create 建立新的备份文件。</li>
<li>-C&lt;目的目录&gt;或–directory=&lt;目的目录&gt; 切换到指定的目录。</li>
<li>-d 或–diff 或–compare 对比备份文件内和文件系统上的文件的差异。</li>
<li>-f&lt;备份文件&gt;或–file=&lt;备份文件&gt; 指定备份文件。</li>
<li>-F&lt;Script文件&gt;或–info-script=&lt;Script文件&gt; 每次更换磁带时，就执行指定的 Script文件。 </li>
<li><ul>
<li>-g 或–listed-incremental 处理 GNU 格式的大量备份。</li>
</ul>
</li>
<li>-G 或–incremental 处理旧的 GNU 格式的大量备份。</li>
<li>-h 或–dereference 不建立符号连接，直接复制该连接所指向的原始文件。</li>
<li>-i 或–ignore-zeros 忽略备份文件中的 0 Byte 区块，也就是 EOF。</li>
<li>-k 或–keep-old-files 解开备份文件时，不覆盖已有的文件。</li>
<li>-K&lt;文件&gt;或–starting-file=&lt;文件&gt; 从指定的文件开始还原。</li>
<li>-l 或–one-file-system 复制的文件或目录存放的文件系统，必须与 tar 指令执行时所处的<br>文件系统相同，否则不予复制。</li>
<li>-L&lt;媒体容量&gt;或-tape-length=&lt;媒体容量&gt; 设置存放每体的容量，单位以 1024 Bytes<br>计算。</li>
<li> -m 或–modification-time 还原文件时，不变更文件的更改时间。</li>
<li>-M 或–multi-volume 在建立，还原备份文件或列出其中的内容时，采用多卷册模式。</li>
<li>-N&lt;日期格式&gt;或–newer=&lt;日期时间&gt; 只将较指定日期更新的文件保存到备份文件里。</li>
<li>-o 或–old-archive 或–portability 将资料写入备份文件时使用 V7 格式。</li>
<li>-O 或–stdout 把从备份文件里还原的文件输出到标准输出设备。</li>
<li>-p 或–same-permissions 用原来的文件权限还原文件。</li>
<li>-P 或–absolute-names 文件名使用绝对名称，不移除文件名称前的”/“号。</li>
<li>-r 或–append 新增文件到已存在的备份文件的结尾部分。</li>
<li> -R 或–block-number 列出每个信息在备份文件中的区块编号。</li>
<li> -s 或–same-order 还原文件的顺序和备份文件内的存放顺序相同。</li>
<li> -S 或–sparse 倘若一个文件内含大量的连续 0 字节，则将此文件存成稀疏文件。</li>
<li> -t 或–list 列出备份文件的内容。</li>
<li> -T&lt;范本文件&gt;或–files-from=&lt;范本文件&gt;指定范本文件，其内含有一个或多个范本样<br>式，让 tar 解开或建立符合设置条件的文件。</li>
<li> -u 或–update 仅置换较备份文件内的文件更新的文件。</li>
<li> -U 或–unlink-first 解开压缩文件还原文件之前，先解除文件的连接。</li>
<li> -v 或–verbose 显示指令执行过程。</li>
<li> -V&lt;卷册名称&gt;或–label=&lt;卷册名称&gt; 建立使用指定的卷册名称的备份文件。</li>
<li> -w 或–interactive 遭遇问题时先询问用户。</li>
<li>-W 或–verify 写入备份文件后，确认文件正确无误。</li>
<li>-x 或–extract 或–get 从备份文件中还原文件。</li>
<li> -X&lt;范本文件&gt;或–exclude-from=&lt;范本文件&gt; 指定范本文件，其内含有一个或多个范本样式，让 ar 排除符合设置条件的文件。</li>
<li> -z 或–gzip 或–ungzip 通过 gzip 指令处理备份文件。</li>
<li> -Z 或–compress 或–uncompress 通过 compress 指令处理备份文件。</li>
<li>-&lt;设备编号&gt;&lt;存储密度&gt; 设置备份用的外围设备编号及存放数据的密度。</li>
<li> –after-date=&lt;日期时间&gt; 此参数的效果和指定”-N”参数相同。</li>
<li> –atime-preserve 不变更文件的存取时间。</li>
<li> –backup=&lt;备份方式&gt;或–backup 移除文件前先进行备份。</li>
<li> –checkpoint 读取备份文件时列出目录名称。</li>
<li> –concatenate 此参数的效果和指定”-A”参数相同。</li>
<li> –confirmation 此参数的效果和指定”-w”参数相同。</li>
<li> –delete 从备份文件中删除指定的文件。</li>
<li> –exclude=&lt;范本样式&gt; 排除符合范本样式的问家。</li>
<li> –group=&lt;群组名称&gt; 把加入设备文件中的文件的所属群组设成指定的群组。</li>
<li> –help 在线帮助。</li>
<li>  –ignore-failed-read 忽略数据读取错误，不中断程序的执行。</li>
<li>–new-volume-script=&lt;Script文件&gt; 此参数的效果和指定”-F”参数相同。</li>
<li> –newer-mtime 只保存更改过的文件。</li>
<li> –no-recursion 不做递归处理，也就是指定目录下的所有文件及子目录不予处理。</li>
<li> –null 从 null 设备读取文件名称。</li>
<li> –numeric-owner 以用户识别码及群组识别码取代用户名称和群组名称。</li>
<li> –owner=&lt;用户名称&gt; 把加入备份文件中的文件的拥有者设成指定的用户。</li>
<li> –posix 将数据写入备份文件时使用 POSIX 格式。</li>
<li> –preserve 此参数的效果和指定”-ps”参数相同。</li>
<li> –preserve-order 此参数的效果和指定”-A”参数相同。</li>
<li> –preserve-permissions 此参数的效果和指定”-p”参数相同。</li>
<li> –record-size=&lt;区块数目&gt; 此参数的效果和指定”-b”参数相同。</li>
<li> –recursive-unlink　解开压缩文件还原目录之前，先解除整个目录下所有文件的连接。</li>
<li>–remove-files 文件加入备份文件后，就将其删除。</li>
<li> –rsh-command=&lt;执行指令&gt; 设置要在远端主机上执行的指令，以取代 rsh 指令。</li>
<li> –same-owner 尝试以相同的文件拥有者还原问家你。</li>
<li>–suffix=&lt;备份字尾字符串&gt; 移除文件前先行备份。</li>
<li>–totals 备份文件建立后，列出文件大小。</li>
<li>–use-compress-program=&lt;执行指令&gt; 通过指定的指令处理备份文件。</li>
<li> –version 显示版本信息。</li>
<li> –volno-file=&lt;编号文件&gt; 使用指定文件内的编号取代预设的卷册编号。</li>
</ul>
<h3 id="unarj"><a href="#unarj" class="headerlink" title="unarj"></a>unarj</h3><p><strong>功能说明</strong>：解压缩.arj 文件。<br><strong>语 法</strong>：unarj [eltx][.arj 压缩文件]<br><strong>补充说明</strong>：unarj 为.arj 压缩文件的压缩程序。<br><strong>参 数</strong>：</p>
<ul>
<li> e 解压缩.arj 文件。</li>
<li> l 显示压缩文件内所包含的文件。</li>
<li> t 检查压缩文件是否正确。</li>
<li> x 解压缩时保留原有的路径。</li>
</ul>
<h3 id="unzip"><a href="#unzip" class="headerlink" title="unzip"></a>unzip</h3><p><strong>功能说明</strong>：解压缩 zip 文件<br><strong>语 法</strong>：unzip [-cflptuvz][-agCjLMnoqsVX][-P &lt;密码&gt;][.zip 文件][文件][-d &lt;目录&gt;][-x &lt;文件&gt;] 或 unzip [-Z]<br><strong>补充说明</strong>：unzip 为.zip 压缩文件的解压缩程序。<br><strong>参 数</strong>：</p>
<ul>
<li> -c 将解压缩的结果显示到屏幕上，并对字符做适当的转换。</li>
<li> -f 更新现有的文件。</li>
<li> -l 显示压缩文件内所包含的文件。</li>
<li> -p 与-c 参数类似，会将解压缩的结果显示到屏幕上，但不会执行任何的转换。</li>
<li> -t 检查压缩文件是否正确。</li>
<li> -u 与-f 参数类似，但是除了更新现有的文件外，也会将压缩文件中的其他文件解压缩到目录中。</li>
<li> -v 执行是时显示详细的信息。</li>
<li> -z 仅显示压缩文件的备注文字。</li>
<li> -a 对文本文件进行必要的字符转换。</li>
<li> -b 不要对文本文件进行字符转换。</li>
<li> -C 压缩文件中的文件名称区分大小写。</li>
<li> -j 不处理压缩文件中原有的目录路径。</li>
<li> -L 将压缩文件中的全部文件名改为小写。</li>
<li> -M 将输出结果送到 more 程序处理。</li>
<li> -n 解压缩时不要覆盖原有的文件。</li>
<li> -o 不必先询问用户，unzip 执行后覆盖原有文件。</li>
<li> -P&lt;密码&gt; 使用 zip 的密码选项。</li>
<li> -q 执行时不显示任何信息。</li>
<li> -s 将文件名中的空白字符转换为底线字符。</li>
<li> -V 保留 VMS 的文件版本信息。</li>
<li>-X 解压缩时同时回存文件原来的 UID/GID。<br>[.zip 文件] 指定.zip 压缩文件。<br>[文件] 指定要处理.zip 压缩文件中的哪些文件。</li>
<li> -d&lt;目录&gt; 指定文件解压缩后所要存储的目录。</li>
<li> -x&lt;文件&gt; 指定不要处理.zip 压缩文件中的哪些文件。</li>
<li> -Z unzip -Z 等于执行 zipinfo 指令。</li>
</ul>
<h3 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h3><p><strong>功能说明</strong>：压缩文件。<br><strong>语 法</strong>：zip [-AcdDfFghjJKlLmoqrSTuvVwXyz$][-b &lt;工作目录&gt;][-ll][-n &lt;字尾字<br>符串&gt;][-t &lt;日期时间&gt;][-&lt;压缩效率&gt;][压缩文件][文件…][-i &lt;范本样式&gt;][-x &lt;范本样式&gt;]<br><strong>补充说明</strong>：zip 是个使用广泛的压缩程序，文件经它压缩后会另外产生具有”.zip”扩展名的压缩文件。<br><strong>参 数</strong>：</p>
<ul>
<li> -A 调整可执行的自动解压缩文件。</li>
<li> -b&lt;工作目录&gt; 指定暂时存放文件的目录。</li>
<li> -c 替每个被压缩的文件加上注释。</li>
<li> -d 从压缩文件内删除指定的文件。</li>
<li> -D 压缩文件内不建立目录名称。</li>
<li> -f 此参数的效果和指定”-u”参数类似，但不仅更新既有文件，如果某些文件原本不存在于压缩文件内，使用本参数会一并将其加入压缩文件中。</li>
<li> -F 尝试修复已损坏的压缩文件。</li>
<li> -g 将文件压缩后附加在既有的压缩文件之后，而非另行建立新的压缩文件。</li>
<li> -h 在线帮助。</li>
<li> -i&lt;范本样式&gt; 只压缩符合条件的文件。</li>
<li> -j 只保存文件名称及其内容，而不存放任何目录名称。</li>
<li> -J 删除压缩文件前面不必要的数据。</li>
<li> -k 使用 MS-DOS 兼容格式的文件名称。</li>
<li> -l 压缩文件时，把 LF 字符置换成 LF+CR 字符。</li>
<li> -ll 压缩文件时，把 LF+CR 字符置换成 LF 字符。</li>
<li> -L 显示版权信息。</li>
<li> -m 将文件压缩并加入压缩文件后，删除原始文件，即把文件移到压缩文件中。</li>
<li> -n&lt;字尾字符串&gt; 不压缩具有特定字尾字符串的文件。</li>
<li> -o 以压缩文件内拥有最新更改时间的文件为准，将压缩文件的更改时间设成和该文件相同。</li>
<li> -q 不显示指令执行过程。</li>
<li> -r 递归处理，将指定目录下的所有文件和子目录一并处理。</li>
<li> -S 包含系统和隐藏文件。</li>
<li> -t&lt;日期时间&gt; 把压缩文件的日期设成指定的日期。</li>
<li> -T 检查备份文件内的每个文件是否正确无误。</li>
<li>-u 更换较新的文件到压缩文件内。</li>
<li> -v 显示指令执行过程或显示版本信息。</li>
<li> -V 保存 VMS 操作系统的文件属性。</li>
<li> -w 在文件名称里假如版本编号，本参数仅在 VMS 操作系统下有效。</li>
<li> -x&lt;范本样式&gt; 压缩时排除符合条件的文件。</li>
<li> -X 不保存额外的文件属性。</li>
<li> -y 直接保存符号连接，而非该连接所指向的文件，本参数仅在 UNIX 之类的系统下有效。</li>
<li> -z 替压缩文件加上注释。</li>
<li> -$ 保存第一个被压缩文件所在磁盘的卷册名称。</li>
<li> -&lt;压缩效率&gt; 压缩效率是一个介于 1-9 的数值。</li>
</ul>
<h2 id="linux-文件管理命令"><a href="#linux-文件管理命令" class="headerlink" title="linux 文件管理命令"></a>linux 文件管理命令</h2><h3 id="diff-differential"><a href="#diff-differential" class="headerlink" title="diff(differential)"></a>diff(differential)</h3><p><strong>功能说明</strong>：比较文件的差异。<br><strong>语 法</strong>：diff [-abBcdefHilnNpPqrstTuvwy][-&lt;行数&gt;][-C &lt;行数&gt;][-D &lt;巨集名称</p>
<blockquote>
<p>][-I &lt; 字符或字符串 &gt;][-S &lt; 文 件 &gt;][-W &lt; 宽 度 &gt;][-x &lt; 文件或目录 &gt;][-X &lt; 文 件&gt;][–help][–left-column][–suppress-common-line][文件或目录 1][文件或目录 2]<br><strong>补充说明</strong>：diff 以逐行的方式，比较文本文件的异同处。所是指定要比较目录，则 diff 会比较目录中相同文件名的文件，但不会比较其中子目录。<br><strong>参 数</strong>：</p>
</blockquote>
<ul>
<li>-&lt;行数&gt; 指定要显示多少行的文本。此参数必须与-c 或-u 参数一并使用。</li>
<li>-a 或–text diff 预设只会逐行比较文本文件。</li>
<li>-b 或–ignore-space-change 不检查空格字符的不同。</li>
<li>-B 或–ignore-blank-lines 不检查空白行。</li>
<li>-c 显示全部内文，并标出不同之处。</li>
<li>-C&lt;行数&gt;或–context&lt;行数&gt; 与执行”-c-&lt;行数&gt;”指令相同。</li>
<li>-d 或–minimal 使用不同的演算法，以较小的单位来做比较。</li>
<li>-D&lt;巨集名称&gt;或 ifdef&lt;巨集名称&gt; 此参数的输出格式可用于前置处理器巨集。</li>
<li>-e 或–ed 此参数的输出格式可用于 ed 的 script 文件。</li>
<li>-f 或-forward-ed 输出的格式类似 ed 的script文件，但按照原来文件的顺序来显示不同处。</li>
<li>-H 或–speed-large-files 比较大文件时，可加快速度。</li>
<li>-l&lt;字符或字符串&gt;或–ignore-matching-lines&lt;字符或字符串&gt; 若两个文件在某几行有<br>所不同，而这几行同时都包含了选项中指定的字符或字符串，则不显示这两个文件的差异。</li>
<li>-i 或–ignore-case 不检查大小写的不同。</li>
<li>-l 或–paginate 将结果交由 pr 程序来分页。</li>
<li>-n 或–rcs 将比较结果以 RCS 的格式来显示。</li>
<li>-N 或–new-file 在比较目录时，若文件 A 仅出现在某个目录中，预设会显示：<br>Only in 目录：文件 A 若使用-N 参数，则 diff 会将文件 A 与一个空白的文件比较。</li>
<li>-p 若比较的文件为 C 语言的程序码文件时，显示差异所在的函数名称。</li>
<li>-P 或–unidirectional-new-file 与-N 类似，但只有当第二个目录包含了一个第一个目<br>录所没有的文件时，才会将这个文件与空白的文件做比较。</li>
<li>-q 或–brief 仅显示有无差异，不显示详细的信息。</li>
<li>-r 或–recursive 比较子目录中的文件。</li>
<li>-s 或–report-identical-files 若没有发现任何差异，仍然显示信息。</li>
<li>-S&lt;文件&gt;或–starting-file&lt;文件&gt; 在比较目录时，从指定的文件开始比较。</li>
<li>-t 或–expand-tabs 在输出时，将 tab 字符展开。</li>
<li>-T 或–initial-tab 在每行前面加上 tab 字符以便对齐。</li>
<li>-u,-U&lt;列数&gt;或–unified=&lt;列数&gt; 以合并的方式来显示文件内容的不同。</li>
<li>-v 或–version 显示版本信息。</li>
<li>-w 或–ignore-all-space 忽略全部的空格字符。</li>
<li>-W&lt;宽度&gt;或–width&lt;宽度&gt; 在使用-y 参数时，指定栏宽。</li>
<li>-x&lt;文件名或目录&gt;或–exclude&lt;文件名或目录&gt; 不比较选项中所指定的文件或目录。</li>
<li>-X&lt;文件&gt;或–exclude-from&lt;文件&gt; 您可以将文件或目录类型存成文本文件，然后在<br>=&lt;文件&gt;中指定此文本文件。</li>
<li>-y 或–side-by-side 以并列的方式显示文件的异同之处。</li>
<li>–help 显示帮助。</li>
<li>–left-column 在使用-y 参数时，若两个文件某一行内容相同，则仅在左侧的栏位显示该行内容。</li>
<li>–suppress-common-lines 在使用-y 参数时，仅显示不同之处。</li>
</ul>
<h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p><strong>功能说明</strong>：查找文件或目录。<br><strong>语 法</strong>：find [目录…][-amin &lt;分钟&gt;][-anewer &lt;参考文件或目录&gt;][-atime &lt;24小时数 &gt;][-cmin &lt; 分 钟 &gt;][-cnewer &lt; 参考文件或目录 &gt;][-ctime &lt;24小时数&gt;][-daystart][-depyh][-empty][-exec &lt; 执行指令 &gt;][-false][-fls &lt; 列表文件&gt;][-follow][-fprint &lt;列表文件&gt;][-fprint0 &lt;列表文件&gt;][-fprintf&lt;列表文件&gt;&lt;输出格式&gt;][-fstype &lt;文件系统类型&gt;][-gid &lt;群组识别码&gt;][-group &lt;群组名称&gt;][-help][-ilname &lt;<br>范本样式&gt;][-iname &lt;范本样式&gt;][-inum &lt;inode 编号&gt;][-ipath &lt;范本样式&gt;][-iregex &lt;范本样式 &gt;][-links &lt; 连接数目 &gt;][-lname &lt; 范本样式 &gt;][-ls][-maxdepth &lt; 目录层级&gt;][-mindepth &lt;目录层级&gt;][-mmin &lt;分钟&gt;][-mount]<br>[-mtime &lt;24小时数 &gt;][-name &lt; 范本样式 &gt;][-newer &lt; 参考文件或目录&gt;][-nogroup][noleaf] [-nouser][-ok &lt;执行指令&gt;][-path &lt;范本样式&gt;][-perm &lt;权限数值&gt;][-print][-print0][-printf &lt;输出格式&gt;][-prune][-regex &lt;范本样式&gt;][-size &lt;文件大小&gt;][-true][-type &lt;文件类型&gt;][-uid &lt;用户识别码&gt;][-used &lt;日数&gt;][-user &lt;拥有者名称&gt;][-version][-xdev][-xtype &lt;文件类型&gt;]<br><strong>补充说明</strong>：find 指令用于查找符合条件的文件。任何位于参数之前的字符串都将被视为欲查找的目录。<br><strong>参 数</strong>：</p>
<ul>
<li>-amin&lt;分钟&gt; 查找在指定时间曾被存取过的文件或目录，单位以分钟计算。</li>
<li>-anewer&lt;参考文件或目录&gt; 查找其存取时间较指定文件或目录的存取时间更接近现在<br>的文件或目录。</li>
<li>-atime&lt;24小时数&gt; 查找在指定时间曾被存取过的文件或目录，单位以 24小时计算。</li>
<li>-cmin&lt;分钟&gt; 查找在指定时间之时被更改的文件或目录。</li>
<li>-cnewer&lt;参考文件或目录&gt; 查找其更改时间较指定文件或目录的更改时间更接近现在<br>的文件或目录。</li>
<li>-ctime&lt;24小时数&gt; 查找在指定时间之时被更改的文件或目录，单位以 24小时计算。</li>
<li>-daystart 从本日开始计算时间。</li>
<li>-depth 从指定目录下最深层的子目录开始查找。</li>
<li>-expty 寻找文件大小为 0 Byte 的文件，或目录下没有任何子目录或文件的空目录。</li>
<li>-exec&lt;执行指令&gt; 假设 find 指令的回传值为 True，就执行该指令。</li>
<li>-false 将 find 指令的回传值皆设为 False。</li>
<li>-fls&lt;列表文件&gt; 此参数的效果和指定”-ls”参数类似，但会把结果保存为指定的列表文<br>件。</li>
<li>-follow 排除符号连接。</li>
<li>-fprint&lt;列表文件&gt; 此参数的效果和指定”-print”参数类似，但会把结果保存成指定的列表文件。</li>
<li>-fprint0&lt;列表文件&gt; 此参数的效果和指定”-print0”参数类似，但会把结果保存成指定<br>的列表文件。</li>
<li>-fprintf&lt;列表文件&gt;&lt;输出格式&gt; 此参数的效果和指定”-printf”参数类似，但会把结果保存成指定的列表文件。</li>
<li>-fstype&lt;文件系统类型&gt; 只寻找该文件系统类型下的文件或目录。</li>
<li>-gid&lt;群组识别码&gt; 查找符合指定之群组识别码的文件或目录。</li>
<li>-group&lt;群组名称&gt; 查找符合指定之群组名称的文件或目录。</li>
<li>-help 或–help 在线帮助。</li>
<li>-ilname&lt;范本样式&gt; 此参数的效果和指定”-lname”参数类似，但忽略字符大小写的差<br>别。</li>
<li>-iname&lt;范本样式&gt; 此参数的效果和指定”-name”参数类似，但忽略字符大小写的差<br>别。</li>
<li>-inum&lt;inode 编号&gt; 查找符合指定的 inode 编号的文件或目录。</li>
<li>-ipath&lt;范本样式&gt; 此参数的效果和指定”-ipath”参数类似，但忽略字符大小写的差别。</li>
<li>-iregex&lt;范本样式&gt; 此参数的效果和指定”-regexe”参数类似，但忽略字符大小写的差<br>别。</li>
<li>-links&lt;连接数目&gt; 查找符合指定的硬连接数目的文件或目录。</li>
<li>-iname&lt;范本样式&gt; 指定字符串作为寻找符号连接的范本样式。</li>
<li>-ls 假设 find 指令的回传值为 True，就将文件或目录名称列出到标准输出。</li>
<li>-maxdepth&lt;目录层级&gt; 设置最大目录层级。</li>
<li>-mindepth&lt;目录层级&gt; 设置最小目录层级。</li>
<li>-mmin&lt;分钟&gt; 查找在指定时间曾被更改过的文件或目录，单位以分钟计算。</li>
<li>-mount 此参数的效果和指定”-xdev”相同。</li>
<li>-mtime&lt;24小时数&gt; 查找在指定时间曾被更改过的文件或目录，单位以 24小时计算。</li>
<li>-name&lt;范本样式&gt; 指定字符串作为寻找文件或目录的范本样式。</li>
<li>-newer&lt;参考文件或目录&gt; 查找其更改时间较指定文件或目录的更改时间更接近现在<br>的文件或目录。</li>
<li>-nogroup 找出不属于本地主机群组识别码的文件或目录。</li>
<li>-noleaf 不去考虑目录至少需拥有两个硬连接存在。</li>
<li>-nouser 找出不属于本地主机用户识别码的文件或目录。</li>
<li>-ok&lt;执行指令&gt; 此参数的效果和指定”-exec”参数类似，但在执行指令之前会先询问用<br>户，若回答”y”或”Y”，则放弃执行指令。</li>
<li>-path&lt;范本样式&gt; 指定字符串作为寻找目录的范本样式。</li>
<li>-perm&lt;权限数值&gt; 查找符合指定的权限数值的文件或目录。</li>
<li>-print 假设 find 指令的回传值为True，就将文件或目录名称列出到标准输出。格式为每列一个名称，每个名称之前皆有”./“字符串。</li>
<li>-print0 假设 find 指令的回传值为 True，就将文件或目录名称列出到标准输出。格式<br>为全部的名称皆在同一行。</li>
<li>-printf&lt;输出格式&gt; 假设find指令的回传值为True，就将文件或目录名称列出到标准输出。格式可以自行指定。</li>
<li>-prune 不寻找字符串作为寻找文件或目录的范本样式。</li>
<li>-regex&lt;范本样式&gt; 指定字符串作为寻找文件或目录的范本样式。</li>
<li>-size&lt;文件大小&gt; 查找符合指定的文件大小的文件。</li>
<li>-true 将 find 指令的回传值皆设为 True。</li>
<li>-typ&lt;文件类型&gt; 只寻找符合指定的文件类型的文件。</li>
<li>-uid&lt;用户识别码&gt; 查找符合指定的用户识别码的文件或目录。</li>
<li>-used&lt;日数&gt; 查找文件或目录被更改之后在指定时间曾被存取过的文件或目录，单位以<br>日计算。</li>
<li>-user&lt;拥有者名称&gt; 查找符合指定的拥有者名称的文件或目录。</li>
<li>-version 或–version 显示版本信息。</li>
<li>-xdev 将范围局限在先行的文件系统中。</li>
<li>-xtype&lt;文件类型&gt; 此参数的效果和指定”-type”参数类似，差别在于它针对符号连接检<br>查。</li>
</ul>
<h3 id="git-gnu-interactive-tools"><a href="#git-gnu-interactive-tools" class="headerlink" title="git(gnu interactive tools)"></a>git(gnu interactive tools)</h3><p><strong>功能说明</strong>：文字模式下的文件管理员。<br><strong>语 法</strong>：git<br><strong>补充说明</strong>：git 是用来管理文件的程序，它十分类似 DOS 下的 Norton Commander，具<br>有互动式操作界面。它的操作方法和 Norton Commander 几乎一样，略诉如下：</p>
<ul>
<li> F1 ：执行 info 指令，查询指令相关信息，会要求您输入欲查询的名称。</li>
<li> F2 ：执行 cat 指令，列出文件内容。</li>
<li> F3 ：执行 gitview 指令，观看文件内容。</li>
<li> F4 ：执行 vi 指令，编辑文件内容。</li>
<li> F5 ：执行 cp 指令，复制文件或目录，会要求您输入目标文件或目录。</li>
<li> F6 ：执行 mv 指令，移动文件或目录，或是更改其名称，会要求您输入目标文件或目录。</li>
<li> F7 ：执行 mkdir 指令，建立目录。</li>
<li> F8 ：执行 rm 指令，删除文件或目录。</li>
<li> F9 ：执行 make 指令，批处理执行指令或编译程序时，会要求您输入相关命令。</li>
<li> F10 ：离开 git 文件管理员。</li>
</ul>
<h3 id="lsattr-list-attribute"><a href="#lsattr-list-attribute" class="headerlink" title="lsattr(list attribute)"></a>lsattr(list attribute)</h3><p><strong>功能说明</strong>：显示文件属性。<br><strong>语 法</strong>：lsattr [-adlRvV][文件或目录…]<br><strong>补充说明</strong>：用 chattr 执行改变文件或目录的属性，可执行lsattr指令查询其属性。<br><strong>参 数</strong>：</p>
<ul>
<li> -a 显示所有文件和目录，包括以”.”为名称开头字符的额外内建，现行目录”.”与上层目录”..”。</li>
<li> -d 显示，目录名称，而非其内容。</li>
<li> -l 此参数目前没有任何作用。</li>
<li> -R 递归处理，将指定目录下的所有文件及子目录一并处理。</li>
<li> -v 显示文件或目录版本。</li>
<li> -V 显示版本信息。</li>
</ul>
<h3 id="rcp-remote-copy"><a href="#rcp-remote-copy" class="headerlink" title="rcp(remote copy)"></a>rcp(remote copy)</h3><p><strong>功能说明</strong>：远端复制文件或目录。<br><strong>语 法</strong>：rcp [-pr][源文件或目录][目标文件或目录] 或 rcp [-pr][源文件或目<br>录…][目标文件]<br><strong>补充说明</strong>：rcp 指令用在远端复制文件或目录，如同时指定两个以上的文件或目<br>录，且最后的目的地是一个已经存在的目录，则它灰把前面指定的所有文件或目<br>录复制到该目录中。<br><strong>参 数</strong>：</p>
<ul>
<li> -p 保留源文件或目录的属性，包括拥有者，所属群组，权限与时间。</li>
<li> -r 递归处理，将指定目录下的文件与子目录一并处理。</li>
</ul>
<h3 id="rm-remove"><a href="#rm-remove" class="headerlink" title="rm(remove)"></a>rm(remove)</h3><p><strong>功能说明</strong>：删除文件或目录。<br><strong>语 法</strong>：rm [-dfirv][–help][–version][文件或目录…]<br><strong>补充说明</strong>：执行 rm 指令可删除文件或目录，如欲删除目录必须加上参数”-r”，<br>否则预设仅会删除文件。<br><strong>参 数</strong>：</p>
<ul>
<li>-d 或–directory 直接把欲删除的目录的硬连接数据删成 0，删除该目录。</li>
<li>-f 或–force 强制删除文件或目录。</li>
<li>-i 或–interactive 删除既有文件或目录之前先询问用户。</li>
<li>-r 或-R 或–recursive 递归处理，将指定目录下的所有文件及子目录一并处理。</li>
<li>-v 或–verbose 显示指令执行过程。</li>
<li>–help 在线帮助。</li>
<li>–version 显示版本信息。</li>
</ul>
<h3 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h3><p><strong>功能说明</strong>：改变文件或目录时间。<br><strong>语 法</strong>：touch [-acfm][-d &lt;日期时间&gt;][-r &lt;参考文件或目录&gt;][-t &lt;日期时间&gt;][–help] [–version][文件或目录…] 或touch[-acfm][–help][–version][日期时间][文件或目录…]<br><strong>补充说明</strong>：使用 touch 指令可更改文件或目录的日期时间，包括存取时间和更改<br>时间。<br><strong>参 数</strong>：</p>
<ul>
<li>-a 或–time=atime 或–time=access 或–time=use 只更改存取时间。</li>
<li>-c 或–no-create 不建立任何文件。</li>
<li>-d&lt;时间日期&gt; 使用指定的日期时间，而非现在的时间。</li>
<li>-f 此参数将忽略不予处理，仅负责解决 BSD 版本 touch 指令的兼容性问题。</li>
<li>-m 或–time=mtime 或–time=modify 只更改变动时间。</li>
<li>-r&lt;参考文件或目录&gt; 把指定文件或目录的日期时间，统统设成和参考文件或<br>目录的日期时间相同。</li>
<li>-t&lt;日期时间&gt; 使用指定的日期时间，而非现在的时间。</li>
<li>–help 在线帮助。</li>
<li>–version 显示版本信息。</li>
</ul>
<h3 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h3><p><strong>使用权限</strong>：所有使用者<br><strong>使用方式</strong>：cat [-AbeEnstTuv] [–help] [–version] fileName<br><strong>说明</strong>：把档案串连接后传到基本输出（萤幕或加 &gt; fileName 到另一个档案）<br><strong>参数</strong>：</p>
<ul>
<li>-n 或 –number 由 1 开始对所有输出的行数编号</li>
<li>-b 或 –number-nonblank 和 -n 相似，只不过对于空白行不编号</li>
<li>-s 或 –squeeze-blank 当遇到有连续两行以上的空白行，就代换为一行的空白行</li>
<li>-v 或 –show-nonprinting</li>
<li>*范例**：</li>
<li>cat -n textfile1 &gt; textfile2 把 textfile1 的档案内容加上行号后输入 textfile2 这个档案里</li>
<li>cat -b textfile1 textfile2 &gt;&gt; textfile3 把 textfile1 和 textfile2 的档案内容加上行号（空白行不加）之后将内容附加到 textfile3 里。</li>
</ul>
<h3 id="chgrp-change-group"><a href="#chgrp-change-group" class="headerlink" title="chgrp(change group)"></a>chgrp(change group)</h3><p><strong>功能说明</strong>：变更文件或目录的所属群组。<br><strong>语 法</strong>： chgrp [-cfhRv][–help][–version][ 所属群组 ][ 文件或目录…] 或 chgrp [-cfhRv][–help][–reference=&lt;参考文件或目录&gt;][–version][文件或目录…]<br><strong>补充说明</strong>：在 UNIX 系统家族里，文件或目录权限的掌控以拥有者及所属群组来<br>管理。您可以使用 chgrp 指令去变更文件与目录的所属群组，设置方式采用群组<br>名称或群组识别码皆可。<br><strong>参 数</strong>：</p>
<ul>
<li>-c 或–changes 效果类似”-v”参数，但仅回报更改的部分。</li>
<li>-f 或–quiet 或–silent 不显示错误信息。</li>
<li>-h 或–no-dereference 只对符号连接的文件作修改，而不更动其他任何相关文<br>件。</li>
<li>-R 或–recursive 递归处理，将指定目录下的所有文件及子目录一并处理。</li>
<li>-v 或–verbose 显示指令执行过程。</li>
<li>–help 在线帮助。</li>
<li>–reference=&lt;参考文件或目录&gt; 把指定文件或目录的所属群组全部设成和参<br>考文件或目录的所属群组相同。</li>
<li>–version 显示版本信息。</li>
</ul>
<h3 id="chmod-change-mode"><a href="#chmod-change-mode" class="headerlink" title="chmod(change mode)"></a>chmod(change mode)</h3><p><strong>功能说明</strong>：变更文件或目录的权限。<br><strong>语 法</strong>：chmod [-cfRv][–help][–version][&lt;权限范围&gt;+/-/=&lt;权限设置…&gt;][文件<br>或目录 …] 或 chmod [-cfRv][–help][–version][ 数字代号 ][ 文件或目<br>录…] 或 chmod [-cfRv][–help][–reference=&lt;参考文件或目录&gt;][–version][文件或目录…]<br><strong>补充说明</strong>：在 UNIX 系统家族里，文件或目录权限的控制分别以读取，写入，执<br>行 3 种一般权限来区分，另有 3 种特殊权限可供运用，再搭配拥有者与所属群组<br>管理权限范围。您可以使用 chmod 指令去变更文件与目录的权限，设置方式采<br>用文字或数字代号皆可。符号连接的权限无法变更，如果您对符号连接修改权限，<br>其改变会作用在被连接的原始文件。权限范围的表示法如下：</p>
<ul>
<li>u：User，即文件或目录的拥有者。</li>
<li>g：Group，即文件或目录的所属群组。</li>
<li>o：Other，除了文件或目录拥有者或所属群组之外，其他用户皆属于这个范围。</li>
<li>a：All，即全部的用户，包含拥有者，所属群组以及其他用户。<br>有关权限代号的部分，列表于下：</li>
<li>r：读取权限，数字代号为”4”。</li>
<li>w：写入权限，数字代号为”2”。</li>
<li>x：执行或切换权限，数字代号为”1”。</li>
<li>-：不具任何权限，数字代号为”0”。</li>
<li>s：特殊?b&gt;功能说明：变更文件或目录的权限。<br>参 数：</li>
<li>-c 或–changes 效果类似”-v”参数，但仅回报更改的部分。</li>
<li>-f 或–quiet 或–silent 不显示错误信息。</li>
<li>-R 或–recursive 递归处理，将指定目录下的所有文件及子目录一并处理。</li>
<li>-v 或–verbose 显示指令执行过程。</li>
<li>–help 在线帮助。</li>
<li>–reference=&lt;参考文件或目录&gt; 把指定文件或目录的权限全部设成和参考文件或目录的权限相同</li>
<li>–version 显示版本信息。</li>
</ul>
<h3 id="chown-change-owner"><a href="#chown-change-owner" class="headerlink" title="chown(change owner)"></a>chown(change owner)</h3><p><strong>功能说明</strong>：变更文件或目录的拥有者或所属群组。<br><strong>语 法</strong>：chown [-cfhRv][–dereference][–help][–version][拥有者.&lt;所属群组&gt;][文件或目录..] 或 chown [-chfRv][–dereference][–help][–version][.所属群组][文件或<br>目录… …] 或 chown[-cfhRv][–dereference][–help][–reference=&lt;参考文件或目录&gt;][–version][文件或目录…]<br><strong>补充说明</strong>：在 UNIX 系统家族里，文件或目录权限的掌控以拥有者及所属群组来<br>管理。您可以使用 chown 指令去变更文件与目录的拥有者或所属群组，设置方<br>式采用用户名称或用户识别码皆可，设置群组则用群组名称或群组识别码。<br><strong>参 数</strong>：</p>
<ul>
<li>-c 或–changes 效果类似”-v”参数，但仅回报更改的部分。</li>
<li>-f 或–quite 或–silent 不显示错误信息。</li>
<li>-h 或–no-dereference 之对符号连接的文件作修改，而不更动其他任何相关文<br>件。</li>
<li>-R 或–recursive 递归处理，将指定目录下的所有文件及子目录一并处理。</li>
<li>-v 或–version 显示指令执行过程。</li>
<li>–dereference 效果和”-h”参数相同。</li>
<li>–help 在线帮助。</li>
<li>–reference=&lt;参考文件或目录&gt; 把指定文件或目录的拥有者与所属群组全部<br>设成和参考文件或目 录的拥有者与所属群组相同。</li>
<li>–version 显示版本信息。</li>
</ul>
<h3 id="cp-copy"><a href="#cp-copy" class="headerlink" title="cp(copy)"></a>cp(copy)</h3><p><strong>功能说明</strong>：复制文件或目录。<br><strong>语 法</strong>： cp [-abdfilpPrRsuvx][-S &lt; 备份字尾字符串 &gt;][-V &lt; 备份方式&gt;][–help][–spares=&lt;使用时机&gt;][–version][源文件或目录][目标文件或目录] [目的目录]<br><strong>补充说明</strong>：cp 指令用在复制文件或目录，如同时指定两个以上的文件或目录，<br>且最后的目的地是一个已经存在的目录，则它会把前面指定的所有文件或目录复<br>制到该目录中。若同时指定多个文件或目录，而最后的目的地并非是一个已存在<br>的目录，则会出现错误信息。<br><strong>参 数</strong>：</p>
<ul>
<li>-a 或–archive 此参数的效果和同时指定”-dpR”参数相同。</li>
<li>-b 或–backup 删除，覆盖目标文件之前的备份，备份文件会在字尾加上一个<br>备份字符串。</li>
<li>-d 或–no-dereference 当复制符号连接时，把目标文件或目录也建立为符号连<br>接，并指向与源文件或目录连接的原始文件或目录。</li>
<li>-f 或–force 强行复制文件或目录，不论目标文件或目录是否已存在。</li>
<li>-i 或–interactive 覆盖既有文件之前先询问用户。</li>
<li>-l 或–link 对源文件建立硬连接，而非复制文件。</li>
<li>-p 或–preserve 保留源文件或目录的属性。</li>
<li>-P 或–parents 保留源文件或目录的路径。</li>
<li>-r 递归处理，将指定目录下的文件与子目录一并处理。</li>
<li>-R 或–recursive 递归处理，将指定目录下的所有文件与子目录一并处理。</li>
<li>-s 或–symbolic-link 对源文件建立符号连接，而非复制文件。</li>
<li>-S&lt;备份字尾字符串&gt;或–suffix=&lt;备份字尾字符串&gt; 用”-b”参数备份目标文件<br>后，备份文件的字尾会被加上一个备份字符串，预设的备份字尾字符串是符号<br>“~”。</li>
<li>-u 或–update 使用这项参数后只会在源文件的更改时间较目标文件更新时或<br>是 名称相互对应的目标文件并不存在，才复制文件。</li>
<li>-v 或–verbose 显示指令执行过程。</li>
<li>-V&lt;备份方式&gt;或–version-control=&lt;备份方式&gt; 用”-b”参数备份目标文件后，<br>备份文件的字尾会被加上一个备份字符串，这字符串不仅可用”-S”参数变更，当<br>使用”-V”参数指定不同备份方式时，也会产生不同字尾的备份字串。</li>
<li>-x 或–one-file-system 复制的文件或目录存放的文件系统，必须与 cp 指令执<br>行时所处的文件系统相同，否则不予复制。</li>
<li>–help 在线帮助。</li>
<li>–sparse=&lt;使用时机&gt; 设置保存稀疏文件的时机。</li>
<li>–version 显示版本信息。</li>
</ul>
<h3 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h3><p><strong>使用权限</strong>：所有使用者<br><strong>用法</strong>：cut -cnum1-num2 filename<br><strong>说明</strong>：显示每行从开头算起 num1 到 num2 的文字。<br><strong>范例</strong>：<br> shell&gt;&gt; cat example<br> test2<br> this is test1<br> shell&gt;&gt; cut -c0-6 example ## print 开头算起前 6 个字元<br> test2<br> this i </p>
<h2 id="linux-文件传输命令"><a href="#linux-文件传输命令" class="headerlink" title="linux 文件传输命令"></a>linux 文件传输命令</h2><h3 id="ncftp-nc-file-transfer-protocol"><a href="#ncftp-nc-file-transfer-protocol" class="headerlink" title="ncftp(nc file transfer protocol)"></a>ncftp(nc file transfer protocol)</h3><p><strong>功能说明</strong>：传输文件。<br><strong>语 法</strong>：ncftp [主机或 IP 地址]<br><strong>补充说明</strong>：FTP 让用户得以下载存放于服务器主机的文件，也能将文件上传到远<br>端主机放置。NcFTP 是文字模式 FTP 程序的佼佼者，它具备多样特色， 包括显<br>示传输速率，下载进度，自动续传，标住书签，可通过防火墙和代理服务器等。</p>
<h3 id="tftp-trivial-file-transfer-protocol"><a href="#tftp-trivial-file-transfer-protocol" class="headerlink" title="tftp(trivial file transfer protocol)"></a>tftp(trivial file transfer protocol)</h3><p><strong>功能说明</strong>：传输文件。<br><strong>语 法</strong>：tftp [主机名称或 IP 地址]<br><strong>补充说明</strong>：FTP 让用户得以下载存放于远端主机的文件，也能将文件上传到远端<br>主机放置。tftp 是简单的文字模式 ftp 程序，它所使用的指令和 FTP 类似。</p>
<h3 id="uucp"><a href="#uucp" class="headerlink" title="uucp"></a>uucp</h3><p><strong>功能说明</strong>：在 Unix 系统之间传送文件。<br><strong>语 法</strong>：uucp [-cCdfjmrRtvW][-g&lt;等级&gt;][-I&lt;配置文件&gt;][-n&lt;用户&gt;][-x&lt;类型</p>
<blockquote>
<p>][–help][…来源][目的]<br><strong>补充说明</strong>：UUCP 为 Unix 系统之间，通过序列线来连线的协议。uucp 使用 UUCP<br>协议，主要的功能为传送文件。<br><strong>参 数</strong>：</p>
</blockquote>
<ul>
<li> -c 或–nocopy 不用将文件复制到缓冲区。</li>
<li> -C 或–copy 将文件复制到缓冲区。</li>
<li> -d 或–directiories 在传送文件时，自动在[目的]建立必要的目录。</li>
<li> -f 或–nodirectiories 在传送文件时，若需要在[目的]建立目录，则放弃执行该作<br>业。</li>
<li> -g&lt;等级&gt;或–grade&lt;等级&gt; 指定文件传送作业的优先顺序。</li>
<li> -I&lt;配置文件&gt;或–config&lt;配置文件&gt; 指定 uucp 配置文件。</li>
<li> -j 或–jobid 显示作业编号。</li>
<li> -m 或–mail 作业结束后，以电子邮件报告作业是否顺利完成。</li>
<li> -n&lt;用户&gt;或–notify&lt;用户&gt; 作业结束后，以电子邮件向指定的用户报告作业是<br>否顺利完成。</li>
<li> -r 或–nouucico 不要立即启动 uucico 服务程序，仅将作业送到队列中，待稍后<br>再执行。</li>
<li> -R 或–recursive 若[来源]为目录，则将整个目录包含子目录复制到[目的]。</li>
<li> -t 或–uuto 将最后一个参数视为”主机名!用户”。</li>
<li> -v 或–version 显示版本信息。</li>
<li> -W 或–noexpand 不要将目前所在的目录加入路径。</li>
<li> -x&lt;类型&gt;或–debug&lt;类型&gt;启动指定的排错模式。</li>
<li>–help 显示帮助。<br>[源…] 指定源文件或路径。<br>[目的] 指定目标文件或路径。</li>
</ul>
<h2 id="linux-磁盘管理命令"><a href="#linux-磁盘管理命令" class="headerlink" title="linux 磁盘管理命令"></a>linux 磁盘管理命令</h2><h3 id="cd-change-directory"><a href="#cd-change-directory" class="headerlink" title="cd(change directory)"></a>cd(change directory)</h3><p><strong>功能说明</strong>：切换目录。<br><strong>语 法</strong>：cd [目的目录]<br><strong>补充说明</strong>：cd 指令可让用户在不同的目录间切换，但该用户必须拥有足够的权<br>限进入目的目录。</p>
<h3 id="df-disk-free"><a href="#df-disk-free" class="headerlink" title="df(disk free)"></a>df(disk free)</h3><p><strong>功能说明</strong>：显示磁盘的相关信息。<br><strong>语 法</strong>：df [-ahHiklmPT][–block-size=&lt;区块大小&gt;][-t &lt;文件系统类型&gt;][-x &lt;文<br>件系统类型&gt;][–help][–no-sync][–sync][–version][文件或设备]<br>补充说明：df 可显示磁盘的文件系统与使用情形。<br><strong>参 数</strong>：</p>
<ul>
<li> -a 或–all 包含全部的文件系统。</li>
<li> –block-size=&lt;区块大小&gt; 以指定的区块大小来显示区块数目。</li>
<li> -h 或–human-readable 以可读性较高的方式来显示信息。</li>
<li> -H 或–si 与-h 参数相同，但在计算时是以 1000 Bytes 为换算单位而非<br>1024 Bytes。</li>
<li> -i 或–inodes 显示 inode 的信息。</li>
<li> -k 或–kilobytes 指定区块大小为 1024 字节。</li>
<li> -l 或–local 仅显示本地端的文件系统。</li>
<li> -m 或–megabytes 指定区块大小为 1048576 字节。</li>
<li> –no-sync 在取得磁盘使用信息前，不要执行 sync 指令，此为预设值。</li>
<li> -P 或–portability 使用 POSIX 的输出格式。</li>
<li> –sync 在取得磁盘使用信息前，先执行 sync 指令。</li>
<li> -t&lt;文件系统类型&gt;或–type=&lt;文件系统类型&gt; 仅显示指定文件系统类型的磁盘<br>信息。</li>
<li> -T 或–print-type 显示文件系统的类型。</li>
<li> -x&lt;文件系统类型&gt;或–exclude-type=&lt;文件系统类型&gt; 不要显示指定文件系统<br>类型的磁盘信息。</li>
<li> –help 显示帮助。</li>
<li>–version 显示版本信息。<br>[文件或设备] 指定磁盘设备。</li>
</ul>
<h3 id="du-disk-usage"><a href="#du-disk-usage" class="headerlink" title="du(disk usage)"></a>du(disk usage)</h3><p><strong>功能说明</strong>：显示目录或文件的大小。<br><strong>语 法</strong>： du [-abcDhHklmsSx][-L &lt; 符号连接 &gt;][-X &lt;文件&gt;][–block-size][–exclude=&lt; 目录或文件 &gt;][–max-depth=&lt; 目录层数&gt;][–help][–version][目录或文件]<br><strong>补充说明</strong>：du 会显示指定的目录或文件所占用的磁盘空间。<br><strong>参 数</strong>：</p>
<ul>
<li> -a 或-all 显示目录中个别文件的大小。</li>
<li> -b 或-bytes 显示目录或文件大小时，以 byte 为单位。</li>
<li> -c 或–total 除了显示个别目录或文件的大小外，同时也显示所有目录或文件的<br>总和。</li>
<li> -D 或–dereference-args 显示指定符号连接的源文件大小。</li>
<li> -h 或–human-readable 以 K，M，G 为单位，提高信息的可读性。</li>
<li> -H 或–si 与-h 参数相同，但是 K，M，G 是以 1000 为换算单位。</li>
<li> -k 或–kilobytes 以 1024 bytes 为单位。</li>
<li> -l 或–count-links 重复计算硬件连接的文件。</li>
<li> -L&lt;符号连接&gt;或–dereference&lt;符号连接&gt; 显示选项中所指定符号连接的源文<br>件大小。</li>
<li> -m 或–megabytes 以 1MB 为单位。</li>
<li> -s 或–summarize 仅显示总计。</li>
<li> -S 或–separate-dirs 显示个别目录的大小时，并不含其子目录的大小。</li>
<li> -x 或–one-file-xystem 以一开始处理时的文件系统为准，若遇上其它不同的文<br>件系统目录则略过。</li>
<li> -X&lt;文件&gt;或–exclude-from=&lt;文件&gt; 在&lt;文件&gt;指定目录或文件。</li>
<li> –exclude=&lt;目录或文件&gt; 略过指定的目录或文件。</li>
<li> –max-depth=&lt;目录层数&gt; 超过指定层数的目录后，予以忽略。</li>
<li> –help 显示帮助。</li>
<li> –version 显示版本信息。</li>
</ul>
<h3 id="ls-list"><a href="#ls-list" class="headerlink" title="ls(list)"></a>ls(list)</h3><p><strong>功能说明</strong>：列出目录内容。<br><strong>语 法</strong>： ls [-1aAbBcCdDfFgGhHiklLmnNopqQrRsStuUvxX][-I &lt; 范本样式</p>
<blockquote>
<p>][-T &lt;跳格字数&gt;][-w &lt;每列字符数&gt;][–block-size=&lt;区块大小&gt;][–color=&lt;使用时<br>机 &gt;][–format=&lt; 列表格式 &gt;][–full-time][–help][–indicator-style=&lt; 标注样式<br>][–quoting-style=&lt; 引号样式 &gt;][–show-control-chars][–sort=&lt; 排序方式<br>][–time=&lt;时间戳记&gt;][–version][文件或目录…]<br><strong>补充说明</strong>：执行 ls 指令可列出目录的内容，包括文件和子目录的名称。<br><strong>参 数</strong>：</p>
</blockquote>
<ul>
<li>-1 每列仅显示一个文件或目录名称。</li>
<li> -a 或–all 下所有文件和目录。</li>
<li> -A 或–almost-all 显示所有文件和目录，但不显示现行目录和上层目录。</li>
<li> -b 或–escape 显示脱离字符。</li>
<li> -B 或–ignore-backups 忽略备份文件和目录。</li>
<li> -c 以更改时间排序，显示文件和目录。</li>
<li> -C 以又上至下，从左到右的直行方式显示文件和目录名称。</li>
<li> -d 或–directory 显示目录名称而非其内容。</li>
<li> -D 或–dired 用 Emacs 的模式产生文件和目录列表。</li>
<li> -f 此参数的效果和同时指定”aU”参数相同，并关闭”lst”参数的效果。</li>
<li> -F 或–classify 在执行文件，目录，Socket，符号连接，管道名称后面，各自加<br>上”*”,”/“,”=”,”@”,”|”号。</li>
<li> -g 次参数将忽略不予处理。</li>
<li> -G 或–no-group 不显示群组名称。</li>
<li> -h 或–human-readable 用”K”,”M”,”G”来显示文件和目录的大小。</li>
<li> -H 或–si 此参数的效果和指定”-h”参数类似，但计算单位是 1000Bytes 而非<br>1024Bytes。</li>
<li> -i 或–inode 显示文件和目录的 inode 编号。</li>
<li> -I&lt;范本样式&gt;或–ignore=&lt;范本样式&gt; 不显示符合范本样式的文件或目录名称。</li>
<li> -k 或–kilobytes 此参数的效果和指定”block-size=1024”参数相同。</li>
<li> -l 使用详细格式列表。</li>
<li> -L 或–dereference 如遇到性质为符号连接的文件或目录，直接列出该连接所指<br>向的原始文件或目录。</li>
<li> -m 用”,”号区隔每个文件和目录的名称。</li>
<li> -n 或–numeric-uid-gid 以用户识别码和群组识别码替代其名称。</li>
<li> -N 或–literal 直接列出文件和目录名称，包括控制字符。</li>
<li> -o 此参数的效果和指定”-l” 参数类似，但不列出群组名称或识别码。</li>
<li> -p 或–file-type 此参数的效果和指定”-F”参数类似，但不会在执行文件名称后面<br>加上”*”号。</li>
<li> -q 或–hide-control-chars 用”?”号取代控制字符，列出文件和目录名称。</li>
<li> -Q 或–quote-name 把文件和目录名称以””号标示起来。</li>
<li> -r 或–reverse 反向排序。</li>
<li> -R 或–recursive 递归处理，将指定目录下的所有文件及子目录一并处理。</li>
<li> -s 或–size 显示文件和目录的大小，以区块为单位。</li>
<li> -S 用文件和目录的大小排序。</li>
<li> -t 用文件和目录的更改时间排序。</li>
<li> -T&lt;跳格字符&gt;或–tabsize=&lt;跳格字数&gt; 设置跳格字符所对应的空白字符数。</li>
<li> -u 以最后存取时间排序，显示文件和目录。</li>
<li> -U 列出文件和目录名称时不予排序。</li>
<li> -v 文件和目录的名称列表以版本进行排序。</li>
<li> -w&lt;每列字符数&gt;或–width=&lt;每列字符数&gt; 设置每列的最大字符数。</li>
<li> -x 以从左到右，由上至下的横列方式显示文件和目录名称。</li>
<li> -X 以文件和目录的最后一个扩展名排序。</li>
<li> –block-size=&lt;区块大小&gt; 指定存放文件的区块大小。</li>
<li> –color=&lt;列表格式&gt; 培植文件和目录的列表格式。</li>
<li> –full-time 列出完整的日期与时间。</li>
<li> –help 在线帮助。</li>
<li> –indicator-style=&lt;标注样式&gt; 在文件和目录等名称后面加上标注，易于辨识该<br>名称所属的类型。</li>
<li> –quoting-syte=&lt;引号样式&gt; 把文件和目录名称以指定的引号样式标示起来。</li>
<li> –show-control-chars 在文件和目录列表时，使用控制字符。</li>
<li> –sort=&lt;排序方式&gt; 配置文件和目录列表的排序方式。</li>
<li> –time=&lt;时间戳记&gt; 用指定的时间戳记取代更改时间。</li>
<li> –version 显示版本信息。</li>
</ul>
<h3 id="mkdir-make-directories"><a href="#mkdir-make-directories" class="headerlink" title="mkdir(make directories)"></a>mkdir(make directories)</h3><p><strong>功能说明</strong>：建立目录<br><strong>语 法</strong>：mkdir [-p][–help][–version][-m &lt;目录属性&gt;][目录名称]<br><strong>补充说明</strong>：mkdir 可建立目录并同时设置目录的权限。<br><strong>参 数</strong>：</p>
<ul>
<li> -m&lt;目录属性&gt;或–mode&lt;目录属性&gt; 建立目录时同时设置目录的权限。</li>
<li> -p 或–parents 若所要建立目录的上层目录目前尚未建立，则会一并建立上层目<br>录。</li>
<li> –help 显示帮助。</li>
<li> –verbose 执行时显示详细的信息。</li>
<li> –version 显示版本信息。</li>
</ul>
<h3 id="quota"><a href="#quota" class="headerlink" title="quota"></a>quota</h3><p><strong>功能说明</strong>：显示磁盘已使用的空间与限制。<br><strong>语 法</strong>：quota [-quvV][用户名称…] 或 quota [-gqvV][群组名称…]<br><strong>补充说明</strong>：执行 quota 指令，可查询磁盘空间的限制，并得知已使用多少空间。<br><strong>参 数</strong>：</p>
<ul>
<li>  -g 列出群组的磁盘空间限制。</li>
<li>  -q 简明列表，只列出超过限制的部分。</li>
<li>  -u 列出用户的磁盘空间限制。</li>
<li>  -v 显示该用户或群组，在所有挂入系统的存储设备的空间限制。</li>
<li>  -V 显示版本信息。</li>
</ul>
<h3 id="rmdir-remove-directory"><a href="#rmdir-remove-directory" class="headerlink" title="rmdir(remove directory)"></a>rmdir(remove directory)</h3><p><strong>功能说明</strong>：删除目录。<br><strong>语 法</strong>：rmdir [-p][–help][–ignore-fail-on-non-empty][–verbose][–version][目<br>录…]<br><strong>补充说明</strong>：当有空目录要删除时，可使用 rmdir 指令。<br><strong>参 数</strong>：</p>
<ul>
<li> -p 或–parents 删除指定目录后，若该目录的上层目录已变成空目录，则将其一<br>并删除。</li>
<li> –help 在线帮助。</li>
<li> –ignore-fail-on-non-empty 忽略非空目录的错误信息。</li>
<li> –verbose 显示指令执行过程。</li>
<li> –version 显示版本信息。</li>
</ul>
<h2 id="linux-网络通讯命令"><a href="#linux-网络通讯命令" class="headerlink" title="linux 网络通讯命令"></a>linux 网络通讯命令</h2><h3 id="ifconfig"><a href="#ifconfig" class="headerlink" title="ifconfig"></a>ifconfig</h3><p><strong>功能说明</strong>：显示或设置网络设备。<br><strong>语 法</strong>：ifconfig [网络设备][down up -allmulti -arp -promisc][add&lt;地址&gt;][del&lt;<br>地址&gt;][&lt;hw&lt;网络设备类型&gt;&lt;硬件地址&gt;][io_addr&lt;I/O 地址&gt;][irq&lt;IRQ 地址&gt;][media&lt;网络媒介类型&gt;][mem_start&lt;内存地址&gt;][metric&lt;数目&gt;][mtu&lt;字节&gt;][netmask&lt;子网掩码&gt;][tunnel&lt;地址&gt;][-broadcast&lt;地址&gt;][-pointopoint&lt;地址&gt;][IP地址]<br><strong>补充说明</strong>：ifconfig 可设置网络设备的状态，或是显示目前的设置。<br><strong>参 数</strong>：</p>
<ul>
<li> add&lt;地址&gt; 设置网络设备 IPv6 的 IP 地址。</li>
<li>del&lt;地址&gt; 删除网络设备 IPv6 的 IP 地址。</li>
<li>down 关闭指定的网络设备。</li>
<li> &lt;hw&lt;网络设备类型&gt;&lt;硬件地址&gt; 设置网络设备的类型与硬件地址。</li>
<li> io_addr&lt;I/O 地址&gt; 设置网络设备的 I/O 地址。</li>
<li> irq&lt;IRQ 地址&gt; 设置网络设备的 IRQ。</li>
<li> media&lt;网络媒介类型&gt; 设置网络设备的媒介类型。</li>
<li>mem_start&lt;内存地址&gt; 设置网络设备在主内存所占用的起始地址。<br>metric&lt;数目&gt; 指定在计算数据包的转送次数时，所要加上的数目。<br>mtu&lt;字节&gt; 设置网络设备的 MTU。<br>netmask&lt;子网掩码&gt; 设置网络设备的子网掩码。<br>tunnel&lt;地址&gt; 建立 IPv4 与 IPv6 之间的隧道通信地址。<br>up 启动指定的网络设备。</li>
</ul>
<p> -broadcast&lt;地址&gt; 将要送往指定地址的数据包当成广播数据包来处理。<br> -pointopoint&lt;地址&gt; 与指定地址的网络设备建立直接连线，此模式具有保密功<br>能。</p>
<ul>
<li> -promisc 关闭或启动指定网络设备的 promiscuous 模式。</li>
<li> [IP 地址] 指定网络设备的 IP 地址。</li>
<li> [网络设备] 指定网络设备的名称。</li>
</ul>
<h3 id="nc"><a href="#nc" class="headerlink" title="nc"></a>nc</h3><p><strong>功能说明</strong>：设置路由器。<br><strong>语 法</strong>：nc [-hlnruz][-g&lt;网关…&gt;][-G&lt;指向器数目&gt;][-i&lt;延迟秒数&gt;][-o&lt;输出文<br>件&gt;][-p&lt;通信端口&gt;][-s&lt;来源位址&gt;][-v…][-w&lt;超时秒数&gt;][主机名称][通信端口…]<br>补充说明：执行本指令可设置路由器的相关参数。<br><strong>参 数</strong>：</p>
<ul>
<li> -g&lt;网关&gt; 设置路由器跃程通信网关，最丢哦可设置 8 个。</li>
<li> -G&lt;指向器数目&gt; 设置来源路由指向器，其数值为 4 的倍数。</li>
<li> -h 在线帮助。</li>
<li> -i&lt;延迟秒数&gt; 设置时间间隔，以便传送信息及扫描通信端口。</li>
<li> -l 使用监听模式，管控传入的资料。</li>
<li> -n 直接使用 IP 地址，而不通过域名服务器。</li>
<li> -o&lt;输出文件&gt; 指定文件名称，把往来传输的数据以 16 进制字码倾倒成该文件<br>保存。</li>
<li> -p&lt;通信端口&gt; 设置本地主机使用的通信端口。</li>
<li> -r 乱数指定本地与远端主机的通信端口。</li>
<li> -s&lt;来源位址&gt; 设置本地主机送出数据包的 IP 地址。</li>
<li> -u 使用 UDP 传输协议。</li>
<li> -v 显示指令执行过程。</li>
<li> -w&lt;超时秒数&gt; 设置等待连线的时间。</li>
<li> -z 使用 0 输入/输出模式，只在扫描通信端口时使用。</li>
</ul>
<h3 id="netconf"><a href="#netconf" class="headerlink" title="netconf"></a>netconf</h3><p><strong>功能说明</strong>：设置各项网络功能。<br><strong>语 法</strong>：netconf<br><strong>补充说明</strong>：netconf 是 Red Hat Linux 发行版专门用来调整 Linux 各项设置的程序。</p>
<h3 id="netconfig"><a href="#netconfig" class="headerlink" title="netconfig"></a>netconfig</h3><p><strong>功能说明</strong>：设置网络环境。<br><strong>语 法</strong>：netconfig<br><strong>补充说明</strong>：这是 Slackware 发行版内附程序，它具有互动式的问答界面，让用户<br>轻易完成网络环境的设置。</p>
<h3 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h3><p><strong>功能说明</strong>：显示网络状态。<br><strong>语 法</strong>：netstat [-acCeFghilMnNoprstuvVwx][-A&lt;网络类型&gt;][–ip]<br><strong>补充说明</strong>：利用 netstat 指令可让你得知整个 Linux 系统的网络情况。<br><strong>参 数</strong>：</p>
<ul>
<li> -a 或–all 显示所有连线中的 Socket。</li>
<li> -A&lt;网络类型&gt;或–&lt;网络类型&gt; 列出该网络类型连线中的相关地址。</li>
<li> -c 或–continuous 持续列出网络状态。</li>
<li> -C 或–cache 显示路由器配置的快取信息。</li>
<li> -e 或–extend 显示网络其他相关信息。</li>
<li> -F 或–fib 显示 FIB。</li>
<li> -g 或–groups 显示多重广播功能群组组员名单。</li>
<li> -h 或–help 在线帮助。</li>
<li> -i 或–interfaces 显示网络界面信息表单。</li>
<li> -l 或–listening 显示监控中的服务器的 Socket。</li>
<li> -M 或–masquerade 显示伪装的网络连线。</li>
<li> -n 或–numeric 直接使用 IP 地址，而不通过域名服务器。</li>
<li> -N 或–netlink 或–symbolic 显示网络硬件外围设备的符号连接名称。</li>
<li> -o 或–timers 显示计时器。</li>
<li> -p 或–programs 显示正在使用 Socket 的程序识别码和程序名称。</li>
<li> -r 或–route 显示 Routing Table。</li>
<li> -s 或–statistice 显示网络工作信息统计表。</li>
<li> -t 或–tcp 显示 TCP 传输协议的连线状况。</li>
<li> -u 或–udp 显示 UDP 传输协议的连线状况。</li>
<li> -v 或–verbose 显示指令执行过程。</li>
<li> -V 或–version 显示版本信息。</li>
<li> -w 或–raw 显示 RAW 传输协议的连线状况。</li>
<li> -x 或–unix 此参数的效果和指定”-A unix”参数相同。</li>
<li>–ip 或–inet 此参数的效果和指定”-A inet”参数相同。</li>
</ul>
<h3 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h3><p><strong>功能说明</strong>：检测主机。<br><strong>语 法</strong>：ping [-dfnqrRv][-c&lt;完成次数&gt;][-i&lt;间隔秒数&gt;][-I&lt;网络界面&gt;][-l&lt;前置<br>载入&gt;][-p&lt;范本样式&gt;][-s&lt;数据包大小&gt;][-t&lt;存活数值&gt;][主机名称或IP地址]<br><strong>补充说明</strong>：执行ping指令会使用ICMP传输协议，发出要求回应的信息，若远端<br>主机的网络功能没有问题，就会回应该信息，因而得知该主机运作正常。<br><strong>参 数</strong>：</p>
<ul>
<li> -d 使用Socket的SO_DEBUG功能。</li>
<li> -c&lt;完成次数&gt; 设置完成要求回应的次数。</li>
<li> -f 极限检测。</li>
<li> -i&lt;间隔秒数&gt; 指定收发信息的间隔时间。</li>
<li> -I&lt;网络界面&gt; 使用指定的网络界面送出数据包。</li>
<li> -l&lt;前置载入&gt; 设置在送出要求信息之前，先行发出的数据包。</li>
<li> -n 只输出数值。</li>
<li> -p&lt;范本样式&gt; 设置填满数据包的范本样式。</li>
<li> -q 不显示指令执行过程，开头和结尾的相关信息除外。</li>
<li> -r 忽略普通的Routing Table，直接将数据包送到远端主机上。</li>
<li> -R 记录路由过程。</li>
<li> -s&lt;数据包大小&gt; 设置数据包的大小。</li>
<li> -t&lt;存活数值&gt; 设置存活数值TTL的大小。</li>
<li> -v 详细显示指令的执行过程。</li>
</ul>
<h3 id="statserial-status-ofserial-port"><a href="#statserial-status-ofserial-port" class="headerlink" title="statserial(status ofserial port)"></a>statserial(status ofserial port)</h3><p><strong>功能说明</strong>：显示串口状态。<br><strong>语 法</strong>：statserial [-dnx][串口设备名称]<br><strong>补充说明</strong>：statserial 可显示各个接脚的状态，常用来判断串口是否正常。<br><strong>参 数</strong>：</p>
<ul>
<li> -d 以 10 进制数字来表示串口的状态。</li>
<li> -n 仅显示一次串口的状态后即结束程序。</li>
<li> -x 与-n 参数类似，但是以 16 进制来表示。</li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>little_eight</tag>
      </tags>
  </entry>
  <entry>
    <title>java.util.Arrays类解析</title>
    <url>/2019/04/11/java.util.Arrays%E7%B1%BB%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>源码的类注释：This class contains various methods for manipulating arrays (such as sorting and searching). This class also contains a static factory that allows arrays to be viewed as lists.<br>可见这就是一个处理数组的类，直接研究含有的方法。</p>
<h2 id="asList"><a href="#asList" class="headerlink" title="asList"></a>asList</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> /**</span><br><span class="line">  * 就是数组转换成List集合</span><br><span class="line">  */</span><br><span class="line">public static &lt;T&gt; List&lt;T&gt; asList(T... a) &#123;</span><br><span class="line">     return new ArrayList&lt;&gt;(a);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="binarySearch"><a href="#binarySearch" class="headerlink" title="binarySearch"></a>binarySearch</h2><p>源码方法注释：Searches the specified array of longs for the specified value using the binary search algorithm. The array must be sorted<br>就是 采用二进制搜索算法，而且其数组必须是要经过排序的（后面的binarySearch0的使用基础必须是已经排序好的数组），排序刚好可以使用它的sort方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 在数组中寻找此元素，返回它的下标</span><br><span class="line"> * 参数可换成其他基本数据类型和Object</span><br><span class="line"> */</span><br><span class="line">public static int binarySearch(long[] a, long key) &#123;</span><br><span class="line">    return binarySearch0(a, 0, a.length, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> /**</span><br><span class="line">  * 遍历的二进制搜索算法</span><br><span class="line">  * @param a 数组</span><br><span class="line">  * @param fromIndex 开始下标</span><br><span class="line">  * @param toIndex 结束下标</span><br><span class="line">  * @param key 寻找的元素</span><br><span class="line">  */</span><br><span class="line"> private static int binarySearch0(long[] a, int fromIndex, int toIndex,</span><br><span class="line">                                 long key) &#123;</span><br><span class="line">    int low = fromIndex;</span><br><span class="line">    int high = toIndex - 1;</span><br><span class="line"></span><br><span class="line">    while (low &lt;= high) &#123;</span><br><span class="line">        // 取中间值</span><br><span class="line">        int mid = (low + high) &gt;&gt;&gt; 1;</span><br><span class="line">        long midVal = a[mid];</span><br><span class="line"></span><br><span class="line">        if (midVal &lt; key)</span><br><span class="line">            low = mid + 1;</span><br><span class="line">        else if (midVal &gt; key)</span><br><span class="line">            high = mid - 1;</span><br><span class="line">        else</span><br><span class="line">            return mid; // key found</span><br><span class="line">    &#125;</span><br><span class="line">    return -(low + 1);  // key not found.</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="copyOf"><a href="#copyOf" class="headerlink" title="copyOf"></a>copyOf</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 顾名思义，就是复制指定的数组</span><br><span class="line"> * @param newLength 指定新数组的长度，如果小于复制的数组，则截取只保留到此长度的元素</span><br><span class="line"> * @param newType 默认是复制数组的类型(注意是T[]不是T)，也可以定义成新的类型</span><br><span class="line"> */</span><br><span class="line">public static &lt;T,U&gt; T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType) &#123;</span><br><span class="line">      @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">      T[] copy = ((Object)newType == (Object)Object[].class)</span><br><span class="line">          ? (T[]) new Object[newLength]</span><br><span class="line">          : (T[]) Array.newInstance(newType.getComponentType(), newLength);</span><br><span class="line">      System.arraycopy(original, 0, copy, 0,</span><br><span class="line">                       Math.min(original.length, newLength));</span><br><span class="line">      return copy;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 还提供另一个可指定范围复制数组的方法</span><br><span class="line"> */</span><br><span class="line"> public static &lt;T,U&gt; T[] copyOfRange(U[] original, int from, int to, Class&lt;? extends T[]&gt; newType) &#123;</span><br><span class="line">      int newLength = to - from;</span><br><span class="line">      if (newLength &lt; 0)</span><br><span class="line">          throw new IllegalArgumentException(from + &quot; &gt; &quot; + to);</span><br><span class="line">      @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">      T[] copy = ((Object)newType == (Object)Object[].class)</span><br><span class="line">          ? (T[]) new Object[newLength]</span><br><span class="line">          : (T[]) Array.newInstance(newType.getComponentType(), newLength);</span><br><span class="line">      System.arraycopy(original, from, copy, 0,</span><br><span class="line">                       Math.min(original.length - from, newLength));</span><br><span class="line">      return copy;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到最终实现的都是System.arraycopy() </p>
<h2 id="deepEquals"><a href="#deepEquals" class="headerlink" title="deepEquals"></a>deepEquals</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 就是对比两个数组的值（包括类型）是否完全一致</span><br><span class="line"> */</span><br><span class="line">public static boolean deepEquals(Object[] a1, Object[] a2) &#123;</span><br><span class="line">       if (a1 == a2)</span><br><span class="line">           return true;</span><br><span class="line">       if (a1 == null || a2==null)</span><br><span class="line">           return false;</span><br><span class="line">       int length = a1.length;</span><br><span class="line">       if (a2.length != length)</span><br><span class="line">           return false;</span><br><span class="line"></span><br><span class="line">       for (int i = 0; i &lt; length; i++) &#123;</span><br><span class="line">           Object e1 = a1[i];</span><br><span class="line">           Object e2 = a2[i];</span><br><span class="line"></span><br><span class="line">           if (e1 == e2)</span><br><span class="line">               continue;</span><br><span class="line">           if (e1 == null)</span><br><span class="line">               return false;</span><br><span class="line"></span><br><span class="line">           // Figure out whether the two elements are equal</span><br><span class="line">           boolean eq = deepEquals0(e1, e2);</span><br><span class="line"></span><br><span class="line">           if (!eq)</span><br><span class="line">               return false;</span><br><span class="line">       &#125;</span><br><span class="line">       return true;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>源码方法注释：Returns a hash code based on the “deep contents” of the specified array. </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 从 result = 1起，然后从第一个元素进行 result = 31 * result + element.HashCode(); 进行循环计算。</span><br><span class="line"> * elementHash ： 就是下一级元素计算出来的。</span><br><span class="line"> * 当element为 引用数据类型数组时，elementHash使用	Arrays.deepHashCode(Object a[])计算。</span><br><span class="line"> * 当element为 基本数据类型数组时，elementHash使用	Arrays.hashCode(Object a[])计算。</span><br><span class="line"> * 当element为 非数组时，elementHash使用	element.hashCode()计算。</span><br><span class="line"> * 很少用过，不理它了。</span><br><span class="line"> */</span><br><span class="line">public static int deepHashCode(Object a[]) &#123;</span><br><span class="line">        if (a == null)</span><br><span class="line">            return 0;</span><br><span class="line"></span><br><span class="line">        int result = 1;</span><br><span class="line"></span><br><span class="line">        for (Object element : a) &#123;</span><br><span class="line">            int elementHash = 0;</span><br><span class="line">            if (element instanceof Object[])</span><br><span class="line">                elementHash = deepHashCode((Object[]) element);</span><br><span class="line">            else if (element instanceof byte[])</span><br><span class="line">                elementHash = hashCode((byte[]) element);</span><br><span class="line">            else if (element instanceof short[])</span><br><span class="line">                elementHash = hashCode((short[]) element);</span><br><span class="line">            else if (element instanceof int[])</span><br><span class="line">                elementHash = hashCode((int[]) element);</span><br><span class="line">            else if (element instanceof long[])</span><br><span class="line">                elementHash = hashCode((long[]) element);</span><br><span class="line">            else if (element instanceof char[])</span><br><span class="line">                elementHash = hashCode((char[]) element);</span><br><span class="line">            else if (element instanceof float[])</span><br><span class="line">                elementHash = hashCode((float[]) element);</span><br><span class="line">            else if (element instanceof double[])</span><br><span class="line">                elementHash = hashCode((double[]) element);</span><br><span class="line">            else if (element instanceof boolean[])</span><br><span class="line">                elementHash = hashCode((boolean[]) element);</span><br><span class="line">            else if (element != null)</span><br><span class="line">                elementHash = element.hashCode();</span><br><span class="line"></span><br><span class="line">            result = 31 * result + elementHash;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="deepToString"><a href="#deepToString" class="headerlink" title="deepToString"></a>deepToString</h2><p>就是把数组转换成“[xx,yy,zz…]”，这样的字符串，可转换多层次嵌套的数组。而toString方法就只能转换一层数组。</p>
<h2 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 相比于deepEquals()，这个只要求元素的值一样就返回true了</span><br><span class="line"> */</span><br><span class="line">public static boolean equals(short[] a, short a2[]) &#123;</span><br><span class="line">       if (a==a2)</span><br><span class="line">           return true;</span><br><span class="line">       if (a==null || a2==null)</span><br><span class="line">           return false;</span><br><span class="line"></span><br><span class="line">       int length = a.length;</span><br><span class="line">       if (a2.length != length)</span><br><span class="line">           return false;</span><br><span class="line"></span><br><span class="line">       for (int i=0; i&lt;length; i++)</span><br><span class="line">           if (a[i] != a2[i])</span><br><span class="line">               return false;</span><br><span class="line"></span><br><span class="line">       return true;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="fill"><a href="#fill" class="headerlink" title="fill"></a>fill</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 将val值赋给每个元素..</span><br><span class="line"> */</span><br><span class="line">public static void fill(long[] a, long val) &#123;</span><br><span class="line">      for (int i = 0, len = a.length; i &lt; len; i++)</span><br><span class="line">          a[i] = val;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 你还可以指定赋值的范围</span><br><span class="line"> */</span><br><span class="line"> public static void fill(long[] a, int fromIndex, int toIndex, long val) &#123;</span><br><span class="line">     rangeCheck(a.length, fromIndex, toIndex);</span><br><span class="line">     for (int i = fromIndex; i &lt; toIndex; i++)</span><br><span class="line">         a[i] = val;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode"></a>hashCode</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 从 result = 1起，然后从第一个元素进行 result = 31 * result +element.HashCode();进行循环计算。</span><br><span class="line"> */</span><br><span class="line">public static int hashCode(byte a[]) &#123;</span><br><span class="line">    if (a == null)</span><br><span class="line">        return 0;</span><br><span class="line"></span><br><span class="line">    int result = 1;</span><br><span class="line">    for (byte element : a)</span><br><span class="line">        result = 31 * result + element;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="legacyMergeSort"><a href="#legacyMergeSort" class="headerlink" title="legacyMergeSort"></a>legacyMergeSort</h2><p>源码方法注释有这玩意：/** To be removed in a future release. */，那就不看他了</p>
<h2 id="parallelPrefix、parallelSetAll"><a href="#parallelPrefix、parallelSetAll" class="headerlink" title="parallelPrefix、parallelSetAll"></a>parallelPrefix、parallelSetAll</h2><p>太少用了，忽略不看。</p>
<h2 id="parallelSort"><a href="#parallelSort" class="headerlink" title="parallelSort"></a>parallelSort</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 就是对数组排序，还提供对指定范围内的方法</span><br><span class="line"> */</span><br><span class="line">public static void parallelSort(long[] a) &#123;</span><br><span class="line">       int n = a.length, p, g;</span><br><span class="line">       if (n &lt;= MIN_ARRAY_SORT_GRAN ||</span><br><span class="line">           (p = ForkJoinPool.getCommonPoolParallelism()) == 1)</span><br><span class="line">           DualPivotQuicksort.sort(a, 0, n - 1, null, 0, 0);</span><br><span class="line">       else</span><br><span class="line">           new ArraysParallelSortHelpers.FJLong.Sorter</span><br><span class="line">               (null, a, new long[n], 0, n, 0,</span><br><span class="line">                ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?</span><br><span class="line">                MIN_ARRAY_SORT_GRAN : g).invoke();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="setAll"><a href="#setAll" class="headerlink" title="setAll"></a>setAll</h2><p>不常用，忽略</p>
<h2 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h2><p>该方法是用于数组排序，在 Arrays 类中有该方法的一系列重载方法，能对7种基本数据类型，包括 byte,char,double,float,int,long,short 等都能进行排序，还有 Object 类型（实现了Comparable接口），以及比较器 Comparator 。这里我们以 int[ ] 为例看看。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 就是对数组排序，还提供对指定范围内的方法</span><br><span class="line"> */</span><br><span class="line"> public static void sort(int[] a) &#123;</span><br><span class="line">    DualPivotQuicksort.sort(a, 0, a.length - 1, null, 0, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Arrays.sort 方法内部调用 DualPivotQuicksort.sort 方法，这个方法的源码很长，分别对于数组的长度进行了各种算法的划分，包括快速排序，插入排序，冒泡排序都有使用。特意翻译了DualPivotQuicksort这个类，有兴趣可以往下看(会逐渐翻译完毕)。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">final class DualPivotQuicksort &#123;</span><br><span class="line">       private DualPivotQuicksort() &#123;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       /**</span><br><span class="line">        * 合并排序中的最大运行次数</span><br><span class="line">        */</span><br><span class="line">       private static final int MAX_RUN_COUNT = 67;</span><br><span class="line"></span><br><span class="line">       /**</span><br><span class="line">        * 合并排序中运行的最大长度。</span><br><span class="line">        */</span><br><span class="line">       private static final int MAX_RUN_LENGTH = 33;</span><br><span class="line"></span><br><span class="line">       /**</span><br><span class="line">        * 如果要排序的数组的长度小于此值常量，快速排序优先用于合并排序。</span><br><span class="line">        */</span><br><span class="line">       private static final int QUICKSORT_THRESHOLD = 286;</span><br><span class="line"></span><br><span class="line">       /**</span><br><span class="line">        * 如果要排序的数组的长度小于此常量，则插入排序优先于快速排序。</span><br><span class="line">        */</span><br><span class="line">       private static final int INSERTION_SORT_THRESHOLD = 47;</span><br><span class="line"></span><br><span class="line">       /**</span><br><span class="line">        * 如果要排序的字节数组的长度大于此常量，则使用计数排序优先于插入排序。</span><br><span class="line">        */</span><br><span class="line">       private static final int COUNTING_SORT_THRESHOLD_FOR_BYTE = 29;</span><br><span class="line"></span><br><span class="line">       /**</span><br><span class="line">        * 如果要排序的短数组或字符数组的长度大于此常量，则计数排序优先于快速排序。</span><br><span class="line">        */</span><br><span class="line">       private static final int COUNTING_SORT_THRESHOLD_FOR_SHORT_OR_CHAR = 3200;</span><br><span class="line"></span><br><span class="line">       /**</span><br><span class="line">        * 如果可以合并，请使用给定的工作区数组切片对数组的指定范围进行排序</span><br><span class="line">        *</span><br><span class="line">        * @param a        要排序的数组</span><br><span class="line">        * @param left     排序开始位置</span><br><span class="line">        * @param right    排序结束位置</span><br><span class="line">        * @param work     工作区数组（切片）</span><br><span class="line">        * @param workBase 工作阵列中可用空间的原点</span><br><span class="line">        * @param workLen  工作阵列的可用大小</span><br><span class="line">        */</span><br><span class="line">        static void sort(int[] a, int left, int right,</span><br><span class="line">                        int[] work, int workBase, int workLen) &#123;</span><br><span class="line">           // 在小数组上使用快速排序</span><br><span class="line">           if (right - left &lt; QUICKSORT_THRESHOLD) &#123;</span><br><span class="line">               sort(a, left, right, true);</span><br><span class="line">               return;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       /*</span><br><span class="line">        * 索引运行[i]是第i次运行的开始（升序或降序）。</span><br><span class="line">        */</span><br><span class="line">           int[] run = new int[MAX_RUN_COUNT + 1];</span><br><span class="line">           int count = 0;</span><br><span class="line">           run[0] = left;</span><br><span class="line"></span><br><span class="line">           // 检查数组是否接近排序</span><br><span class="line">           for (int k = left; k &lt; right; run[count] = k) &#123;</span><br><span class="line">               if (a[k] &lt; a[k + 1]) &#123; //</span><br><span class="line">                   while (++k &lt;= right &amp;&amp; a[k - 1] &lt;= a[k]) ;</span><br><span class="line">               &#125; else if (a[k] &gt; a[k + 1]) &#123; // descending</span><br><span class="line">                   while (++k &lt;= right &amp;&amp; a[k - 1] &gt;= a[k]) ;</span><br><span class="line">                   for (int lo = run[count] - 1, hi = k; ++lo &lt; --hi; ) &#123;</span><br><span class="line">                       int t = a[lo];</span><br><span class="line">                       a[lo] = a[hi];</span><br><span class="line">                       a[hi] = t;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">                   for (int m = MAX_RUN_LENGTH; ++k &lt;= right &amp;&amp; a[k - 1] == a[k]; ) &#123;</span><br><span class="line">                       if (--m == 0) &#123;</span><br><span class="line">                           sort(a, left, right, true);</span><br><span class="line">                           return;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">           /*</span><br><span class="line">            * 数组不是高度结构化的，请使用快速排序而不是合并排序。</span><br><span class="line">            */</span><br><span class="line">               if (++count == MAX_RUN_COUNT) &#123;</span><br><span class="line">                   sort(a, left, right, true);</span><br><span class="line">                   return;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // 检查特殊情况</span><br><span class="line">           // 实施说明：变量“right”增加1。</span><br><span class="line">           if (run[count] == right++) &#123; // 上次运行包含一个元素</span><br><span class="line">               run[++count] = right;</span><br><span class="line">           &#125; else if (count == 1) &#123; // 数组已排序</span><br><span class="line">               return;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // 确定合并的替换基</span><br><span class="line">           byte odd = 0;</span><br><span class="line">           for (int n = 1; (n &lt;&lt;= 1) &lt; count; odd ^= 1) ;</span><br><span class="line"></span><br><span class="line">           // 使用或创建用于合并的临时数组B</span><br><span class="line">           int[] b;                 // 临时数组；替换为 a</span><br><span class="line">           int ao, bo;              // 从“左”开始的数组偏移量</span><br><span class="line">           int blen = right - left; // B所需空间</span><br><span class="line">           if (work == null || workLen &lt; blen || workBase + blen &gt; work.length) &#123;</span><br><span class="line">               work = new int[blen];</span><br><span class="line">               workBase = 0;</span><br><span class="line">           &#125;</span><br><span class="line">           if (odd == 0) &#123;</span><br><span class="line">               System.arraycopy(a, left, work, workBase, blen);</span><br><span class="line">               b = a;</span><br><span class="line">               bo = 0;</span><br><span class="line">               a = work;</span><br><span class="line">               ao = workBase - left;</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               b = work;</span><br><span class="line">               ao = 0;</span><br><span class="line">               bo = workBase - left;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // 合并</span><br><span class="line">           for (int last; count &gt; 1; count = last) &#123;</span><br><span class="line">               for (int k = (last = 0) + 2; k &lt;= count; k += 2) &#123;</span><br><span class="line">                   int hi = run[k], mi = run[k - 1];</span><br><span class="line">                   for (int i = run[k - 2], p = i, q = mi; i &lt; hi; ++i) &#123;</span><br><span class="line">                       if (q &gt;= hi || p &lt; mi &amp;&amp; a[p + ao] &lt;= a[q + ao]) &#123;</span><br><span class="line">                           b[i + bo] = a[p++ + ao];</span><br><span class="line">                       &#125; else &#123;</span><br><span class="line">                           b[i + bo] = a[q++ + ao];</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">                   run[++last] = hi;</span><br><span class="line">               &#125;</span><br><span class="line">               if ((count &amp; 1) != 0) &#123;</span><br><span class="line">                   for (int i = right, lo = run[count - 1]; --i &gt;= lo;</span><br><span class="line">                        b[i + bo] = a[i + ao]</span><br><span class="line">                           )</span><br><span class="line">                       ;</span><br><span class="line">                   run[++last] = right;</span><br><span class="line">               &#125;</span><br><span class="line">               int[] t = a;</span><br><span class="line">               a = b;</span><br><span class="line">               b = t;</span><br><span class="line">               int o = ao;</span><br><span class="line">               ao = bo;</span><br><span class="line">               bo = o;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       /**</span><br><span class="line">        * 快速排序</span><br><span class="line">        *</span><br><span class="line">        * @param leftmost 指示此部分是否在范围内最左边</span><br><span class="line">        */</span><br><span class="line">       private static void sort(int[] a, int left, int right, boolean leftmost) &#123;</span><br><span class="line">           int length = right - left + 1;</span><br><span class="line"></span><br><span class="line">           // 在小数组上使用插入排序</span><br><span class="line">           if (length &lt; INSERTION_SORT_THRESHOLD) &#123;</span><br><span class="line">               if (leftmost) &#123;</span><br><span class="line">               /*</span><br><span class="line">                * 传统的（不带sentinel）插入排序，针对服务器虚拟机进行了优化，用于最左边的部分。</span><br><span class="line">                */</span><br><span class="line">                   for (int i = left, j = i; i &lt; right; j = ++i) &#123;</span><br><span class="line">                       int ai = a[i + 1];</span><br><span class="line">                       while (ai &lt; a[j]) &#123;</span><br><span class="line">                           a[j + 1] = a[j];</span><br><span class="line">                           if (j-- == left) &#123;</span><br><span class="line">                               break;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                       a[j + 1] = ai;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">               /*</span><br><span class="line">                * 跳过最长的升序。</span><br><span class="line">                */</span><br><span class="line">                   do &#123;</span><br><span class="line">                       if (left &gt;= right) &#123;</span><br><span class="line">                           return;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125; while (a[++left] &gt;= a[left - 1]);</span><br><span class="line"></span><br><span class="line">               /*</span><br><span class="line">                * 相邻部分的每一个元素都扮演着哨兵的角色，</span><br><span class="line">                * 因此这允许我们避免在每次迭代中进行左范围检查。</span><br><span class="line">                * 此外，我们使用了更优化的算法，即对插入排序，</span><br><span class="line">                * 这比传统的插入排序实现更快（在快速排序的上下文中）。</span><br><span class="line">                */</span><br><span class="line">                   for (int k = left; ++left &lt;= right; k = ++left) &#123;</span><br><span class="line">                       int a1 = a[k], a2 = a[left];</span><br><span class="line"></span><br><span class="line">                       if (a1 &lt; a2) &#123;</span><br><span class="line">                           a2 = a1;</span><br><span class="line">                           a1 = a[left];</span><br><span class="line">                       &#125;</span><br><span class="line">                       while (a1 &lt; a[--k]) &#123;</span><br><span class="line">                           a[k + 2] = a[k];</span><br><span class="line">                       &#125;</span><br><span class="line">                       a[++k + 1] = a1;</span><br><span class="line"></span><br><span class="line">                       while (a2 &lt; a[--k]) &#123;</span><br><span class="line">                           a[k + 1] = a[k];</span><br><span class="line">                       &#125;</span><br><span class="line">                       a[k + 1] = a2;</span><br><span class="line">                   &#125;</span><br><span class="line">                   int last = a[right];</span><br><span class="line"></span><br><span class="line">                   while (last &lt; a[--right]) &#123;</span><br><span class="line">                       a[right + 1] = a[right];</span><br><span class="line">                   &#125;</span><br><span class="line">                   a[right + 1] = last;</span><br><span class="line">               &#125;</span><br><span class="line">               return;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // 长度的廉价近似值/7</span><br><span class="line">           int seventh = (length &gt;&gt; 3) + (length &gt;&gt; 6) + 1;</span><br><span class="line"></span><br><span class="line">       /*</span><br><span class="line">        * 在范围内的中心元素周围（包括中心元素）对五个等距元素进行排序。</span><br><span class="line">        * 这些元素将用于如下所述的轴选择。</span><br><span class="line">        * 选择这些元素的间距是根据经验确定的，可以很好地处理各种输入。</span><br><span class="line">        */</span><br><span class="line">           int e3 = (left + right) &gt;&gt;&gt; 1; // The midpoint</span><br><span class="line">           int e2 = e3 - seventh;</span><br><span class="line">           int e1 = e2 - seventh;</span><br><span class="line">           int e4 = e3 + seventh;</span><br><span class="line">           int e5 = e4 + seventh;</span><br><span class="line"></span><br><span class="line">           // 使用插入排序对这些元素排序</span><br><span class="line">           if (a[e2] &lt; a[e1]) &#123;</span><br><span class="line">               int t = a[e2];</span><br><span class="line">               a[e2] = a[e1];</span><br><span class="line">               a[e1] = t;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           if (a[e3] &lt; a[e2]) &#123;</span><br><span class="line">               int t = a[e3];</span><br><span class="line">               a[e3] = a[e2];</span><br><span class="line">               a[e2] = t;</span><br><span class="line">               if (t &lt; a[e1]) &#123;</span><br><span class="line">                   a[e2] = a[e1];</span><br><span class="line">                   a[e1] = t;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           if (a[e4] &lt; a[e3]) &#123;</span><br><span class="line">               int t = a[e4];</span><br><span class="line">               a[e4] = a[e3];</span><br><span class="line">               a[e3] = t;</span><br><span class="line">               if (t &lt; a[e2]) &#123;</span><br><span class="line">                   a[e3] = a[e2];</span><br><span class="line">                   a[e2] = t;</span><br><span class="line">                   if (t &lt; a[e1]) &#123;</span><br><span class="line">                       a[e2] = a[e1];</span><br><span class="line">                       a[e1] = t;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           if (a[e5] &lt; a[e4]) &#123;</span><br><span class="line">               int t = a[e5];</span><br><span class="line">               a[e5] = a[e4];</span><br><span class="line">               a[e4] = t;</span><br><span class="line">               if (t &lt; a[e3]) &#123;</span><br><span class="line">                   a[e4] = a[e3];</span><br><span class="line">                   a[e3] = t;</span><br><span class="line">                   if (t &lt; a[e2]) &#123;</span><br><span class="line">                       a[e3] = a[e2];</span><br><span class="line">                       a[e2] = t;</span><br><span class="line">                       if (t &lt; a[e1]) &#123;</span><br><span class="line">                           a[e2] = a[e1];</span><br><span class="line">                           a[e1] = t;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // 指针</span><br><span class="line">           int less = left;  // 中心部分第一个元素的索引</span><br><span class="line">           int great = right; // 右部分第一个元素前的索引</span><br><span class="line"></span><br><span class="line">           if (a[e1] != a[e2] &amp;&amp; a[e2] != a[e3] &amp;&amp; a[e3] != a[e4] &amp;&amp; a[e4] != a[e5]) &#123;</span><br><span class="line">           /*</span><br><span class="line">            * 使用五个已排序元素中的第二个和第四个元素作为轴心。</span><br><span class="line">            * 这些值是数组第一和第二个词组的廉价近似值。注意，Pivot1&lt;=Pivot2。</span><br><span class="line">            */</span><br><span class="line">               int pivot1 = a[e2];</span><br><span class="line">               int pivot2 = a[e4];</span><br><span class="line"></span><br><span class="line">           /*</span><br><span class="line">            * 要排序的第一个和最后一个元素将移动到以前由枢轴占用的位置。</span><br><span class="line">            * 当分区完成时，数据透视被交换回它们的最终位置，并从随后的排序中排除。</span><br><span class="line">            */</span><br><span class="line">               a[e2] = a[left];</span><br><span class="line">               a[e4] = a[right];</span><br><span class="line"></span><br><span class="line">           /*</span><br><span class="line">            * 跳过小于或大于透视值的元素。</span><br><span class="line">            */</span><br><span class="line">               while (a[++less] &lt; pivot1) ;</span><br><span class="line">               while (a[--great] &gt; pivot2) ;</span><br><span class="line"></span><br><span class="line">           /*</span><br><span class="line">            * 划分:</span><br><span class="line">            *</span><br><span class="line">            *   左边部分           中间部分                   右边部分</span><br><span class="line">            * +--------------------------------------------------------------+</span><br><span class="line">            * |  &lt; pivot1  |  pivot1 &lt;= &amp;&amp; &lt;= pivot2  |    ?    |  &gt; pivot2  |</span><br><span class="line">            * +--------------------------------------------------------------+</span><br><span class="line">            *               ^                          ^       ^</span><br><span class="line">            *               |                          |       |</span><br><span class="line">            *              less                        k     great</span><br><span class="line">            *</span><br><span class="line">            * 不变式:</span><br><span class="line">            *</span><br><span class="line">            *              all in (左边, less)   &lt; pivot1</span><br><span class="line">            *    pivot1 &lt;= all in [less, k)     &lt;= pivot2</span><br><span class="line">            *              all in (great, 右边) &gt; pivot2</span><br><span class="line">            *</span><br><span class="line">            * Pointer k is the first index of ?-part.</span><br><span class="line">            */</span><br><span class="line">               outer:</span><br><span class="line">               for (int k = less - 1; ++k &lt;= great; ) &#123;</span><br><span class="line">                   int ak = a[k];</span><br><span class="line">                   if (ak &lt; pivot1) &#123; // 移动 a[k] 到左边</span><br><span class="line">                       a[k] = a[less];</span><br><span class="line">                   /*</span><br><span class="line">                    * 由于性能问题，这里和我们使用下面的 &quot;a[i] = b; i++;&quot; 而不是&quot;a[i++] = b;&quot;</span><br><span class="line">                    */</span><br><span class="line">                       a[less] = ak;</span><br><span class="line">                       ++less;</span><br><span class="line">                   &#125; else if (ak &gt; pivot2) &#123; // 移动 a[k] to 到右边</span><br><span class="line">                       while (a[great] &gt; pivot2) &#123;</span><br><span class="line">                           if (great-- == k) &#123;</span><br><span class="line">                               break outer;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                       if (a[great] &lt; pivot1) &#123; // a[great] &lt;= pivot2</span><br><span class="line">                           a[k] = a[less];</span><br><span class="line">                           a[less] = a[great];</span><br><span class="line">                           ++less;</span><br><span class="line">                       &#125; else &#123; // pivot1 &lt;= a[great] &lt;= pivot2</span><br><span class="line">                           a[k] = a[great];</span><br><span class="line">                       &#125;</span><br><span class="line">                   /*</span><br><span class="line">                    * 由于性能问题，这里和我们使用下面的 &quot;a[i] = b; i--;&quot;  而不是&quot;a[i--] = b;&quot;</span><br><span class="line">                    */</span><br><span class="line">                       a[great] = ak;</span><br><span class="line">                       --great;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               // 将pivots调到最终位置</span><br><span class="line">               a[left] = a[less - 1];</span><br><span class="line">               a[less - 1] = pivot1;</span><br><span class="line">               a[right] = a[great + 1];</span><br><span class="line">               a[great + 1] = pivot2;</span><br><span class="line"></span><br><span class="line">               // 以递归方式对左右部分排序，不包括已知的数据透视</span><br><span class="line">               sort(a, left, less - 2, leftmost);</span><br><span class="line">               sort(a, great + 2, right, false);</span><br><span class="line"></span><br><span class="line">           /*</span><br><span class="line">            * 如果中心部分太大（包括数组的4/7以上），请将内部轴值交换到末端。</span><br><span class="line">            */</span><br><span class="line">               if (less &lt; e1 &amp;&amp; e5 &lt; great) &#123;</span><br><span class="line">               /*</span><br><span class="line">                * 跳过与透视值相等的元素。</span><br><span class="line">                */</span><br><span class="line">                   while (a[less] == pivot1) &#123;</span><br><span class="line">                       ++less;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   while (a[great] == pivot2) &#123;</span><br><span class="line">                       --great;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">               /*</span><br><span class="line">                * 划分:</span><br><span class="line">                *</span><br><span class="line">                *   左边部分           中间部分                   右边部分</span><br><span class="line">                * +----------------------------------------------------------+</span><br><span class="line">                * | == pivot1 |  pivot1 &lt; &amp;&amp; &lt; pivot2  |    ?    | == pivot2 |</span><br><span class="line">                * +----------------------------------------------------------+</span><br><span class="line">                *              ^                        ^       ^</span><br><span class="line">                *              |                        |       |</span><br><span class="line">                *             less                      k     great</span><br><span class="line">                *</span><br><span class="line">                * 不变式:</span><br><span class="line">                *</span><br><span class="line">                *              all in (*,  less) == pivot1</span><br><span class="line">                *     pivot1 &lt; all in [less,  k)  &lt; pivot2</span><br><span class="line">                *              all in (great, *) == pivot2</span><br><span class="line">                *</span><br><span class="line">                * Pointer k is the first index of ?-part.</span><br><span class="line">                */</span><br><span class="line">                   outer:</span><br><span class="line">                   for (int k = less - 1; ++k &lt;= great; ) &#123;</span><br><span class="line">                       int ak = a[k];</span><br><span class="line">                       if (ak == pivot1) &#123; // 移动 a[k] 到左边</span><br><span class="line">                           a[k] = a[less];</span><br><span class="line">                           a[less] = ak;</span><br><span class="line">                           ++less;</span><br><span class="line">                       &#125; else if (ak == pivot2) &#123; // 移动 a[k] 到右边</span><br><span class="line">                           while (a[great] == pivot2) &#123;</span><br><span class="line">                               if (great-- == k) &#123;</span><br><span class="line">                                   break outer;</span><br><span class="line">                               &#125;</span><br><span class="line">                           &#125;</span><br><span class="line">                           if (a[great] == pivot1) &#123; // a[great] &lt; pivot2</span><br><span class="line">                               a[k] = a[less];</span><br><span class="line">                           /*</span><br><span class="line">                            * 即使[great]等于Pivot1，如果[great]和Pivot1是不同符号的浮点零，</span><br><span class="line">                            * 则赋值a[less]=Pivot1可能不正确。</span><br><span class="line">                            * 因此，在浮动和双重排序方法中，</span><br><span class="line">                            * 我们必须使用更精确的赋值a[less]=a[great]。</span><br><span class="line">                            */</span><br><span class="line">                               a[less] = pivot1;</span><br><span class="line">                               ++less;</span><br><span class="line">                           &#125; else &#123; // pivot1 &lt; a[great] &lt; pivot2</span><br><span class="line">                               a[k] = a[great];</span><br><span class="line">                           &#125;</span><br><span class="line">                           a[great] = ak;</span><br><span class="line">                           --great;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               // 递归排序中心部分</span><br><span class="line">               sort(a, less, great, false);</span><br><span class="line"></span><br><span class="line">           &#125; else &#123; // Partitioning with one pivot</span><br><span class="line">           /*</span><br><span class="line">            * Use the third of the five sorted elements as pivot.</span><br><span class="line">            * This value is inexpensive approximation of the median.</span><br><span class="line">            */</span><br><span class="line">               int pivot = a[e3];</span><br><span class="line"></span><br><span class="line">           /*</span><br><span class="line">            * Partitioning degenerates to the traditional 3-way</span><br><span class="line">            * (or &quot;Dutch National Flag&quot;) schema:</span><br><span class="line">            *</span><br><span class="line">            *   left part    center part              right part</span><br><span class="line">            * +-------------------------------------------------+</span><br><span class="line">            * |  &lt; pivot  |   == pivot   |     ?    |  &gt; pivot  |</span><br><span class="line">            * +-------------------------------------------------+</span><br><span class="line">            *              ^              ^        ^</span><br><span class="line">            *              |              |        |</span><br><span class="line">            *             less            k      great</span><br><span class="line">            *</span><br><span class="line">            * Invariants:</span><br><span class="line">            *</span><br><span class="line">            *   all in (left, less)   &lt; pivot</span><br><span class="line">            *   all in [less, k)     == pivot</span><br><span class="line">            *   all in (great, right) &gt; pivot</span><br><span class="line">            *</span><br><span class="line">            * Pointer k is the first index of ?-part.</span><br><span class="line">            */</span><br><span class="line">               for (int k = less; k &lt;= great; ++k) &#123;</span><br><span class="line">                   if (a[k] == pivot) &#123;</span><br><span class="line">                       continue;</span><br><span class="line">                   &#125;</span><br><span class="line">                   int ak = a[k];</span><br><span class="line">                   if (ak &lt; pivot) &#123; // Move a[k] to left part</span><br><span class="line">                       a[k] = a[less];</span><br><span class="line">                       a[less] = ak;</span><br><span class="line">                       ++less;</span><br><span class="line">                   &#125; else &#123; // a[k] &gt; pivot - Move a[k] to right part</span><br><span class="line">                       while (a[great] &gt; pivot) &#123;</span><br><span class="line">                           --great;</span><br><span class="line">                       &#125;</span><br><span class="line">                       if (a[great] &lt; pivot) &#123; // a[great] &lt;= pivot</span><br><span class="line">                           a[k] = a[less];</span><br><span class="line">                           a[less] = a[great];</span><br><span class="line">                           ++less;</span><br><span class="line">                       &#125; else &#123; // a[great] == pivot</span><br><span class="line">                       /*</span><br><span class="line">                        * Even though a[great] equals to pivot, the</span><br><span class="line">                        * assignment a[k] = pivot may be incorrect,</span><br><span class="line">                        * if a[great] and pivot are floating-point</span><br><span class="line">                        * zeros of different signs. Therefore in float</span><br><span class="line">                        * and double sorting methods we have to use</span><br><span class="line">                        * more accurate assignment a[k] = a[great].</span><br><span class="line">                        */</span><br><span class="line">                           a[k] = pivot;</span><br><span class="line">                       &#125;</span><br><span class="line">                       a[great] = ak;</span><br><span class="line">                       --great;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">           /*</span><br><span class="line">            * Sort left and right parts recursively.</span><br><span class="line">            * All elements from center part are equal</span><br><span class="line">            * and, therefore, already sorted.</span><br><span class="line">            */</span><br><span class="line">               sort(a, left, less - 1, leftmost);</span><br><span class="line">               sort(a, great + 1, right, false);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       /**</span><br><span class="line">        * Sorts the specified range of the array using the given</span><br><span class="line">        * workspace array slice if possible for merging</span><br><span class="line">        *</span><br><span class="line">        * @param a        the array to be sorted</span><br><span class="line">        * @param left     the index of the first element, inclusive, to be sorted</span><br><span class="line">        * @param right    the index of the last element, inclusive, to be sorted</span><br><span class="line">        * @param work     a workspace array (slice)</span><br><span class="line">        * @param workBase origin of usable space in work array</span><br><span class="line">        * @param workLen  usable size of work array</span><br><span class="line">        */</span><br><span class="line">       static void sort(long[] a, int left, int right,</span><br><span class="line">                        long[] work, int workBase, int workLen) &#123;</span><br><span class="line">           // Use Quicksort on small arrays</span><br><span class="line">           if (right - left &lt; QUICKSORT_THRESHOLD) &#123;</span><br><span class="line">               sort(a, left, right, true);</span><br><span class="line">               return;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       /*</span><br><span class="line">        * Index run[i] is the start of i-th run</span><br><span class="line">        * (ascending or descending sequence).</span><br><span class="line">        */</span><br><span class="line">           int[] run = new int[MAX_RUN_COUNT + 1];</span><br><span class="line">           int count = 0;</span><br><span class="line">           run[0] = left;</span><br><span class="line"></span><br><span class="line">           // Check if the array is nearly sorted</span><br><span class="line">           for (int k = left; k &lt; right; run[count] = k) &#123;</span><br><span class="line">               if (a[k] &lt; a[k + 1]) &#123; // ascending</span><br><span class="line">                   while (++k &lt;= right &amp;&amp; a[k - 1] &lt;= a[k]) ;</span><br><span class="line">               &#125; else if (a[k] &gt; a[k + 1]) &#123; // descending</span><br><span class="line">                   while (++k &lt;= right &amp;&amp; a[k - 1] &gt;= a[k]) ;</span><br><span class="line">                   for (int lo = run[count] - 1, hi = k; ++lo &lt; --hi; ) &#123;</span><br><span class="line">                       long t = a[lo];</span><br><span class="line">                       a[lo] = a[hi];</span><br><span class="line">                       a[hi] = t;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; else &#123; // equal</span><br><span class="line">                   for (int m = MAX_RUN_LENGTH; ++k &lt;= right &amp;&amp; a[k - 1] == a[k]; ) &#123;</span><br><span class="line">                       if (--m == 0) &#123;</span><br><span class="line">                           sort(a, left, right, true);</span><br><span class="line">                           return;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">           /*</span><br><span class="line">            * The array is not highly structured,</span><br><span class="line">            * use Quicksort instead of merge sort.</span><br><span class="line">            */</span><br><span class="line">               if (++count == MAX_RUN_COUNT) &#123;</span><br><span class="line">                   sort(a, left, right, true);</span><br><span class="line">                   return;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // Check special cases</span><br><span class="line">           // Implementation note: variable &quot;right&quot; is increased by 1.</span><br><span class="line">           if (run[count] == right++) &#123; // The last run contains one element</span><br><span class="line">               run[++count] = right;</span><br><span class="line">           &#125; else if (count == 1) &#123; // The array is already sorted</span><br><span class="line">               return;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // Determine alternation base for merge</span><br><span class="line">           byte odd = 0;</span><br><span class="line">           for (int n = 1; (n &lt;&lt;= 1) &lt; count; odd ^= 1) ;</span><br><span class="line"></span><br><span class="line">           // Use or create temporary array b for merging</span><br><span class="line">           long[] b;                 // temp array; alternates with a</span><br><span class="line">           int ao, bo;              // array offsets from &#x27;left&#x27;</span><br><span class="line">           int blen = right - left; // space needed for b</span><br><span class="line">           if (work == null || workLen &lt; blen || workBase + blen &gt; work.length) &#123;</span><br><span class="line">               work = new long[blen];</span><br><span class="line">               workBase = 0;</span><br><span class="line">           &#125;</span><br><span class="line">           if (odd == 0) &#123;</span><br><span class="line">               System.arraycopy(a, left, work, workBase, blen);</span><br><span class="line">               b = a;</span><br><span class="line">               bo = 0;</span><br><span class="line">               a = work;</span><br><span class="line">               ao = workBase - left;</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               b = work;</span><br><span class="line">               ao = 0;</span><br><span class="line">               bo = workBase - left;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // Merging</span><br><span class="line">           for (int last; count &gt; 1; count = last) &#123;</span><br><span class="line">               for (int k = (last = 0) + 2; k &lt;= count; k += 2) &#123;</span><br><span class="line">                   int hi = run[k], mi = run[k - 1];</span><br><span class="line">                   for (int i = run[k - 2], p = i, q = mi; i &lt; hi; ++i) &#123;</span><br><span class="line">                       if (q &gt;= hi || p &lt; mi &amp;&amp; a[p + ao] &lt;= a[q + ao]) &#123;</span><br><span class="line">                           b[i + bo] = a[p++ + ao];</span><br><span class="line">                       &#125; else &#123;</span><br><span class="line">                           b[i + bo] = a[q++ + ao];</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">                   run[++last] = hi;</span><br><span class="line">               &#125;</span><br><span class="line">               if ((count &amp; 1) != 0) &#123;</span><br><span class="line">                   for (int i = right, lo = run[count - 1]; --i &gt;= lo;</span><br><span class="line">                        b[i + bo] = a[i + ao]</span><br><span class="line">                           )</span><br><span class="line">                       ;</span><br><span class="line">                   run[++last] = right;</span><br><span class="line">               &#125;</span><br><span class="line">               long[] t = a;</span><br><span class="line">               a = b;</span><br><span class="line">               b = t;</span><br><span class="line">               int o = ao;</span><br><span class="line">               ao = bo;</span><br><span class="line">               bo = o;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       /**</span><br><span class="line">        * Sorts the specified range of the array by Dual-Pivot Quicksort.</span><br><span class="line">        *</span><br><span class="line">        * @param a        the array to be sorted</span><br><span class="line">        * @param left     the index of the first element, inclusive, to be sorted</span><br><span class="line">        * @param right    the index of the last element, inclusive, to be sorted</span><br><span class="line">        * @param leftmost indicates if this part is the leftmost in the range</span><br><span class="line">        */</span><br><span class="line">       private static void sort(long[] a, int left, int right, boolean leftmost) &#123;</span><br><span class="line">           int length = right - left + 1;</span><br><span class="line"></span><br><span class="line">           // Use insertion sort on tiny arrays</span><br><span class="line">           if (length &lt; INSERTION_SORT_THRESHOLD) &#123;</span><br><span class="line">               if (leftmost) &#123;</span><br><span class="line">               /*</span><br><span class="line">                * Traditional (without sentinel) insertion sort,</span><br><span class="line">                * optimized for server VM, is used in case of</span><br><span class="line">                * the leftmost part.</span><br><span class="line">                */</span><br><span class="line">                   for (int i = left, j = i; i &lt; right; j = ++i) &#123;</span><br><span class="line">                       long ai = a[i + 1];</span><br><span class="line">                       while (ai &lt; a[j]) &#123;</span><br><span class="line">                           a[j + 1] = a[j];</span><br><span class="line">                           if (j-- == left) &#123;</span><br><span class="line">                               break;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                       a[j + 1] = ai;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">               /*</span><br><span class="line">                * Skip the longest ascending sequence.</span><br><span class="line">                */</span><br><span class="line">                   do &#123;</span><br><span class="line">                       if (left &gt;= right) &#123;</span><br><span class="line">                           return;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125; while (a[++left] &gt;= a[left - 1]);</span><br><span class="line"></span><br><span class="line">               /*</span><br><span class="line">                * Every element from adjoining part plays the role</span><br><span class="line">                * of sentinel, therefore this allows us to avoid the</span><br><span class="line">                * left range check on each iteration. Moreover, we use</span><br><span class="line">                * the more optimized algorithm, so called pair insertion</span><br><span class="line">                * sort, which is faster (in the context of Quicksort)</span><br><span class="line">                * than traditional implementation of insertion sort.</span><br><span class="line">                */</span><br><span class="line">                   for (int k = left; ++left &lt;= right; k = ++left) &#123;</span><br><span class="line">                       long a1 = a[k], a2 = a[left];</span><br><span class="line"></span><br><span class="line">                       if (a1 &lt; a2) &#123;</span><br><span class="line">                           a2 = a1;</span><br><span class="line">                           a1 = a[left];</span><br><span class="line">                       &#125;</span><br><span class="line">                       while (a1 &lt; a[--k]) &#123;</span><br><span class="line">                           a[k + 2] = a[k];</span><br><span class="line">                       &#125;</span><br><span class="line">                       a[++k + 1] = a1;</span><br><span class="line"></span><br><span class="line">                       while (a2 &lt; a[--k]) &#123;</span><br><span class="line">                           a[k + 1] = a[k];</span><br><span class="line">                       &#125;</span><br><span class="line">                       a[k + 1] = a2;</span><br><span class="line">                   &#125;</span><br><span class="line">                   long last = a[right];</span><br><span class="line"></span><br><span class="line">                   while (last &lt; a[--right]) &#123;</span><br><span class="line">                       a[right + 1] = a[right];</span><br><span class="line">                   &#125;</span><br><span class="line">                   a[right + 1] = last;</span><br><span class="line">               &#125;</span><br><span class="line">               return;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // Inexpensive approximation of length / 7</span><br><span class="line">           int seventh = (length &gt;&gt; 3) + (length &gt;&gt; 6) + 1;</span><br><span class="line"></span><br><span class="line">       /*</span><br><span class="line">        * Sort five evenly spaced elements around (and including) the</span><br><span class="line">        * center element in the range. These elements will be used for</span><br><span class="line">        * pivot selection as described below. The choice for spacing</span><br><span class="line">        * these elements was empirically determined to work well on</span><br><span class="line">        * a wide variety of inputs.</span><br><span class="line">        */</span><br><span class="line">           int e3 = (left + right) &gt;&gt;&gt; 1; // The midpoint</span><br><span class="line">           int e2 = e3 - seventh;</span><br><span class="line">           int e1 = e2 - seventh;</span><br><span class="line">           int e4 = e3 + seventh;</span><br><span class="line">           int e5 = e4 + seventh;</span><br><span class="line"></span><br><span class="line">           // Sort these elements using insertion sort</span><br><span class="line">           if (a[e2] &lt; a[e1]) &#123;</span><br><span class="line">               long t = a[e2];</span><br><span class="line">               a[e2] = a[e1];</span><br><span class="line">               a[e1] = t;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           if (a[e3] &lt; a[e2]) &#123;</span><br><span class="line">               long t = a[e3];</span><br><span class="line">               a[e3] = a[e2];</span><br><span class="line">               a[e2] = t;</span><br><span class="line">               if (t &lt; a[e1]) &#123;</span><br><span class="line">                   a[e2] = a[e1];</span><br><span class="line">                   a[e1] = t;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           if (a[e4] &lt; a[e3]) &#123;</span><br><span class="line">               long t = a[e4];</span><br><span class="line">               a[e4] = a[e3];</span><br><span class="line">               a[e3] = t;</span><br><span class="line">               if (t &lt; a[e2]) &#123;</span><br><span class="line">                   a[e3] = a[e2];</span><br><span class="line">                   a[e2] = t;</span><br><span class="line">                   if (t &lt; a[e1]) &#123;</span><br><span class="line">                       a[e2] = a[e1];</span><br><span class="line">                       a[e1] = t;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           if (a[e5] &lt; a[e4]) &#123;</span><br><span class="line">               long t = a[e5];</span><br><span class="line">               a[e5] = a[e4];</span><br><span class="line">               a[e4] = t;</span><br><span class="line">               if (t &lt; a[e3]) &#123;</span><br><span class="line">                   a[e4] = a[e3];</span><br><span class="line">                   a[e3] = t;</span><br><span class="line">                   if (t &lt; a[e2]) &#123;</span><br><span class="line">                       a[e3] = a[e2];</span><br><span class="line">                       a[e2] = t;</span><br><span class="line">                       if (t &lt; a[e1]) &#123;</span><br><span class="line">                           a[e2] = a[e1];</span><br><span class="line">                           a[e1] = t;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // Pointers</span><br><span class="line">           int less = left;  // The index of the first element of center part</span><br><span class="line">           int great = right; // The index before the first element of right part</span><br><span class="line"></span><br><span class="line">           if (a[e1] != a[e2] &amp;&amp; a[e2] != a[e3] &amp;&amp; a[e3] != a[e4] &amp;&amp; a[e4] != a[e5]) &#123;</span><br><span class="line">           /*</span><br><span class="line">            * Use the second and fourth of the five sorted elements as pivots.</span><br><span class="line">            * These values are inexpensive approximations of the first and</span><br><span class="line">            * second terciles of the array. Note that pivot1 &lt;= pivot2.</span><br><span class="line">            */</span><br><span class="line">               long pivot1 = a[e2];</span><br><span class="line">               long pivot2 = a[e4];</span><br><span class="line"></span><br><span class="line">           /*</span><br><span class="line">            * The first and the last elements to be sorted are moved to the</span><br><span class="line">            * locations formerly occupied by the pivots. When partitioning</span><br><span class="line">            * is complete, the pivots are swapped back into their final</span><br><span class="line">            * positions, and excluded from subsequent sorting.</span><br><span class="line">            */</span><br><span class="line">               a[e2] = a[left];</span><br><span class="line">               a[e4] = a[right];</span><br><span class="line"></span><br><span class="line">           /*</span><br><span class="line">            * Skip elements, which are less or greater than pivot values.</span><br><span class="line">            */</span><br><span class="line">               while (a[++less] &lt; pivot1) ;</span><br><span class="line">               while (a[--great] &gt; pivot2) ;</span><br><span class="line"></span><br><span class="line">           /*</span><br><span class="line">            * Partitioning:</span><br><span class="line">            *</span><br><span class="line">            *   left part           center part                   right part</span><br><span class="line">            * +--------------------------------------------------------------+</span><br><span class="line">            * |  &lt; pivot1  |  pivot1 &lt;= &amp;&amp; &lt;= pivot2  |    ?    |  &gt; pivot2  |</span><br><span class="line">            * +--------------------------------------------------------------+</span><br><span class="line">            *               ^                          ^       ^</span><br><span class="line">            *               |                          |       |</span><br><span class="line">            *              less                        k     great</span><br><span class="line">            *</span><br><span class="line">            * Invariants:</span><br><span class="line">            *</span><br><span class="line">            *              all in (left, less)   &lt; pivot1</span><br><span class="line">            *    pivot1 &lt;= all in [less, k)     &lt;= pivot2</span><br><span class="line">            *              all in (great, right) &gt; pivot2</span><br><span class="line">            *</span><br><span class="line">            * Pointer k is the first index of ?-part.</span><br><span class="line">            */</span><br><span class="line">               outer:</span><br><span class="line">               for (int k = less - 1; ++k &lt;= great; ) &#123;</span><br><span class="line">                   long ak = a[k];</span><br><span class="line">                   if (ak &lt; pivot1) &#123; // Move a[k] to left part</span><br><span class="line">                       a[k] = a[less];</span><br><span class="line">                   /*</span><br><span class="line">                    * Here and below we use &quot;a[i] = b; i++;&quot; instead</span><br><span class="line">                    * of &quot;a[i++] = b;&quot; due to performance issue.</span><br><span class="line">                    */</span><br><span class="line">                       a[less] = ak;</span><br><span class="line">                       ++less;</span><br><span class="line">                   &#125; else if (ak &gt; pivot2) &#123; // Move a[k] to right part</span><br><span class="line">                       while (a[great] &gt; pivot2) &#123;</span><br><span class="line">                           if (great-- == k) &#123;</span><br><span class="line">                               break outer;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                       if (a[great] &lt; pivot1) &#123; // a[great] &lt;= pivot2</span><br><span class="line">                           a[k] = a[less];</span><br><span class="line">                           a[less] = a[great];</span><br><span class="line">                           ++less;</span><br><span class="line">                       &#125; else &#123; // pivot1 &lt;= a[great] &lt;= pivot2</span><br><span class="line">                           a[k] = a[great];</span><br><span class="line">                       &#125;</span><br><span class="line">                   /*</span><br><span class="line">                    * Here and below we use &quot;a[i] = b; i--;&quot; instead</span><br><span class="line">                    * of &quot;a[i--] = b;&quot; due to performance issue.</span><br><span class="line">                    */</span><br><span class="line">                       a[great] = ak;</span><br><span class="line">                       --great;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               // Swap pivots into their final positions</span><br><span class="line">               a[left] = a[less - 1];</span><br><span class="line">               a[less - 1] = pivot1;</span><br><span class="line">               a[right] = a[great + 1];</span><br><span class="line">               a[great + 1] = pivot2;</span><br><span class="line"></span><br><span class="line">               // Sort left and right parts recursively, excluding known pivots</span><br><span class="line">               sort(a, left, less - 2, leftmost);</span><br><span class="line">               sort(a, great + 2, right, false);</span><br><span class="line"></span><br><span class="line">           /*</span><br><span class="line">            * If center part is too large (comprises &gt; 4/7 of the array),</span><br><span class="line">            * swap internal pivot values to ends.</span><br><span class="line">            */</span><br><span class="line">               if (less &lt; e1 &amp;&amp; e5 &lt; great) &#123;</span><br><span class="line">               /*</span><br><span class="line">                * Skip elements, which are equal to pivot values.</span><br><span class="line">                */</span><br><span class="line">                   while (a[less] == pivot1) &#123;</span><br><span class="line">                       ++less;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   while (a[great] == pivot2) &#123;</span><br><span class="line">                       --great;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">               /*</span><br><span class="line">                * Partitioning:</span><br><span class="line">                *</span><br><span class="line">                *   left part         center part                  right part</span><br><span class="line">                * +----------------------------------------------------------+</span><br><span class="line">                * | == pivot1 |  pivot1 &lt; &amp;&amp; &lt; pivot2  |    ?    | == pivot2 |</span><br><span class="line">                * +----------------------------------------------------------+</span><br><span class="line">                *              ^                        ^       ^</span><br><span class="line">                *              |                        |       |</span><br><span class="line">                *             less                      k     great</span><br><span class="line">                *</span><br><span class="line">                * Invariants:</span><br><span class="line">                *</span><br><span class="line">                *              all in (*,  less) == pivot1</span><br><span class="line">                *     pivot1 &lt; all in [less,  k)  &lt; pivot2</span><br><span class="line">                *              all in (great, *) == pivot2</span><br><span class="line">                *</span><br><span class="line">                * Pointer k is the first index of ?-part.</span><br><span class="line">                */</span><br><span class="line">                   outer:</span><br><span class="line">                   for (int k = less - 1; ++k &lt;= great; ) &#123;</span><br><span class="line">                       long ak = a[k];</span><br><span class="line">                       if (ak == pivot1) &#123; // Move a[k] to left part</span><br><span class="line">                           a[k] = a[less];</span><br><span class="line">                           a[less] = ak;</span><br><span class="line">                           ++less;</span><br><span class="line">                       &#125; else if (ak == pivot2) &#123; // Move a[k] to right part</span><br><span class="line">                           while (a[great] == pivot2) &#123;</span><br><span class="line">                               if (great-- == k) &#123;</span><br><span class="line">                                   break outer;</span><br><span class="line">                               &#125;</span><br><span class="line">                           &#125;</span><br><span class="line">                           if (a[great] == pivot1) &#123; // a[great] &lt; pivot2</span><br><span class="line">                               a[k] = a[less];</span><br><span class="line">                           /*</span><br><span class="line">                            * Even though a[great] equals to pivot1, the</span><br><span class="line">                            * assignment a[less] = pivot1 may be incorrect,</span><br><span class="line">                            * if a[great] and pivot1 are floating-point zeros</span><br><span class="line">                            * of different signs. Therefore in float and</span><br><span class="line">                            * double sorting methods we have to use more</span><br><span class="line">                            * accurate assignment a[less] = a[great].</span><br><span class="line">                            */</span><br><span class="line">                               a[less] = pivot1;</span><br><span class="line">                               ++less;</span><br><span class="line">                           &#125; else &#123; // pivot1 &lt; a[great] &lt; pivot2</span><br><span class="line">                               a[k] = a[great];</span><br><span class="line">                           &#125;</span><br><span class="line">                           a[great] = ak;</span><br><span class="line">                           --great;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               // Sort center part recursively</span><br><span class="line">               sort(a, less, great, false);</span><br><span class="line"></span><br><span class="line">           &#125; else &#123; // Partitioning with one pivot</span><br><span class="line">           /*</span><br><span class="line">            * Use the third of the five sorted elements as pivot.</span><br><span class="line">            * This value is inexpensive approximation of the median.</span><br><span class="line">            */</span><br><span class="line">               long pivot = a[e3];</span><br><span class="line"></span><br><span class="line">           /*</span><br><span class="line">            * Partitioning degenerates to the traditional 3-way</span><br><span class="line">            * (or &quot;Dutch National Flag&quot;) schema:</span><br><span class="line">            *</span><br><span class="line">            *   left part    center part              right part</span><br><span class="line">            * +-------------------------------------------------+</span><br><span class="line">            * |  &lt; pivot  |   == pivot   |     ?    |  &gt; pivot  |</span><br><span class="line">            * +-------------------------------------------------+</span><br><span class="line">            *              ^              ^        ^</span><br><span class="line">            *              |              |        |</span><br><span class="line">            *             less            k      great</span><br><span class="line">            *</span><br><span class="line">            * Invariants:</span><br><span class="line">            *</span><br><span class="line">            *   all in (left, less)   &lt; pivot</span><br><span class="line">            *   all in [less, k)     == pivot</span><br><span class="line">            *   all in (great, right) &gt; pivot</span><br><span class="line">            *</span><br><span class="line">            * Pointer k is the first index of ?-part.</span><br><span class="line">            */</span><br><span class="line">               for (int k = less; k &lt;= great; ++k) &#123;</span><br><span class="line">                   if (a[k] == pivot) &#123;</span><br><span class="line">                       continue;</span><br><span class="line">                   &#125;</span><br><span class="line">                   long ak = a[k];</span><br><span class="line">                   if (ak &lt; pivot) &#123; // Move a[k] to left part</span><br><span class="line">                       a[k] = a[less];</span><br><span class="line">                       a[less] = ak;</span><br><span class="line">                       ++less;</span><br><span class="line">                   &#125; else &#123; // a[k] &gt; pivot - Move a[k] to right part</span><br><span class="line">                       while (a[great] &gt; pivot) &#123;</span><br><span class="line">                           --great;</span><br><span class="line">                       &#125;</span><br><span class="line">                       if (a[great] &lt; pivot) &#123; // a[great] &lt;= pivot</span><br><span class="line">                           a[k] = a[less];</span><br><span class="line">                           a[less] = a[great];</span><br><span class="line">                           ++less;</span><br><span class="line">                       &#125; else &#123; // a[great] == pivot</span><br><span class="line">                       /*</span><br><span class="line">                        * Even though a[great] equals to pivot, the</span><br><span class="line">                        * assignment a[k] = pivot may be incorrect,</span><br><span class="line">                        * if a[great] and pivot are floating-point</span><br><span class="line">                        * zeros of different signs. Therefore in float</span><br><span class="line">                        * and double sorting methods we have to use</span><br><span class="line">                        * more accurate assignment a[k] = a[great].</span><br><span class="line">                        */</span><br><span class="line">                           a[k] = pivot;</span><br><span class="line">                       &#125;</span><br><span class="line">                       a[great] = ak;</span><br><span class="line">                       --great;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">           /*</span><br><span class="line">            * Sort left and right parts recursively.</span><br><span class="line">            * All elements from center part are equal</span><br><span class="line">            * and, therefore, already sorted.</span><br><span class="line">            */</span><br><span class="line">               sort(a, left, less - 1, leftmost);</span><br><span class="line">               sort(a, great + 1, right, false);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       /**</span><br><span class="line">        * Sorts the specified range of the array using the given</span><br><span class="line">        * workspace array slice if possible for merging</span><br><span class="line">        *</span><br><span class="line">        * @param a        the array to be sorted</span><br><span class="line">        * @param left     the index of the first element, inclusive, to be sorted</span><br><span class="line">        * @param right    the index of the last element, inclusive, to be sorted</span><br><span class="line">        * @param work     a workspace array (slice)</span><br><span class="line">        * @param workBase origin of usable space in work array</span><br><span class="line">        * @param workLen  usable size of work array</span><br><span class="line">        */</span><br><span class="line">       static void sort(short[] a, int left, int right,</span><br><span class="line">                        short[] work, int workBase, int workLen) &#123;</span><br><span class="line">           // Use counting sort on large arrays</span><br><span class="line">           if (right - left &gt; COUNTING_SORT_THRESHOLD_FOR_SHORT_OR_CHAR) &#123;</span><br><span class="line">               int[] count = new int[NUM_SHORT_VALUES];</span><br><span class="line"></span><br><span class="line">               for (int i = left - 1; ++i &lt;= right;</span><br><span class="line">                    count[a[i] - Short.MIN_VALUE]++</span><br><span class="line">                       )</span><br><span class="line">                   ;</span><br><span class="line">               for (int i = NUM_SHORT_VALUES, k = right + 1; k &gt; left; ) &#123;</span><br><span class="line">                   while (count[--i] == 0) ;</span><br><span class="line">                   short value = (short) (i + Short.MIN_VALUE);</span><br><span class="line">                   int s = count[i];</span><br><span class="line"></span><br><span class="line">                   do &#123;</span><br><span class="line">                       a[--k] = value;</span><br><span class="line">                   &#125; while (--s &gt; 0);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; else &#123; // Use Dual-Pivot Quicksort on small arrays</span><br><span class="line">               doSort(a, left, right, work, workBase, workLen);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       /**</span><br><span class="line">        * The number of distinct short values.</span><br><span class="line">        */</span><br><span class="line">       private static final int NUM_SHORT_VALUES = 1 &lt;&lt; 16;</span><br><span class="line"></span><br><span class="line">       /**</span><br><span class="line">        * Sorts the specified range of the array.</span><br><span class="line">        *</span><br><span class="line">        * @param a        the array to be sorted</span><br><span class="line">        * @param left     the index of the first element, inclusive, to be sorted</span><br><span class="line">        * @param right    the index of the last element, inclusive, to be sorted</span><br><span class="line">        * @param work     a workspace array (slice)</span><br><span class="line">        * @param workBase origin of usable space in work array</span><br><span class="line">        * @param workLen  usable size of work array</span><br><span class="line">        */</span><br><span class="line">       private static void doSort(short[] a, int left, int right,</span><br><span class="line">                                  short[] work, int workBase, int workLen) &#123;</span><br><span class="line">           // Use Quicksort on small arrays</span><br><span class="line">           if (right - left &lt; QUICKSORT_THRESHOLD) &#123;</span><br><span class="line">               sort(a, left, right, true);</span><br><span class="line">               return;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       /*</span><br><span class="line">        * Index run[i] is the start of i-th run</span><br><span class="line">        * (ascending or descending sequence).</span><br><span class="line">        */</span><br><span class="line">           int[] run = new int[MAX_RUN_COUNT + 1];</span><br><span class="line">           int count = 0;</span><br><span class="line">           run[0] = left;</span><br><span class="line"></span><br><span class="line">           // Check if the array is nearly sorted</span><br><span class="line">           for (int k = left; k &lt; right; run[count] = k) &#123;</span><br><span class="line">               if (a[k] &lt; a[k + 1]) &#123; // ascending</span><br><span class="line">                   while (++k &lt;= right &amp;&amp; a[k - 1] &lt;= a[k]) ;</span><br><span class="line">               &#125; else if (a[k] &gt; a[k + 1]) &#123; // descending</span><br><span class="line">                   while (++k &lt;= right &amp;&amp; a[k - 1] &gt;= a[k]) ;</span><br><span class="line">                   for (int lo = run[count] - 1, hi = k; ++lo &lt; --hi; ) &#123;</span><br><span class="line">                       short t = a[lo];</span><br><span class="line">                       a[lo] = a[hi];</span><br><span class="line">                       a[hi] = t;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; else &#123; // equal</span><br><span class="line">                   for (int m = MAX_RUN_LENGTH; ++k &lt;= right &amp;&amp; a[k - 1] == a[k]; ) &#123;</span><br><span class="line">                       if (--m == 0) &#123;</span><br><span class="line">                           sort(a, left, right, true);</span><br><span class="line">                           return;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">           /*</span><br><span class="line">            * The array is not highly structured,</span><br><span class="line">            * use Quicksort instead of merge sort.</span><br><span class="line">            */</span><br><span class="line">               if (++count == MAX_RUN_COUNT) &#123;</span><br><span class="line">                   sort(a, left, right, true);</span><br><span class="line">                   return;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // Check special cases</span><br><span class="line">           // Implementation note: variable &quot;right&quot; is increased by 1.</span><br><span class="line">           if (run[count] == right++) &#123; // The last run contains one element</span><br><span class="line">               run[++count] = right;</span><br><span class="line">           &#125; else if (count == 1) &#123; // The array is already sorted</span><br><span class="line">               return;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // Determine alternation base for merge</span><br><span class="line">           byte odd = 0;</span><br><span class="line">           for (int n = 1; (n &lt;&lt;= 1) &lt; count; odd ^= 1) ;</span><br><span class="line"></span><br><span class="line">           // Use or create temporary array b for merging</span><br><span class="line">           short[] b;                 // temp array; alternates with a</span><br><span class="line">           int ao, bo;              // array offsets from &#x27;left&#x27;</span><br><span class="line">           int blen = right - left; // space needed for b</span><br><span class="line">           if (work == null || workLen &lt; blen || workBase + blen &gt; work.length) &#123;</span><br><span class="line">               work = new short[blen];</span><br><span class="line">               workBase = 0;</span><br><span class="line">           &#125;</span><br><span class="line">           if (odd == 0) &#123;</span><br><span class="line">               System.arraycopy(a, left, work, workBase, blen);</span><br><span class="line">               b = a;</span><br><span class="line">               bo = 0;</span><br><span class="line">               a = work;</span><br><span class="line">               ao = workBase - left;</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               b = work;</span><br><span class="line">               ao = 0;</span><br><span class="line">               bo = workBase - left;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // Merging</span><br><span class="line">           for (int last; count &gt; 1; count = last) &#123;</span><br><span class="line">               for (int k = (last = 0) + 2; k &lt;= count; k += 2) &#123;</span><br><span class="line">                   int hi = run[k], mi = run[k - 1];</span><br><span class="line">                   for (int i = run[k - 2], p = i, q = mi; i &lt; hi; ++i) &#123;</span><br><span class="line">                       if (q &gt;= hi || p &lt; mi &amp;&amp; a[p + ao] &lt;= a[q + ao]) &#123;</span><br><span class="line">                           b[i + bo] = a[p++ + ao];</span><br><span class="line">                       &#125; else &#123;</span><br><span class="line">                           b[i + bo] = a[q++ + ao];</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">                   run[++last] = hi;</span><br><span class="line">               &#125;</span><br><span class="line">               if ((count &amp; 1) != 0) &#123;</span><br><span class="line">                   for (int i = right, lo = run[count - 1]; --i &gt;= lo;</span><br><span class="line">                        b[i + bo] = a[i + ao]</span><br><span class="line">                           )</span><br><span class="line">                       ;</span><br><span class="line">                   run[++last] = right;</span><br><span class="line">               &#125;</span><br><span class="line">               short[] t = a;</span><br><span class="line">               a = b;</span><br><span class="line">               b = t;</span><br><span class="line">               int o = ao;</span><br><span class="line">               ao = bo;</span><br><span class="line">               bo = o;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       /**</span><br><span class="line">        * Sorts the specified range of the array by Dual-Pivot Quicksort.</span><br><span class="line">        *</span><br><span class="line">        * @param a        the array to be sorted</span><br><span class="line">        * @param left     the index of the first element, inclusive, to be sorted</span><br><span class="line">        * @param right    the index of the last element, inclusive, to be sorted</span><br><span class="line">        * @param leftmost indicates if this part is the leftmost in the range</span><br><span class="line">        */</span><br><span class="line">       private static void sort(short[] a, int left, int right, boolean leftmost) &#123;</span><br><span class="line">           int length = right - left + 1;</span><br><span class="line"></span><br><span class="line">           // Use insertion sort on tiny arrays</span><br><span class="line">           if (length &lt; INSERTION_SORT_THRESHOLD) &#123;</span><br><span class="line">               if (leftmost) &#123;</span><br><span class="line">               /*</span><br><span class="line">                * Traditional (without sentinel) insertion sort,</span><br><span class="line">                * optimized for server VM, is used in case of</span><br><span class="line">                * the leftmost part.</span><br><span class="line">                */</span><br><span class="line">                   for (int i = left, j = i; i &lt; right; j = ++i) &#123;</span><br><span class="line">                       short ai = a[i + 1];</span><br><span class="line">                       while (ai &lt; a[j]) &#123;</span><br><span class="line">                           a[j + 1] = a[j];</span><br><span class="line">                           if (j-- == left) &#123;</span><br><span class="line">                               break;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                       a[j + 1] = ai;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">               /*</span><br><span class="line">                * Skip the longest ascending sequence.</span><br><span class="line">                */</span><br><span class="line">                   do &#123;</span><br><span class="line">                       if (left &gt;= right) &#123;</span><br><span class="line">                           return;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125; while (a[++left] &gt;= a[left - 1]);</span><br><span class="line"></span><br><span class="line">               /*</span><br><span class="line">                * Every element from adjoining part plays the role</span><br><span class="line">                * of sentinel, therefore this allows us to avoid the</span><br><span class="line">                * left range check on each iteration. Moreover, we use</span><br><span class="line">                * the more optimized algorithm, so called pair insertion</span><br><span class="line">                * sort, which is faster (in the context of Quicksort)</span><br><span class="line">                * than traditional implementation of insertion sort.</span><br><span class="line">                */</span><br><span class="line">                   for (int k = left; ++left &lt;= right; k = ++left) &#123;</span><br><span class="line">                       short a1 = a[k], a2 = a[left];</span><br><span class="line"></span><br><span class="line">                       if (a1 &lt; a2) &#123;</span><br><span class="line">                           a2 = a1;</span><br><span class="line">                           a1 = a[left];</span><br><span class="line">                       &#125;</span><br><span class="line">                       while (a1 &lt; a[--k]) &#123;</span><br><span class="line">                           a[k + 2] = a[k];</span><br><span class="line">                       &#125;</span><br><span class="line">                       a[++k + 1] = a1;</span><br><span class="line"></span><br><span class="line">                       while (a2 &lt; a[--k]) &#123;</span><br><span class="line">                           a[k + 1] = a[k];</span><br><span class="line">                       &#125;</span><br><span class="line">                       a[k + 1] = a2;</span><br><span class="line">                   &#125;</span><br><span class="line">                   short last = a[right];</span><br><span class="line"></span><br><span class="line">                   while (last &lt; a[--right]) &#123;</span><br><span class="line">                       a[right + 1] = a[right];</span><br><span class="line">                   &#125;</span><br><span class="line">                   a[right + 1] = last;</span><br><span class="line">               &#125;</span><br><span class="line">               return;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // Inexpensive approximation of length / 7</span><br><span class="line">           int seventh = (length &gt;&gt; 3) + (length &gt;&gt; 6) + 1;</span><br><span class="line"></span><br><span class="line">       /*</span><br><span class="line">        * Sort five evenly spaced elements around (and including) the</span><br><span class="line">        * center element in the range. These elements will be used for</span><br><span class="line">        * pivot selection as described below. The choice for spacing</span><br><span class="line">        * these elements was empirically determined to work well on</span><br><span class="line">        * a wide variety of inputs.</span><br><span class="line">        */</span><br><span class="line">           int e3 = (left + right) &gt;&gt;&gt; 1; // The midpoint</span><br><span class="line">           int e2 = e3 - seventh;</span><br><span class="line">           int e1 = e2 - seventh;</span><br><span class="line">           int e4 = e3 + seventh;</span><br><span class="line">           int e5 = e4 + seventh;</span><br><span class="line"></span><br><span class="line">           // Sort these elements using insertion sort</span><br><span class="line">           if (a[e2] &lt; a[e1]) &#123;</span><br><span class="line">               short t = a[e2];</span><br><span class="line">               a[e2] = a[e1];</span><br><span class="line">               a[e1] = t;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           if (a[e3] &lt; a[e2]) &#123;</span><br><span class="line">               short t = a[e3];</span><br><span class="line">               a[e3] = a[e2];</span><br><span class="line">               a[e2] = t;</span><br><span class="line">               if (t &lt; a[e1]) &#123;</span><br><span class="line">                   a[e2] = a[e1];</span><br><span class="line">                   a[e1] = t;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           if (a[e4] &lt; a[e3]) &#123;</span><br><span class="line">               short t = a[e4];</span><br><span class="line">               a[e4] = a[e3];</span><br><span class="line">               a[e3] = t;</span><br><span class="line">               if (t &lt; a[e2]) &#123;</span><br><span class="line">                   a[e3] = a[e2];</span><br><span class="line">                   a[e2] = t;</span><br><span class="line">                   if (t &lt; a[e1]) &#123;</span><br><span class="line">                       a[e2] = a[e1];</span><br><span class="line">                       a[e1] = t;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           if (a[e5] &lt; a[e4]) &#123;</span><br><span class="line">               short t = a[e5];</span><br><span class="line">               a[e5] = a[e4];</span><br><span class="line">               a[e4] = t;</span><br><span class="line">               if (t &lt; a[e3]) &#123;</span><br><span class="line">                   a[e4] = a[e3];</span><br><span class="line">                   a[e3] = t;</span><br><span class="line">                   if (t &lt; a[e2]) &#123;</span><br><span class="line">                       a[e3] = a[e2];</span><br><span class="line">                       a[e2] = t;</span><br><span class="line">                       if (t &lt; a[e1]) &#123;</span><br><span class="line">                           a[e2] = a[e1];</span><br><span class="line">                           a[e1] = t;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // Pointers</span><br><span class="line">           int less = left;  // The index of the first element of center part</span><br><span class="line">           int great = right; // The index before the first element of right part</span><br><span class="line"></span><br><span class="line">           if (a[e1] != a[e2] &amp;&amp; a[e2] != a[e3] &amp;&amp; a[e3] != a[e4] &amp;&amp; a[e4] != a[e5]) &#123;</span><br><span class="line">           /*</span><br><span class="line">            * Use the second and fourth of the five sorted elements as pivots.</span><br><span class="line">            * These values are inexpensive approximations of the first and</span><br><span class="line">            * second terciles of the array. Note that pivot1 &lt;= pivot2.</span><br><span class="line">            */</span><br><span class="line">               short pivot1 = a[e2];</span><br><span class="line">               short pivot2 = a[e4];</span><br><span class="line"></span><br><span class="line">           /*</span><br><span class="line">            * The first and the last elements to be sorted are moved to the</span><br><span class="line">            * locations formerly occupied by the pivots. When partitioning</span><br><span class="line">            * is complete, the pivots are swapped back into their final</span><br><span class="line">            * positions, and excluded from subsequent sorting.</span><br><span class="line">            */</span><br><span class="line">               a[e2] = a[left];</span><br><span class="line">               a[e4] = a[right];</span><br><span class="line"></span><br><span class="line">           /*</span><br><span class="line">            * Skip elements, which are less or greater than pivot values.</span><br><span class="line">            */</span><br><span class="line">               while (a[++less] &lt; pivot1) ;</span><br><span class="line">               while (a[--great] &gt; pivot2) ;</span><br><span class="line"></span><br><span class="line">           /*</span><br><span class="line">            * Partitioning:</span><br><span class="line">            *</span><br><span class="line">            *   left part           center part                   right part</span><br><span class="line">            * +--------------------------------------------------------------+</span><br><span class="line">            * |  &lt; pivot1  |  pivot1 &lt;= &amp;&amp; &lt;= pivot2  |    ?    |  &gt; pivot2  |</span><br><span class="line">            * +--------------------------------------------------------------+</span><br><span class="line">            *               ^                          ^       ^</span><br><span class="line">            *               |                          |       |</span><br><span class="line">            *              less                        k     great</span><br><span class="line">            *</span><br><span class="line">            * Invariants:</span><br><span class="line">            *</span><br><span class="line">            *              all in (left, less)   &lt; pivot1</span><br><span class="line">            *    pivot1 &lt;= all in [less, k)     &lt;= pivot2</span><br><span class="line">            *              all in (great, right) &gt; pivot2</span><br><span class="line">            *</span><br><span class="line">            * Pointer k is the first index of ?-part.</span><br><span class="line">            */</span><br><span class="line">               outer:</span><br><span class="line">               for (int k = less - 1; ++k &lt;= great; ) &#123;</span><br><span class="line">                   short ak = a[k];</span><br><span class="line">                   if (ak &lt; pivot1) &#123; // Move a[k] to left part</span><br><span class="line">                       a[k] = a[less];</span><br><span class="line">                   /*</span><br><span class="line">                    * Here and below we use &quot;a[i] = b; i++;&quot; instead</span><br><span class="line">                    * of &quot;a[i++] = b;&quot; due to performance issue.</span><br><span class="line">                    */</span><br><span class="line">                       a[less] = ak;</span><br><span class="line">                       ++less;</span><br><span class="line">                   &#125; else if (ak &gt; pivot2) &#123; // Move a[k] to right part</span><br><span class="line">                       while (a[great] &gt; pivot2) &#123;</span><br><span class="line">                           if (great-- == k) &#123;</span><br><span class="line">                               break outer;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                       if (a[great] &lt; pivot1) &#123; // a[great] &lt;= pivot2</span><br><span class="line">                           a[k] = a[less];</span><br><span class="line">                           a[less] = a[great];</span><br><span class="line">                           ++less;</span><br><span class="line">                       &#125; else &#123; // pivot1 &lt;= a[great] &lt;= pivot2</span><br><span class="line">                           a[k] = a[great];</span><br><span class="line">                       &#125;</span><br><span class="line">                   /*</span><br><span class="line">                    * Here and below we use &quot;a[i] = b; i--;&quot; instead</span><br><span class="line">                    * of &quot;a[i--] = b;&quot; due to performance issue.</span><br><span class="line">                    */</span><br><span class="line">                       a[great] = ak;</span><br><span class="line">                       --great;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               // Swap pivots into their final positions</span><br><span class="line">               a[left] = a[less - 1];</span><br><span class="line">               a[less - 1] = pivot1;</span><br><span class="line">               a[right] = a[great + 1];</span><br><span class="line">               a[great + 1] = pivot2;</span><br><span class="line"></span><br><span class="line">               // Sort left and right parts recursively, excluding known pivots</span><br><span class="line">               sort(a, left, less - 2, leftmost);</span><br><span class="line">               sort(a, great + 2, right, false);</span><br><span class="line"></span><br><span class="line">           /*</span><br><span class="line">            * If center part is too large (comprises &gt; 4/7 of the array),</span><br><span class="line">            * swap internal pivot values to ends.</span><br><span class="line">            */</span><br><span class="line">               if (less &lt; e1 &amp;&amp; e5 &lt; great) &#123;</span><br><span class="line">               /*</span><br><span class="line">                * Skip elements, which are equal to pivot values.</span><br><span class="line">                */</span><br><span class="line">                   while (a[less] == pivot1) &#123;</span><br><span class="line">                       ++less;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   while (a[great] == pivot2) &#123;</span><br><span class="line">                       --great;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">               /*</span><br><span class="line">                * Partitioning:</span><br><span class="line">                *</span><br><span class="line">                *   left part         center part                  right part</span><br><span class="line">                * +----------------------------------------------------------+</span><br><span class="line">                * | == pivot1 |  pivot1 &lt; &amp;&amp; &lt; pivot2  |    ?    | == pivot2 |</span><br><span class="line">                * +----------------------------------------------------------+</span><br><span class="line">                *              ^                        ^       ^</span><br><span class="line">                *              |                        |       |</span><br><span class="line">                *             less                      k     great</span><br><span class="line">                *</span><br><span class="line">                * Invariants:</span><br><span class="line">                *</span><br><span class="line">                *              all in (*,  less) == pivot1</span><br><span class="line">                *     pivot1 &lt; all in [less,  k)  &lt; pivot2</span><br><span class="line">                *              all in (great, *) == pivot2</span><br><span class="line">                *</span><br><span class="line">                * Pointer k is the first index of ?-part.</span><br><span class="line">                */</span><br><span class="line">                   outer:</span><br><span class="line">                   for (int k = less - 1; ++k &lt;= great; ) &#123;</span><br><span class="line">                       short ak = a[k];</span><br><span class="line">                       if (ak == pivot1) &#123; // Move a[k] to left part</span><br><span class="line">                           a[k] = a[less];</span><br><span class="line">                           a[less] = ak;</span><br><span class="line">                           ++less;</span><br><span class="line">                       &#125; else if (ak == pivot2) &#123; // Move a[k] to right part</span><br><span class="line">                           while (a[great] == pivot2) &#123;</span><br><span class="line">                               if (great-- == k) &#123;</span><br><span class="line">                                   break outer;</span><br><span class="line">                               &#125;</span><br><span class="line">                           &#125;</span><br><span class="line">                           if (a[great] == pivot1) &#123; // a[great] &lt; pivot2</span><br><span class="line">                               a[k] = a[less];</span><br><span class="line">                           /*</span><br><span class="line">                            * Even though a[great] equals to pivot1, the</span><br><span class="line">                            * assignment a[less] = pivot1 may be incorrect,</span><br><span class="line">                            * if a[great] and pivot1 are floating-point zeros</span><br><span class="line">                            * of different signs. Therefore in float and</span><br><span class="line">                            * double sorting methods we have to use more</span><br><span class="line">                            * accurate assignment a[less] = a[great].</span><br><span class="line">                            */</span><br><span class="line">                               a[less] = pivot1;</span><br><span class="line">                               ++less;</span><br><span class="line">                           &#125; else &#123; // pivot1 &lt; a[great] &lt; pivot2</span><br><span class="line">                               a[k] = a[great];</span><br><span class="line">                           &#125;</span><br><span class="line">                           a[great] = ak;</span><br><span class="line">                           --great;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               // Sort center part recursively</span><br><span class="line">               sort(a, less, great, false);</span><br><span class="line"></span><br><span class="line">           &#125; else &#123; // Partitioning with one pivot</span><br><span class="line">           /*</span><br><span class="line">            * Use the third of the five sorted elements as pivot.</span><br><span class="line">            * This value is inexpensive approximation of the median.</span><br><span class="line">            */</span><br><span class="line">               short pivot = a[e3];</span><br><span class="line"></span><br><span class="line">           /*</span><br><span class="line">            * Partitioning degenerates to the traditional 3-way</span><br><span class="line">            * (or &quot;Dutch National Flag&quot;) schema:</span><br><span class="line">            *</span><br><span class="line">            *   left part    center part              right part</span><br><span class="line">            * +-------------------------------------------------+</span><br><span class="line">            * |  &lt; pivot  |   == pivot   |     ?    |  &gt; pivot  |</span><br><span class="line">            * +-------------------------------------------------+</span><br><span class="line">            *              ^              ^        ^</span><br><span class="line">            *              |              |        |</span><br><span class="line">            *             less            k      great</span><br><span class="line">            *</span><br><span class="line">            * Invariants:</span><br><span class="line">            *</span><br><span class="line">            *   all in (left, less)   &lt; pivot</span><br><span class="line">            *   all in [less, k)     == pivot</span><br><span class="line">            *   all in (great, right) &gt; pivot</span><br><span class="line">            *</span><br><span class="line">            * Pointer k is the first index of ?-part.</span><br><span class="line">            */</span><br><span class="line">               for (int k = less; k &lt;= great; ++k) &#123;</span><br><span class="line">                   if (a[k] == pivot) &#123;</span><br><span class="line">                       continue;</span><br><span class="line">                   &#125;</span><br><span class="line">                   short ak = a[k];</span><br><span class="line">                   if (ak &lt; pivot) &#123; // Move a[k] to left part</span><br><span class="line">                       a[k] = a[less];</span><br><span class="line">                       a[less] = ak;</span><br><span class="line">                       ++less;</span><br><span class="line">                   &#125; else &#123; // a[k] &gt; pivot - Move a[k] to right part</span><br><span class="line">                       while (a[great] &gt; pivot) &#123;</span><br><span class="line">                           --great;</span><br><span class="line">                       &#125;</span><br><span class="line">                       if (a[great] &lt; pivot) &#123; // a[great] &lt;= pivot</span><br><span class="line">                           a[k] = a[less];</span><br><span class="line">                           a[less] = a[great];</span><br><span class="line">                           ++less;</span><br><span class="line">                       &#125; else &#123; // a[great] == pivot</span><br><span class="line">                       /*</span><br><span class="line">                        * Even though a[great] equals to pivot, the</span><br><span class="line">                        * assignment a[k] = pivot may be incorrect,</span><br><span class="line">                        * if a[great] and pivot are floating-point</span><br><span class="line">                        * zeros of different signs. Therefore in float</span><br><span class="line">                        * and double sorting methods we have to use</span><br><span class="line">                        * more accurate assignment a[k] = a[great].</span><br><span class="line">                        */</span><br><span class="line">                           a[k] = pivot;</span><br><span class="line">                       &#125;</span><br><span class="line">                       a[great] = ak;</span><br><span class="line">                       --great;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">           /*</span><br><span class="line">            * Sort left and right parts recursively.</span><br><span class="line">            * All elements from center part are equal</span><br><span class="line">            * and, therefore, already sorted.</span><br><span class="line">            */</span><br><span class="line">               sort(a, left, less - 1, leftmost);</span><br><span class="line">               sort(a, great + 1, right, false);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       /**</span><br><span class="line">        * Sorts the specified range of the array using the given</span><br><span class="line">        * workspace array slice if possible for merging</span><br><span class="line">        *</span><br><span class="line">        * @param a        the array to be sorted</span><br><span class="line">        * @param left     the index of the first element, inclusive, to be sorted</span><br><span class="line">        * @param right    the index of the last element, inclusive, to be sorted</span><br><span class="line">        * @param work     a workspace array (slice)</span><br><span class="line">        * @param workBase origin of usable space in work array</span><br><span class="line">        * @param workLen  usable size of work array</span><br><span class="line">        */</span><br><span class="line">       static void sort(char[] a, int left, int right,</span><br><span class="line">                        char[] work, int workBase, int workLen) &#123;</span><br><span class="line">           // Use counting sort on large arrays</span><br><span class="line">           if (right - left &gt; COUNTING_SORT_THRESHOLD_FOR_SHORT_OR_CHAR) &#123;</span><br><span class="line">               int[] count = new int[NUM_CHAR_VALUES];</span><br><span class="line"></span><br><span class="line">               for (int i = left - 1; ++i &lt;= right;</span><br><span class="line">                    count[a[i]]++</span><br><span class="line">                       )</span><br><span class="line">                   ;</span><br><span class="line">               for (int i = NUM_CHAR_VALUES, k = right + 1; k &gt; left; ) &#123;</span><br><span class="line">                   while (count[--i] == 0) ;</span><br><span class="line">                   char value = (char) i;</span><br><span class="line">                   int s = count[i];</span><br><span class="line"></span><br><span class="line">                   do &#123;</span><br><span class="line">                       a[--k] = value;</span><br><span class="line">                   &#125; while (--s &gt; 0);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; else &#123; // Use Dual-Pivot Quicksort on small arrays</span><br><span class="line">               doSort(a, left, right, work, workBase, workLen);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       /**</span><br><span class="line">        * The number of distinct char values.</span><br><span class="line">        */</span><br><span class="line">       private static final int NUM_CHAR_VALUES = 1 &lt;&lt; 16;</span><br><span class="line"></span><br><span class="line">       /**</span><br><span class="line">        * Sorts the specified range of the array.</span><br><span class="line">        *</span><br><span class="line">        * @param a        the array to be sorted</span><br><span class="line">        * @param left     the index of the first element, inclusive, to be sorted</span><br><span class="line">        * @param right    the index of the last element, inclusive, to be sorted</span><br><span class="line">        * @param work     a workspace array (slice)</span><br><span class="line">        * @param workBase origin of usable space in work array</span><br><span class="line">        * @param workLen  usable size of work array</span><br><span class="line">        */</span><br><span class="line">       private static void doSort(char[] a, int left, int right,</span><br><span class="line">                                  char[] work, int workBase, int workLen) &#123;</span><br><span class="line">           // Use Quicksort on small arrays</span><br><span class="line">           if (right - left &lt; QUICKSORT_THRESHOLD) &#123;</span><br><span class="line">               sort(a, left, right, true);</span><br><span class="line">               return;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       /*</span><br><span class="line">        * Index run[i] is the start of i-th run</span><br><span class="line">        * (ascending or descending sequence).</span><br><span class="line">        */</span><br><span class="line">           int[] run = new int[MAX_RUN_COUNT + 1];</span><br><span class="line">           int count = 0;</span><br><span class="line">           run[0] = left;</span><br><span class="line"></span><br><span class="line">           // Check if the array is nearly sorted</span><br><span class="line">           for (int k = left; k &lt; right; run[count] = k) &#123;</span><br><span class="line">               if (a[k] &lt; a[k + 1]) &#123; // ascending</span><br><span class="line">                   while (++k &lt;= right &amp;&amp; a[k - 1] &lt;= a[k]) ;</span><br><span class="line">               &#125; else if (a[k] &gt; a[k + 1]) &#123; // descending</span><br><span class="line">                   while (++k &lt;= right &amp;&amp; a[k - 1] &gt;= a[k]) ;</span><br><span class="line">                   for (int lo = run[count] - 1, hi = k; ++lo &lt; --hi; ) &#123;</span><br><span class="line">                       char t = a[lo];</span><br><span class="line">                       a[lo] = a[hi];</span><br><span class="line">                       a[hi] = t;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; else &#123; // equal</span><br><span class="line">                   for (int m = MAX_RUN_LENGTH; ++k &lt;= right &amp;&amp; a[k - 1] == a[k]; ) &#123;</span><br><span class="line">                       if (--m == 0) &#123;</span><br><span class="line">                           sort(a, left, right, true);</span><br><span class="line">                           return;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">           /*</span><br><span class="line">            * The array is not highly structured,</span><br><span class="line">            * use Quicksort instead of merge sort.</span><br><span class="line">            */</span><br><span class="line">               if (++count == MAX_RUN_COUNT) &#123;</span><br><span class="line">                   sort(a, left, right, true);</span><br><span class="line">                   return;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // Check special cases</span><br><span class="line">           // Implementation note: variable &quot;right&quot; is increased by 1.</span><br><span class="line">           if (run[count] == right++) &#123; // The last run contains one element</span><br><span class="line">               run[++count] = right;</span><br><span class="line">           &#125; else if (count == 1) &#123; // The array is already sorted</span><br><span class="line">               return;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // Determine alternation base for merge</span><br><span class="line">           byte odd = 0;</span><br><span class="line">           for (int n = 1; (n &lt;&lt;= 1) &lt; count; odd ^= 1) ;</span><br><span class="line"></span><br><span class="line">           // Use or create temporary array b for merging</span><br><span class="line">           char[] b;                 // temp array; alternates with a</span><br><span class="line">           int ao, bo;              // array offsets from &#x27;left&#x27;</span><br><span class="line">           int blen = right - left; // space needed for b</span><br><span class="line">           if (work == null || workLen &lt; blen || workBase + blen &gt; work.length) &#123;</span><br><span class="line">               work = new char[blen];</span><br><span class="line">               workBase = 0;</span><br><span class="line">           &#125;</span><br><span class="line">           if (odd == 0) &#123;</span><br><span class="line">               System.arraycopy(a, left, work, workBase, blen);</span><br><span class="line">               b = a;</span><br><span class="line">               bo = 0;</span><br><span class="line">               a = work;</span><br><span class="line">               ao = workBase - left;</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               b = work;</span><br><span class="line">               ao = 0;</span><br><span class="line">               bo = workBase - left;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // Merging</span><br><span class="line">           for (int last; count &gt; 1; count = last) &#123;</span><br><span class="line">               for (int k = (last = 0) + 2; k &lt;= count; k += 2) &#123;</span><br><span class="line">                   int hi = run[k], mi = run[k - 1];</span><br><span class="line">                   for (int i = run[k - 2], p = i, q = mi; i &lt; hi; ++i) &#123;</span><br><span class="line">                       if (q &gt;= hi || p &lt; mi &amp;&amp; a[p + ao] &lt;= a[q + ao]) &#123;</span><br><span class="line">                           b[i + bo] = a[p++ + ao];</span><br><span class="line">                       &#125; else &#123;</span><br><span class="line">                           b[i + bo] = a[q++ + ao];</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">                   run[++last] = hi;</span><br><span class="line">               &#125;</span><br><span class="line">               if ((count &amp; 1) != 0) &#123;</span><br><span class="line">                   for (int i = right, lo = run[count - 1]; --i &gt;= lo;</span><br><span class="line">                        b[i + bo] = a[i + ao]</span><br><span class="line">                           )</span><br><span class="line">                       ;</span><br><span class="line">                   run[++last] = right;</span><br><span class="line">               &#125;</span><br><span class="line">               char[] t = a;</span><br><span class="line">               a = b;</span><br><span class="line">               b = t;</span><br><span class="line">               int o = ao;</span><br><span class="line">               ao = bo;</span><br><span class="line">               bo = o;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       /**</span><br><span class="line">        * Sorts the specified range of the array by Dual-Pivot Quicksort.</span><br><span class="line">        *</span><br><span class="line">        * @param a        the array to be sorted</span><br><span class="line">        * @param left     the index of the first element, inclusive, to be sorted</span><br><span class="line">        * @param right    the index of the last element, inclusive, to be sorted</span><br><span class="line">        * @param leftmost indicates if this part is the leftmost in the range</span><br><span class="line">        */</span><br><span class="line">       private static void sort(char[] a, int left, int right, boolean leftmost) &#123;</span><br><span class="line">           int length = right - left + 1;</span><br><span class="line"></span><br><span class="line">           // Use insertion sort on tiny arrays</span><br><span class="line">           if (length &lt; INSERTION_SORT_THRESHOLD) &#123;</span><br><span class="line">               if (leftmost) &#123;</span><br><span class="line">               /*</span><br><span class="line">                * Traditional (without sentinel) insertion sort,</span><br><span class="line">                * optimized for server VM, is used in case of</span><br><span class="line">                * the leftmost part.</span><br><span class="line">                */</span><br><span class="line">                   for (int i = left, j = i; i &lt; right; j = ++i) &#123;</span><br><span class="line">                       char ai = a[i + 1];</span><br><span class="line">                       while (ai &lt; a[j]) &#123;</span><br><span class="line">                           a[j + 1] = a[j];</span><br><span class="line">                           if (j-- == left) &#123;</span><br><span class="line">                               break;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                       a[j + 1] = ai;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">               /*</span><br><span class="line">                * Skip the longest ascending sequence.</span><br><span class="line">                */</span><br><span class="line">                   do &#123;</span><br><span class="line">                       if (left &gt;= right) &#123;</span><br><span class="line">                           return;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125; while (a[++left] &gt;= a[left - 1]);</span><br><span class="line"></span><br><span class="line">               /*</span><br><span class="line">                * Every element from adjoining part plays the role</span><br><span class="line">                * of sentinel, therefore this allows us to avoid the</span><br><span class="line">                * left range check on each iteration. Moreover, we use</span><br><span class="line">                * the more optimized algorithm, so called pair insertion</span><br><span class="line">                * sort, which is faster (in the context of Quicksort)</span><br><span class="line">                * than traditional implementation of insertion sort.</span><br><span class="line">                */</span><br><span class="line">                   for (int k = left; ++left &lt;= right; k = ++left) &#123;</span><br><span class="line">                       char a1 = a[k], a2 = a[left];</span><br><span class="line"></span><br><span class="line">                       if (a1 &lt; a2) &#123;</span><br><span class="line">                           a2 = a1;</span><br><span class="line">                           a1 = a[left];</span><br><span class="line">                       &#125;</span><br><span class="line">                       while (a1 &lt; a[--k]) &#123;</span><br><span class="line">                           a[k + 2] = a[k];</span><br><span class="line">                       &#125;</span><br><span class="line">                       a[++k + 1] = a1;</span><br><span class="line"></span><br><span class="line">                       while (a2 &lt; a[--k]) &#123;</span><br><span class="line">                           a[k + 1] = a[k];</span><br><span class="line">                       &#125;</span><br><span class="line">                       a[k + 1] = a2;</span><br><span class="line">                   &#125;</span><br><span class="line">                   char last = a[right];</span><br><span class="line"></span><br><span class="line">                   while (last &lt; a[--right]) &#123;</span><br><span class="line">                       a[right + 1] = a[right];</span><br><span class="line">                   &#125;</span><br><span class="line">                   a[right + 1] = last;</span><br><span class="line">               &#125;</span><br><span class="line">               return;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // Inexpensive approximation of length / 7</span><br><span class="line">           int seventh = (length &gt;&gt; 3) + (length &gt;&gt; 6) + 1;</span><br><span class="line"></span><br><span class="line">       /*</span><br><span class="line">        * Sort five evenly spaced elements around (and including) the</span><br><span class="line">        * center element in the range. These elements will be used for</span><br><span class="line">        * pivot selection as described below. The choice for spacing</span><br><span class="line">        * these elements was empirically determined to work well on</span><br><span class="line">        * a wide variety of inputs.</span><br><span class="line">        */</span><br><span class="line">           int e3 = (left + right) &gt;&gt;&gt; 1; // The midpoint</span><br><span class="line">           int e2 = e3 - seventh;</span><br><span class="line">           int e1 = e2 - seventh;</span><br><span class="line">           int e4 = e3 + seventh;</span><br><span class="line">           int e5 = e4 + seventh;</span><br><span class="line"></span><br><span class="line">           // Sort these elements using insertion sort</span><br><span class="line">           if (a[e2] &lt; a[e1]) &#123;</span><br><span class="line">               char t = a[e2];</span><br><span class="line">               a[e2] = a[e1];</span><br><span class="line">               a[e1] = t;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           if (a[e3] &lt; a[e2]) &#123;</span><br><span class="line">               char t = a[e3];</span><br><span class="line">               a[e3] = a[e2];</span><br><span class="line">               a[e2] = t;</span><br><span class="line">               if (t &lt; a[e1]) &#123;</span><br><span class="line">                   a[e2] = a[e1];</span><br><span class="line">                   a[e1] = t;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           if (a[e4] &lt; a[e3]) &#123;</span><br><span class="line">               char t = a[e4];</span><br><span class="line">               a[e4] = a[e3];</span><br><span class="line">               a[e3] = t;</span><br><span class="line">               if (t &lt; a[e2]) &#123;</span><br><span class="line">                   a[e3] = a[e2];</span><br><span class="line">                   a[e2] = t;</span><br><span class="line">                   if (t &lt; a[e1]) &#123;</span><br><span class="line">                       a[e2] = a[e1];</span><br><span class="line">                       a[e1] = t;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           if (a[e5] &lt; a[e4]) &#123;</span><br><span class="line">               char t = a[e5];</span><br><span class="line">               a[e5] = a[e4];</span><br><span class="line">               a[e4] = t;</span><br><span class="line">               if (t &lt; a[e3]) &#123;</span><br><span class="line">                   a[e4] = a[e3];</span><br><span class="line">                   a[e3] = t;</span><br><span class="line">                   if (t &lt; a[e2]) &#123;</span><br><span class="line">                       a[e3] = a[e2];</span><br><span class="line">                       a[e2] = t;</span><br><span class="line">                       if (t &lt; a[e1]) &#123;</span><br><span class="line">                           a[e2] = a[e1];</span><br><span class="line">                           a[e1] = t;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // Pointers</span><br><span class="line">           int less = left;  // The index of the first element of center part</span><br><span class="line">           int great = right; // The index before the first element of right part</span><br><span class="line"></span><br><span class="line">           if (a[e1] != a[e2] &amp;&amp; a[e2] != a[e3] &amp;&amp; a[e3] != a[e4] &amp;&amp; a[e4] != a[e5]) &#123;</span><br><span class="line">           /*</span><br><span class="line">            * Use the second and fourth of the five sorted elements as pivots.</span><br><span class="line">            * These values are inexpensive approximations of the first and</span><br><span class="line">            * second terciles of the array. Note that pivot1 &lt;= pivot2.</span><br><span class="line">            */</span><br><span class="line">               char pivot1 = a[e2];</span><br><span class="line">               char pivot2 = a[e4];</span><br><span class="line"></span><br><span class="line">           /*</span><br><span class="line">            * The first and the last elements to be sorted are moved to the</span><br><span class="line">            * locations formerly occupied by the pivots. When partitioning</span><br><span class="line">            * is complete, the pivots are swapped back into their final</span><br><span class="line">            * positions, and excluded from subsequent sorting.</span><br><span class="line">            */</span><br><span class="line">               a[e2] = a[left];</span><br><span class="line">               a[e4] = a[right];</span><br><span class="line"></span><br><span class="line">           /*</span><br><span class="line">            * Skip elements, which are less or greater than pivot values.</span><br><span class="line">            */</span><br><span class="line">               while (a[++less] &lt; pivot1) ;</span><br><span class="line">               while (a[--great] &gt; pivot2) ;</span><br><span class="line"></span><br><span class="line">           /*</span><br><span class="line">            * Partitioning:</span><br><span class="line">            *</span><br><span class="line">            *   left part           center part                   right part</span><br><span class="line">            * +--------------------------------------------------------------+</span><br><span class="line">            * |  &lt; pivot1  |  pivot1 &lt;= &amp;&amp; &lt;= pivot2  |    ?    |  &gt; pivot2  |</span><br><span class="line">            * +--------------------------------------------------------------+</span><br><span class="line">            *               ^                          ^       ^</span><br><span class="line">            *               |                          |       |</span><br><span class="line">            *              less                        k     great</span><br><span class="line">            *</span><br><span class="line">            * Invariants:</span><br><span class="line">            *</span><br><span class="line">            *              all in (left, less)   &lt; pivot1</span><br><span class="line">            *    pivot1 &lt;= all in [less, k)     &lt;= pivot2</span><br><span class="line">            *              all in (great, right) &gt; pivot2</span><br><span class="line">            *</span><br><span class="line">            * Pointer k is the first index of ?-part.</span><br><span class="line">            */</span><br><span class="line">               outer:</span><br><span class="line">               for (int k = less - 1; ++k &lt;= great; ) &#123;</span><br><span class="line">                   char ak = a[k];</span><br><span class="line">                   if (ak &lt; pivot1) &#123; // Move a[k] to left part</span><br><span class="line">                       a[k] = a[less];</span><br><span class="line">                   /*</span><br><span class="line">                    * Here and below we use &quot;a[i] = b; i++;&quot; instead</span><br><span class="line">                    * of &quot;a[i++] = b;&quot; due to performance issue.</span><br><span class="line">                    */</span><br><span class="line">                       a[less] = ak;</span><br><span class="line">                       ++less;</span><br><span class="line">                   &#125; else if (ak &gt; pivot2) &#123; // Move a[k] to right part</span><br><span class="line">                       while (a[great] &gt; pivot2) &#123;</span><br><span class="line">                           if (great-- == k) &#123;</span><br><span class="line">                               break outer;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                       if (a[great] &lt; pivot1) &#123; // a[great] &lt;= pivot2</span><br><span class="line">                           a[k] = a[less];</span><br><span class="line">                           a[less] = a[great];</span><br><span class="line">                           ++less;</span><br><span class="line">                       &#125; else &#123; // pivot1 &lt;= a[great] &lt;= pivot2</span><br><span class="line">                           a[k] = a[great];</span><br><span class="line">                       &#125;</span><br><span class="line">                   /*</span><br><span class="line">                    * Here and below we use &quot;a[i] = b; i--;&quot; instead</span><br><span class="line">                    * of &quot;a[i--] = b;&quot; due to performance issue.</span><br><span class="line">                    */</span><br><span class="line">                       a[great] = ak;</span><br><span class="line">                       --great;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               // Swap pivots into their final positions</span><br><span class="line">               a[left] = a[less - 1];</span><br><span class="line">               a[less - 1] = pivot1;</span><br><span class="line">               a[right] = a[great + 1];</span><br><span class="line">               a[great + 1] = pivot2;</span><br><span class="line"></span><br><span class="line">               // Sort left and right parts recursively, excluding known pivots</span><br><span class="line">               sort(a, left, less - 2, leftmost);</span><br><span class="line">               sort(a, great + 2, right, false);</span><br><span class="line"></span><br><span class="line">           /*</span><br><span class="line">            * If center part is too large (comprises &gt; 4/7 of the array),</span><br><span class="line">            * swap internal pivot values to ends.</span><br><span class="line">            */</span><br><span class="line">               if (less &lt; e1 &amp;&amp; e5 &lt; great) &#123;</span><br><span class="line">               /*</span><br><span class="line">                * Skip elements, which are equal to pivot values.</span><br><span class="line">                */</span><br><span class="line">                   while (a[less] == pivot1) &#123;</span><br><span class="line">                       ++less;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   while (a[great] == pivot2) &#123;</span><br><span class="line">                       --great;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">               /*</span><br><span class="line">                * Partitioning:</span><br><span class="line">                *</span><br><span class="line">                *   left part         center part                  right part</span><br><span class="line">                * +----------------------------------------------------------+</span><br><span class="line">                * | == pivot1 |  pivot1 &lt; &amp;&amp; &lt; pivot2  |    ?    | == pivot2 |</span><br><span class="line">                * +----------------------------------------------------------+</span><br><span class="line">                *              ^                        ^       ^</span><br><span class="line">                *              |                        |       |</span><br><span class="line">                *             less                      k     great</span><br><span class="line">                *</span><br><span class="line">                * Invariants:</span><br><span class="line">                *</span><br><span class="line">                *              all in (*,  less) == pivot1</span><br><span class="line">                *     pivot1 &lt; all in [less,  k)  &lt; pivot2</span><br><span class="line">                *              all in (great, *) == pivot2</span><br><span class="line">                *</span><br><span class="line">                * Pointer k is the first index of ?-part.</span><br><span class="line">                */</span><br><span class="line">                   outer:</span><br><span class="line">                   for (int k = less - 1; ++k &lt;= great; ) &#123;</span><br><span class="line">                       char ak = a[k];</span><br><span class="line">                       if (ak == pivot1) &#123; // Move a[k] to left part</span><br><span class="line">                           a[k] = a[less];</span><br><span class="line">                           a[less] = ak;</span><br><span class="line">                           ++less;</span><br><span class="line">                       &#125; else if (ak == pivot2) &#123; // Move a[k] to right part</span><br><span class="line">                           while (a[great] == pivot2) &#123;</span><br><span class="line">                               if (great-- == k) &#123;</span><br><span class="line">                                   break outer;</span><br><span class="line">                               &#125;</span><br><span class="line">                           &#125;</span><br><span class="line">                           if (a[great] == pivot1) &#123; // a[great] &lt; pivot2</span><br><span class="line">                               a[k] = a[less];</span><br><span class="line">                           /*</span><br><span class="line">                            * Even though a[great] equals to pivot1, the</span><br><span class="line">                            * assignment a[less] = pivot1 may be incorrect,</span><br><span class="line">                            * if a[great] and pivot1 are floating-point zeros</span><br><span class="line">                            * of different signs. Therefore in float and</span><br><span class="line">                            * double sorting methods we have to use more</span><br><span class="line">                            * accurate assignment a[less] = a[great].</span><br><span class="line">                            */</span><br><span class="line">                               a[less] = pivot1;</span><br><span class="line">                               ++less;</span><br><span class="line">                           &#125; else &#123; // pivot1 &lt; a[great] &lt; pivot2</span><br><span class="line">                               a[k] = a[great];</span><br><span class="line">                           &#125;</span><br><span class="line">                           a[great] = ak;</span><br><span class="line">                           --great;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               // Sort center part recursively</span><br><span class="line">               sort(a, less, great, false);</span><br><span class="line"></span><br><span class="line">           &#125; else &#123; // Partitioning with one pivot</span><br><span class="line">           /*</span><br><span class="line">            * Use the third of the five sorted elements as pivot.</span><br><span class="line">            * This value is inexpensive approximation of the median.</span><br><span class="line">            */</span><br><span class="line">               char pivot = a[e3];</span><br><span class="line"></span><br><span class="line">           /*</span><br><span class="line">            * Partitioning degenerates to the traditional 3-way</span><br><span class="line">            * (or &quot;Dutch National Flag&quot;) schema:</span><br><span class="line">            *</span><br><span class="line">            *   left part    center part              right part</span><br><span class="line">            * +-------------------------------------------------+</span><br><span class="line">            * |  &lt; pivot  |   == pivot   |     ?    |  &gt; pivot  |</span><br><span class="line">            * +-------------------------------------------------+</span><br><span class="line">            *              ^              ^        ^</span><br><span class="line">            *              |              |        |</span><br><span class="line">            *             less            k      great</span><br><span class="line">            *</span><br><span class="line">            * Invariants:</span><br><span class="line">            *</span><br><span class="line">            *   all in (left, less)   &lt; pivot</span><br><span class="line">            *   all in [less, k)     == pivot</span><br><span class="line">            *   all in (great, right) &gt; pivot</span><br><span class="line">            *</span><br><span class="line">            * Pointer k is the first index of ?-part.</span><br><span class="line">            */</span><br><span class="line">               for (int k = less; k &lt;= great; ++k) &#123;</span><br><span class="line">                   if (a[k] == pivot) &#123;</span><br><span class="line">                       continue;</span><br><span class="line">                   &#125;</span><br><span class="line">                   char ak = a[k];</span><br><span class="line">                   if (ak &lt; pivot) &#123; // Move a[k] to left part</span><br><span class="line">                       a[k] = a[less];</span><br><span class="line">                       a[less] = ak;</span><br><span class="line">                       ++less;</span><br><span class="line">                   &#125; else &#123; // a[k] &gt; pivot - Move a[k] to right part</span><br><span class="line">                       while (a[great] &gt; pivot) &#123;</span><br><span class="line">                           --great;</span><br><span class="line">                       &#125;</span><br><span class="line">                       if (a[great] &lt; pivot) &#123; // a[great] &lt;= pivot</span><br><span class="line">                           a[k] = a[less];</span><br><span class="line">                           a[less] = a[great];</span><br><span class="line">                           ++less;</span><br><span class="line">                       &#125; else &#123; // a[great] == pivot</span><br><span class="line">                       /*</span><br><span class="line">                        * Even though a[great] equals to pivot, the</span><br><span class="line">                        * assignment a[k] = pivot may be incorrect,</span><br><span class="line">                        * if a[great] and pivot are floating-point</span><br><span class="line">                        * zeros of different signs. Therefore in float</span><br><span class="line">                        * and double sorting methods we have to use</span><br><span class="line">                        * more accurate assignment a[k] = a[great].</span><br><span class="line">                        */</span><br><span class="line">                           a[k] = pivot;</span><br><span class="line">                       &#125;</span><br><span class="line">                       a[great] = ak;</span><br><span class="line">                       --great;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">           /*</span><br><span class="line">            * Sort left and right parts recursively.</span><br><span class="line">            * All elements from center part are equal</span><br><span class="line">            * and, therefore, already sorted.</span><br><span class="line">            */</span><br><span class="line">               sort(a, left, less - 1, leftmost);</span><br><span class="line">               sort(a, great + 1, right, false);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       /**</span><br><span class="line">        * The number of distinct byte values.</span><br><span class="line">        */</span><br><span class="line">       private static final int NUM_BYTE_VALUES = 1 &lt;&lt; 8;</span><br><span class="line"></span><br><span class="line">       /**</span><br><span class="line">        * Sorts the specified range of the array.</span><br><span class="line">        *</span><br><span class="line">        * @param a     the array to be sorted</span><br><span class="line">        * @param left  the index of the first element, inclusive, to be sorted</span><br><span class="line">        * @param right the index of the last element, inclusive, to be sorted</span><br><span class="line">        */</span><br><span class="line">       static void sort(byte[] a, int left, int right) &#123;</span><br><span class="line">           // Use counting sort on large arrays</span><br><span class="line">           if (right - left &gt; COUNTING_SORT_THRESHOLD_FOR_BYTE) &#123;</span><br><span class="line">               int[] count = new int[NUM_BYTE_VALUES];</span><br><span class="line"></span><br><span class="line">               for (int i = left - 1; ++i &lt;= right;</span><br><span class="line">                    count[a[i] - Byte.MIN_VALUE]++</span><br><span class="line">                       )</span><br><span class="line">                   ;</span><br><span class="line">               for (int i = NUM_BYTE_VALUES, k = right + 1; k &gt; left; ) &#123;</span><br><span class="line">                   while (count[--i] == 0) ;</span><br><span class="line">                   byte value = (byte) (i + Byte.MIN_VALUE);</span><br><span class="line">                   int s = count[i];</span><br><span class="line"></span><br><span class="line">                   do &#123;</span><br><span class="line">                       a[--k] = value;</span><br><span class="line">                   &#125; while (--s &gt; 0);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; else &#123; // Use insertion sort on small arrays</span><br><span class="line">               for (int i = left, j = i; i &lt; right; j = ++i) &#123;</span><br><span class="line">                   byte ai = a[i + 1];</span><br><span class="line">                   while (ai &lt; a[j]) &#123;</span><br><span class="line">                       a[j + 1] = a[j];</span><br><span class="line">                       if (j-- == left) &#123;</span><br><span class="line">                           break;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">                   a[j + 1] = ai;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       /**</span><br><span class="line">        * Sorts the specified range of the array using the given</span><br><span class="line">        * workspace array slice if possible for merging</span><br><span class="line">        *</span><br><span class="line">        * @param a        the array to be sorted</span><br><span class="line">        * @param left     the index of the first element, inclusive, to be sorted</span><br><span class="line">        * @param right    the index of the last element, inclusive, to be sorted</span><br><span class="line">        * @param work     a workspace array (slice)</span><br><span class="line">        * @param workBase origin of usable space in work array</span><br><span class="line">        * @param workLen  usable size of work array</span><br><span class="line">        */</span><br><span class="line">       static void sort(float[] a, int left, int right,</span><br><span class="line">                        float[] work, int workBase, int workLen) &#123;</span><br><span class="line">       /*</span><br><span class="line">        * Phase 1: Move NaNs to the end of the array.</span><br><span class="line">        */</span><br><span class="line">           while (left &lt;= right &amp;&amp; Float.isNaN(a[right])) &#123;</span><br><span class="line">               --right;</span><br><span class="line">           &#125;</span><br><span class="line">           for (int k = right; --k &gt;= left; ) &#123;</span><br><span class="line">               float ak = a[k];</span><br><span class="line">               if (ak != ak) &#123; // a[k] is NaN</span><br><span class="line">                   a[k] = a[right];</span><br><span class="line">                   a[right] = ak;</span><br><span class="line">                   --right;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       /*</span><br><span class="line">        * Phase 2: Sort everything except NaNs (which are already in place).</span><br><span class="line">        */</span><br><span class="line">           doSort(a, left, right, work, workBase, workLen);</span><br><span class="line"></span><br><span class="line">       /*</span><br><span class="line">        * Phase 3: Place negative zeros before positive zeros.</span><br><span class="line">        */</span><br><span class="line">           int hi = right;</span><br><span class="line"></span><br><span class="line">       /*</span><br><span class="line">        * Find the first zero, or first positive, or last negative element.</span><br><span class="line">        */</span><br><span class="line">           while (left &lt; hi) &#123;</span><br><span class="line">               int middle = (left + hi) &gt;&gt;&gt; 1;</span><br><span class="line">               float middleValue = a[middle];</span><br><span class="line"></span><br><span class="line">               if (middleValue &lt; 0.0f) &#123;</span><br><span class="line">                   left = middle + 1;</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">                   hi = middle;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       /*</span><br><span class="line">        * Skip the last negative value (if any) or all leading negative zeros.</span><br><span class="line">        */</span><br><span class="line">           while (left &lt;= right &amp;&amp; Float.floatToRawIntBits(a[left]) &lt; 0) &#123;</span><br><span class="line">               ++left;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       /*</span><br><span class="line">        * Move negative zeros to the beginning of the sub-range.</span><br><span class="line">        *</span><br><span class="line">        * Partitioning:</span><br><span class="line">        *</span><br><span class="line">        * +----------------------------------------------------+</span><br><span class="line">        * |   &lt; 0.0   |   -0.0   |   0.0   |   ?  ( &gt;= 0.0 )   |</span><br><span class="line">        * +----------------------------------------------------+</span><br><span class="line">        *              ^          ^         ^</span><br><span class="line">        *              |          |         |</span><br><span class="line">        *             left        p         k</span><br><span class="line">        *</span><br><span class="line">        * Invariants:</span><br><span class="line">        *</span><br><span class="line">        *   all in (*,  left)  &lt;  0.0</span><br><span class="line">        *   all in [left,  p) == -0.0</span><br><span class="line">        *   all in [p,     k) ==  0.0</span><br><span class="line">        *   all in [k, right] &gt;=  0.0</span><br><span class="line">        *</span><br><span class="line">        * Pointer k is the first index of ?-part.</span><br><span class="line">        */</span><br><span class="line">           for (int k = left, p = left - 1; ++k &lt;= right; ) &#123;</span><br><span class="line">               float ak = a[k];</span><br><span class="line">               if (ak != 0.0f) &#123;</span><br><span class="line">                   break;</span><br><span class="line">               &#125;</span><br><span class="line">               if (Float.floatToRawIntBits(ak) &lt; 0) &#123; // ak is -0.0f</span><br><span class="line">                   a[k] = 0.0f;</span><br><span class="line">                   a[++p] = -0.0f;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       /**</span><br><span class="line">        * Sorts the specified range of the array.</span><br><span class="line">        *</span><br><span class="line">        * @param a        the array to be sorted</span><br><span class="line">        * @param left     the index of the first element, inclusive, to be sorted</span><br><span class="line">        * @param right    the index of the last element, inclusive, to be sorted</span><br><span class="line">        * @param work     a workspace array (slice)</span><br><span class="line">        * @param workBase origin of usable space in work array</span><br><span class="line">        * @param workLen  usable size of work array</span><br><span class="line">        */</span><br><span class="line">       private static void doSort(float[] a, int left, int right,</span><br><span class="line">                                  float[] work, int workBase, int workLen) &#123;</span><br><span class="line">           // Use Quicksort on small arrays</span><br><span class="line">           if (right - left &lt; QUICKSORT_THRESHOLD) &#123;</span><br><span class="line">               sort(a, left, right, true);</span><br><span class="line">               return;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       /*</span><br><span class="line">        * Index run[i] is the start of i-th run</span><br><span class="line">        * (ascending or descending sequence).</span><br><span class="line">        */</span><br><span class="line">           int[] run = new int[MAX_RUN_COUNT + 1];</span><br><span class="line">           int count = 0;</span><br><span class="line">           run[0] = left;</span><br><span class="line"></span><br><span class="line">           // Check if the array is nearly sorted</span><br><span class="line">           for (int k = left; k &lt; right; run[count] = k) &#123;</span><br><span class="line">               if (a[k] &lt; a[k + 1]) &#123; // ascending</span><br><span class="line">                   while (++k &lt;= right &amp;&amp; a[k - 1] &lt;= a[k]) ;</span><br><span class="line">               &#125; else if (a[k] &gt; a[k + 1]) &#123; // descending</span><br><span class="line">                   while (++k &lt;= right &amp;&amp; a[k - 1] &gt;= a[k]) ;</span><br><span class="line">                   for (int lo = run[count] - 1, hi = k; ++lo &lt; --hi; ) &#123;</span><br><span class="line">                       float t = a[lo];</span><br><span class="line">                       a[lo] = a[hi];</span><br><span class="line">                       a[hi] = t;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; else &#123; // equal</span><br><span class="line">                   for (int m = MAX_RUN_LENGTH; ++k &lt;= right &amp;&amp; a[k - 1] == a[k]; ) &#123;</span><br><span class="line">                       if (--m == 0) &#123;</span><br><span class="line">                           sort(a, left, right, true);</span><br><span class="line">                           return;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">           /*</span><br><span class="line">            * The array is not highly structured,</span><br><span class="line">            * use Quicksort instead of merge sort.</span><br><span class="line">            */</span><br><span class="line">               if (++count == MAX_RUN_COUNT) &#123;</span><br><span class="line">                   sort(a, left, right, true);</span><br><span class="line">                   return;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // Check special cases</span><br><span class="line">           // Implementation note: variable &quot;right&quot; is increased by 1.</span><br><span class="line">           if (run[count] == right++) &#123; // The last run contains one element</span><br><span class="line">               run[++count] = right;</span><br><span class="line">           &#125; else if (count == 1) &#123; // The array is already sorted</span><br><span class="line">               return;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // Determine alternation base for merge</span><br><span class="line">           byte odd = 0;</span><br><span class="line">           for (int n = 1; (n &lt;&lt;= 1) &lt; count; odd ^= 1) ;</span><br><span class="line"></span><br><span class="line">           // Use or create temporary array b for merging</span><br><span class="line">           float[] b;                 // temp array; alternates with a</span><br><span class="line">           int ao, bo;              // array offsets from &#x27;left&#x27;</span><br><span class="line">           int blen = right - left; // space needed for b</span><br><span class="line">           if (work == null || workLen &lt; blen || workBase + blen &gt; work.length) &#123;</span><br><span class="line">               work = new float[blen];</span><br><span class="line">               workBase = 0;</span><br><span class="line">           &#125;</span><br><span class="line">           if (odd == 0) &#123;</span><br><span class="line">               System.arraycopy(a, left, work, workBase, blen);</span><br><span class="line">               b = a;</span><br><span class="line">               bo = 0;</span><br><span class="line">               a = work;</span><br><span class="line">               ao = workBase - left;</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               b = work;</span><br><span class="line">               ao = 0;</span><br><span class="line">               bo = workBase - left;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // Merging</span><br><span class="line">           for (int last; count &gt; 1; count = last) &#123;</span><br><span class="line">               for (int k = (last = 0) + 2; k &lt;= count; k += 2) &#123;</span><br><span class="line">                   int hi = run[k], mi = run[k - 1];</span><br><span class="line">                   for (int i = run[k - 2], p = i, q = mi; i &lt; hi; ++i) &#123;</span><br><span class="line">                       if (q &gt;= hi || p &lt; mi &amp;&amp; a[p + ao] &lt;= a[q + ao]) &#123;</span><br><span class="line">                           b[i + bo] = a[p++ + ao];</span><br><span class="line">                       &#125; else &#123;</span><br><span class="line">                           b[i + bo] = a[q++ + ao];</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">                   run[++last] = hi;</span><br><span class="line">               &#125;</span><br><span class="line">               if ((count &amp; 1) != 0) &#123;</span><br><span class="line">                   for (int i = right, lo = run[count - 1]; --i &gt;= lo;</span><br><span class="line">                        b[i + bo] = a[i + ao]</span><br><span class="line">                           )</span><br><span class="line">                       ;</span><br><span class="line">                   run[++last] = right;</span><br><span class="line">               &#125;</span><br><span class="line">               float[] t = a;</span><br><span class="line">               a = b;</span><br><span class="line">               b = t;</span><br><span class="line">               int o = ao;</span><br><span class="line">               ao = bo;</span><br><span class="line">               bo = o;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       /**</span><br><span class="line">        * Sorts the specified range of the array by Dual-Pivot Quicksort.</span><br><span class="line">        *</span><br><span class="line">        * @param a        the array to be sorted</span><br><span class="line">        * @param left     the index of the first element, inclusive, to be sorted</span><br><span class="line">        * @param right    the index of the last element, inclusive, to be sorted</span><br><span class="line">        * @param leftmost indicates if this part is the leftmost in the range</span><br><span class="line">        */</span><br><span class="line">       private static void sort(float[] a, int left, int right, boolean leftmost) &#123;</span><br><span class="line">           int length = right - left + 1;</span><br><span class="line"></span><br><span class="line">           // Use insertion sort on tiny arrays</span><br><span class="line">           if (length &lt; INSERTION_SORT_THRESHOLD) &#123;</span><br><span class="line">               if (leftmost) &#123;</span><br><span class="line">               /*</span><br><span class="line">                * Traditional (without sentinel) insertion sort,</span><br><span class="line">                * optimized for server VM, is used in case of</span><br><span class="line">                * the leftmost part.</span><br><span class="line">                */</span><br><span class="line">                   for (int i = left, j = i; i &lt; right; j = ++i) &#123;</span><br><span class="line">                       float ai = a[i + 1];</span><br><span class="line">                       while (ai &lt; a[j]) &#123;</span><br><span class="line">                           a[j + 1] = a[j];</span><br><span class="line">                           if (j-- == left) &#123;</span><br><span class="line">                               break;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                       a[j + 1] = ai;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">               /*</span><br><span class="line">                * Skip the longest ascending sequence.</span><br><span class="line">                */</span><br><span class="line">                   do &#123;</span><br><span class="line">                       if (left &gt;= right) &#123;</span><br><span class="line">                           return;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125; while (a[++left] &gt;= a[left - 1]);</span><br><span class="line"></span><br><span class="line">               /*</span><br><span class="line">                * Every element from adjoining part plays the role</span><br><span class="line">                * of sentinel, therefore this allows us to avoid the</span><br><span class="line">                * left range check on each iteration. Moreover, we use</span><br><span class="line">                * the more optimized algorithm, so called pair insertion</span><br><span class="line">                * sort, which is faster (in the context of Quicksort)</span><br><span class="line">                * than traditional implementation of insertion sort.</span><br><span class="line">                */</span><br><span class="line">                   for (int k = left; ++left &lt;= right; k = ++left) &#123;</span><br><span class="line">                       float a1 = a[k], a2 = a[left];</span><br><span class="line"></span><br><span class="line">                       if (a1 &lt; a2) &#123;</span><br><span class="line">                           a2 = a1;</span><br><span class="line">                           a1 = a[left];</span><br><span class="line">                       &#125;</span><br><span class="line">                       while (a1 &lt; a[--k]) &#123;</span><br><span class="line">                           a[k + 2] = a[k];</span><br><span class="line">                       &#125;</span><br><span class="line">                       a[++k + 1] = a1;</span><br><span class="line"></span><br><span class="line">                       while (a2 &lt; a[--k]) &#123;</span><br><span class="line">                           a[k + 1] = a[k];</span><br><span class="line">                       &#125;</span><br><span class="line">                       a[k + 1] = a2;</span><br><span class="line">                   &#125;</span><br><span class="line">                   float last = a[right];</span><br><span class="line"></span><br><span class="line">                   while (last &lt; a[--right]) &#123;</span><br><span class="line">                       a[right + 1] = a[right];</span><br><span class="line">                   &#125;</span><br><span class="line">                   a[right + 1] = last;</span><br><span class="line">               &#125;</span><br><span class="line">               return;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // Inexpensive approximation of length / 7</span><br><span class="line">           int seventh = (length &gt;&gt; 3) + (length &gt;&gt; 6) + 1;</span><br><span class="line"></span><br><span class="line">       /*</span><br><span class="line">        * Sort five evenly spaced elements around (and including) the</span><br><span class="line">        * center element in the range. These elements will be used for</span><br><span class="line">        * pivot selection as described below. The choice for spacing</span><br><span class="line">        * these elements was empirically determined to work well on</span><br><span class="line">        * a wide variety of inputs.</span><br><span class="line">        */</span><br><span class="line">           int e3 = (left + right) &gt;&gt;&gt; 1; // The midpoint</span><br><span class="line">           int e2 = e3 - seventh;</span><br><span class="line">           int e1 = e2 - seventh;</span><br><span class="line">           int e4 = e3 + seventh;</span><br><span class="line">           int e5 = e4 + seventh;</span><br><span class="line"></span><br><span class="line">           // Sort these elements using insertion sort</span><br><span class="line">           if (a[e2] &lt; a[e1]) &#123;</span><br><span class="line">               float t = a[e2];</span><br><span class="line">               a[e2] = a[e1];</span><br><span class="line">               a[e1] = t;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           if (a[e3] &lt; a[e2]) &#123;</span><br><span class="line">               float t = a[e3];</span><br><span class="line">               a[e3] = a[e2];</span><br><span class="line">               a[e2] = t;</span><br><span class="line">               if (t &lt; a[e1]) &#123;</span><br><span class="line">                   a[e2] = a[e1];</span><br><span class="line">                   a[e1] = t;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           if (a[e4] &lt; a[e3]) &#123;</span><br><span class="line">               float t = a[e4];</span><br><span class="line">               a[e4] = a[e3];</span><br><span class="line">               a[e3] = t;</span><br><span class="line">               if (t &lt; a[e2]) &#123;</span><br><span class="line">                   a[e3] = a[e2];</span><br><span class="line">                   a[e2] = t;</span><br><span class="line">                   if (t &lt; a[e1]) &#123;</span><br><span class="line">                       a[e2] = a[e1];</span><br><span class="line">                       a[e1] = t;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           if (a[e5] &lt; a[e4]) &#123;</span><br><span class="line">               float t = a[e5];</span><br><span class="line">               a[e5] = a[e4];</span><br><span class="line">               a[e4] = t;</span><br><span class="line">               if (t &lt; a[e3]) &#123;</span><br><span class="line">                   a[e4] = a[e3];</span><br><span class="line">                   a[e3] = t;</span><br><span class="line">                   if (t &lt; a[e2]) &#123;</span><br><span class="line">                       a[e3] = a[e2];</span><br><span class="line">                       a[e2] = t;</span><br><span class="line">                       if (t &lt; a[e1]) &#123;</span><br><span class="line">                           a[e2] = a[e1];</span><br><span class="line">                           a[e1] = t;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // Pointers</span><br><span class="line">           int less = left;  // The index of the first element of center part</span><br><span class="line">           int great = right; // The index before the first element of right part</span><br><span class="line"></span><br><span class="line">           if (a[e1] != a[e2] &amp;&amp; a[e2] != a[e3] &amp;&amp; a[e3] != a[e4] &amp;&amp; a[e4] != a[e5]) &#123;</span><br><span class="line">           /*</span><br><span class="line">            * Use the second and fourth of the five sorted elements as pivots.</span><br><span class="line">            * These values are inexpensive approximations of the first and</span><br><span class="line">            * second terciles of the array. Note that pivot1 &lt;= pivot2.</span><br><span class="line">            */</span><br><span class="line">               float pivot1 = a[e2];</span><br><span class="line">               float pivot2 = a[e4];</span><br><span class="line"></span><br><span class="line">           /*</span><br><span class="line">            * The first and the last elements to be sorted are moved to the</span><br><span class="line">            * locations formerly occupied by the pivots. When partitioning</span><br><span class="line">            * is complete, the pivots are swapped back into their final</span><br><span class="line">            * positions, and excluded from subsequent sorting.</span><br><span class="line">            */</span><br><span class="line">               a[e2] = a[left];</span><br><span class="line">               a[e4] = a[right];</span><br><span class="line"></span><br><span class="line">           /*</span><br><span class="line">            * Skip elements, which are less or greater than pivot values.</span><br><span class="line">            */</span><br><span class="line">               while (a[++less] &lt; pivot1) ;</span><br><span class="line">               while (a[--great] &gt; pivot2) ;</span><br><span class="line"></span><br><span class="line">           /*</span><br><span class="line">            * Partitioning:</span><br><span class="line">            *</span><br><span class="line">            *   left part           center part                   right part</span><br><span class="line">            * +--------------------------------------------------------------+</span><br><span class="line">            * |  &lt; pivot1  |  pivot1 &lt;= &amp;&amp; &lt;= pivot2  |    ?    |  &gt; pivot2  |</span><br><span class="line">            * +--------------------------------------------------------------+</span><br><span class="line">            *               ^                          ^       ^</span><br><span class="line">            *               |                          |       |</span><br><span class="line">            *              less                        k     great</span><br><span class="line">            *</span><br><span class="line">            * Invariants:</span><br><span class="line">            *</span><br><span class="line">            *              all in (left, less)   &lt; pivot1</span><br><span class="line">            *    pivot1 &lt;= all in [less, k)     &lt;= pivot2</span><br><span class="line">            *              all in (great, right) &gt; pivot2</span><br><span class="line">            *</span><br><span class="line">            * Pointer k is the first index of ?-part.</span><br><span class="line">            */</span><br><span class="line">               outer:</span><br><span class="line">               for (int k = less - 1; ++k &lt;= great; ) &#123;</span><br><span class="line">                   float ak = a[k];</span><br><span class="line">                   if (ak &lt; pivot1) &#123; // Move a[k] to left part</span><br><span class="line">                       a[k] = a[less];</span><br><span class="line">                   /*</span><br><span class="line">                    * Here and below we use &quot;a[i] = b; i++;&quot; instead</span><br><span class="line">                    * of &quot;a[i++] = b;&quot; due to performance issue.</span><br><span class="line">                    */</span><br><span class="line">                       a[less] = ak;</span><br><span class="line">                       ++less;</span><br><span class="line">                   &#125; else if (ak &gt; pivot2) &#123; // Move a[k] to right part</span><br><span class="line">                       while (a[great] &gt; pivot2) &#123;</span><br><span class="line">                           if (great-- == k) &#123;</span><br><span class="line">                               break outer;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                       if (a[great] &lt; pivot1) &#123; // a[great] &lt;= pivot2</span><br><span class="line">                           a[k] = a[less];</span><br><span class="line">                           a[less] = a[great];</span><br><span class="line">                           ++less;</span><br><span class="line">                       &#125; else &#123; // pivot1 &lt;= a[great] &lt;= pivot2</span><br><span class="line">                           a[k] = a[great];</span><br><span class="line">                       &#125;</span><br><span class="line">                   /*</span><br><span class="line">                    * Here and below we use &quot;a[i] = b; i--;&quot; instead</span><br><span class="line">                    * of &quot;a[i--] = b;&quot; due to performance issue.</span><br><span class="line">                    */</span><br><span class="line">                       a[great] = ak;</span><br><span class="line">                       --great;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               // Swap pivots into their final positions</span><br><span class="line">               a[left] = a[less - 1];</span><br><span class="line">               a[less - 1] = pivot1;</span><br><span class="line">               a[right] = a[great + 1];</span><br><span class="line">               a[great + 1] = pivot2;</span><br><span class="line"></span><br><span class="line">               // Sort left and right parts recursively, excluding known pivots</span><br><span class="line">               sort(a, left, less - 2, leftmost);</span><br><span class="line">               sort(a, great + 2, right, false);</span><br><span class="line"></span><br><span class="line">           /*</span><br><span class="line">            * If center part is too large (comprises &gt; 4/7 of the array),</span><br><span class="line">            * swap internal pivot values to ends.</span><br><span class="line">            */</span><br><span class="line">               if (less &lt; e1 &amp;&amp; e5 &lt; great) &#123;</span><br><span class="line">               /*</span><br><span class="line">                * Skip elements, which are equal to pivot values.</span><br><span class="line">                */</span><br><span class="line">                   while (a[less] == pivot1) &#123;</span><br><span class="line">                       ++less;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   while (a[great] == pivot2) &#123;</span><br><span class="line">                       --great;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">               /*</span><br><span class="line">                * Partitioning:</span><br><span class="line">                *</span><br><span class="line">                *   left part         center part                  right part</span><br><span class="line">                * +----------------------------------------------------------+</span><br><span class="line">                * | == pivot1 |  pivot1 &lt; &amp;&amp; &lt; pivot2  |    ?    | == pivot2 |</span><br><span class="line">                * +----------------------------------------------------------+</span><br><span class="line">                *              ^                        ^       ^</span><br><span class="line">                *              |                        |       |</span><br><span class="line">                *             less                      k     great</span><br><span class="line">                *</span><br><span class="line">                * Invariants:</span><br><span class="line">                *</span><br><span class="line">                *              all in (*,  less) == pivot1</span><br><span class="line">                *     pivot1 &lt; all in [less,  k)  &lt; pivot2</span><br><span class="line">                *              all in (great, *) == pivot2</span><br><span class="line">                *</span><br><span class="line">                * Pointer k is the first index of ?-part.</span><br><span class="line">                */</span><br><span class="line">                   outer:</span><br><span class="line">                   for (int k = less - 1; ++k &lt;= great; ) &#123;</span><br><span class="line">                       float ak = a[k];</span><br><span class="line">                       if (ak == pivot1) &#123; // Move a[k] to left part</span><br><span class="line">                           a[k] = a[less];</span><br><span class="line">                           a[less] = ak;</span><br><span class="line">                           ++less;</span><br><span class="line">                       &#125; else if (ak == pivot2) &#123; // Move a[k] to right part</span><br><span class="line">                           while (a[great] == pivot2) &#123;</span><br><span class="line">                               if (great-- == k) &#123;</span><br><span class="line">                                   break outer;</span><br><span class="line">                               &#125;</span><br><span class="line">                           &#125;</span><br><span class="line">                           if (a[great] == pivot1) &#123; // a[great] &lt; pivot2</span><br><span class="line">                               a[k] = a[less];</span><br><span class="line">                           /*</span><br><span class="line">                            * Even though a[great] equals to pivot1, the</span><br><span class="line">                            * assignment a[less] = pivot1 may be incorrect,</span><br><span class="line">                            * if a[great] and pivot1 are floating-point zeros</span><br><span class="line">                            * of different signs. Therefore in float and</span><br><span class="line">                            * double sorting methods we have to use more</span><br><span class="line">                            * accurate assignment a[less] = a[great].</span><br><span class="line">                            */</span><br><span class="line">                               a[less] = a[great];</span><br><span class="line">                               ++less;</span><br><span class="line">                           &#125; else &#123; // pivot1 &lt; a[great] &lt; pivot2</span><br><span class="line">                               a[k] = a[great];</span><br><span class="line">                           &#125;</span><br><span class="line">                           a[great] = ak;</span><br><span class="line">                           --great;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               // Sort center part recursively</span><br><span class="line">               sort(a, less, great, false);</span><br><span class="line"></span><br><span class="line">           &#125; else &#123; // Partitioning with one pivot</span><br><span class="line">           /*</span><br><span class="line">            * Use the third of the five sorted elements as pivot.</span><br><span class="line">            * This value is inexpensive approximation of the median.</span><br><span class="line">            */</span><br><span class="line">               float pivot = a[e3];</span><br><span class="line"></span><br><span class="line">           /*</span><br><span class="line">            * Partitioning degenerates to the traditional 3-way</span><br><span class="line">            * (or &quot;Dutch National Flag&quot;) schema:</span><br><span class="line">            *</span><br><span class="line">            *   left part    center part              right part</span><br><span class="line">            * +-------------------------------------------------+</span><br><span class="line">            * |  &lt; pivot  |   == pivot   |     ?    |  &gt; pivot  |</span><br><span class="line">            * +-------------------------------------------------+</span><br><span class="line">            *              ^              ^        ^</span><br><span class="line">            *              |              |        |</span><br><span class="line">            *             less            k      great</span><br><span class="line">            *</span><br><span class="line">            * Invariants:</span><br><span class="line">            *</span><br><span class="line">            *   all in (left, less)   &lt; pivot</span><br><span class="line">            *   all in [less, k)     == pivot</span><br><span class="line">            *   all in (great, right) &gt; pivot</span><br><span class="line">            *</span><br><span class="line">            * Pointer k is the first index of ?-part.</span><br><span class="line">            */</span><br><span class="line">               for (int k = less; k &lt;= great; ++k) &#123;</span><br><span class="line">                   if (a[k] == pivot) &#123;</span><br><span class="line">                       continue;</span><br><span class="line">                   &#125;</span><br><span class="line">                   float ak = a[k];</span><br><span class="line">                   if (ak &lt; pivot) &#123; // Move a[k] to left part</span><br><span class="line">                       a[k] = a[less];</span><br><span class="line">                       a[less] = ak;</span><br><span class="line">                       ++less;</span><br><span class="line">                   &#125; else &#123; // a[k] &gt; pivot - Move a[k] to right part</span><br><span class="line">                       while (a[great] &gt; pivot) &#123;</span><br><span class="line">                           --great;</span><br><span class="line">                       &#125;</span><br><span class="line">                       if (a[great] &lt; pivot) &#123; // a[great] &lt;= pivot</span><br><span class="line">                           a[k] = a[less];</span><br><span class="line">                           a[less] = a[great];</span><br><span class="line">                           ++less;</span><br><span class="line">                       &#125; else &#123; // a[great] == pivot</span><br><span class="line">                       /*</span><br><span class="line">                        * Even though a[great] equals to pivot, the</span><br><span class="line">                        * assignment a[k] = pivot may be incorrect,</span><br><span class="line">                        * if a[great] and pivot are floating-point</span><br><span class="line">                        * zeros of different signs. Therefore in float</span><br><span class="line">                        * and double sorting methods we have to use</span><br><span class="line">                        * more accurate assignment a[k] = a[great].</span><br><span class="line">                        */</span><br><span class="line">                           a[k] = a[great];</span><br><span class="line">                       &#125;</span><br><span class="line">                       a[great] = ak;</span><br><span class="line">                       --great;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">           /*</span><br><span class="line">            * Sort left and right parts recursively.</span><br><span class="line">            * All elements from center part are equal</span><br><span class="line">            * and, therefore, already sorted.</span><br><span class="line">            */</span><br><span class="line">               sort(a, left, less - 1, leftmost);</span><br><span class="line">               sort(a, great + 1, right, false);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       /**</span><br><span class="line">        * Sorts the specified range of the array using the given</span><br><span class="line">        * workspace array slice if possible for merging</span><br><span class="line">        *</span><br><span class="line">        * @param a        the array to be sorted</span><br><span class="line">        * @param left     the index of the first element, inclusive, to be sorted</span><br><span class="line">        * @param right    the index of the last element, inclusive, to be sorted</span><br><span class="line">        * @param work     a workspace array (slice)</span><br><span class="line">        * @param workBase origin of usable space in work array</span><br><span class="line">        * @param workLen  usable size of work array</span><br><span class="line">        */</span><br><span class="line">       static void sort(double[] a, int left, int right,</span><br><span class="line">                        double[] work, int workBase, int workLen) &#123;</span><br><span class="line">       /*</span><br><span class="line">        * Phase 1: Move NaNs to the end of the array.</span><br><span class="line">        */</span><br><span class="line">           while (left &lt;= right &amp;&amp; Double.isNaN(a[right])) &#123;</span><br><span class="line">               --right;</span><br><span class="line">           &#125;</span><br><span class="line">           for (int k = right; --k &gt;= left; ) &#123;</span><br><span class="line">               double ak = a[k];</span><br><span class="line">               if (ak != ak) &#123; // a[k] is NaN</span><br><span class="line">                   a[k] = a[right];</span><br><span class="line">                   a[right] = ak;</span><br><span class="line">                   --right;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       /*</span><br><span class="line">        * Phase 2: Sort everything except NaNs (which are already in place).</span><br><span class="line">        */</span><br><span class="line">           doSort(a, left, right, work, workBase, workLen);</span><br><span class="line"></span><br><span class="line">       /*</span><br><span class="line">        * Phase 3: Place negative zeros before positive zeros.</span><br><span class="line">        */</span><br><span class="line">           int hi = right;</span><br><span class="line"></span><br><span class="line">       /*</span><br><span class="line">        * Find the first zero, or first positive, or last negative element.</span><br><span class="line">        */</span><br><span class="line">           while (left &lt; hi) &#123;</span><br><span class="line">               int middle = (left + hi) &gt;&gt;&gt; 1;</span><br><span class="line">               double middleValue = a[middle];</span><br><span class="line"></span><br><span class="line">               if (middleValue &lt; 0.0d) &#123;</span><br><span class="line">                   left = middle + 1;</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">                   hi = middle;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       /*</span><br><span class="line">        * Skip the last negative value (if any) or all leading negative zeros.</span><br><span class="line">        */</span><br><span class="line">           while (left &lt;= right &amp;&amp; Double.doubleToRawLongBits(a[left]) &lt; 0) &#123;</span><br><span class="line">               ++left;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       /*</span><br><span class="line">        * Move negative zeros to the beginning of the sub-range.</span><br><span class="line">        *</span><br><span class="line">        * Partitioning:</span><br><span class="line">        *</span><br><span class="line">        * +----------------------------------------------------+</span><br><span class="line">        * |   &lt; 0.0   |   -0.0   |   0.0   |   ?  ( &gt;= 0.0 )   |</span><br><span class="line">        * +----------------------------------------------------+</span><br><span class="line">        *              ^          ^         ^</span><br><span class="line">        *              |          |         |</span><br><span class="line">        *             left        p         k</span><br><span class="line">        *</span><br><span class="line">        * Invariants:</span><br><span class="line">        *</span><br><span class="line">        *   all in (*,  left)  &lt;  0.0</span><br><span class="line">        *   all in [left,  p) == -0.0</span><br><span class="line">        *   all in [p,     k) ==  0.0</span><br><span class="line">        *   all in [k, right] &gt;=  0.0</span><br><span class="line">        *</span><br><span class="line">        * Pointer k is the first index of ?-part.</span><br><span class="line">        */</span><br><span class="line">           for (int k = left, p = left - 1; ++k &lt;= right; ) &#123;</span><br><span class="line">               double ak = a[k];</span><br><span class="line">               if (ak != 0.0d) &#123;</span><br><span class="line">                   break;</span><br><span class="line">               &#125;</span><br><span class="line">               if (Double.doubleToRawLongBits(ak) &lt; 0) &#123; // ak is -0.0d</span><br><span class="line">                   a[k] = 0.0d;</span><br><span class="line">                   a[++p] = -0.0d;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       /**</span><br><span class="line">        * Sorts the specified range of the array.</span><br><span class="line">        *</span><br><span class="line">        * @param a        the array to be sorted</span><br><span class="line">        * @param left     the index of the first element, inclusive, to be sorted</span><br><span class="line">        * @param right    the index of the last element, inclusive, to be sorted</span><br><span class="line">        * @param work     a workspace array (slice)</span><br><span class="line">        * @param workBase origin of usable space in work array</span><br><span class="line">        * @param workLen  usable size of work array</span><br><span class="line">        */</span><br><span class="line">       private static void doSort(double[] a, int left, int right,</span><br><span class="line">                                  double[] work, int workBase, int workLen) &#123;</span><br><span class="line">           // Use Quicksort on small arrays</span><br><span class="line">           if (right - left &lt; QUICKSORT_THRESHOLD) &#123;</span><br><span class="line">               sort(a, left, right, true);</span><br><span class="line">               return;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       /*</span><br><span class="line">        * Index run[i] is the start of i-th run</span><br><span class="line">        * (ascending or descending sequence).</span><br><span class="line">        */</span><br><span class="line">           int[] run = new int[MAX_RUN_COUNT + 1];</span><br><span class="line">           int count = 0;</span><br><span class="line">           run[0] = left;</span><br><span class="line"></span><br><span class="line">           // Check if the array is nearly sorted</span><br><span class="line">           for (int k = left; k &lt; right; run[count] = k) &#123;</span><br><span class="line">               if (a[k] &lt; a[k + 1]) &#123; // ascending</span><br><span class="line">                   while (++k &lt;= right &amp;&amp; a[k - 1] &lt;= a[k]) ;</span><br><span class="line">               &#125; else if (a[k] &gt; a[k + 1]) &#123; // descending</span><br><span class="line">                   while (++k &lt;= right &amp;&amp; a[k - 1] &gt;= a[k]) ;</span><br><span class="line">                   for (int lo = run[count] - 1, hi = k; ++lo &lt; --hi; ) &#123;</span><br><span class="line">                       double t = a[lo];</span><br><span class="line">                       a[lo] = a[hi];</span><br><span class="line">                       a[hi] = t;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; else &#123; // equal</span><br><span class="line">                   for (int m = MAX_RUN_LENGTH; ++k &lt;= right &amp;&amp; a[k - 1] == a[k]; ) &#123;</span><br><span class="line">                       if (--m == 0) &#123;</span><br><span class="line">                           sort(a, left, right, true);</span><br><span class="line">                           return;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">           /*</span><br><span class="line">            * The array is not highly structured,</span><br><span class="line">            * use Quicksort instead of merge sort.</span><br><span class="line">            */</span><br><span class="line">               if (++count == MAX_RUN_COUNT) &#123;</span><br><span class="line">                   sort(a, left, right, true);</span><br><span class="line">                   return;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // Check special cases</span><br><span class="line">           // Implementation note: variable &quot;right&quot; is increased by 1.</span><br><span class="line">           if (run[count] == right++) &#123; // The last run contains one element</span><br><span class="line">               run[++count] = right;</span><br><span class="line">           &#125; else if (count == 1) &#123; // The array is already sorted</span><br><span class="line">               return;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // Determine alternation base for merge</span><br><span class="line">           byte odd = 0;</span><br><span class="line">           for (int n = 1; (n &lt;&lt;= 1) &lt; count; odd ^= 1) ;</span><br><span class="line"></span><br><span class="line">           // Use or create temporary array b for merging</span><br><span class="line">           double[] b;                 // temp array; alternates with a</span><br><span class="line">           int ao, bo;              // array offsets from &#x27;left&#x27;</span><br><span class="line">           int blen = right - left; // space needed for b</span><br><span class="line">           if (work == null || workLen &lt; blen || workBase + blen &gt; work.length) &#123;</span><br><span class="line">               work = new double[blen];</span><br><span class="line">               workBase = 0;</span><br><span class="line">           &#125;</span><br><span class="line">           if (odd == 0) &#123;</span><br><span class="line">               System.arraycopy(a, left, work, workBase, blen);</span><br><span class="line">               b = a;</span><br><span class="line">               bo = 0;</span><br><span class="line">               a = work;</span><br><span class="line">               ao = workBase - left;</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               b = work;</span><br><span class="line">               ao = 0;</span><br><span class="line">               bo = workBase - left;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // Merging</span><br><span class="line">           for (int last; count &gt; 1; count = last) &#123;</span><br><span class="line">               for (int k = (last = 0) + 2; k &lt;= count; k += 2) &#123;</span><br><span class="line">                   int hi = run[k], mi = run[k - 1];</span><br><span class="line">                   for (int i = run[k - 2], p = i, q = mi; i &lt; hi; ++i) &#123;</span><br><span class="line">                       if (q &gt;= hi || p &lt; mi &amp;&amp; a[p + ao] &lt;= a[q + ao]) &#123;</span><br><span class="line">                           b[i + bo] = a[p++ + ao];</span><br><span class="line">                       &#125; else &#123;</span><br><span class="line">                           b[i + bo] = a[q++ + ao];</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">                   run[++last] = hi;</span><br><span class="line">               &#125;</span><br><span class="line">               if ((count &amp; 1) != 0) &#123;</span><br><span class="line">                   for (int i = right, lo = run[count - 1]; --i &gt;= lo;</span><br><span class="line">                        b[i + bo] = a[i + ao]</span><br><span class="line">                           )</span><br><span class="line">                       ;</span><br><span class="line">                   run[++last] = right;</span><br><span class="line">               &#125;</span><br><span class="line">               double[] t = a;</span><br><span class="line">               a = b;</span><br><span class="line">               b = t;</span><br><span class="line">               int o = ao;</span><br><span class="line">               ao = bo;</span><br><span class="line">               bo = o;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       /**</span><br><span class="line">        * Sorts the specified range of the array by Dual-Pivot Quicksort.</span><br><span class="line">        *</span><br><span class="line">        * @param a        the array to be sorted</span><br><span class="line">        * @param left     the index of the first element, inclusive, to be sorted</span><br><span class="line">        * @param right    the index of the last element, inclusive, to be sorted</span><br><span class="line">        * @param leftmost indicates if this part is the leftmost in the range</span><br><span class="line">        */</span><br><span class="line">       private static void sort(double[] a, int left, int right, boolean leftmost) &#123;</span><br><span class="line">           int length = right - left + 1;</span><br><span class="line"></span><br><span class="line">           // Use insertion sort on tiny arrays</span><br><span class="line">           if (length &lt; INSERTION_SORT_THRESHOLD) &#123;</span><br><span class="line">               if (leftmost) &#123;</span><br><span class="line">               /*</span><br><span class="line">                * Traditional (without sentinel) insertion sort,</span><br><span class="line">                * optimized for server VM, is used in case of</span><br><span class="line">                * the leftmost part.</span><br><span class="line">                */</span><br><span class="line">                   for (int i = left, j = i; i &lt; right; j = ++i) &#123;</span><br><span class="line">                       double ai = a[i + 1];</span><br><span class="line">                       while (ai &lt; a[j]) &#123;</span><br><span class="line">                           a[j + 1] = a[j];</span><br><span class="line">                           if (j-- == left) &#123;</span><br><span class="line">                               break;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                       a[j + 1] = ai;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">               /*</span><br><span class="line">                * Skip the longest ascending sequence.</span><br><span class="line">                */</span><br><span class="line">                   do &#123;</span><br><span class="line">                       if (left &gt;= right) &#123;</span><br><span class="line">                           return;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125; while (a[++left] &gt;= a[left - 1]);</span><br><span class="line"></span><br><span class="line">               /*</span><br><span class="line">                * Every element from adjoining part plays the role</span><br><span class="line">                * of sentinel, therefore this allows us to avoid the</span><br><span class="line">                * left range check on each iteration. Moreover, we use</span><br><span class="line">                * the more optimized algorithm, so called pair insertion</span><br><span class="line">                * sort, which is faster (in the context of Quicksort)</span><br><span class="line">                * than traditional implementation of insertion sort.</span><br><span class="line">                */</span><br><span class="line">                   for (int k = left; ++left &lt;= right; k = ++left) &#123;</span><br><span class="line">                       double a1 = a[k], a2 = a[left];</span><br><span class="line"></span><br><span class="line">                       if (a1 &lt; a2) &#123;</span><br><span class="line">                           a2 = a1;</span><br><span class="line">                           a1 = a[left];</span><br><span class="line">                       &#125;</span><br><span class="line">                       while (a1 &lt; a[--k]) &#123;</span><br><span class="line">                           a[k + 2] = a[k];</span><br><span class="line">                       &#125;</span><br><span class="line">                       a[++k + 1] = a1;</span><br><span class="line"></span><br><span class="line">                       while (a2 &lt; a[--k]) &#123;</span><br><span class="line">                           a[k + 1] = a[k];</span><br><span class="line">                       &#125;</span><br><span class="line">                       a[k + 1] = a2;</span><br><span class="line">                   &#125;</span><br><span class="line">                   double last = a[right];</span><br><span class="line"></span><br><span class="line">                   while (last &lt; a[--right]) &#123;</span><br><span class="line">                       a[right + 1] = a[right];</span><br><span class="line">                   &#125;</span><br><span class="line">                   a[right + 1] = last;</span><br><span class="line">               &#125;</span><br><span class="line">               return;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // Inexpensive approximation of length / 7</span><br><span class="line">           int seventh = (length &gt;&gt; 3) + (length &gt;&gt; 6) + 1;</span><br><span class="line"></span><br><span class="line">       /*</span><br><span class="line">        * Sort five evenly spaced elements around (and including) the</span><br><span class="line">        * center element in the range. These elements will be used for</span><br><span class="line">        * pivot selection as described below. The choice for spacing</span><br><span class="line">        * these elements was empirically determined to work well on</span><br><span class="line">        * a wide variety of inputs.</span><br><span class="line">        */</span><br><span class="line">           int e3 = (left + right) &gt;&gt;&gt; 1; // The midpoint</span><br><span class="line">           int e2 = e3 - seventh;</span><br><span class="line">           int e1 = e2 - seventh;</span><br><span class="line">           int e4 = e3 + seventh;</span><br><span class="line">           int e5 = e4 + seventh;</span><br><span class="line"></span><br><span class="line">           // Sort these elements using insertion sort</span><br><span class="line">           if (a[e2] &lt; a[e1]) &#123;</span><br><span class="line">               double t = a[e2];</span><br><span class="line">               a[e2] = a[e1];</span><br><span class="line">               a[e1] = t;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           if (a[e3] &lt; a[e2]) &#123;</span><br><span class="line">               double t = a[e3];</span><br><span class="line">               a[e3] = a[e2];</span><br><span class="line">               a[e2] = t;</span><br><span class="line">               if (t &lt; a[e1]) &#123;</span><br><span class="line">                   a[e2] = a[e1];</span><br><span class="line">                   a[e1] = t;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           if (a[e4] &lt; a[e3]) &#123;</span><br><span class="line">               double t = a[e4];</span><br><span class="line">               a[e4] = a[e3];</span><br><span class="line">               a[e3] = t;</span><br><span class="line">               if (t &lt; a[e2]) &#123;</span><br><span class="line">                   a[e3] = a[e2];</span><br><span class="line">                   a[e2] = t;</span><br><span class="line">                   if (t &lt; a[e1]) &#123;</span><br><span class="line">                       a[e2] = a[e1];</span><br><span class="line">                       a[e1] = t;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           if (a[e5] &lt; a[e4]) &#123;</span><br><span class="line">               double t = a[e5];</span><br><span class="line">               a[e5] = a[e4];</span><br><span class="line">               a[e4] = t;</span><br><span class="line">               if (t &lt; a[e3]) &#123;</span><br><span class="line">                   a[e4] = a[e3];</span><br><span class="line">                   a[e3] = t;</span><br><span class="line">                   if (t &lt; a[e2]) &#123;</span><br><span class="line">                       a[e3] = a[e2];</span><br><span class="line">                       a[e2] = t;</span><br><span class="line">                       if (t &lt; a[e1]) &#123;</span><br><span class="line">                           a[e2] = a[e1];</span><br><span class="line">                           a[e1] = t;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // Pointers</span><br><span class="line">           int less = left;  // The index of the first element of center part</span><br><span class="line">           int great = right; // The index before the first element of right part</span><br><span class="line"></span><br><span class="line">           if (a[e1] != a[e2] &amp;&amp; a[e2] != a[e3] &amp;&amp; a[e3] != a[e4] &amp;&amp; a[e4] != a[e5]) &#123;</span><br><span class="line">           /*</span><br><span class="line">            * Use the second and fourth of the five sorted elements as pivots.</span><br><span class="line">            * These values are inexpensive approximations of the first and</span><br><span class="line">            * second terciles of the array. Note that pivot1 &lt;= pivot2.</span><br><span class="line">            */</span><br><span class="line">               double pivot1 = a[e2];</span><br><span class="line">               double pivot2 = a[e4];</span><br><span class="line"></span><br><span class="line">           /*</span><br><span class="line">            * The first and the last elements to be sorted are moved to the</span><br><span class="line">            * locations formerly occupied by the pivots. When partitioning</span><br><span class="line">            * is complete, the pivots are swapped back into their final</span><br><span class="line">            * positions, and excluded from subsequent sorting.</span><br><span class="line">            */</span><br><span class="line">               a[e2] = a[left];</span><br><span class="line">               a[e4] = a[right];</span><br><span class="line"></span><br><span class="line">           /*</span><br><span class="line">            * Skip elements, which are less or greater than pivot values.</span><br><span class="line">            */</span><br><span class="line">               while (a[++less] &lt; pivot1) ;</span><br><span class="line">               while (a[--great] &gt; pivot2) ;</span><br><span class="line"></span><br><span class="line">           /*</span><br><span class="line">            * Partitioning:</span><br><span class="line">            *</span><br><span class="line">            *   left part           center part                   right part</span><br><span class="line">            * +--------------------------------------------------------------+</span><br><span class="line">            * |  &lt; pivot1  |  pivot1 &lt;= &amp;&amp; &lt;= pivot2  |    ?    |  &gt; pivot2  |</span><br><span class="line">            * +--------------------------------------------------------------+</span><br><span class="line">            *               ^                          ^       ^</span><br><span class="line">            *               |                          |       |</span><br><span class="line">            *              less                        k     great</span><br><span class="line">            *</span><br><span class="line">            * Invariants:</span><br><span class="line">            *</span><br><span class="line">            *              all in (left, less)   &lt; pivot1</span><br><span class="line">            *    pivot1 &lt;= all in [less, k)     &lt;= pivot2</span><br><span class="line">            *              all in (great, right) &gt; pivot2</span><br><span class="line">            *</span><br><span class="line">            * Pointer k is the first index of ?-part.</span><br><span class="line">            */</span><br><span class="line">               outer:</span><br><span class="line">               for (int k = less - 1; ++k &lt;= great; ) &#123;</span><br><span class="line">                   double ak = a[k];</span><br><span class="line">                   if (ak &lt; pivot1) &#123; // Move a[k] to left part</span><br><span class="line">                       a[k] = a[less];</span><br><span class="line">                   /*</span><br><span class="line">                    * Here and below we use &quot;a[i] = b; i++;&quot; instead</span><br><span class="line">                    * of &quot;a[i++] = b;&quot; due to performance issue.</span><br><span class="line">                    */</span><br><span class="line">                       a[less] = ak;</span><br><span class="line">                       ++less;</span><br><span class="line">                   &#125; else if (ak &gt; pivot2) &#123; // Move a[k] to right part</span><br><span class="line">                       while (a[great] &gt; pivot2) &#123;</span><br><span class="line">                           if (great-- == k) &#123;</span><br><span class="line">                               break outer;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                       if (a[great] &lt; pivot1) &#123; // a[great] &lt;= pivot2</span><br><span class="line">                           a[k] = a[less];</span><br><span class="line">                           a[less] = a[great];</span><br><span class="line">                           ++less;</span><br><span class="line">                       &#125; else &#123; // pivot1 &lt;= a[great] &lt;= pivot2</span><br><span class="line">                           a[k] = a[great];</span><br><span class="line">                       &#125;</span><br><span class="line">                   /*</span><br><span class="line">                    * Here and below we use &quot;a[i] = b; i--;&quot; instead</span><br><span class="line">                    * of &quot;a[i--] = b;&quot; due to performance issue.</span><br><span class="line">                    */</span><br><span class="line">                       a[great] = ak;</span><br><span class="line">                       --great;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               // Swap pivots into their final positions</span><br><span class="line">               a[left] = a[less - 1];</span><br><span class="line">               a[less - 1] = pivot1;</span><br><span class="line">               a[right] = a[great + 1];</span><br><span class="line">               a[great + 1] = pivot2;</span><br><span class="line"></span><br><span class="line">               // Sort left and right parts recursively, excluding known pivots</span><br><span class="line">               sort(a, left, less - 2, leftmost);</span><br><span class="line">               sort(a, great + 2, right, false);</span><br><span class="line"></span><br><span class="line">           /*</span><br><span class="line">            * If center part is too large (comprises &gt; 4/7 of the array),</span><br><span class="line">            * swap internal pivot values to ends.</span><br><span class="line">            */</span><br><span class="line">               if (less &lt; e1 &amp;&amp; e5 &lt; great) &#123;</span><br><span class="line">               /*</span><br><span class="line">                * Skip elements, which are equal to pivot values.</span><br><span class="line">                */</span><br><span class="line">                   while (a[less] == pivot1) &#123;</span><br><span class="line">                       ++less;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   while (a[great] == pivot2) &#123;</span><br><span class="line">                       --great;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">               /*</span><br><span class="line">                * Partitioning:</span><br><span class="line">                *</span><br><span class="line">                *   left part         center part                  right part</span><br><span class="line">                * +----------------------------------------------------------+</span><br><span class="line">                * | == pivot1 |  pivot1 &lt; &amp;&amp; &lt; pivot2  |    ?    | == pivot2 |</span><br><span class="line">                * +----------------------------------------------------------+</span><br><span class="line">                *              ^                        ^       ^</span><br><span class="line">                *              |                        |       |</span><br><span class="line">                *             less                      k     great</span><br><span class="line">                *</span><br><span class="line">                * Invariants:</span><br><span class="line">                *</span><br><span class="line">                *              all in (*,  less) == pivot1</span><br><span class="line">                *     pivot1 &lt; all in [less,  k)  &lt; pivot2</span><br><span class="line">                *              all in (great, *) == pivot2</span><br><span class="line">                *</span><br><span class="line">                * Pointer k is the first index of ?-part.</span><br><span class="line">                */</span><br><span class="line">                   outer:</span><br><span class="line">                   for (int k = less - 1; ++k &lt;= great; ) &#123;</span><br><span class="line">                       double ak = a[k];</span><br><span class="line">                       if (ak == pivot1) &#123; // Move a[k] to left part</span><br><span class="line">                           a[k] = a[less];</span><br><span class="line">                           a[less] = ak;</span><br><span class="line">                           ++less;</span><br><span class="line">                       &#125; else if (ak == pivot2) &#123; // Move a[k] to right part</span><br><span class="line">                           while (a[great] == pivot2) &#123;</span><br><span class="line">                               if (great-- == k) &#123;</span><br><span class="line">                                   break outer;</span><br><span class="line">                               &#125;</span><br><span class="line">                           &#125;</span><br><span class="line">                           if (a[great] == pivot1) &#123; // a[great] &lt; pivot2</span><br><span class="line">                               a[k] = a[less];</span><br><span class="line">                           /*</span><br><span class="line">                            * Even though a[great] equals to pivot1, the</span><br><span class="line">                            * assignment a[less] = pivot1 may be incorrect,</span><br><span class="line">                            * if a[great] and pivot1 are floating-point zeros</span><br><span class="line">                            * of different signs. Therefore in float and</span><br><span class="line">                            * double sorting methods we have to use more</span><br><span class="line">                            * accurate assignment a[less] = a[great].</span><br><span class="line">                            */</span><br><span class="line">                               a[less] = a[great];</span><br><span class="line">                               ++less;</span><br><span class="line">                           &#125; else &#123; // pivot1 &lt; a[great] &lt; pivot2</span><br><span class="line">                               a[k] = a[great];</span><br><span class="line">                           &#125;</span><br><span class="line">                           a[great] = ak;</span><br><span class="line">                           --great;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               // Sort center part recursively</span><br><span class="line">               sort(a, less, great, false);</span><br><span class="line"></span><br><span class="line">           &#125; else &#123; // Partitioning with one pivot</span><br><span class="line">           /*</span><br><span class="line">            * Use the third of the five sorted elements as pivot.</span><br><span class="line">            * This value is inexpensive approximation of the median.</span><br><span class="line">            */</span><br><span class="line">               double pivot = a[e3];</span><br><span class="line"></span><br><span class="line">           /*</span><br><span class="line">            * Partitioning degenerates to the traditional 3-way</span><br><span class="line">            * (or &quot;Dutch National Flag&quot;) schema:</span><br><span class="line">            *</span><br><span class="line">            *   left part    center part              right part</span><br><span class="line">            * +-------------------------------------------------+</span><br><span class="line">            * |  &lt; pivot  |   == pivot   |     ?    |  &gt; pivot  |</span><br><span class="line">            * +-------------------------------------------------+</span><br><span class="line">            *              ^              ^        ^</span><br><span class="line">            *              |              |        |</span><br><span class="line">            *             less            k      great</span><br><span class="line">            *</span><br><span class="line">            * Invariants:</span><br><span class="line">            *</span><br><span class="line">            *   all in (left, less)   &lt; pivot</span><br><span class="line">            *   all in [less, k)     == pivot</span><br><span class="line">            *   all in (great, right) &gt; pivot</span><br><span class="line">            *</span><br><span class="line">            * Pointer k is the first index of ?-part.</span><br><span class="line">            */</span><br><span class="line">               for (int k = less; k &lt;= great; ++k) &#123;</span><br><span class="line">                   if (a[k] == pivot) &#123;</span><br><span class="line">                       continue;</span><br><span class="line">                   &#125;</span><br><span class="line">                   double ak = a[k];</span><br><span class="line">                   if (ak &lt; pivot) &#123; // Move a[k] to left part</span><br><span class="line">                       a[k] = a[less];</span><br><span class="line">                       a[less] = ak;</span><br><span class="line">                       ++less;</span><br><span class="line">                   &#125; else &#123; // a[k] &gt; pivot - Move a[k] to right part</span><br><span class="line">                       while (a[great] &gt; pivot) &#123;</span><br><span class="line">                           --great;</span><br><span class="line">                       &#125;</span><br><span class="line">                       if (a[great] &lt; pivot) &#123; // a[great] &lt;= pivot</span><br><span class="line">                           a[k] = a[less];</span><br><span class="line">                           a[less] = a[great];</span><br><span class="line">                           ++less;</span><br><span class="line">                       &#125; else &#123; // a[great] == pivot</span><br><span class="line">                       /*</span><br><span class="line">                        * Even though a[great] equals to pivot, the</span><br><span class="line">                        * assignment a[k] = pivot may be incorrect,</span><br><span class="line">                        * if a[great] and pivot are floating-point</span><br><span class="line">                        * zeros of different signs. Therefore in float</span><br><span class="line">                        * and double sorting methods we have to use</span><br><span class="line">                        * more accurate assignment a[k] = a[great].</span><br><span class="line">                        */</span><br><span class="line">                           a[k] = a[great];</span><br><span class="line">                       &#125;</span><br><span class="line">                       a[great] = ak;</span><br><span class="line">                       --great;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">           /*</span><br><span class="line">            * Sort left and right parts recursively.</span><br><span class="line">            * All elements from center part are equal</span><br><span class="line">            * and, therefore, already sorted.</span><br><span class="line">            */</span><br><span class="line">               sort(a, left, less - 1, leftmost);</span><br><span class="line">               sort(a, great + 1, right, false);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>little_eight</tag>
      </tags>
  </entry>
  <entry>
    <title>对于架构的深入探讨</title>
    <url>/2021/09/10/%E5%AF%B9%E4%BA%8E%E6%9E%B6%E6%9E%84%E7%9A%84%E6%B7%B1%E5%85%A5%E6%8E%A2%E8%AE%A8/</url>
    <content><![CDATA[<pre><code>本文基于[凤凰架构](https://icyfenix.cn/)网站的基础上复制缩减而成。
</code></pre>
<h2 id="服务架构的的演进史"><a href="#服务架构的的演进史" class="headerlink" title="服务架构的的演进史"></a>服务架构的的演进史</h2><h3 id="原始分布式时代"><a href="#原始分布式时代" class="headerlink" title="原始分布式时代"></a>原始分布式时代</h3><p>在 20 世纪 70 年代末期到 80 年代初，计算机科学刚经历了从以大型机为主向以微型机为主的蜕变，计算机逐渐从一种存在于研究机构、实验室当中的科研设备，转变为存在于商业企业中的生产设备，甚至是面向家庭、个人用户的娱乐设备。<br>当时计算机硬件局促的运算处理能力，已直接妨碍到了在单台计算机上信息系统软件能够达到的最大规模。为突破硬件算力的限制，各个高校、研究机构、软硬件厂商开始分头探索，寻找使用多台计算机共同协作来支撑同一套软件系统运行的可行方案。这一阶段是对分布式架构最原始的探索，从结果来看，历史局限决定了它不可能一蹴而就地解决分布式的难题，但仅从过程来看，这个阶段的探索称得上成绩斐然。研究过程的很多中间成果都对今天计算机科学的诸多领域产生了深远的影响，直接牵引了后续软件架构的演化进程。譬如<strong>NCA（Network Computing Architecture）</strong>是未来远程服务调用的雏形，卡内基·梅隆大学提出的<strong>AFS 文件系统（Andrew File System）</strong>是日后分布式文件系统的最早实现；麻省理工学院提出的<strong>Kerberos 协议</strong>是服务认证和访问控制的基础性协议，是分布式服务安全性的重要支撑，目前仍被用于实现包括 Windows 和 MacOS 在内众多操作系统的登录、认证功能，等等。<br>​<span id="more"></span></p>
<h3 id="单体系统时代"><a href="#单体系统时代" class="headerlink" title="单体系统时代"></a>单体系统时代</h3><p>顾名思义，就是一个程序代表全部系统。单体不仅易于开发、易于测试、易于部署，且由于系统中各个功能、模块、方法的调用过程都是进程内调用，不会发生<strong>进程间通信</strong>（Inter-Process Communication，IPC。广义上讲，可以认为 RPC 属于 IPC 的一种特例，但请注意这里两个“PC”不是同个单词的缩写），因此也是运行效率最高的一种架构风格。单体系统的不足，必须基于软件的性能需求超过了单机，软件的开发人员规模明显超过了某种范畴的前提下才有讨论的价值。</p>
<h3 id="SOA时代"><a href="#SOA时代" class="headerlink" title="SOA时代"></a>SOA时代</h3><p><strong>面向服务的架构（SOA）</strong>是一个组件模型，它将应用程序的不同功能单元（称为服务）进行拆分，并通过这些服务之间定义良好的接口和协议联系起来。接口是采用中立的方式进行定义的，它应该独立于实现服务的硬件平台、操作系统和编程语言。这使得构建在各种各样的系统中的服务可以以一种统一和通用的方式进行交互。<br>为了对大型的单体系统进行拆分，让每一个子系统都能独立地部署、运行、更新，开发者们曾经尝试过多种方案，这里列举以下三种较有代表性的架构模式，具体如下。</p>
<ul>
<li><strong>烟囱式架构（Information Silo Architecture）</strong>：信息烟囱又名信息孤岛（Information Island），使用这种架构的系统也被称为孤岛式信息系统或者烟囱式信息系统。它指的是一种完全不与其他相关信息系统进行互操作或者协调工作的设计模式。这样的系统其实并没有什么“架构设计”可言。接着上一节中企业与部门的例子来说，如果两个部门真的完全不会发生任何交互，就并没有什么理由强迫它们必须在一栋楼里办公；两个不发生交互的信息系统，让它们使用独立的数据库和服务器即可实现拆分，而唯一的问题，也是致命的问题是，企业中真的存在完全不发生交互的部门吗？对于两个信息系统来说，哪怕真的毫无业务往来关系，但系统的人员、组织、权限等主数据，会是完全独立、没有任何重叠的吗？这样“独立拆分”“老死不相往来”的系统，显然不可能是企业所希望见到的。</li>
<li><strong>微内核架构（Microkernel Architecture）</strong>：微内核架构也被称为插件式架构（Plug-in Architecture）。既然在烟囱式架构中，没有业务往来关系的系统也可能需要共享人员、组织、权限等一些的公共的主数据，那不妨就将这些主数据，连同其他可能被各子系统使用到的公共服务、数据、资源集中到一块，成为一个被所有业务系统共同依赖的核心（Kernel，也称为 Core System），具体的业务系统以插件模块（Plug-in Modules）的形式存在，这样也可提供可扩展的、灵活的、天然隔离的功能特性，即微内核架构。<br>这种模式很适合桌面应用程序，也经常在 Web 应用程序中使用。任何计算机系统都是由各种软件互相配合工作来实现具体功能的，本节列举的不同架构实现的软件，都可视作整个系统的某种插件。对于平台型应用来说，如果我们希望将新特性或者新功能及时加入系统，微内核架构会是一种不错的方案。微内核架构也可以嵌入到其他的架构模式之中，通过插件的方式来提供新功能的定制开发能力，如果你准备实现一个能够支持二次开发的软件系统，微内核也会是一种良好的选择。<br>不过，微内核架构也有它的局限和使用前提，它假设系统中各个插件模块之间是互不认识，不可预知系统将安装哪些模块，因此这些插件可以访问内核中一些公共的资源，但不会直接交互。可是，无论是企业信息系统还是互联网应用，这一前提假设在许多场景中都并不成立，我们必须找到办法，既能拆分出独立的系统，也能让拆分后的子系统之间顺畅地互相调用通信。</li>
<li><strong>事件驱动架构（Event-Driven Architecture）</strong>：为了能让子系统互相通信，一种可行的方案是在子系统之间建立一套事件队列管道（Event Queues），来自系统外部的消息将以事件的形式发送至管道中，各个子系统从管道里获取自己感兴趣、能够处理的事件消息，也可以为事件新增或者修改其中的附加信息，甚至可以自己发布一些新的事件到管道队列中去，如此，每一个消息的处理者都是独立的，高度解耦的，但又能与其他处理者（如果存在该消息处理者的话）通过事件管道进行互动。</li>
</ul>
<p>​</p>
<p>软件架构来到 <strong>SOA 时代</strong>，许多概念、思想都已经能在今天微服务中找到对应的身影了，譬如服务之间的<strong>注册、发现、治理，隔离、编排</strong>等等。这些在今天微服务中耳熟能详的名词概念，大多数也是在分布式服务刚被提出时就已经可以预见的困难点。SOA 针对这些问题，甚至是针对“软件开发”这件事情本身，都进行了更加系统性、更加具体的探索。<br>尽管 SOA 本身还是属抽象概念，而不是特指某一种具体的技术，但它比单体架构和前面所列举的三种架构模式的操作性要更强，已经不能简单视其为一种架构风格，而是可以称为一套软件设计的基础平台了。</p>
<ul>
<li>它拥有领导制定技术标准的组织 <strong>Open CSA</strong>；</li>
<li>有清晰软件设计的指导原则，譬如服务的封装性、自治、松耦合、可重用、可组合、无状态，等等；明确了采用 SOAP 作为远程调用的协议，依靠 **SOAP 协议族（WSDL、UDDI 和一大票 WS-*协议）**来完成服务的发布、发现和治理；</li>
<li>利用一个被称为企业服务总线（Enterprise Service Bus，<strong>ESB</strong>）的消息管道来实现各个子系统之间的通信交互，令各服务间在 ESB 调度下无须相互依赖却能相互通信，既带来了服务松耦合的好处，也为以后可以进一步实施业务流程编排（Business Process Management，BPM）提供了基础；</li>
<li>使用服务数据对象（Service Data Object，<strong>SDO</strong>）来访问和表示数据</li>
<li>使用服务组件架构（Service Component Architecture，<strong>SCA</strong>）来定义服务封装的形式和服务运行的容器。</li>
</ul>
<p>​</p>
<p>在这一整套成体系可以互相精密协作的技术组件支持下，若仅从技术可行性这一个角度来评判的话，SOA 可以算是成功地解决了分布式环境下出现的主要技术问题。<br>SOA 的终极目标是希望总结出一套<strong>自上而下的软件研发方法论</strong>，希望做到企业只需要跟着 SOA 的思路，就能够一揽子解决掉软件开发过程中的全部问题，譬如该如何挖掘需求、如何将需求分解为业务能力、如何编排已有服务、如何开发测试部署新的功能，等等。这里面技术问题确实是重点和难点，但也仅仅是其中的一个方面，SOA 不仅关注技术，还关注研发过程中涉及到的需求、管理、流程和组织。如果这个目标真的能够达成，软件开发就有可能从此迈进工业化大生产的阶段，试想如果有一天写出符合客户需求的软件会像写八股文一样有迹可循、有法可依，那对软件开发者来说也许是无趣的，但整个社会实施信息化的效率肯定会有大幅的提升。<br>SOA 在 21 世纪最初的十年里曾经盛行一时，有 IBM 等一众行业巨头厂商为其呐喊冲锋，吸引了不少软件开发商、尤其是企业级软件的开发商的跟随，最终却还是偃旗息鼓，沉寂了下去。在稍后的远程服务调用一节，笔者会提到 SOAP 协议被逐渐边缘化的本质原因：<strong>过于严格的规范定义带来过度的复杂性</strong>。而构建在 SOAP 基础之上的 ESB、BPM、SCA、SDO 等诸多上层建筑，进一步加剧了这种复杂性。开发信息系统毕竟不是作八股文章，<strong>过于精密的流程和理论</strong>也需要懂得复杂概念的专业人员才能够驾驭。SOA 诞生的那一天起，就已经注定了它只能是少数系统阳春白雪式的精致奢侈品，它可以实现多个异构大型系统之间的复杂集成交互，却很难作为一种具有广泛普适性的软件架构风格来推广。</p>
<h3 id="微服务时代"><a href="#微服务时代" class="headerlink" title="微服务时代"></a>微服务时代</h3><p>微服务是一种通过多个小型服务组合来构建单个应用的架构风格，这些服务围绕业务能力而非特定的技术标准来构建。各个服务可以采用不同的编程语言，不同的数据存储技术，运行在不同的进程之中。服务采取轻量级的通信机制和自动化的部署机制实现通信与运维。<br>微服务的概念提出后，在将近十年的时间里面，并没有受到太多的追捧。如果只是对现有 SOA 架构的修修补补，确实难以唤起广大技术人员的更多激情。<br>微服务真正的崛起是在 2014 年，相信阅读此文的大多数读者，也是从 Martin Fowler 与 James Lewis 合写的文章《Microservices: A Definition of This New Architectural Term》中首次了解到微服务的。文中列举了微服务的九个核心的业务与技术特征，下面将其一一列出并解读。</p>
<ul>
<li><strong>围绕业务能力构建（Organized around Business Capability）</strong>。这里再次强调了康威定律的重要性，有怎样结构、规模、能力的团队，就会产生出对应结构、规模、能力的产品。这个结论不是某个团队、某个公司遇到的巧合，而是必然的演化结果。如果本应该归属同一个产品内的功能被划分在不同团队中，必然会产生大量的跨团队沟通协作，跨越团队边界无论在管理、沟通、工作安排上都有更高昂的成本，高效的团队自然会针对其进行改进，当团队、产品磨合调节稳定之后，团队与产品就会拥有一致的结构。</li>
<li><strong>分散治理（Decentralized Governance）</strong>。这是要表达“谁家孩子谁来管”的意思，服务对应的开发团队有直接对服务运行质量负责的责任，也应该有着不受外界干预地掌控服务各个方面的权力，譬如选择与其他服务异构的技术来实现自己的服务。这一点在真正实践时多少存有宽松的处理余地，大多数公司都不会在某一个服务使用 Java，另一个用 Python，下一个用 Golang，而是通常会有统一的主流语言，乃至统一的技术栈或专有的技术平台。微服务不提倡也并不反对这种“统一”，只要负责提供和维护基础技术栈的团队，有被各方依赖的觉悟，要有“经常被凌晨 3 点的闹钟吵醒”的心理准备就好。微服务更加强调的是确实有必要技术异构时，应能够有选择“不统一”的权利，譬如不应该强迫 Node.js 去开发报表页面，要做人工智能训练模型时，应该可以选择 Python，等等。</li>
<li><strong>通过服务来实现独立自治的组件（Componentization via Services）</strong>。之所以强调通过“服务”（Service）而不是“类库”（Library）来构建组件，是因为类库在编译期静态链接到程序中，通过本地调用来提供功能，而服务是进程外组件，通过远程调用来提供功能。前面的文章里我们已经分析过，尽管远程服务有更高昂的调用成本，但这是为组件带来隔离与自治能力的必要代价。</li>
<li><strong>产品化思维（Products not Projects）</strong>。避免把软件研发视作要去完成某种功能，而是视作一种持续改进、提升的过程。譬如，不应该把运维只看作运维团队的事，把开发只看作开发团队的事，团队应该为软件产品的整个生命周期负责，开发者不仅应该知道软件如何开发，还应该知道它如何运作，用户如何反馈，乃至售后支持工作是怎样进行的。注意，这里服务的用户不一定是最终用户，也可能是消费这个服务的另外一个服务。以前在单体架构下，程序的规模决定了无法让全部人员都关注完整的产品，组织中会有开发、运维、支持等细致的分工的成员，各人只关注于自己的一块工作，但在微服务下，要求开发团队中每个人都具有产品化思维，关心整个产品的全部方面是具有可行性的。</li>
<li><strong>数据去中心化（Decentralized Data Management）</strong>。微服务明确地提倡数据应该按领域分散管理、更新、维护、存储，在单体服务中，一个系统的各个功能模块通常会使用同一个数据库，诚然中心化的存储天生就更容易避免一致性问题，但是，同一个数据实体在不同服务的视角里，它的抽象形态往往也是不同的。譬如，Bookstore 应用中的书本，在销售领域中关注的是价格，在仓储领域中关注的库存数量，在商品展示领域中关注的是书籍的介绍信息，如果作为中心化的存储，所有领域都必须修改和映射到同一个实体之中，这便使得不同的服务很可能会互相产生影响而丧失掉独立性。尽管在分布式中要处理好一致性的问题也相当困难，很多时候都没法使用传统的事务处理来保证，但是两害相权取其轻，有一些必要的代价仍是值得付出的。</li>
<li><strong>强终端弱管道（Smart Endpoint and Dumb Pipe</strong>）。弱管道（Dumb Pipe）几乎算是直接指名道姓地反对 SOAP 和 ESB 的那一堆复杂的通信机制。ESB 可以处理消息的编码加工、业务规则转换等；BPM 可以集中编排企业业务服务；SOAP 有几十个 WS-*协议族在处理事务、一致性、认证授权等一系列工作，这些构筑在通信管道上的功能也许对某个系统中的某一部分服务是有必要的，但对于另外更多的服务则是强加进来的负担。如果服务需要上面的额外通信能力，就应该在服务自己的 Endpoint 上解决，而不是在通信管道上一揽子处理。微服务提倡类似于经典 UNIX 过滤器那样简单直接的通信方式，RESTful 风格的通信在微服务中会是更加合适的选择。</li>
<li><strong>容错性设计（Design for Failure）</strong>。不再虚幻地追求服务永远稳定，而是接受服务总会出错的现实，要求在微服务的设计中，有自动的机制对其依赖的服务能够进行快速故障检测，在持续出错的时候进行隔离，在服务恢复的时候重新联通。所以“断路器”这类设施，对实际生产环境的微服务来说并不是可选的外围组件，而是一个必须的支撑点，如果没有容错性的设计，系统很容易就会被因为一两个服务的崩溃所带来的雪崩效应淹没。可靠系统完全可能由会出错的服务组成，这是微服务最大的价值所在，也是这部开源文档标题“凤凰架构”的含义。</li>
<li><strong>演进式设计（Evolutionary Design）</strong>。容错性设计承认服务会出错，演进式设计则是承认服务会被报废淘汰。一个设计良好的服务，应该是能够报废的，而不是期望得到长存永生。假如系统中出现不可更改、无可替代的服务，这并不能说明这个服务是多么的优秀、多么的重要，反而是一种系统设计上脆弱的表现，微服务所追求的独立、自治，也是反对这种脆弱性的表现。</li>
<li><strong>基础设施自动化（Infrastructure Automation）</strong>。基础设施自动化，如 CI/CD 的长足发展，显著减少了构建、发布、运维工作的复杂性。由于微服务下运维的对象比起单体架构要有数量级的增长，使用微服务的团队更加依赖于基础设施的自动化，人工是很难支撑成百上千乃至成千上万级别的服务的。</li>
</ul>
<p>​</p>
<p>微服务所带来的自由是一把双刃开锋的宝剑，当软件架构者拿起这把宝剑，一刃指向 SOA 定下的复杂技术标准，将选择的权力夺回的同一时刻，另外一刃也正朝向着自己映出冷冷的寒光。微服务时代中，软件研发本身的复杂度应该说是有所降低。一个简单服务，并不见得就会同时面临分布式中所有的问题，也就没有必要背上 SOA 那百宝袋般沉重的技术包袱。需要解决什么问题，就引入什么工具；团队熟悉什么技术，就使用什么框架。此外，像 Spring Cloud 这样的胶水式的全家桶工具集，通过一致的接口、声明和配置，进一步屏蔽了源自于具体工具、框架的复杂性，降低了在不同工具、框架之间切换的成本，所以，作为一个普通的服务开发者，作为一个“螺丝钉”式的程序员，微服务架构是友善的。可是，微服务对架构者是满满的恶意，对架构能力要求已提升到史无前例的程度，笔者在这部文档的多处反复强调过，技术架构者的第一职责就是做决策权衡，有利有弊才需要决策，有取有舍才需要权衡，如果架构者本身的知识面不足以覆盖所需要决策的内容，不清楚其中利弊，恐怕也就无可避免地陷入选择困难症的困境之中。<br>​</p>
<h3 id="后微服务时代"><a href="#后微服务时代" class="headerlink" title="后微服务时代"></a>后微服务时代</h3><p>从软件层面独力应对微服务架构问题，发展到软、硬一体，合力应对架构问题的时代，此即为“后微服务时代”。<br>2017 年是容器生态发展历史中具有里程碑意义的一年。在这一年，各个关键厂家都提出使用Kubernetes ，Kubernetes 登基加冕是容器发展中一个时代的终章，也将是软件架构发展下一个纪元的开端。<br>Kubernetes 成为容器战争胜利者标志着后微服务时代的开端，但 Kubernetes 仍然没有能够完美解决全部的分布式问题——“不完美”的意思是，仅从功能上看，单纯的 Kubernetes 反而不如之前的 Spring Cloud 方案。这是因为有一些问题处于应用系统与基础设施的边缘，使得完全在基础设施层面中确实很难精细化地处理。<br>为了解决这一类问题，虚拟化的基础设施很快完成了第二次进化，引入了今天被称为<strong>服务网格（Service Mesh）</strong>的<strong>边车代理模式（Sidecar Proxy）</strong>，代表性如istio。所谓的边车是由系统自动在服务容器（通常是指 Kubernetes 的 Pod）中注入一个通信代理服务器，以类似网络安全里中间人攻击的方式进行流量劫持，在应用毫无感知的情况下，悄然接管应用所有对外通信。这个代理除了实现正常的服务间通信外（称为数据平面通信），还接收来自控制器的指令（称为控制平面通信），根据控制平面中的配置，对数据平面通信的内容进行分析处理，以实现熔断、认证、度量、监控、负载均衡等各种附加功能。这样便实现了既不需要在应用层面加入额外的处理代码，也提供了几乎不亚于程序代码的精细管理能力。<br><img data-src="https://gitee.com/littleeight/blog-images/raw/master/%E5%AF%B9%E4%BA%8E%E6%9E%B6%E6%9E%84%E7%9A%84%E6%B7%B1%E5%85%A5%E6%8E%A2%E8%AE%A8/1.png"></p>
<p>未来 Kubernetes 将会成为服务器端标准的运行环境，如同现在 Linux 系统；服务网格将会成为微服务之间通信交互的主流模式，把“选择什么通信协议”、“怎样调度流量”、“如何认证授权”之类的技术问题隔离于程序代码之外，取代今天 Spring Cloud 全家桶中大部分组件的功能，微服务只需要考虑业务本身的逻辑，这才是最理想的Smart Endpoints解决方案。</p>
<h3 id="无服务时代"><a href="#无服务时代" class="headerlink" title="无服务时代"></a>无服务时代</h3><p>无服务的愿景是让开发者只需要纯粹地关注业务，不需要考虑技术组件，后端的技术组件是现成的，可以直接取用，没有采购、版权和选型的烦恼；不需要考虑如何部署，部署过程完全是托管到云端的，工作由云端自动完成；不需要考虑算力，有整个数据中心支撑，算力可以认为是无限的；也不需要操心运维，维护系统持续平稳运行是云计算服务商的责任而不再是开发者的责任。在 UC Berkeley 的论文中，把无服务架构下开发者不再关心这些技术层面的细节，类比成当年软件开发从汇编语言踏进高级语言的发展过程，开发者可以不去关注寄存器、信号、中断等与机器底层相关的细节，从而令生产力得到极大地解放。<br>无服务架构的远期前景看起来是很美好的，但笔者自己对无服务中短期内的发展并没有那么乐观。与单体架构、微服务架构不同，无服务架构有一些天生的特点决定了它现在不是，以后如果没有重大变革的话，估计也很难成为一种普适性的架构模式。无服务架构对一些适合的应用确实能够降低开发和运维环节的成本，譬如不需要交互的离线大规模计算，又譬如多数 Web 资讯类网站、小程序、公共 API 服务、移动应用服务端等都契合于无服务架构所擅长的短链接、无状态、适合事件驱动的交互形式；但另一方面，对于那些信息管理系统、网络游戏等应用，又或者说所有具有业务逻辑复杂，依赖服务端状态，响应速度要求较高，需要长链接等这些特征的应用，至少目前是相对并不适合的。这是因为无服务天生“无限算力”的假设决定了它必须要按使用量（函数运算的时间和占用的内存）计费以控制消耗算力的规模，因而函数不会一直以活动状态常驻服务器，请求到了才会开始运行，这导致了函数不便依赖服务端状态，也导致了函数会有冷启动时间，响应的性能不可能太好（目前无服务的冷启动过程大概是在数十到百毫秒级别，对于 Java 这类启动性能差的应用，甚至能到接近秒的级别）。<br>​</p>
<p>​</p>
<h2 id="架构中的微服务"><a href="#架构中的微服务" class="headerlink" title="架构中的微服务"></a>架构中的微服务</h2><h3 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h3><p>所有的远程服务调用都是使用<strong>全限定名</strong>（Fully Qualified Domain Name，<a href="https://en.wikipedia.org/wiki/Fully_qualified_domain_name">FQDN</a>）、<strong>端口号</strong>与<strong>服务标识</strong>所构成的三元组来确定一个远程服务的精确坐标的。全限定名代表了网络中某台主机的精确位置，端口代表了主机上某一个提供了 TCP/UDP 网络服务的程序，服务标识则代表了该程序所提供的某个具体的方法入口。其中“全限定名、端口号”的含义对所有的远程服务来说都一致，而“服务标识”则与具体的应用层协议相关，不同协议具有不同形式的标识，譬如 REST 的远程服务，标识是 URL 地址；RMI 的远程服务，标识是 Stub 类中的方法；SOAP 的远程服务，标识是 WSDL 中定义方法，等等。远程服务标识的多样性，决定了“服务发现”也可以有两种不同的理解，一种是以 UDDI 为代表的“百科全书式”的服务发现，上至提供服务的企业信息（企业实体、联系地址、分类目录等等），下至服务的程序接口细节（方法名称、参数、返回值、技术规范等等）都在服务发现的管辖范围之内；另一种是类似于 DNS 这样“门牌号码式”的服务发现，只满足从某个代表服务提供者的全限定名到服务实际主机 IP 地址的翻译转换，并不关心服务具体是哪个厂家提供的，也不关心服务有几个方法，各自由什么参数构成，默认这些细节信息是服务消费者本身已完全了解的，此时服务坐标就可以退化为更简单的“全限定名+端口号”。当今，后一种服务发现占主流地位，本文后续所说的服务发现，如无说明，均是特指的是后者。<br>人们最初是尝试使用 ZooKeeper 这样的分布式 K/V 框架，通过软件自身来完成服务注册与发现，ZooKeeper 也的确曾短暂统治过远程服务发现，是微服务早期的主流选择，但毕竟 ZooKeeper 是很底层的分布式工具，用户自己还需要做相当多的工作才能满足服务发现的需求。到了 2014 年，在 Netflix 内部经受过长时间实际考验的、专门用于服务发现的 Eureka 宣布开源，并很快被纳入 Spring Cloud，成为 Spring 默认的远程服务发现的解决方案。从此 Java 程序员再无须再在服务注册这件事情上花费太多的力气。到 2018 年，Spring Cloud Eureka 进入维护模式以后，HashiCorp 的 Consul 和阿里巴巴的 Nacos 很就快从 Eureka 手上接过传承的衣钵。<br>服务发现的具体操作：</p>
<ul>
<li><strong>服务的注册</strong>（Service Registration）：当服务启动的时候，它应该通过某些形式（如调用 API、产生事件消息、在 ZooKeeper/Etcd 的指定位置记录、存入数据库，等等）将自己的坐标信息通知到服务注册中心，这个过程可能由应用程序本身来完成，称为自注册模式，譬如 Spring Cloud 的@EnableEurekaClient 注解；也可能有容器编排框架或第三方注册工具来完成，称为第三方注册模式，譬如 Kubernetes 和 Registrator。</li>
<li><strong>服务的维护</strong>（Service Maintaining）：尽管服务发现框架通常都有提供下线机制，但并没有什么办法保证每次服务都能优雅地下线（Graceful Shutdown）而不是由于宕机、断网等原因突然失联。所以服务发现框架必须要自己去保证所维护的服务列表的正确性，以避免告知消费者服务的坐标后，得到的服务却不能使用的尴尬情况。现在的服务发现框架，往往都能支持多种协议（HTTP、TCP 等）、多种方式（长连接、心跳、探针、进程状态等）去监控服务是否健康存活，将不健康的服务自动从服务注册表中剔除。</li>
<li><strong>服务的发现</strong>（Service Discovery）：这里的发现是特指狭义上消费者从服务发现框架中，把一个符号（譬如 Eureka 中的 ServiceID、Nacos 中的服务名、或者通用的 FQDN）转换为服务实际坐标的过程，这个过程现在一般是通过 HTTP API 请求或者通过 DNS Lookup 操作来完成，也还有一些相对少用的方式，譬如 Kubernetes 也支持注入环境变量来做服务发现。</li>
</ul>
<p>​</p>
<p>以上三点只是列举了服务发现必须提供的功能，从 <strong>CAP 定理</strong>开始，到分布式共识算法，我们已在理论上探讨过多次服务的可用和数据的可靠之间需有所取舍，但服务发现却面临着两者都难以舍弃的困境。<br>在真实的系统里，注册中心的地位是特殊的，不能为完全视其为一个普通的服务。注册中心不依赖其他服务，但被所有其他服务共同依赖，是系统中最基础的服务（类似地位的大概就数配置中心了，现在服务发现框架也开始同时提供配置中心的功能，以避免配置中心又去专门摆弄出一集群的节点来），几乎没有可能在业务层面进行容错。这意味着服务注册中心一旦崩溃，整个系统都不再可用，因此，必须尽最大努力保证服务发现的可用性。实际用于生产的分布式系统，服务注册中心都是以集群的方式进行部署的，通常使用三个或者五个节点（通常最多七个，一般也不会更多了，否则日志复制的开销太高）来保证高可用，如图 7-2 所示：<br><img data-src="https://gitee.com/littleeight/blog-images/raw/master/%E5%AF%B9%E4%BA%8E%E6%9E%B6%E6%9E%84%E7%9A%84%E6%B7%B1%E5%85%A5%E6%8E%A2%E8%AE%A8/2.png"></p>
<p>同时，也请注意到上图中各服务注册中心节点之间的“Replicate”字样，作为用户，我们当然期望服务注册中心一直可用永远健康的同时，也能够在访问每一个节点中都能取到可靠一致的数据，而不是从注册中心拿到的服务地址可能已经下线，这两个需求就构成了 CAP 矛盾，不可能同时满足。以最有代表性的 Netflix Eureka 和 Hashicorp Consul 为例：<br>Eureka 的选择是优先保证高可用性，相对牺牲系统中服务状态的一致性。Eureka 的各个节点间采用异步复制来交换服务注册信息，当有新服务注册进来时，并不需要等待信息在其他节点复制完成，而是马上在该服务发现节点宣告服务可见，只是不保证在其他节点上多长时间后才会可见。同时，当有旧的服务发生变动，譬如下线或者断网，只会由超时机制来控制何时从哪一个服务注册表中移除，变动信息不会实时的同步给所有服务端与客户端。这样的设计使得不论是 Eureka 的服务端还是客户端，都能够持有自己的服务注册表缓存，并以 TTL（Time to Live）机制来进行更新，哪怕服务注册中心完全崩溃，客户端在仍然可以维持最低限度的可用。Eureka 的服务发现模型对节点关系相对固定，服务一般不会频繁上下线的系统是很合适的，以较小的同步代价换取了最高的可用性；Eureka 能够选择这种模型的底气在于万一客户端拿到了已经发生变动的错误地址，也能够通过 Ribbon 和 Hystrix 模块配合来兜底，实现故障转移（Failover）或者快速失败（Failfast）。<br>Consul 的选择是优先保证高可靠性，相对牺牲系统服务发现的可用性。Consul 采用<strong>Raft 算法</strong>，要求多数派节点写入成功后服务的注册或变动才算完成，严格地保证了在集群外部读取到的服务发现结果必定是一致的；同时采用 Gossip 协议，支持多数据中心之间更大规模的服务同步。Consul 优先保证高可靠性一定程度上是基于产品现实情况而做的技术决策，它不像 Netflix OSS 那样有着全家桶式的微服务组件，万一从服务发现中取到错误地址，就没有其他组件为它兜底了。</p>
<h3 id="服务治理"><a href="#服务治理" class="headerlink" title="服务治理"></a>服务治理</h3><h4 id="服务容错"><a href="#服务容错" class="headerlink" title="服务容错"></a>服务容错</h4><p>容错性设计不能妥协源于分布式系统的本质是不可靠的，一个大的服务集群中，程序可能崩溃、节点可能宕机、网络可能中断，这些“意外情况”其实全部都在“意料之中”。原本信息系统设计成分布式架构的主要动力之一就是为了提升系统的可用性，最低限度也必须保证将原有系统重构为分布式架构之后，可用性不出现倒退下降才行。如果服务集群中出现任何一点差错都能让系统面临“千里之堤溃于蚁穴”的风险，那分布式恐怕就根本没有机会成为一种可用的系统架构形式。<br>要落实容错性设计这条原则，除了思想观念上转变过来，正视程序必然是会出错的，对它进行有计划的防御之外，还必须了解一些常用的<strong>容错策略</strong>和<strong>容错设计模式</strong>，作为具体设计与编码实践的指导。这里容错策略指的是“面对故障，我们该做些什么”，稍后将讲解的容错设计模式指的是“要实现某种容错策略，我们该如何去做”。常见的容错策略有以下几种：</p>
<ul>
<li><strong>故障转移</strong>（Failover）：高可用的服务集群中，多数的服务——尤其是那些经常被其他服务所依赖的关键路径上的服务，均会部署多有个副本。这些副本可能部署在不同的节点（避免节点宕机）、不同的网络交换机（避免网络分区）甚至是不同的可用区（避免整个地区发生灾害或电力、骨干网故障）中。故障转移是指如果调用的服务器出现故障，系统不会立即向调用者返回失败结果，而是自动切换到其他服务副本，尝试其他副本能否返回成功调用的结果，从而保证了整体的高可用性。<br>故障转移的容错策略应该有一定的调用次数限制，譬如允许最多重试三个服务，如果都发生报错，那还是会返回调用失败。原因不仅是因为重试是有执行成本的，更是因为过度的重试反而可能让系统处于更加不利的状况。譬如有以下调用链：Service A → Service B → Service C 。 假设 A 的超时阈值为 100 毫秒，而 B 调用 C 花费 60 毫秒，然后不幸失败了，这时候做故障转移其实已经没有太大意义了，因为即时下一次调用能够返回正确结果，也很可能同样需要耗费 60 毫秒时间，时间总和就已经触及 A 服务的超时阈值，所以在这种情况下故障转移反而对系统是不利的。</li>
</ul>
<p>​</p>
<ul>
<li><strong>快速失败</strong>（Failfast）：还有另外一些业务场景是不允许做故障转移的，故障转移策略能够实施的前提是要求服务具备幂等性，对于非幂等的服务，重复调用就可能产生脏数据，引起的麻烦远大于单纯的某次服务调用失败，此时就应该以快速失败作为首选的容错策略。譬如，在支付场景中，需要调用银行的扣款接口，如果该接口返回的结果是网络异常，程序是很难判断到底是扣款指令发送给银行时出现的网络异常，还是银行扣款后返回结果给服务时出现的网络异常的。为了避免重复扣款，此时最恰当可行的方案就是尽快让服务报错，坚决避免重试，尽快抛出异常，由调用者自行处理。</li>
<li><strong>安全失败</strong>（Failsafe）：在一个调用链路中的服务通常也有主路和旁路之分，并不见得其中每个服务都是不可或缺的，有部分服务失败了也不影响核心业务的正确性。譬如开发基于 Spring 管理的应用程序时，通过扩展点、事件或者 AOP 注入的逻辑往往就属于旁路逻辑，典型的有审计、日志、调试信息，等等。属于旁路逻辑的另一个显著特征是后续处理不会依赖其返回值，或者它的返回值是什么都不会影响后续处理的结果，譬如只是将返回值记录到数据库，并不使用它参与最终结果的运算。对这类逻辑，一种理想的容错策略是即使旁路逻辑调用实际失败了，也当作正确来返回，如果需要返回值的话，系统就自动返回一个符合要求的数据类型的对应零值，然后自动记录一条服务调用出错的日志备查即可，这种策略被称为安全失败。</li>
<li><strong>沉默失败</strong>（Failsilent）：如果大量的请求需要等到超时（或者长时间处理后）才宣告失败，很容易由于某个远程服务的请求堆积而消耗大量的线程、内存、网络等资源，进而影响到整个系统的稳定。面对这种情况，一种合理的失败策略是当请求失败后，就默认服务提供者一定时间内无法再对外提供服务，不再向它分配请求流量，将错误隔离开来，避免对系统其他部分产生影响，此即为沉默失败策略。</li>
<li><strong>故障恢复</strong>（Failback）：故障恢复一般不单独存在，而是作为其他容错策略的补充措施，一般在微服务管理框架中，如果设置容错策略为故障恢复的话，通常默认会采用快速失败加上故障恢复的策略组合。它是指当服务调用出错了以后，将该次调用失败的信息存入一个消息队列中，然后由系统自动开始异步重试调用。<br>故障恢复策略一方面是尽力促使失败的调用最终能够被正常执行，另一方面也可以为服务注册中心和负载均衡器及时提供服务恢复的通知信息。故障恢复显然也是要求服务必须具备幂等性的，由于它的重试是后台异步进行，即使最后调用成功了，原来的请求也早已经响应完毕，所以故障恢复策略一般用于对实时性要求不高的主路逻辑，同时也适合处理那些不需要返回值的旁路逻辑。为了避免在内存中异步调用任务堆积，故障恢复与故障转移一样，应该有最大重试次数的限制。</li>
<li><strong>并行调用</strong>（Forking）：上面五种以“Fail”开头的策略是针对调用失败时如何进行弥补的，以下这两种策略则是在调用之前就开始考虑如何获得最大的成功概率。并行调用策略很符合人们日常对一些重要环节进行的“双重保险”或者“多重保险”的处理思路，它是指一开始就同时向多个服务副本发起调用，只要有其中任何一个返回成功，那调用便宣告成功，这是一种在关键场景中使用更高的执行成本换取执行时间和成功概率的策略。</li>
<li><strong>广播调用</strong>（Broadcast）：广播调用与并行调用是相对应的，都是同时发起多个调用，但并行调用是任何一个调用结果返回成功便宣告成功，广播调用则是要求所有的请求全部都成功，这次调用才算是成功，任何一个服务提供者出现异常都算调用失败，广播调用通常会被用于实现“刷新分布式缓存”这类的操作。</li>
</ul>
<p>容错策略并非计算机科学独有的，在交通、能源、航天等很多领域都有容错性设计，也会使用到上面这些策略，并在自己的行业领域中进行解读与延伸。这里介绍到的容错策略并非全部，只是最常见的几种，笔者将它们各自的优缺点、应用场景总结为表 ，供大家使用时参考：<br><img data-src="https://gitee.com/littleeight/blog-images/raw/master/%E5%AF%B9%E4%BA%8E%E6%9E%B6%E6%9E%84%E7%9A%84%E6%B7%B1%E5%85%A5%E6%8E%A2%E8%AE%A8/3.png"></p>
<p>为了实现各种各样的容错策略，开发人员总结出了一些被实践证明是有效的服务容错设计模式，譬如微服务中常见的<strong>断路器模式、舱壁隔离模式，重试模式</strong>，等等。</p>
<h5 id="断路器模式"><a href="#断路器模式" class="headerlink" title="断路器模式"></a>断路器模式</h5><p>断路器模式是微服务架构中最基础的容错设计模式，以至于像 Hystrix 这种服务治理工具往往被人们忽略了它的服务隔离、请求合并、请求缓存等其他服务治理职能，直接将它称之为微服务断路器或者熔断器。断路器的基本思路是很简单的，就是通过代理（断路器对象）来一对一地（一个远程服务对应一个断路器对象）地接管服务调用者的远程请求。断路器会持续监控并统计服务返回的成功、失败、超时、拒绝等各种结果，当出现故障（失败、超时、拒绝）的次数达到断路器的阈值时，它状态就自动变为“OPEN”，后续此断路器代理的远程访问都将直接返回调用失败，而不会发出真正的远程服务请求。通过断路器对远程服务的熔断，避免因持续的失败或拒绝而消耗资源，因持续的超时而堆积请求，最终的目的就是避免雪崩效应的出现。由此可见，断路器本质是一种快速失败策略的实现方式，它的工作过程可以通过下面图来表示：<br><img data-src="https://gitee.com/littleeight/blog-images/raw/master/%E5%AF%B9%E4%BA%8E%E6%9E%B6%E6%9E%84%E7%9A%84%E6%B7%B1%E5%85%A5%E6%8E%A2%E8%AE%A8/4.png"></p>
<p>从调用序列来看，断路器就是一种有限状态机，断路器模式就是根据自身状态变化自动调整代理请求策略的过程。一般要设置以下三种断路器的状态：</p>
<ul>
<li><strong>CLOSED</strong>：表示断路器关闭，此时的远程请求会真正发送给服务提供者。断路器刚刚建立时默认处于这种状态，此后将持续监视远程请求的数量和执行结果，决定是否要进入 OPEN 状态。</li>
<li><strong>OPEN</strong>：表示断路器开启，此时不会进行远程请求，直接给服务调用者返回调用失败的信息，以实现快速失败策略。</li>
<li><strong>HALF OPEN</strong>：这是一种中间状态。断路器必须带有自动的故障恢复能力，当进入 OPEN 状态一段时间以后，将“自动”（一般是由下一次请求而不是计时器触发的，所以这里自动带引号）切换到 HALF OPEN 状态。该状态下，会放行一次远程调用，然后根据这次调用的结果成功与否，转换为 CLOSED 或者 OPEN 状态，以实现断路器的弹性恢复。</li>
</ul>
<p>这些状态的转换逻辑与条件如图所示：<br><img data-src="https://gitee.com/littleeight/blog-images/raw/master/%E5%AF%B9%E4%BA%8E%E6%9E%B6%E6%9E%84%E7%9A%84%E6%B7%B1%E5%85%A5%E6%8E%A2%E8%AE%A8/5.png"></p>
<p>OPEN 和 CLOSED 状态的含义是十分清晰的，与我们日常生活中电路的断路器并没有什么差别，值得讨论的是这两者的转换条件是什么？最简单直接的方案是只要遇到一次调用失败，那就默认以后所有的调用都会接着失败，断路器直接进入 OPEN 状态，但这样做的效果是很差的，虽然避免了故障扩散和请求堆积，却使得外部看来系统将表现极其不稳定。现实中，比较可行的办法是在以下两个条件同时满足时，断路器状态转变为 OPEN：</p>
<ul>
<li>一段时间（譬如 10 秒以内）内请求数量达到一定阈值（譬如 20 个请求）。这个条件的意思是如果请求本身就很少，那就用不着断路器介入。</li>
<li>一段时间（譬如 10 秒以内）内请求的故障率（发生失败、超时、拒绝的统计比例）到达一定阈值（譬如 50%）。这个条件的意思是如果请求本身都能正确返回，也用不着断路器介入。</li>
</ul>
<p>以上两个条件<strong>同时</strong>满足时，断路器就会转变为 OPEN 状态。括号中举例的数值是 Netflix Hystrix 的默认值，其他服务治理的工具，譬如 Resilience4j、Envoy 等也同样会包含有类似的设置。<br>额外提到的是<strong>服务熔断</strong>和<strong>服务降级</strong>之间的联系与差别。断路器做的事情是自动进行服务熔断，这是一种快速失败的容错策略的实现方法。在快速失败策略明确反馈了故障信息给上游服务以后，上游服务必须能够主动处理调用失败的后果，而不是坐视故障扩散，这里的“处理”指的就是一种典型的服务降级逻辑，降级逻辑可以包括，但不应该仅仅限于是把异常信息抛到用户界面去，而应该尽力想办法通过其他路径解决问题，譬如把原本要处理的业务记录下来，留待以后重新处理是最低限度的通用降级逻辑。举个例子：你女朋友有事想召唤你，打你手机没人接，响了几声气冲冲地挂断后（快速失败），又打了你另外三个不同朋友的手机号（故障转移），都还是没能找到你（重试超过阈值）。这时候她生气地在微信上给你留言“三分钟不回电话就分手”，以此来与你取得联系。在这个不是太吉利的故事里，女朋友给你留言这个行为便是服务降级逻辑。<br>服务降级不一定是在出现错误后才被动执行的，许多场景里面，人们所谈论的降级更可能是指需要主动迫使服务进入降级逻辑的情况。譬如，出于应对可预见的峰值流量，或者是系统检修等原因，要关闭系统部分功能或关闭部分旁路服务，这时候就有可能会主动迫使这些服务降级。当然，此时服务降级就不一定是出于服务容错的目的了，更可能属于下一节要将的讲解的流量控制的范畴。<br>​</p>
<h5 id="舱壁隔离模式"><a href="#舱壁隔离模式" class="headerlink" title="舱壁隔离模式"></a>舱壁隔离模式</h5><p>介绍过服务熔断和服务降级，我们再来看看另一个微服务治理中常听见的概念：服务隔离。舱壁隔离模式是常用的实现服务隔离的设计模式，舱壁这个词是来自造船业的舶来品，它原本的意思是设计舰船时，要在每个区域设计独立的水密舱室，一旦某个舱室进水，也只是影响这个舱室中的货物，而不至于让整艘舰艇沉没。这种思想就很符合容错策略中失败静默策略。<br>我们来看一个具体的场景，当分布式系统所依赖的某个服务，譬如下图中的“服务 I”发生了超时，那在高流量的访问下——或者更具体点，假设平均 1 秒钟内对该服务的调用会发生 50 次，这就意味着该服务如果长时间不结束的话，每秒会有 50 条用户线程被阻塞。如果这样的访问量一直持续，我们按 Tomcat 默认的 HTTP 超时时间 20 秒来计算，20 秒内将会阻塞掉 1000 条用户线程，此后才陆续会有用户线程因超时被释放出来，回归 Tomcat 的全局线程池中。一般 Java 应用的线程池最大只会设置到 200 至 400 之间，这意味着此时系统在外部将表现为所有服务的全面瘫痪，而不仅仅是只有涉及到“服务 I”的功能不可用，因为 Tomcat 已经没有任何空余的线程来为其他请求提供服务了。<br><img data-src="https://gitee.com/littleeight/blog-images/raw/master/%E5%AF%B9%E4%BA%8E%E6%9E%B6%E6%9E%84%E7%9A%84%E6%B7%B1%E5%85%A5%E6%8E%A2%E8%AE%A8/6.png"></p>
<p>对于这类情况，一种可行的解决办法是为每个服务单独设立线程池，这些线程池默认不预置活动线程，只用来控制单个服务的最大连接数。譬如，对出问题的“服务 I”设置了一个最大线程数为 5 的线程池，这时候它的超时故障就只会最多阻塞 5 条用户线程，而不至于影响全局。此时，其他不依赖“服务 I”的用户线程依然能够正常对外提供服务，如图所示。<br><img data-src="https://gitee.com/littleeight/blog-images/raw/master/%E5%AF%B9%E4%BA%8E%E6%9E%B6%E6%9E%84%E7%9A%84%E6%B7%B1%E5%85%A5%E6%8E%A2%E8%AE%A8/7.png"></p>
<p>使用局部的线程池来控制服务的最大连接数有许多好处，当服务出问题时能够隔离影响，当服务恢复后，还可以通过清理掉局部线程池，瞬间恢复该服务的调用，而如果是 Tomcat 的全局线程池被占满，再恢复就会十分麻烦。但是，局部线程池有一个显著的弱点，它额外增加了 CPU 的开销，每个独立的线程池都要进行排队、调度和下文切换工作。根据 Netflix 官方给出的数据，一旦启用 Hystrix 线程池来进行服务隔离，大概会为每次服务调用增加约 3 毫秒至 10 毫秒的延时，如果调用链中有 20 次远程服务调用，那每次请求就要多付出 60 毫秒至 200 毫秒的代价来换取服务隔离的安全保障。<br>为应对这种情况，还有一种更轻量的可以用来控制服务最大连接数的办法：<strong>信号量机制</strong>（Semaphore）。如果不考虑清理线程池、客户端主动中断线程这些额外的功能，仅仅是为了控制一个服务并发调用的最大次数，可以只为每个远程服务维护一个线程安全的计数器即可，并不需要建立局部线程池。具体做法是当服务开始调用时计数器加 1，服务返回结果后计数器减 1，一旦计数器超过设置的阈值就立即开始限流，在回落到阈值范围之前都不再允许请求了。由于不需要承担线程的排队、调度、切换工作，所以单纯维护一个作为计数器的信号量的性能损耗，相对于局部线程池来说几乎可以忽略不计。</p>
<h5 id="重试模式"><a href="#重试模式" class="headerlink" title="重试模式"></a>重试模式</h5><p>故障转移和故障恢复策略都需要对服务进行重复调用，差别是这些重复调用有可能是同步的，也可能是后台异步进行；有可能会重复调用同一个服务，也可能会调用到服务的其他副本。无论具体是通过怎样的方式调用、调用的服务实例是否相同，都可以归结为重试设计模式的应用范畴。重试模式适合解决系统中的瞬时故障，简单的说就是有可能自己恢复（Resilient，称为自愈，也叫做回弹性）的临时性失灵，网络抖动、服务的临时过载（典型的如返回了 503 Bad Gateway 错误）这些都属于瞬时故障。重试模式实现并不困难，即使完全不考虑框架的支持，靠程序员自己编写十几行代码也能够完成。在实践中，重试模式面临的风险反而大多来源于太过简单而导致的滥用。我们判断是否应该且是否能够对一个服务进行重试时，应<strong>同时</strong>满足以下几个前提条件：</p>
<ul>
<li>仅在主路逻辑的关键服务上进行同步的重试，不是关键的服务，一般不把重试作为首选容错方案，尤其不该进行同步重试。</li>
<li>仅对由瞬时故障导致的失败进行重试。尽管一个故障是否属于可自愈的瞬时故障并不容易精确判定，但从 HTTP 的状态码上至少可以获得一些初步的结论，譬如，当发出的请求收到了 401 Unauthorized 响应，说明服务本身是可用的，只是你没有权限调用，这时候再去重试就没有什么意义。功能完善的服务治理工具会提供具体的重试策略配置（如 Envoy 的Retry Policy），可以根据包括 HTTP 响应码在内的各种具体条件来设置不同的重试参数。</li>
<li>仅对具备幂等性的服务进行重试。如果服务调用者和提供者不属于同一个团队，那服务是否幂等其实也是一个难以精确判断的问题，但仍可以找到一些总体上通用的原则。譬如，RESTful 服务中的 POST 请求是非幂等的，而 GET、HEAD、OPTIONS、TRACE 由于不会改变资源状态，这些请求应该被设计成幂等的；PUT 请求一般也是幂等的，因为 n 个 PUT 请求会覆盖相同的资源 n-1 次；DELETE 也可看作是幂等的，同一个资源首次删除会得到 200 OK 响应，此后应该得到 204 No Content 响应。这些都是 HTTP 协议中定义的通用的指导原则，虽然对于具体服务如何实现并无强制约束力，但我们自己建设系统时，遵循业界惯例本身就是一种良好的习惯。</li>
<li>重试必须有明确的终止条件，常用的终止条件有两种：<ul>
<li>超时终止：并不限于重试，所有调用远程服务都应该要有超时机制避免无限期的等待。这里只是强调重试模式更加应该配合上超时机制来使用，否则重试对系统很可能反而是有害的，笔者已经在前面介绍故障转移策略时举过具体的例子，这里就不重复了。</li>
<li>次数终止：重试必须要有一定限度，不能无限制地做下去，通常最多就只重试 2 至 5 次。重试不仅会给调用者带来负担，对于服务提供者也是同样是负担。所以应避免将重试次数设的太大。此外，如果服务提供者返回的响应头中带有Retry-After的话，尽管它没有强制约束力，我们也应该充分尊重服务端的要求，做个“有礼貌”的调用者。、、</li>
</ul>
</li>
</ul>
<p>由于重试模式可以在网络链路的多个环节中去实现，譬如客户端发起调用时自动重试，网关中自动重试、负载均衡器中自动重试，等等，而且现在的微服务框架都足够便捷，只需设置一两个开关参数就可以开启对某个服务甚至全部服务的重试机制。所以，对于没有太多经验的程序员，有可能根本意识不到其中会带来多大的负担。这里笔者举个具体例子：一套基于 Netflix OSS 建设的微服务系统，如果同时在 Zuul、Feign 和 Ribbon 上都打开了重试功能，且不考虑重试被超时终止的话，那总重试次数就相当于它们的重试次数的乘积。假设按它们都重试 4 次，且 Ribbon 可以转移 4 个服务副本来计算，理论上最多会产生高达 4×4×4×4=256 次调用请求。</p>
<h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4><p>任何一个系统的运算、存储、网络资源都不是无限的，当系统资源不足以支撑外部超过预期的突发流量时，便应该要有取舍，建立面对超额流量自我保护的机制，这个机制就是微服务中常说的“限流”。<br>要做流量控制，首先要弄清楚到底哪些指标能反映系统的流量压力大小。相较而言，容错的统计指标是明确的，容错的触发条件基本上只取决于请求的故障率，发生失败、拒绝与超时都算作故障；但限流的统计指标就不那么明确了，限流中的“流”到底指什么呢？要解答这个问题，我们先来理清经常用于衡量服务流量压力，但又较容易混淆的三个指标的定义：</p>
<ul>
<li><strong>每秒事务数</strong>（Transactions per Second，TPS）：TPS 是衡量信息系统吞吐量的最终标准。“事务”可以理解为一个逻辑上具备原子性的业务操作。譬如你在 Fenix’s Bookstore 买了一本书，将要进行支付，“支付”就是一笔业务操作，支付无论成功还是不成功，这个操作在逻辑上是原子的，即逻辑上不可能让你买本书还成功支付了前面 200 页，又失败了后面 300 页。</li>
<li><strong>每秒请求数</strong>（Hits per Second，HPS）：HPS 是指每秒从客户端发向服务端的请求数（请将 Hits 理解为 Requests 而不是 Clicks，国内某些翻译把它理解为“每秒点击数”多少有点望文生义的嫌疑）。如果只要一个请求就能完成一笔业务，那 HPS 与 TPS 是等价的，但在一些场景（尤其常见于网页中）里，一笔业务可能需要多次请求才能完成。譬如你在 Fenix’s Bookstore 买了一本书要进行支付，尽管逻辑上它是原子的，但技术实现上，除非你是直接在银行开的商城中购物能够直接扣款，否则这个操作就很难在一次请求里完成，总要经过显示支付二维码、扫码付款、校验支付是否成功等过程，中间不可避免地会发生多次请求。</li>
<li><strong>每秒查询数</strong>（Queries per Second，QPS）：QPS 是指一台服务器能够响应的查询次数。如果只有一台服务器来应答请求，那 QPS 和 HPS 是等价的，但在分布式系统中，一个请求的响应往往要由后台多个服务节点共同协作来完成。譬如你在 Fenix’s Bookstore 买了一本书要进行支付，尽管扫描支付二维码时尽管客户端只发送了一个请求，但这背后服务端很可能需要向仓储服务确认库存信息避免超卖、向支付服务发送指令划转货款、向用户服务修改用户的购物积分，等等，这里面每次内部访问都要消耗掉一次或多次查询数。</li>
</ul>
<p>​</p>
<p>与容错模式类似，对于具体如何进行限流，也有一些常见常用的设计模式可以参考使用，本节将介绍<strong>流量计数器</strong>、<strong>滑动时间窗</strong>、<strong>漏桶</strong>和<strong>令牌桶</strong>四种限流设计模式。<br>​</p>
<h5 id="流量计数器模式"><a href="#流量计数器模式" class="headerlink" title="流量计数器模式"></a>流量计数器模式</h5><p>做限流最容易想到的一种方法就是设置一个计算器，根据当前时刻的流量计数结果是否超过阈值来决定是否限流。譬如前面场景应用题中，我们计算得出了该系统能承受的最大持续流量是 80 TPS，那就控制任何一秒内，发现超过 80 次业务请求就直接拒绝掉超额部分。这种做法很直观，也确实有些简单的限流就是这么实现的，但它并不严谨，以下两个结论就很可能出乎对限流算法没有了解的同学意料之外：</p>
<ol>
<li>即使每一秒的统计流量都没有超过 80 TPS，也不能说明系统没有遇到过大于 80 TPS 的流量压力。<br>你可以想像如下场景，如果系统连续两秒都收到 60 TPS 的访问请求，但这两个 60 TPS 请求分别是前 1 秒里面的后 0.5 秒，以及后 1 秒中的前面 0.5 秒所发生的。这样虽然每个周期的流量都不超过 80 TPS 请求的阈值，但是系统确实曾经在 1 秒内实在在发生了超过阈值的 120 TPS 请求。</li>
<li>即使连续若干秒的统计流量都超过了 80 TPS，也不能说明流量压力就一定超过了系统的承受能力。<br>你可以想像如下场景，如果 10 秒的时间片段中，前 3 秒 TPS 平均值到了 100，而后 7 秒的平均值是 30 左右，此时系统是否能够处理完这些请求而不产生超时失败？答案是可以的，因为条件中给出的超时时间是 10 秒，而最慢的请求也能在 8 秒左右处理完毕。如果只基于固定时间周期来控制请求阈值为 80 TPS，反而会误杀一部分请求，造成部分请求出现原本不必要的失败。</li>
</ol>
<p>流量计数器的缺陷根源在于它只是针对时间点进行离散的统计，为了弥补该缺陷，一种名为“滑动时间窗”的限流模式被设计出来，它可以实现平滑的基于时间片段统计。</p>
<h5 id="滑动时间窗模式"><a href="#滑动时间窗模式" class="headerlink" title="滑动时间窗模式"></a>滑动时间窗模式</h5><p>滑动窗口算法（Sliding Window Algorithm）在计算机科学的很多领域中都有成功的应用，譬如编译原理中的窥孔优化（Peephole Optimization）、TCP 协议的流量控制（Flow Control）等都使用到滑动窗口算法。对分布式系统来说，无论是服务容错中对服务响应结果的统计，还是流量控制中对服务请求数量的统计，都经常要用到滑动窗口算法。关于这个算法的运作过程，建议你能发挥想象力，在脑海中构造如下场景：在不断向前流淌的时间轴上，漂浮着一个固定大小的窗口，窗口与时间一起平滑地向前滚动。任何时刻静态地通过窗口内观察到的信息，都等价于一段长度与窗口大小相等、动态流动中时间片段的信息。由于窗口观察的目标都是时间轴，所以它被称为形象地称为“滑动时间窗模式”。<br>举个更具体的例子，假如我们准备观察时间片段为 10 秒，并以 1 秒为统计精度的话，那可以设定一个长度为 10 的数组（设计通常是以双头队列去实现，这里简化一下）和一个每秒触发 1 次的定时器。假如我们准备通过统计结果进行限流和容错，并定下限流阈值是最近 10 秒内收到的外部请求不要超过 500 个，服务熔断的阈值是最近 10 秒内故障率不超过 50%，那每个数组元素（图中称为 Buckets）中就应该存储请求的总数（实际是通过明细相加得到）及其中成功、失败、超时、拒绝的明细数，具体如下图所示：<br><img data-src="https://gitee.com/littleeight/blog-images/raw/master/%E5%AF%B9%E4%BA%8E%E6%9E%B6%E6%9E%84%E7%9A%84%E6%B7%B1%E5%85%A5%E6%8E%A2%E8%AE%A8/8.png"></p>
<p>当频率固定每秒一次的定时器被唤醒时，它应该完成以下几项工作，这也就是滑动时间窗的工作过程：</p>
<ol>
<li>将数组最后一位的元素丢弃掉，并把所有元素都后移一位，然后在数组第一个插入一个新的空元素。这个步骤即为“滑动窗口”。</li>
<li>将计数器中所有统计信息写入到第一位的空元素中。</li>
<li>对数组中所有元素进行统计，并复位清空计数器数据供下一个统计周期使用。</li>
</ol>
<p>滑动时间窗口模式的限流完全解决了流量计数器的缺陷，可以保证任意时间片段内，只需经过简单的调用计数比较，就能控制住请求次数一定不会超过限流的阈值，在单机限流或者分布式服务单点网关中的限流中很常用。不过，这种限流也有其缺点，它通常只适用于否决式限流，超过阈值的流量就必须强制失败或降级，很难进行阻塞等待处理，也就很难在细粒度上对流量曲线进行整形，起不到削峰填谷的作用。下面笔者继续介绍两种适用于阻塞式限流的限流模式。<br>​</p>
<h5 id="漏桶模式"><a href="#漏桶模式" class="headerlink" title="漏桶模式"></a>漏桶模式</h5><p>在计算机网络中，专门有一个术语流量整形（Traffic Shaping）用来描述如何限制网络设备的流量突变，使得网络报文以比较均匀的速度向外发送。 流量整形通常都需要用到缓冲区来实现，当报文的发送速度过快时，首先在缓冲区中暂存，然后再在控制算法的调节下均匀地发送这些被缓冲的报文。常用的控制算法有漏桶算法（Leaky Bucket Algorithm）和令牌桶算法（Token Bucket Algorithm）两种，这两种算法的思路截然相反，但达到的效果又是相似的。<br>所谓漏桶，就是大家小学做应用题时一定遇到过的“一个水池，每秒以 X 升速度注水，同时又以 Y 升速度出水，问水池啥时候装满”的那个奇怪的水池。你把请求当作水，水来了都先放进池子里，水池同时又以额定的速度出水，让请求进入系统中。这样，如果一段时间内注水过快的话，水池还能充当缓冲区，让出水口的速度不至于过快。不过，由于请求总是有超时时间的，所以缓冲区大小也必须是有限度的，当注水速度持续超过出水速度一段时间以后，水池终究会被灌满，此时，从网络的流量整形的角度看是体现为部分数据包被丢弃，而在信息系统的角度看就体现为有部分请求会遭遇失败和降级。<br>漏桶在代码实现上非常简单，它其实就是一个以请求对象作为元素的先入先出队列（FIFO Queue），队列长度就相当于漏桶的大小，当队列已满时便拒绝新的请求进入。漏桶实现起来很容易，困难在于如何确定漏桶的两个参数：桶的大小和水的流出速率。如果桶设置得太大，那服务依然可能遭遇到流量过大的冲击，不能完全发挥限流的作用；如果设置得太小，那很可能就会误杀掉一部分正常的请求，这种情况与流量计数器模式中举过的例子是一样的。流出速率在漏桶算法中一般是个固定值，对本节开头场景应用题中那样固定拓扑结构的服务是很合适的，但同时你也应该明白那是经过最大限度简化的场景，现实中系统的处理速度往往受到其内部拓扑结构变化和动态伸缩的影响，所以能够支持变动请求处理速率的令牌桶算法往往可能会是更受程序员青睐的选择。</p>
<h5 id="令牌桶模式"><a href="#令牌桶模式" class="headerlink" title="令牌桶模式"></a>令牌桶模式</h5><p>如果说漏桶是小学应用题中的奇怪水池，那令牌桶就是你去银行办事时摆在门口的那台排队机。它与漏桶一样都是基于缓冲区的限流算法，只是方向刚好相反，漏桶是从水池里往系统出水，令牌桶则是系统往排队机中放入令牌。<br>假设我们要限制系统在 X 秒内最大请求次数不超过 Y，那就每间隔 X/Y 时间就往桶中放一个令牌，当有请求进来时，首先要从桶中取得一个准入的令牌，然后才能进入系统处理。任何时候，一旦请求进入桶中却发现没有令牌可取了，就应该马上失败或进入服务降级逻辑。与漏桶类似，令牌桶同样有最大容量，这意味着当系统比较空闲时，桶中令牌累积到一定程度就不再无限增加，预存在桶中的令牌便是请求最大缓冲的余量。上面这段话，可以转化为以下步骤来指导程序编码：</p>
<ol>
<li>让系统以一个由限流目标决定的速率向桶中注入令牌，譬如要控制系统的访问不超过 100 次，速率即设定为 1/100=10 毫秒。</li>
<li>桶中最多可以存放 N 个令牌，N 的具体数量是由超时时间和服务处理能力共同决定的。如果桶已满，第 N+1 个令牌进入的令牌会被丢弃掉。</li>
<li>请求到时先从桶中取走 1 个令牌，如果桶已空就进入降级逻辑。</li>
</ol>
<p>令牌桶模式的实现看似比较复杂，每间隔固定时间就要放新的令牌到桶中，但其实并不需要真的用一个专用线程或者定时器来做这件事情，只要在令牌中增加一个时间戳记录，每次获取令牌前，比较一下时间戳与当前时间，就可以轻易计算出这段时间需要放多少令牌进去，然后一次过放完全部令牌即可，所以真正编码并不会显得复杂。</p>
<h3 id="服务负载均衡"><a href="#服务负载均衡" class="headerlink" title="服务负载均衡"></a>服务负载均衡</h3><h4 id="客户端负载均衡"><a href="#客户端负载均衡" class="headerlink" title="客户端负载均衡"></a>客户端负载均衡</h4><p>对于任何一个大型系统，负载均衡器都是必不可少的设施。以前，负载均衡器大多只部署在整个服务集群的前端，将用户的请求分流到各个服务进行处理，这种经典的部署形式现在被称为集中式的负载均衡。随着微服务日渐流行，服务集群的收到的请求来源不再局限于外部，越来越多的访问请求是由集群内部的某个服务发起，由集群内部的另一个服务进行响应的，对于这类流量的负载均衡，既有的方案依然是可行的，但针内部流量的特点，直接在服务集群内部消化掉，肯定是更合理更受开发者青睐的办法。由此一种全新的、独立位于每个服务前端的、分散式的负载均衡方式正逐渐变得流行起来，这就是本节我们要讨论的主角：客户端负载均衡器（Client-Side Load Balancer），如图 7-4 所示：<br><img data-src="https://gitee.com/littleeight/blog-images/raw/master/%E5%AF%B9%E4%BA%8E%E6%9E%B6%E6%9E%84%E7%9A%84%E6%B7%B1%E5%85%A5%E6%8E%A2%E8%AE%A8/9.png"></p>
<p>客户端负载均衡器的理念提出以后，此前的集中式负载均衡器也有了一个方便与它对比的名字“服务端负载均衡器”（Server-Side Load Balancer）。从图中能够清晰地看到客户端负载均衡器的特点，也是它与服务端负载均衡器的关键差别所在：客户端均衡器是和服务实例一一对应的，而且与服务实例并存于同一个进程之内。这个特点能为它带来很多好处，如：</p>
<ul>
<li>均衡器与服务之间信息交换是进程内的方法调用，不存在任何额外的网络开销。</li>
<li>不依赖集群边缘的设施，所有内部流量都仅在服务集群的内部循环，避免了出现前文那样，集群内部流量要“绕场一周”的尴尬局面。</li>
<li>分散式的均衡器意味着天然避免了集中式的单点问题，它的带宽资源将不会像集中式均衡器那样敏感，这在以七层均衡器为主流、不能通过 IP 隧道和三角传输这样方式节省带宽的微服务环境中显得更具优势。</li>
<li>客户端均衡器要更加灵活，能够针对每一个服务实例单独设置均衡策略等参数，访问某个服务，是不是需要具备亲和性，选择服务的策略是随机、轮询、加权还是最小连接等等，都可以单独设置而不影响其它服务。</li>
<li>……</li>
</ul>
<p>但是，客户端均衡器也不是银弹，它得到上述诸多好处的同时，缺点同样也是不少的：</p>
<ul>
<li>它与服务运行于同一个进程之内，意味着它的选型受到服务所使用的编程语言的限制，譬如用 Golang 开发的微服务就不太可能搭配 Spring Cloud Load Balancer 来使用，要为每种语言都实现对应的能够支持复杂网络情况的均衡器是非常难的。客户端均衡器的这个缺陷有违于微服务中技术异构不应受到限制的原则。</li>
<li>从个体服务来看，由于是共用一个进程，均衡器的稳定性会直接影响整个服务进程的稳定性，消耗的 CPU、内存等资源也同样影响到服务的可用资源。从集群整体来看，在服务数量达成千乃至上万规模时，客户端均衡器消耗的资源总量是相当可观的。</li>
<li>由于请求的来源可能是来自集群中任意一个服务节点，而不再是统一来自集中式均衡器，这就使得内部网络安全和信任关系变得复杂，当攻破任何一个服务时，更容易通过该服务突破集群中的其他部分。</li>
<li>服务集群的拓扑关系是动态的，每一个客户端均衡器必须持续跟踪其他服务的健康状况，以实现上线新服务、下线旧服务、自动剔除失败的服务、自动重连恢复的服务等均衡器必须具备的功能。由于这些操作都需要通过访问服务注册中心来完成，数量庞大的客户端均衡器一直持续轮询服务注册中心，也会为它带来不小的负担。<h4 id="代理负载均衡"><a href="#代理负载均衡" class="headerlink" title="代理负载均衡"></a>代理负载均衡</h4>在 Java 领域，客户端均衡器中最具代表性的产品是 Netflix Ribbon 和 Spring Cloud Load Balancer，随着微服务的流行，它们在 Java 微服务中已积聚了相当可观的使用者。直到最近两三年，服务网格（Service Mesh）开始逐渐盛行，另外一种被称为“代理客户端负载均衡器”（Proxy Client-Side Load Balancer，后文简称“代理均衡器”）的客户端均衡器变体形式开始引起不同编程语言的微服务开发者共同关注，它解决了此前客户端均衡器的大多数缺陷。代理均衡器对此前的客户端负载均衡器的改进是将原本嵌入在服务进程中的均衡器提取出来，作为一个进程之外，同一 Pod 之内的特殊服务，放到边车代理中去实现，它的流量关系如图 7-5 所示。<br><img data-src="https://gitee.com/littleeight/blog-images/raw/master/%E5%AF%B9%E4%BA%8E%E6%9E%B6%E6%9E%84%E7%9A%84%E6%B7%B1%E5%85%A5%E6%8E%A2%E8%AE%A8/10.png"></li>
</ul>
<p>虽然代理均衡器与服务实例不再是进程内通信，而是通过网络协议栈进行数据交换的，数据要经过操作系统的协议栈，要进行打包拆包、计算校验和、维护序列号等网络数据的收发步骤，流量比起之前的客户端均衡器确实多增加了一系列处理步骤。不过，Kubernetes 严格保证了同一个 Pod 中的容器不会跨越不同的节点，这些容器共享着同一个网络名称空间，因此代理均衡器与服务实例的交互，实质上是对本机回环设备的访问，仍然要比真正的网络交互高效且稳定得多。代理均衡器付出的代价较小，但从服务进程中分离出来所获得的收益却是非常显著的：<br>代理均衡器不再受编程语言的限制。发展一个支持 Java、Golang、Python 等所有微服务应用服务的通用的代理均衡器具有很高的性价比。集中不同编程语言的使用者的力量，更容易打造出能面对复杂网络情况的、高效健壮的均衡器。即使退一步说，独立于服务进程的均衡器也不会由于自身的稳定性影响到服务进程的稳定。</p>
<ul>
<li>在服务拓扑感知方面代理均衡器也要更有优势。由于边车代理接受控制平面的统一管理，当服务节点拓扑关系发生变化时，控制平面就会主动向边车代理发送更新服务清单的控制指令，这避免了此前客户端均衡器必须长期主动轮询服务注册中心所造成的浪费。</li>
<li>在安全性、可观测性上，由于边车代理都是一致的实现，有利于在服务间建立双向 TLS 通信，也有利于对整个调用链路给出更详细的统计信息。<h3 id="服务日志"><a href="#服务日志" class="headerlink" title="服务日志"></a>服务日志</h3>日志用来记录系统运行期间发生过的离散事件。相信没有哪一个生产系统能够缺少日志功能，然而也很少人会把日志作为多么关键功能来看待。日志就像阳光与空气，无可或缺却不太被重视。程序员们会说日志简单，其实这是在说“打印日志”这个操作简单，打印日志的目的是为了日后从中得到有价值的信息，而今天只要稍微复杂点的系统，尤其是复杂的分布式系统，就很难只依靠 tail、grep、awk 来从日志中挖掘信息了，往往还要有专门的全局查询和可视化功能。此时，从打印日志到分析查询之间，还隔着收集、缓冲、聚合、加工、索引、存储等若干个步骤，如图所示：<br><img data-src="https://gitee.com/littleeight/blog-images/raw/master/%E5%AF%B9%E4%BA%8E%E6%9E%B6%E6%9E%84%E7%9A%84%E6%B7%B1%E5%85%A5%E6%8E%A2%E8%AE%A8/11.png"></li>
</ul>
<h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>要是说好的日志能像文章一样，能让人读起来身心舒畅，这话肯定有夸大的成分，不过好的日志应该能做到像“流水账”一样，无有遗漏地记录信息，格式统一，内容恰当。其中“恰当”是一个难点，它要求日志不应该过多，也不应该过少。“多与少”一般不针对输出的日志行数，尽管笔者听过最夸张的系统有单节点 INFO 级别下每天的日志都能以 TB 计算（这是代码有问题的），给网络与磁盘 I/O 带来了不小压力，但笔者通常不以数量来衡量日志是否恰当，恰当是指日志中不该出现的内容不要有，该有的不要少，下面笔者先列出一些常见的“不应该有”的例子：</p>
<ul>
<li><strong>避免打印敏感信息</strong>。不用专门去提醒，任何程序员肯定都知道不该将密码，银行账号，身份证件这些敏感信息打到日志里，但笔者曾见过不止一个系统的日志中直接能找到这些信息。一旦这些敏感信息随日志流到了后续的索引、存储、归档等步骤后，清理起来将非常麻烦。不过，日志中应当包含必要的非敏感信息，譬如当前用户的 ID（最好是内部 ID，避免登录名或者用户名称），有些系统就直接用MDC（Mapped Diagnostic Context）将用户 ID 自动打印在日志模版（Pattern Layout）上。</li>
<li><strong>避免引用慢操作</strong>。日志中打印的信息应该是上下文中可以直接取到的，如果当前上下文中根本没有这项数据，需要专门调用远程服务或者从数据库获取，又或者通过大量计算才能取到的话，那应该先考虑这项信息放到日志中是不是必要且恰当的。</li>
<li><strong>避免打印追踪诊断信息</strong>。日志中不要打印方法输入参数、输出结果、方法执行时长之类的调试信息。这个观点是反直觉的，不少公司甚至会将其作为最佳实践来提倡，但是笔者仍坚持将其归入反模式中。日志的职责是记录事件，追踪诊断应由追踪系统去处理，哪怕贵公司完全没有开发追踪诊断方面功能的打算，笔者也建议使用BTrace或者Arthas这类“On-The-Fly”的工具来解决。之所以将其归为反模式，是因为上面说的敏感信息、慢操作等的主要源头就是这些原本想用于调试的日志。譬如，当前方法入口参数有个 User 对象，如果要输出这个对象的话，常见做法是将它序列化成 JSON 字符串然后打到日志里，这时候 User 里面的 Password 字段、BankCard 字段就很容易被暴露出来；再譬如，当前方法的返回值是个 Map，开发期的调试数据只做了三五个 Entity，觉得遍历一下把具体内容打到日志里面没什么问题，到了生产期，这个 Map 里面有可能存放了成千上万个 Entity，这时候打印日志就相当于引用慢操作。</li>
<li><strong>避免误导他人</strong>。日志中给日后调试除错的人挖坑是十分恶劣却又常见的行为。相信程序员并不是专门要去误导别人，只是很可能会无意识地这样做了。譬如明明已经在逻辑中妥善处理好了某个异常，偏习惯性地调用 printStackTrace()方法，把堆栈打到日志中，一旦这个方法附近出现问题，由其他人来除错的话，很容易会盯着这段堆栈去找线索而浪费大量时间。</li>
</ul>
<p>另一方面，日志中不该缺少的内容也“不应该少”，以下是部分笔者建议应该输出到日志中的内容：</p>
<ul>
<li><strong>处理请求时的 TraceID</strong>。服务收到请求时，如果该请求没有附带 TraceID，就应该自动生成唯一的 TraceID 来对请求进行标记，并使用 MDC 自动输出到日志。TraceID 会贯穿整条调用链，目的是通过它把请求在分布式系统各个服务中的执行过程串联起来。TraceID 通常也会随着请求的响应返回到客户端，如果响应内容出现了异常，用户便能通过此 ID 快速找到与问题相关的日志。TraceID 是链路追踪里的概念，类似的还有用于标识进程内调用状况的 SpanID，在 Java 程序中这些都可以用 Spring Cloud Sleuth 来自动生成。尽管 TraceID 在分布式跟踪会发挥最大的作用，但即使对单体系统，将 TraceID 记录到日志并返回给最终用户，对快速定位错误仍然十分有价值。**</li>
<li><strong>系统运行过程中的关键事件</strong>。日志的职责就是记录事件，进行了哪些操作、发生了与预期不符的情况、运行期间出现未能处理的异常或警告、定期自动执行的任务，等等，都应该在日志中完整记录下来。原则上程序中发生的事件只要有价值就应该去记录，但应判断清楚事件的重要程度，选定相匹配的日志的级别。至于如何快速处理大量日志，这是后面步骤要考虑的问题，如果输出日志实在太频繁以至于影响性能，应由运维人员去调整全局或单个类的日志级别来解决。</li>
<li><strong>启动时输出配置信息</strong>。与避免输出诊断信息不同，对于系统启动时或者检测到配置中心变化时更新的配置，应将非敏感的配置信息输出到日志中，譬如连接的数据库、临时目录的路径等等，初始化配置的逻辑一般只会执行一次，不便于诊断时复现，所以应该输出到日志中。</li>
</ul>
<p>​</p>
<h4 id="收集与缓冲"><a href="#收集与缓冲" class="headerlink" title="收集与缓冲"></a>收集与缓冲</h4><p>写日志是在服务节点中进行的，但我们不可能在每个节点都单独建设日志查询功能。这不是资源或工作量的问题，而是分布式系统处理一个请求要跨越多个服务节点，为了能看到跨节点的全部日志，就要有能覆盖整个链路的全局日志系统。这个需求决定了每个节点输出日志到文件后，必须将日志文件统一收集起来集中存储、索引，由此便催生了专门的日志收集器。<br>最初，ELK 中日志收集与下一节要讲的加工聚合的职责都是由 Logstash 来承担的，Logstash 除了部署在各个节点中作为收集的客户端（Shipper）以外，它还同时设有独立部署的节点，扮演归集转换日志的服务端（Master）角色。Logstash 有良好的插件化设计，收集、转换、输出都支持插件化定制，应对多重角色本身并没有什么困难。但是 Logstash 与它的插件是基于 JRuby 编写的，要跑在单独的 Java 虚拟机进程上，而且 Logstash 的默认的堆大小就到了 1GB。对于归集部分（Master）这种消耗并不是什么问题，但作为每个节点都要部署的日志收集器就显得太过负重了。后来，Elastic.co 公司将所有需要在服务节点中处理的工作整理成以Libbeat为核心的Beats 框架，并使用 Golang 重写了一个功能较少，却更轻量高效的日志收集器，这就是今天流行的Filebeat。<br>现在的 Beats 已经是一个很大的家族了，除了 Filebeat 外，Elastic.co 还提供有用于收集 Linux 审计数据的Auditbeat、用于无服务计算架构的Functionbeat、用于心跳检测的Heartbeat、用于聚合度量的Metricbeat、用于收集 Linux Systemd Journald 日志的Journalbeat、用于收集 Windows 事件日志的Winlogbeat，用于网络包嗅探的Packetbeat，等等，如果再算上大量由社区维护的Community Beats，那几乎是你能想像到的数据都可以被收集到，以至于 ELK 也可以一定程度上代替度量和追踪系统，实现它们的部分职能，这对于中小型分布式系统来说是便利的，但对于大型系统，笔者建议还是让专业的工具去做专业的事情。<br>日志收集器不仅要保证能覆盖全部数据来源，还要尽力保证日志数据的连续性，这其实并不容易做到。譬如淘宝这类大型的互联网系统，每天的日志量超过了 10,000TB（10PB）量级，日志收集器的部署实例数能到达百万量级（数据来源），此时归集到系统中的日志要与实际产生的日志保持绝对的一致性是非常困难的，也不应该为此付出过高成本。换而言之，日志不追求绝对的完整精确，只追求在代价可承受的范围内保证尽可能地保证较高的数据质量。一种最常用的缓解压力的做法是将日志接收者从 Logstash 和 Elasticsearch 转移至抗压能力更强的队列缓存，譬如在 Logstash 之前架设一个 Kafka 或者 Redis 作为缓冲层，面对突发流量，Logstash 或 Elasticsearch 处理能力出现瓶颈时自动削峰填谷，甚至当它们短时间停顿，也不会丢失日志数据。</p>
<h4 id="加工与聚合"><a href="#加工与聚合" class="headerlink" title="加工与聚合"></a>加工与聚合</h4><pre><code>Logstash 的基本职能是把日志行中的非结构化数据，通过 Grok 表达式语法转换为上面表格那样的结构化数据，进行结构化的同时，还可能会根据需要，调用其他插件来完成时间处理（统一时间格式）、类型转换（如字符串、数值的转换）、查询归类（譬如将 IP 地址根据地理信息库按省市归类）等种额外处理工作，然后以 JSON 格式输出到 Elasticsearch 中（这是最普遍的输出形式，Logstash 输出也有很多插件可以具体定制不同的格式）。有了这些经过 Logstash 转换，已经结构化的日志，Elasticsearch 便可针对不同的数据项来建立索引，进行条件查询、统计、聚合等操作的了。
</code></pre>
<p>提到聚合，这也是 Logstash 的另一个常见职能。日志中存储的是离散事件，离散的意思是每个事件都是相互独立的，譬如有 10 个用户访问服务，他们操作所产生的事件都在日志中会分别记录。如果想从离散的日志中获得统计信息，譬如想知道这些用户中正常返回（200 OK）的有多少、出现异常的（500 Internal Server Error）的有多少，再生成个可视化统计图表，一种解决方案是通过 Elasticsearch 本身的处理能力做实时的聚合统计，这很便捷，不过要消耗 Elasticsearch 服务器的运算资源。另一种解决方案是在收集日志后自动生成某些常用的、固定的聚合指标，这种聚合就会在 Logstash 中通过聚合插件来完成。这两种聚合方式都有不少实际应用，前者一般用于应对即席查询，后者用于应对固定查询。</p>
<h4 id="存储与查询"><a href="#存储与查询" class="headerlink" title="存储与查询"></a>存储与查询</h4><p>经过收集、缓冲、加工、聚合的日志数据，终于可以放入 Elasticsearch 中索引存储了。Elasticsearch 是整个 Elastic Stack 技术栈的核心，其他步骤的工具，如 Filebeat、Logstash、Kibana 都有替代品，有自由选择的余地，唯独 Elasticsearch 在日志分析这方面完全没有什么值得一提的竞争者，几乎就是解决此问题的唯一答案。这样的结果肯定与 Elasticsearch 本身是一款优秀产品有关，然而更关键的是 Elasticsearch 的优势正好与日志分析的需求完美契合：</p>
<ul>
<li>从数据特征的角度看，日志是典型的基于时间的数据流，但它与其他时间数据流，譬如你的新浪微博、微信朋友圈这种社交网络数据又稍有区别：日志虽然增长速度很快，但已写入的数据几乎没有再发生变动的可能。日志的数据特征决定了所有用于日志分析的 Elasticsearch 都会使用时间范围作为索引，根据实际数据量的大小可能是按月、按周或者按日、按时。以按日索引为例，由于你能准确地预知明天、后天的日期，因此全部索引都可以预先创建，这免去了动态创建的寻找节点、创建分片、在集群中广播变动信息等开销。又由于所有新的日志都是“今天”的日志，所以只要建立“logs_current”这样的索引别名来指向当前索引，就能避免代码因日期而变动。</li>
<li>从数据价值的角度看，日志基本上只会以最近的数据为检索目标，随着时间推移，早期的数据将逐渐失去价值。这点决定了可以很容易区分出冷数据和热数据，进而对不同数据采用不一样的硬件策略。譬如为热数据配备 SSD 磁盘和更好的处理器，为冷数据配备 HDD 磁盘和较弱的处理器，甚至可以放到更为廉价的对象存储（如阿里云的 OSS，腾讯云的 COS，AWS 的 S3）中归档。<br>注意，本节的主题是日志在可观测性方面的作用，另外还有一些基于日志的其他类型应用，譬如从日志记录的事件中去挖掘业务热点，分析用户习惯等等，这属于真正大数据挖掘的范畴，并不在我们讨论“价值”的范围之内，事实上它们更可能采用的技术栈是 HBase 与 Spark 的组合，而不是 Elastic Stack。</li>
<li>从数据使用的角度看，分析日志很依赖全文检索和即席查询，对实时性的要求是处于实时与离线两者之间的“近实时”，即不强求日志产生后立刻能查到，但也不能接受日志产生之后按小时甚至按天的频率来更新，这些检索能力和近实时性，也正好都是 Elasticsearch 的强项。</li>
</ul>
<p>Elasticsearch 只提供了 API 层面的查询能力，它通常搭配同样出自 Elastic.co 公司的 Kibana 一起使用，可以将 Kibana 视为 Elastic Stack 的 GUI 部分。Kibana 尽管只负责图形界面和展示，但它提供的能力远不止让你能在界面上执行 Elasticsearch 的查询那么简单。Kibana 宣传的核心能力是“探索数据并可视化”，即把存储在 Elasticsearch 中的数据被检索、聚合、统计后，定制形成各种图形、表格、指标、统计，以此观察系统的运行状态，找出日志事件中潜藏的规律和隐患。按 Kibana 官方的宣传语来说就是“一张图片胜过千万行日志”。<br><img data-src="https://gitee.com/littleeight/blog-images/raw/master/%E5%AF%B9%E4%BA%8E%E6%9E%B6%E6%9E%84%E7%9A%84%E6%B7%B1%E5%85%A5%E6%8E%A2%E8%AE%A8/12.png"></p>
<h3 id="事务处理"><a href="#事务处理" class="headerlink" title="事务处理"></a>事务处理</h3><p>事务处理几乎在每一个信息系统中都会涉及，它存在的意义是为了保证系统中所有的数据都是符合期望的，且相互关联的数据之间不会产生矛盾，即数据状态的<strong>一致性（Consistency）</strong>。<br>按照数据库的经典理论，要达成这个目标，需要三方面共同努力来保障。</p>
<ul>
<li><strong>原子性</strong>（<strong>A</strong>tomic）：在同一项业务处理过程中，事务保证了对多个数据的修改，要么同时成功，要么同时被撤销。</li>
<li><strong>隔离性</strong>（<strong>I</strong>solation）：在不同的业务处理过程中，事务保证了各自业务正在读、写的数据互相独立，不会彼此影响。</li>
<li><strong>持久性</strong>（<strong>D</strong>urability）：事务应当保证所有成功被提交的数据修改都能够正确地被持久化，不丢失数据。</li>
</ul>
<p>以上四种属性即事务的“ACID”特性，但笔者对这种说法其实不是太认同，因为这四种特性并不正交，A、I、D 是手段，C 是目的，前者是因，后者是果，弄到一块去完全是为了拼凑个单词缩写。<br>事务的概念虽然最初起源于数据库系统，但今天已经有所延伸，而不再局限于数据库本身了，所有需要保证数据一致性的应用场景，包括但不限于数据库、事务内存、缓存、消息队列、分布式存储，等等，都有可能会用到事务，后文里笔者会使用“数据源”来泛指所有这些场景中提供与存储数据的逻辑设备，但是上述场景所说的事务和一致性含义可能并不完全一致，说明如下。</p>
<ul>
<li>当一个服务只使用一个数据源时，通过 A、I、D 来获得一致性是最经典的做法，也是相对容易的。此时，多个并发事务所读写的数据能够被数据源感知是否存在冲突，并发事务的读写在时间线上的最终顺序是由数据源来确定的，这种事务间一致性被称为“内部一致性”。</li>
<li>当一个服务使用到多个不同的数据源，甚至多个不同服务同时涉及多个不同的数据源时，问题就变得相对困难了许多。此时，并发执行甚至是先后执行的多个事务，在时间线上的顺序并不由任何一个数据源来决定，这种涉及多个数据源的事务间一致性被称为“外部一致性”。</li>
</ul>
<p>外部一致性问题通常很难再使用 A、I、D 来解决，因为这样需要付出很大乃至不切实际的代价；但是外部一致性又是分布式系统中必然会遇到且必须要解决的问题，为此我们要转变观念，将一致性从“是或否”的二元属性转变为可以按不同强度分开讨论的多元属性，在确保代价可承受的前提下获得强度尽可能高的一致性保障，也正因如此，事务处理才从一个具体操作上的“编程问题”上升成一个需要全局权衡的“架构问题”。</p>
<h4 id="本地事务"><a href="#本地事务" class="headerlink" title="本地事务"></a>本地事务</h4><p>本地事务是最基础的一种事务解决方案，只适用于单个服务使用单个数据源的场景。从应用角度看，它是直接依赖于数据源本身提供的事务能力来工作的，在程序代码层面，最多只能对事务接口做一层标准化的包装（如 JDBC 接口），并不能深入参与到事务的运作过程当中，事务的开启、终止、提交、回滚、嵌套、设置隔离级别，乃至与应用代码贴近的事务传播方式，全部都要依赖底层数据源的支持才能工作。<br>众所周知，数据必须要成功写入磁盘、磁带等持久化存储器后才能拥有持久性，只存储在内存中的数据，一旦遇到应用程序忽然崩溃，或者数据库、操作系统一侧的崩溃，甚至是机器突然断电宕机等情况就会丢失，后文我们将这些意外情况都统称为<strong>“崩溃”（Crash）</strong>。实现原子性和持久性的最大困难是“写入磁盘”这个操作并不是原子的，不仅有“写入”与“未写入”状态，还客观地存在着“正在写”的中间状态。正因为写入中间状态与崩溃都不可能消除，所以如果不做额外保障措施的话，将内存中的数据写入磁盘，并不能保证原子性与持久性。<br>由于写入中间状态与崩溃都是无法避免的，为了保证原子性和持久性，就只能在崩溃后采取恢复的补救措施，这种数据恢复操作被称为<strong>“崩溃恢复”（Crash Recovery，也有资料称作 Failure Recovery 或 Transaction Recovery）</strong>。<br>为了能够顺利地完成崩溃恢复，在磁盘中写入数据就不能像程序修改内存中变量值那样，直接改变某表某行某列的某个值，而是必须将修改数据这个操作所需的全部信息，包括修改什么数据、数据物理上位于哪个内存页和磁盘块中、从什么值改成什么值，等等，以日志的形式——即仅进行顺序追加的文件写入的形式（这是最高效的写入方式）先记录到磁盘中。只有在日志记录全部都安全落盘，数据库在日志中看到代表事务成功提交的“提交记录”（Commit Record）后，才会根据日志上的信息对真正的数据进行修改，修改完成后，再在日志中加入一条“结束记录”（End Record）表示事务已完成持久化，这种事务实现方法被称为“Commit Logging”（提交日志）。<br>Commit Logging 保障数据持久性、原子性的原理并不难理解：首先，日志一旦成功写入 Commit Record，那整个事务就是成功的，即使真正修改数据时崩溃了，重启后根据已经写入磁盘的日志信息恢复现场、继续修改数据即可，这保证了持久性；其次，如果日志没有成功写入 Commit Record 就发生崩溃，那整个事务就是失败的，系统重启后会看到一部分没有 Commit Record 的日志，那将这部分日志标记为回滚状态即可，整个事务就像完全没好有发生过一样，这保证了原子性。<br>但是，Commit Logging 存在一个巨大的先天缺陷：<strong>所有对数据的真实修改都必须发生在事务提交以后，即日志写入了 Commit Record 之后</strong>。在此之前，即使磁盘 I/O 有足够空闲、即使某个事务修改的数据量非常庞大，占用了大量的内存缓冲区，无论有何种理由，都决不允许在事务提交之前就修改磁盘上的数据，这一点是 Commit Logging 成立的前提，却对提升数据库的性能十分不利。为了解决这个问题，前面提到的 ARIES 理论终于可以登场。ARIES 提出了“Write-Ahead Logging”的日志改进方案，所谓“提前写入”（Write-Ahead），就是允许在事务提交之前，提前写入变动数据的意思。<br>Write-Ahead Logging 先将何时写入变动数据，按照事务提交时点为界，划分为 FORCE 和 STEAL 两类情况。</p>
<ul>
<li><strong>FORCE</strong>：当事务提交后，要求变动数据必须同时完成写入则称为 FORCE，如果不强制变动数据必须同时完成写入则称为 NO-FORCE。现实中绝大多数数据库采用的都是 NO-FORCE 策略，因为只要有了日志，变动数据随时可以持久化，从优化磁盘 I/O 性能考虑，没有必要强制数据写入立即进行。</li>
<li><strong>STEAL</strong>：在事务提交前，允许变动数据提前写入则称为 STEAL，不允许则称为 NO-STEAL。从优化磁盘 I/O 性能考虑，允许数据提前写入，有利于利用空闲 I/O 资源，也有利于节省数据库缓存区的内存。</li>
</ul>
<p>Commit Logging 允许 NO-FORCE，但不允许 STEAL。因为假如事务提交前就有部分变动数据写入磁盘，那一旦事务要回滚，或者发生了崩溃，这些提前写入的变动数据就都成了错误。<br>​</p>
<p>Write-Ahead Logging 允许 NO-FORCE，也允许 STEAL，它给出的解决办法是增加了另一种被称为 Undo Log 的日志类型，当变动数据写入磁盘前，必须先记录 Undo Log，注明修改了哪个位置的数据、从什么值改成什么值，等等。以便在事务回滚或者崩溃恢复时根据 Undo Log 对提前写入的数据变动进行擦除。Undo Log 现在一般被翻译为“回滚日志”，此前记录的用于崩溃恢复时重演数据变动的日志就相应被命名为 Redo Log，一般翻译为“重做日志”。由于 Undo Log 的加入，Write-Ahead Logging 在崩溃恢复时会执行以下三个阶段的操作。</p>
<ul>
<li><strong>分析阶段</strong>（Analysis）：该阶段从最后一次检查点（Checkpoint，可理解为在这个点之前所有应该持久化的变动都已安全落盘）开始扫描日志，找出所有没有 End Record 的事务，组成待恢复的事务集合，这个集合至少会包括 Transaction Table 和 Dirty Page Table 两个组成部分。</li>
<li><strong>重做阶段</strong>（Redo）：该阶段依据分析阶段中产生的待恢复的事务集合来重演历史（Repeat History），具体操作为：找出所有包含 Commit Record 的日志，将这些日志修改的数据写入磁盘，写入完成后在日志中增加一条 End Record，然后移除出待恢复事务集合。</li>
<li><strong>回滚阶段</strong>（Undo）：该阶段处理经过分析、重做阶段后剩余的恢复事务集合，此时剩下的都是需要回滚的事务，它们被称为 Loser，根据 Undo Log 中的信息，将已经提前写入磁盘的信息重新改写回去，以达到回滚这些 Loser 事务的目的。</li>
</ul>
<p>​</p>
<h4 id="全局事务"><a href="#全局事务" class="headerlink" title="全局事务"></a>全局事务</h4><p>与本地事务相对的是全局事务（Global Transaction），有一些资料中也将其称为外部事务（External Transaction），在本节里，全局事务被限定为一种适用于单个服务使用多个数据源场景的事务解决方案。请注意，理论上真正的全局事务并没有“单个服务”的约束，它本来就是 DTP（Distributed Transaction Processing）模型中的概念，但本节所讨论的内容是一种在分布式环境中仍追求强一致性的事务处理方案，对于多节点而且互相调用彼此服务的场合（典型的就是现在的微服务系统）是极不合适的，今天它几乎只实际应用于单服务多数据源的场合中，为了避免与后续介绍的放弃了 ACID 的弱一致性事务处理方式相互混淆，所以这里的全局事务所指范围有所缩减，后续涉及多服务多数据源的事务，笔者将称其为“分布式事务”。<br>1991 年，为了解决分布式事务的一致性问题， X/Open组织提出了<strong>XA</strong>的处理事务架构，其核心内容是定义了全局的事务管理器（Transaction Manager，用于协调全局事务）和局部的资源管理器（Resource Manager，用于驱动本地事务）之间的通信接口。XA 接口是双向的，能在一个事务管理器和多个资源管理器（Resource Manager）之间形成通信桥梁，通过协调多个数据源的一致动作，实现全局事务的统一提交或者统一回滚，现在我们在 Java 代码中还偶尔能看见的 XADataSource、XAResource 这些名字都源于此。<br>XA 将事务提交拆分成为两阶段过程<strong>（称为“两段式提交”（2 Phase Commit，2PC）协议）</strong>：</p>
<ul>
<li><strong>准备阶段</strong>：又叫作投票阶段，在这一阶段，协调者询问事务的所有参与者是否准备好提交，参与者如果已经准备好提交则回复 Prepared，否则回复 Non-Prepared。这里所说的准备操作跟人类语言中通常理解的准备并不相同，对于数据库来说，<strong>准备操作是在重做日志中记录全部事务提交操作所要做的内容</strong>，它与本地事务中真正提交的区别只是暂不写入最后一条 Commit Record 而已，这意味着在做完数据持久化后并不立即释放隔离性，即仍继续持有锁，维持数据对其他非事务内观察者的隔离状态。</li>
<li><strong>提交阶段</strong>：又叫作执行阶段，协调者如果在上一阶段收到所有事务参与者回复的 Prepared 消息，则先自己在本地持久化事务状态为 Commit，在此操作完成后向所有参与者发送 Commit 指令，所有参与者立即执行提交操作；否则，任意一个参与者回复了 Non-Prepared 消息，或任意一个参与者超时未回复，协调者将将自己的事务状态持久化为 Abort 之后，向所有参与者发送 Abort 指令，参与者立即执行回滚操作。对于数据库来说，这个阶段的提交操作应是很轻量的，仅仅是持久化一条 Commit Record 而已，通常能够快速完成，只有收到 Abort 指令时，才需要根据回滚日志清理已提交的数据，这可能是相对重负载操作。</li>
</ul>
<p><img data-src="https://gitee.com/littleeight/blog-images/raw/master/%E5%AF%B9%E4%BA%8E%E6%9E%B6%E6%9E%84%E7%9A%84%E6%B7%B1%E5%85%A5%E6%8E%A2%E8%AE%A8/13.png"><br>两段式提交原理简单，并不难实现，但有几个非常显著的缺点：</p>
<ul>
<li><strong>单点问题</strong>：协调者在两段提交中具有举足轻重的作用，协调者等待参与者回复时可以有超时机制，允许参与者宕机，但参与者等待协调者指令时无法做超时处理。一旦宕机的不是其中某个参与者，而是协调者的话，所有参与者都会受到影响。如果协调者一直没有恢复，没有正常发送 Commit 或者 Rollback 的指令，那所有参与者都必须一直等待。</li>
<li><strong>性能问题</strong>：两段提交过程中，所有参与者相当于被绑定成为一个统一调度的整体，期间要经过两次远程服务调用，三次数据持久化（准备阶段写重做日志，协调者做状态持久化，提交阶段在日志写入 Commit Record），整个过程将持续到参与者集群中最慢的那一个处理操作结束为止，这决定了两段式提交的性能通常都较差。</li>
<li><strong>一致性风险</strong>：前面已经提到，两段式提交的成立是有前提条件的，当网络稳定性和宕机恢复能力的假设不成立时，仍可能出现一致性问题。宕机恢复能力这一点不必多谈，1985 年 Fischer、Lynch、Paterson 提出了“FLP 不可能原理”，证明了如果宕机最后不能恢复，那就不存在任何一种分布式协议可以正确地达成一致性结果。该原理在分布式中是与“CAP 不可兼得原理“齐名的理论。而网络稳定性带来的一致性风险是指：尽管提交阶段时间很短，但这仍是一段明确存在的危险期，如果协调者在发出准备指令后，根据收到各个参与者发回的信息确定事务状态是可以提交的，协调者会先持久化事务状态，并提交自己的事务，如果这时候网络忽然被断开，无法再通过网络向所有参与者发出 Commit 指令的话，就会导致部分数据（协调者的）已提交，但部分数据（参与者的）既未提交，也没有办法回滚，产生了数据不一致的问题。</li>
</ul>
<p>​</p>
<p>为了缓解两段式提交协议的一部分缺陷，具体地说是协调者的单点问题和准备阶段的性能问题，后续又发展出了<strong>“三段式提交”（3 Phase Commit，3PC）协议</strong>。三段式提交把原本的两段式提交的准备阶段再细分为两个阶段，分别称为** CanCommit、PreCommit<strong>，把提交阶段改称为</strong> DoCommit <strong>阶段。其中，新增的 CanCommit 是一个询问阶段，协调者让每个参与的数据库根据自身状态，评估该事务是否有可能顺利完成。将准备阶段一分为二的理由是这个阶段是重负载的操作，一旦协调者发出开始准备的消息，每个参与者都将马上开始写重做日志，它们所涉及的数据资源即被锁住，如果此时某一个参与者宣告无法完成提交，相当于大家都白做了一轮无用功。所以，增加一轮询问阶段，如果都得到了正面的响应，那事务能够成功提交的把握就比较大了，这也意味着因某个参与者提交时发生崩溃而导致大家全部回滚的风险相对变小。因此，在事务需要回滚的场景中，三段式的性能通常是要比两段式好很多的，但在事务能够正常提交的场景中，两者的性能都依然很差，甚至三段式因为多了一次询问，还要稍微更差一些。<br>同样也是由于事务失败回滚概率变小的原因，在三段式提交中，如果在 PreCommit 阶段之后发生了协调者宕机，即参与者没有能等到 DoCommit 的消息的话，</strong>默认的操作策略将是提交事务而不是回滚事务或者持续等待**，这就相当于避免了协调者单点问题的风险。<br><img data-src="https://gitee.com/littleeight/blog-images/raw/master/%E5%AF%B9%E4%BA%8E%E6%9E%B6%E6%9E%84%E7%9A%84%E6%B7%B1%E5%85%A5%E6%8E%A2%E8%AE%A8/14.png"></p>
<h4 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h4><p>涉及共享数据问题时，以下三个特性最多只能同时满足其中两个：</p>
<ul>
<li><strong>一致性（Consistency）</strong>：代表数据在任何时刻、任何分布式节点中所看到的都是符合预期的。一致性在分布式研究中是有严肃定义、有多种细分类型的概念，以后讨论分布式共识算法时，我们还会再提到一致性，那种面向副本复制的一致性与这里面向数据库状态的一致性严格来说并不完全等同，具体差别我们将在后续分布式共识算法中再作探讨。</li>
<li><strong>可用性（Availability）</strong>：代表系统不间断地提供服务的能力，理解可用性要先理解与其密切相关两个指标：可靠性（Reliability）和可维护性（Serviceability）。可靠性使用平均无故障时间（Mean Time Between Failure，MTBF）来度量；可维护性使用平均可修复时间（Mean Time To Repair，MTTR）来度量。可用性衡量系统可以正常使用的时间与总时间之比，其表征为：A=MTBF/（MTBF+MTTR），即可用性是由可靠性和可维护性计算得出的比例值，譬如 99.9999%可用，即代表平均年故障修复时间为 32 秒。</li>
<li><strong>分区容忍性（Partition Tolerance）</strong>：代表分布式环境中部分节点因网络原因而彼此失联后，即与其他节点形成“网络分区”时，系统仍能正确地提供服务的能力。</li>
</ul>
<p>​</p>
<p>由于 CAP 定理已有严格的证明，本节不去探讨为何 CAP 不可兼得，而是直接分析如果舍弃 C、A、P 时所带来的不同影响。</p>
<ul>
<li><strong>如果放弃分区容忍性</strong>（CA without P），意味着我们将假设节点之间通信永远是可靠的。永远可靠的通信在分布式系统中必定不成立的，这不是你想不想的问题，而是只要用到网络来共享数据，分区现象就会始终存在。在现实中，最容易找到放弃分区容忍性的例子便是传统的关系数据库集群，这样的集群虽然依然采用由网络连接的多个节点来协同工作，但数据却不是通过网络来实现共享的。以 Oracle 的 RAC 集群为例，它的每一个节点均有自己独立的 SGA、重做日志、回滚日志等部件，但各个节点是通过共享存储中的同一份数据文件和控制文件来获取数据的，通过共享磁盘的方式来避免出现网络分区。因而 Oracle RAC 虽然也是由多个实例组成的数据库，但它并不能称作是分布式数据库。</li>
<li><strong>如果放弃可用性</strong>（CP without A），意味着我们将假设一旦网络发生分区，节点之间的信息同步时间可以无限制地延长，此时，问题相当于退化到前面“全局事务”中讨论的一个系统使用多个数据源的场景之中，我们可以通过 2PC/3PC 等手段，同时获得分区容忍性和一致性。在现实中，选择放弃可用性的 CP 系统情况一般用于对数据质量要求很高的场合中，除了 DTP 模型的分布式数据库事务外，著名的 HBase 也是属于 CP 系统，以 HBase 集群为例，假如某个 RegionServer 宕机了，这个 RegionServer 持有的所有键值范围都将离线，直到数据恢复过程完成为止，这个过程要消耗的时间是无法预先估计的。</li>
<li><strong>如果放弃一致性</strong>（AP without C），意味着我们将假设一旦发生分区，节点之间所提供的数据可能不一致。选择放弃一致性的 AP 系统目前是设计分布式系统的主流选择，因为 P 是分布式网络的天然属性，你再不想要也无法丢弃；而 A 通常是建设分布式的目的，如果可用性随着节点数量增加反而降低的话，很多分布式系统可能就失去了存在的价值，除非银行、证券这些涉及金钱交易的服务，宁可中断也不能出错，否则多数系统是不能容忍节点越多可用性反而越低的。目前大多数 NoSQL 库和支持分布式的缓存框架都是 AP 系统，以 Redis 集群为例，如果某个 Redis 节点出现网络分区，那仍不妨碍各个节点以自己本地存储的数据对外提供缓存服务，但这时有可能出现请求分配到不同节点时返回给客户端的是不一致的数据。</li>
</ul>
<p>​</p>
<h5 id="可靠事件队列"><a href="#可靠事件队列" class="headerlink" title="可靠事件队列"></a>可靠事件队列</h5><p>最终一致性的概念是 eBay 的系统架构师 Dan Pritchett 在 2008 年在 ACM 发表的论文《Base: An Acid Alternative》中提出的，该论文总结了一种独立于 ACID 获得的强一致性之外的、使用 BASE 来达成一致性目的的途径。BASE 分别是<strong>基本可用性（Basically Available）</strong>、<strong>柔性事务（Soft State）</strong>和<strong>最终一致性（Eventually Consistent）</strong>的缩写。BASE 这提法简直是把数据库科学家酷爱凑缩写的恶趣味发挥到淋漓尽致，不过有 ACID vs BASE（酸 vs 碱）这个朗朗上口的梗，该论文的影响力的确传播得足够快。在这里笔者就不多谈 BASE 中的概念问题了，虽然调侃它是恶趣味，但这篇论文本身作为最终一致性的概念起源，并系统性地总结了一种针对分布式事务的技术手段，是非常有价值的。<br>举个例子：<br>用100块买一本书，分别要经过三个业务服务：<strong>账号服务、仓库服务，商家服务</strong>。这时候可加入一个<strong>消息队列服务</strong>，在账号服务扣钱成功后，在自己的数据库建立一张消息表，里面存入一条消息：“事务 ID：某 UUID，扣款：100 元（状态：已完成），仓库出库《深入理解 Java 虚拟机》：1 本（状态：进行中），某商家收款：100 元（状态：进行中）”。消息队列服务，定时轮询消息表，将状态是“进行中”的消息同时发送到库存和商家服务节点中去（也可以串行地发，即一个成功后再发送另一个，但在我们讨论的场景中没必要）。这时候可能产生以下几种情况：</p>
<ol>
<li>商家和仓库服务都成功完成了收款和出库工作，向用户账号服务器返回执行结果，用户账号服务把消息状态从“进行中”更新为“已完成”。整个事务宣告顺利结束，达到最终一致性的状态。</li>
<li>商家或仓库服务中至少一个因网络原因，未能收到来自用户账号服务的消息。此时，由于用户账号服务器中存储的消息状态一直处于“进行中”，所以消息服务器将在每次轮询的时候持续地向未响应的服务重复发送消息。这个步骤的可重复性决定了所有被消息服务器发送的消息都必须具备幂等性，通常的设计是让消息带上一个唯一的事务 ID，以保证一个事务中的出库、收款动作会且只会被处理一次。</li>
<li>商家或仓库服务有某个或全部无法完成工作，譬如仓库发现《深入理解 Java 虚拟机》没有库存了，<strong>此时，仍然是持续自动重发消息，直至操作成功（譬如补充了新库存），或者被人工介入为止</strong>。由此可见，可靠事件队列只要第一步业务完成了，后续就没有失败回滚的概念，只许成功，不许失败。</li>
<li>商家和仓库服务<strong>成功完成了收款和出库工作</strong>，但回复的应答消息因网络原因丢失，此时，<strong>用户账号服务仍会重新发出下一条消息</strong>，但因操作具备幂等性，所以不会导致重复出库和收款，只会导致商家、仓库服务器重新发送一条应答消息，此过程重复直至双方网络通信恢复正常。</li>
<li>也有一些支持分布式事务的消息框架，如 RocketMQ，原生就支持分布式事务操作，这时候上述情况 2、4 也可以交由消息框架来保障。</li>
</ol>
<p>​</p>
<h5 id="TCC事务"><a href="#TCC事务" class="headerlink" title="TCC事务"></a>TCC事务</h5><p>TCC 是另一种常见的分布式事务机制，它是“Try-Confirm-Cancel”三个单词的缩写，在具体实现上，TCC 较为烦琐，它是一种业务侵入式较强的事务方案，要求业务处理过程必须拆分为“预留业务资源”和“确认/释放消费资源”两个子过程。如同 TCC 的名字所示，它分为以下三个阶段。</p>
<ul>
<li><strong>Try</strong>：尝试执行阶段，完成所有业务可执行性的检查（保障一致性），并且预留好全部需用到的业务资源（保障隔离性）。</li>
<li><strong>Confirm</strong>：确认执行阶段，不进行任何业务检查，直接使用 Try 阶段准备的资源来完成业务处理。Confirm 阶段可能会重复执行，因此本阶段所执行的操作需要具备幂等性。</li>
<li><strong>Cancel</strong>：取消执行阶段，释放 Try 阶段预留的业务资源。Cancel 阶段可能会重复执行，也需要满足幂等性。</li>
</ul>
<p>​</p>
<p>依然是同一个例子，用100块买一本书，分别要经过三个业务服务：<strong>账号服务、仓库服务，商家服务</strong>，其过程如下：</p>
<ol>
<li>用户发送交易请求：购买一本价值 100 元的《深入理解 Java 虚拟机》。</li>
<li>创建事务，生成事务 ID，记录在活动日志中，进入 Try 阶段：<ul>
<li>用户服务：检查业务可行性，可行的话，将该用户的 100 元设置为“冻结”状态，通知下一步进入 Confirm 阶段；不可行的话，通知下一步进入 Cancel 阶段。</li>
<li>仓库服务：检查业务可行性，可行的话，将该仓库的 1 本《深入理解 Java 虚拟机》设置为“冻结”状态，通知下一步进入 Confirm 阶段；不可行的话，通知下一步进入 Cancel 阶段。</li>
<li>商家服务：检查业务可行性，不需要冻结资源。</li>
</ul>
</li>
<li>如果第 2 步所有业务均反馈业务可行，将活动日志中的状态记录为 Confirm，进入 Confirm 阶段：<ul>
<li>用户服务：完成业务操作（扣减那被冻结的 100 元）。</li>
<li>仓库服务：完成业务操作（标记那 1 本冻结的书为出库状态，扣减相应库存）。</li>
<li>商家服务：完成业务操作（收款 100 元）。</li>
</ul>
</li>
<li>第 3 步如果全部完成，事务宣告正常结束，如果第 3 步中任何一方出现异常，不论是业务异常或者网络异常，都将根据活动日志中的记录，重复执行该服务的 Confirm 操作，即进行最大努力交付。</li>
<li>如果第 2 步有任意一方反馈业务不可行，或任意一方超时，将活动日志的状态记录为 Cancel，进入 Cancel 阶段：<ul>
<li>用户服务：取消业务操作（释放被冻结的 100 元）。</li>
<li>仓库服务：取消业务操作（释放被冻结的 1 本书）。</li>
<li>商家服务：取消业务操作（大哭一场后安慰商家谋生不易）。</li>
</ul>
</li>
<li>第 5 步如果全部完成，事务宣告以失败回滚结束，如果第 5 步中任何一方出现异常，不论是业务异常或者网络异常，都将根据活动日志中的记录，<strong>重复执行该服务的 Cancel 操作</strong>，即进行最大努力交付。</li>
</ol>
<p>​</p>
<p>由上述操作过程可见，TCC 其实有点类似 2PC 的准备阶段和提交阶段，但 TCC 是位于用户代码层面，而不是在基础设施层面，这为它的实现带来了较高的灵活性，可以根据需要设计资源锁定的粒度。TCC 在业务执行时只操作预留资源，几乎不会涉及锁和资源的争用，具有很高的性能潜力。但是 TCC 并非纯粹只有好处，它也带来了更高的开发成本和业务侵入性，意味着有更高的开发成本和更换事务实现方案的替换成本，所以，通常我们并不会完全靠裸编码来实现 TCC，而是基于某些分布式事务中间件（譬如阿里开源的Seata）去完成，尽量减轻一些编码工作量。</p>
<h5 id="SAGA-事务"><a href="#SAGA-事务" class="headerlink" title="SAGA 事务"></a>SAGA 事务</h5><p>TCC 事务具有较强的隔离性，避免了“超售”的问题，而且其性能一般来说是本篇提及的几种柔性事务模式中最高的，但它仍不能满足所有的场景。TCC 的最主要限制是它的<strong>业务侵入性很强</strong>，这里并不是重复上一节提到的它需要开发编码配合所带来的工作量，而更多的是指它所要求的技术可控性上的约束。譬如，把我们的场景事例修改如下：由于中国网络支付日益盛行，现在用户和商家在书店系统中可以选择不再开设充值账号，至少不会强求一定要先从银行充值到系统中才能进行消费，允许直接在购物时通过 U 盾或扫码支付，在银行账号中划转货款。这个需求完全符合国内网络支付盛行的现状，却给系统的事务设计增加了额外的限制：如果用户、商家的账号余额由银行管理的话，其操作权限和数据结构就不可能再随心所欲的地自行定义，通常也就无法完成冻结款项、解冻、扣减这样的操作，因为银行一般不会配合你的操作。所以 TCC 中的第一步 Try 阶段往往无法施行。我们只能考虑采用另外一种柔性事务方案：SAGA 事务。SAGA 在英文中是“长篇故事、长篇记叙、一长串事件”的意思。<br>SAGA 事务模式的历史十分悠久，还早于分布式事务概念的提出。它源于 1987 年普林斯顿大学的 Hector Garcia-Molina 和 Kenneth Salem 在 ACM 发表的一篇论文《SAGAS》（这就是论文的全名）。文中提出了一种提升“长时间事务”（Long Lived Transaction）运作效率的方法，大致思路是把一个大事务分解为可以交错运行的一系列子事务集合。原本 SAGA 的目的是避免大事务长时间锁定数据库的资源，后来才发展成将一个分布式环境中的大事务分解为一系列本地事务的设计模式。SAGA 由两部分操作组成。</p>
<ul>
<li>大事务拆分若干个小事务，将整个分布式事务 T 分解为 n 个子事务，命名为 T1，T2，…，Ti，…，Tn。每个子事务都应该是或者能被视为是原子行为。如果分布式事务能够正常提交，其对数据的影响（最终一致性）应与连续按顺序成功提交 Ti等价。</li>
<li>为每一个子事务设计对应的补偿动作，命名为 C1，C2，…，Ci，…，Cn。Ti与 Ci必须满足以下条件：<ul>
<li>Ti与 Ci都具备幂等性。</li>
<li>Ti与 Ci满足交换律（Commutative），即先执行 Ti还是先执行 Ci，其效果都是一样的。</li>
<li>Ci必须能成功提交，即不考虑 Ci本身提交失败被回滚的情形，如出现就必须持续重试直至成功，或者要人工介入。</li>
</ul>
</li>
</ul>
<p>如果 T1到 Tn均成功提交，那事务顺利完成，否则，要采取以下两种恢复策略之一：</p>
<ul>
<li><strong>正向恢复</strong>（Forward Recovery）：如果 Ti事务提交失败，则一直对 Ti进行重试，直至成功为止（最大努力交付）。这种恢复方式不需要补偿，适用于事务最终都要成功的场景，譬如在别人的银行账号中扣了款，就一定要给别人发货。正向恢复的执行模式为：T1，T2，…，Ti（失败），Ti（重试）…，Ti+1，…，Tn。</li>
<li><strong>反向恢复</strong>（Backward Recovery）：如果 Ti事务提交失败，则一直执行 Ci对 Ti进行补偿，直至成功为止（最大努力交付）。这里要求 Ci必须（在持续重试后）执行成功。反向恢复的执行模式为：T1，T2，…，Ti（失败），Ci（补偿），…，C2，C1。</li>
</ul>
<p>与 TCC 相比，SAGA 不需要为资源设计冻结状态和撤销冻结的操作，补偿操作往往要比冻结操作容易实现得多。譬如，前面提到的账号余额直接在银行维护的场景，从银行划转货款到 Fenix’s Bookstore 系统中，这步是经由用户支付操作（扫码或 U 盾）来促使银行提供服务；如果后续业务操作失败，尽管我们无法要求银行撤销掉之前的用户转账操作，但是由 Fenix’s Bookstore 系统将货款转回到用户账上作为补偿措施却是完全可行的。<br>SAGA 必须保证所有子事务都得以提交或者补偿，但 SAGA 系统本身也有可能会崩溃，所以它必须设计成与数据库类似的日志机制（被称为 SAGA Log）以保证系统恢复后可以追踪到子事务的执行情况，譬如执行至哪一步或者补偿至哪一步了。另外，尽管补偿操作通常比冻结/撤销容易实现，但保证正向、反向恢复过程的能严谨地进行也需要花费不少的工夫，譬如通过服务编排、可靠事件队列等方式完成，所以，SAGA 事务通常也不会直接靠裸编码来实现，一般也是在事务中间件的基础上完成，前面提到的 Seata 就同样支持 SAGA 事务模式。<br>​</p>
<h3 id="服务安全"><a href="#服务安全" class="headerlink" title="服务安全"></a>服务安全</h3><p>即使只限定在“软件架构设计”这个语境下，系统安全仍然是一个很大的话题。我们谈论的计算机系统安全，不仅仅是指“防御系统被黑客攻击”这样狭隘的安全,，还至少应包括（不限于）以下这些问题的具体解决方案：</p>
<ul>
<li><strong>认证（Authentication）</strong>：系统如何正确分辨出操作用户的真实身份？</li>
<li><strong>授权（ Authorization）</strong>：系统如何控制一个用户该看到哪些数据、能操作哪些功能？</li>
<li><strong>凭证（Credential）</strong>：系统如何保证它与用户之间的承诺是双方当时真实意图的体现，是准确、完整且不可抵赖的？</li>
<li><strong>保密（Confidentiality）</strong>：系统如何保证敏感数据无法被包括系统管理员在内的内外部人员所窃取、滥用？</li>
<li><strong>传输（Transport Security）</strong>：系统如何保证通过网络传输的信息无法被第三方窃听、篡改和冒充？</li>
<li><strong>验证（Verification）</strong>：系统如何确保提交到每项服务中的数据是合乎规则的，不会对系统稳定性、数据一致性、正确性产生风险？</li>
</ul>
<p>​</p>
<h4 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h4><p>引用 J2EE 1.2 对安全的改进还有另一个原因，它内置的 Basic、Digest、Form 和 Client-Cert 这四种认证方案都很有代表性，刚好分别覆盖了通信信道、协议和内容层面的认证。而这三种层面认证恰好涵盖了主流的三种认证方式，具体含义和应用场景列举如下。</p>
<ul>
<li><strong>通信信道上的认证</strong>：你和我建立通信连接之前，要先证明你是谁。在网络传输（Network）场景中的典型是基于 SSL/TLS 传输安全层的认证。</li>
<li><strong>通信协议上的认证</strong>：你请求获取我的资源之前，要先证明你是谁。在互联网（Internet）场景中的典型是基于 HTTP 协议的认证。</li>
<li><strong>通信内容上的认证</strong>：你使用我提供的服务之前，要先证明你是谁。在万维网（World Wide Web）场景中的典型是基于 Web 内容的认证。</li>
</ul>
<p>关于通信信道上的认证，由于内容较多，又与后续介绍微服务安全方面的话题关系密切，将会独立放到本章的“传输”里，而且 J2EE 中的 Client-Cert 其实并不是用于 TLS 的，以它引出 TLS 并不合适。下面重点了解基于通信协议和通信内容的两种认证方式。</p>
<h5 id="HTTP-认证"><a href="#HTTP-认证" class="headerlink" title="HTTP 认证"></a>HTTP 认证</h5><p><strong>HTTP Basic 认证</strong>是一种主要以演示为目的的认证方案，也应用于一些不要求安全性的场合，譬如家里的路由器登录等。Basic 认证产生用户身份凭证的方法是让用户输入用户名和密码，经过 Base64 编码“加密”后作为身份凭证。比如发送内容：<br><code>GET /admin HTTP/1.1</code><br><code>Authorization: Basic aWN5ZmVuaXg6MTIzNDU2</code><br>服务端接收到请求，解码后检查用户名和密码是否合法，如果合法就返回/admin的资源，否则就返回 403 Forbidden 错误，禁止下一步操作。注意 Base64 只是一种编码方式，并非任何形式的加密，所以 Basic 认证的风险是显而易见的。<br>​</p>
<h5 id="web认证"><a href="#web认证" class="headerlink" title="web认证"></a>web认证</h5><p>IETF 为 HTTP 认证框架设计了可插拔（Pluggable）的认证方案，原本是希望能涌现出各式各样的认证方案去支持不同的应用场景。尽管上节列举了一些还算常用的认证方案，但目前的信息系统，尤其是在系统对终端用户的认证场景中，直接采用 HTTP 认证框架的比例其实十分低，这不难理解，HTTP 是“超文本传输协议”，传输协议的根本职责是把资源从服务端传输到客户端，至于资源具体是什么内容，只能由客户端自行解析驱动。以 HTTP 协议为基础的认证框架也只能面向传输协议而不是具体传输内容来设计，如果用户想要从服务器中下载文件，弹出一个 HTTP 服务器的对话框，让用户登录是可接受的；但如果用户访问信息系统中的具体服务，身份认证肯定希望是由系统本身的功能去完成的，而不是由 HTTP 服务器来负责认证。这种依靠内容而不是传输协议来实现的认证方式，在万维网里被称为“Web 认证”，由于实现形式上登录表单占了绝对的主流，因此通常也被称为“表单认证”（Form Authentication）。<br>直至 2019 年以前，表单认证都没有什么行业标准可循，表单是什么样，其中的用户字段、密码字段、验证码字段是否要在客户端加密，采用何种方式加密，接受表单的服务地址是什么等，都完全由服务端与客户端的开发者自行协商决定。“没有标准的约束”反倒成了表单认证的一大优点，表单认证允许我们做出五花八门的页面，各种程序语言、框架或开发者本身都可以自行决定认证的全套交互细节。</p>
<h4 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h4><p>授权这个概念通常伴随着认证、审计、账号一同出现，并称为** AAAA（Authentication、Authorization、Audit、Account，也有一些领域把 Account 解释为计费的意思）**。授权行为在程序中的应用非常广泛，给某个类或某个方法设置范围控制符（public、protected、private、<Package>）在本质上也是一种授权（访问控制）行为。而在安全领域中所说的授权就更具体一些，通常涉及以下两个相对独立的问题：</p>
<ul>
<li><strong>确保授权的过程可靠</strong>：对于单一系统来说，授权的过程是比较容易做到可控的，以前很多语境上提到授权，实质上讲的都是访问控制，理论上两者是应该分开的。而在涉及多方的系统中，授权过程则是一个比较困难却必须严肃对待的问题：如何既让第三方系统能够访问到所需的资源，又能保证其不泄露用户的敏感数据呢？常用的多方授权协议主要有** OAuth2** 和 <strong>SAML 2.0</strong>（两个协议涵盖的功能并不是直接对等的）。</li>
<li><strong>确保授权的结果可控</strong>：授权的结果用于对程序功能或者资源的访问控制（Access Control），成理论体系的权限控制模型有很多，譬如自主访问控制（Discretionary Access Control，DAC）、强制访问控制（Mandatory Access Control，MAC）、基于属性的访问控制（Attribute-Based Access Control，ABAC），还有最为常用的<strong>基于角色的访问控制（Role-Based Access Control，RBAC）</strong>。</li>
</ul>
<p>​</p>
<p>这里只讲述RBAC与OAuth2。<br>​</p>
<h5 id="RBAC"><a href="#RBAC" class="headerlink" title="RBAC"></a>RBAC</h5><p>所有的访问控制模型，实质上都是在解决同一个问题：“<strong>谁</strong>（User）拥有什么<strong>权限</strong>（Authority）去<strong>操作</strong>（Operation）哪些<strong>资源</strong>（Resource）”。<br>这个问题初看起来并不难，一种直观的解决方案就是在用户对象上设定一些权限，当用户使用资源时，检查是否有对应的操作权限即可。很多著名的安全框架，譬如 Spring Security 的访问控制本质上就是支持这么做的。不过，这种把权限直接关联在用户身上的简单设计，在复杂系统上确实会导致一些比较烦琐的问题。试想一下，如果某个系统涉及到成百上千的资源，又有成千上万的用户，一旦两者搅合到一起，要为每个用户访问每个资源都分配合适的权限，必定导致巨大的操作量和极高的出错概率，这也正是 RBAC 所关注的问题之一。<br>RBAC 模型在业界中有多种说法，其中以美国 George Mason 大学信息安全技术实验室提出的 RBAC96 模型最具有系统性，得到普遍的认可。为了避免对每一个用户设定权限，RBAC 将权限从用户身上剥离，改为绑定到“<strong>角色</strong>”（Role）上，将权限控制变为对“<strong>角色</strong>拥有操作哪些<strong>资源</strong>的<strong>许可</strong>”这个逻辑表达式的值是否为真的求解过程。RBAC 的主要元素的关系可以用下图来表示：<br><img data-src="https://gitee.com/littleeight/blog-images/raw/master/%E5%AF%B9%E4%BA%8E%E6%9E%B6%E6%9E%84%E7%9A%84%E6%B7%B1%E5%85%A5%E6%8E%A2%E8%AE%A8/15.png"></p>
<h5 id="OAuth2"><a href="#OAuth2" class="headerlink" title="OAuth2"></a>OAuth2</h5><p>了解过 RBAC 的内容后，下面我们再来看看相对更复杂烦琐的 OAuth2 认证授权协议（更烦琐的 OAuth1 已经完全被废弃了）。 OAuth2 是<strong>面向于解决第三方应用</strong>（Third-Party Application）的认证授权协议。如果你的系统并不涉及第三方，譬如我们单体架构的 Fenix’s Bookstore 中就既不为第三方提供服务，也不使用第三方的服务，那引入 OAuth2 其实并无必要。为什么强调第三方？在多方系统授权过程具体会有什么问题需要专门制订一个标准协议来解决呢？笔者举个现实的例子来解释。<br>譬如你创建了一个自己的博客，它的建设和更新大致流程是：笔者写好了某篇文章，上传到GitHub仓库上，接着由Travis-CI提供的持续集成服务会检测到该仓库发生了变化，触发一次 Vuepress 编译活动，生成目录和静态的 HTML 页面，然后推送回GitHub Pages，再触发国内的 CDN 缓存刷新。这个过程要能顺利进行，就存在一系列必须解决的授权问题，Travis-CI 只有得到了我的明确授权，GitHub 才能同意它读取我代码仓库中的内容，问题是它该如何获得我的授权呢？一种最简单粗暴的方案是把我的用户账号和密码都告诉 Travis-CI，但这显然导致了以下这些问题：</p>
<ul>
<li><strong>密码泄漏</strong>：如果 Travis-CI 被黑客攻破，将导致我的 GitHub 的密码也同时被泄漏。</li>
<li><strong>访问范围</strong>：Travis-CI 将有能力读取、修改、删除、更新我放在 GitHub 上的所有代码仓库，而我并不希望它能够修改删除文件。</li>
<li><strong>授权回收</strong>：只有修改密码才能回收我授予给 Travis-CI 的权力，可是我在 GitHub 的密码只有一个，授权的应用除了 Travis-CI 之外却还有许多，修改了意味着所有别的第三方的应用程序会全部失效。</li>
</ul>
<p>​</p>
<p>以上列举的这些问题，也正是 OAuth2 所要解决的问题，尤其是要求第三方系统没有支持 HTTPS 传输安全的环境下依然能够解决这些问题，这并非易事。<br>OAuth2 给出了多种解决办法，这些办法的共同特征是以令牌（Token）代替用户密码作为授权的凭证。有了令牌之后，哪怕令牌被泄漏，也不会导致密码的泄漏；令牌上可以设定访问资源的范围以及时效性；每个应用都持有独立的令牌，哪个失效都不会波及其他。这样上面提出的三个问题就都解决了。有了一层令牌之后，整个授权的流程如下图所示：<br><img data-src="https://gitee.com/littleeight/blog-images/raw/master/%E5%AF%B9%E4%BA%8E%E6%9E%B6%E6%9E%84%E7%9A%84%E6%B7%B1%E5%85%A5%E6%8E%A2%E8%AE%A8/16.png"></p>
<p>这个时序图里面涉及到了 OAuth2 中几个关键术语，我们通过前面那个具体的上下文语境来解释其含义，这对理解后续几种认证流程十分重要：</p>
<ul>
<li><strong>第三方应用</strong>（Third-Party Application）：需要得到授权访问我资源的那个应用，即此场景中的“Travis-CI”。</li>
<li><strong>授权服务器</strong>（Authorization Server）：能够根据我的意愿提供授权（授权之前肯定已经进行了必要的认证过程，但它与授权可以没有直接关系）的服务器，即此场景中的“GitHub”。</li>
<li><strong>资源服务器</strong>（Resource Server）：能够提供第三方应用所需资源的服务器，它与认证服务可以是相同的服务器，也可以是不同的服务器，此场景中的“我的代码仓库”。</li>
<li><strong>资源所有者</strong>（Resource Owner）： 拥有授权权限的人，即此场景中的“我”。</li>
<li><strong>操作代理</strong>（User Agent）：指用户用来访问服务器的工具，对于人类用户来说，这个通常是指浏览器，但在微服务中一个服务经常会作为另一个服务的用户，此时指的可能就是 HttpClient、RPCClient 或者其他访问途径。</li>
</ul>
<p>“用令牌代替密码”确实是解决问题的好方法，但这充其量只能算个思路，距离可实施的步骤还是不够具体的，时序图中的“要求/同意授权”、“要求/同意发放令牌”、“要求/同意开放资源”几个服务请求、响应该如何设计，这就是执行步骤的关键了。对此，OAuth2 一共提出了四种不同的授权方式（这也是 OAuth2 复杂烦琐的主要原因），分别为：</p>
<ul>
<li><strong>授权码模式（Authorization Code）</strong></li>
<li><strong>隐式授权模式（Implicit）</strong></li>
<li><strong>密码模式（Resource Owner Password Credentials）</strong></li>
<li><strong>客户端模式（Client Credentials）</strong><h6 id="授权码模式"><a href="#授权码模式" class="headerlink" title="授权码模式"></a>授权码模式</h6>授权码模式是四种模式中最严（luō）谨（suō）的，它考虑到了几乎所有敏感信息泄漏的预防和后果。具体步骤的时序如图所示：<br><img data-src="https://gitee.com/littleeight/blog-images/raw/master/%E5%AF%B9%E4%BA%8E%E6%9E%B6%E6%9E%84%E7%9A%84%E6%B7%B1%E5%85%A5%E6%8E%A2%E8%AE%A8/17.png"></li>
</ul>
<p>开始进行授权过程以前，第三方应用先要到授权服务器上进行注册，所谓注册，是指向认证服务器提供一个域名地址，然后从授权服务器中获取 <strong>ClientID</strong> 和 <strong>ClientSecret</strong>，以便能够顺利完成如下授权过程：</p>
<ol>
<li>第三方应用将资源所有者（用户）导向授权服务器的授权页面，并向授权服务器提供 ClientID 及用户同意授权后的回调 URI，这是一次客户端页面转向。</li>
<li>授权服务器根据 ClientID 确认第三方应用的身份，用户在授权服务器中决定是否同意向该身份的应用进行授权，用户认证的过程未定义在此步骤中，在此之前应该已经完成。</li>
<li>如果用户同意授权，授权服务器将转向第三方应用在第 1 步调用中提供的回调 URI，并附带上一个授权码和获取令牌的地址作为参数，这是第二次客户端页面转向。</li>
<li>第三方应用通过回调地址收到授权码，然后将授权码与自己的 ClientSecret 一起作为参数，通过服务器向授权服务器提供的获取令牌的服务地址发起请求，换取令牌。该服务器的地址应与注册时提供的域名处于同一个域中。</li>
<li>授权服务器核对授权码和 ClientSecret，确认无误后，向第三方应用授予令牌。令牌可以是一个或者两个，其中必定要有的是访问令牌（Access Token），可选的是刷新令牌（Refresh Token）。访问令牌用于到资源服务器获取资源，有效期较短，刷新令牌用于在访问令牌失效后重新获取，有效期较长。</li>
<li>资源服务器根据访问令牌所允许的权限，向第三方应用提供资源。</li>
</ol>
<p>这个过程设计，已经考虑到了几乎所有合理的意外情况，笔者再举几个最容易遇到的意外状况，以便你能够更好地理解为何要这样设计 OAuth2。</p>
<ul>
<li>会不会有其他应用冒充第三方应用骗取授权？<br>ClientID 代表一个第三方应用的“用户名”，这项信息是可以完全公开的。但 ClientSecret 应当只有应用自己才知道，这个代表了第三方应用的“密码”。在第 5 步发放令牌时，调用者必须能够提供 ClientSecret 才能成功完成。只要第三方应用妥善保管好 ClientSecret，就没有人能够冒充它。</li>
<li>为什么要先发放授权码，再用授权码换令牌？<br>这是因为客户端转向（通常就是一次 HTTP 302 重定向）对于用户是可见的，换而言之，授权码可能会暴露给用户以及用户机器上的其他程序，但由于用户并没有 ClientSecret，光有授权码也是无法换取到令牌的，所以避免了令牌在传输转向过程中被泄漏的风险。</li>
<li>为什么要设计一个时限较长的刷新令牌和时限较短的访问令牌？不能直接把访问令牌的时间调长吗？<br>这是为了缓解 OAuth2 在实际应用中的一个主要缺陷，通常访问令牌一旦发放，除非超过了令牌中的有效期，否则很难（需要付出较大代价）有其他方式让它失效，所以访问令牌的时效性一般设计的比较短，譬如几个小时，如果还需要继续用，那就定期用刷新令牌去更新，授权服务器就可以在更新过程中决定是否还要继续给予授权。</li>
</ul>
<p>尽管授权码模式是严谨的，但是它并不够好用，这不仅仅体现在它那繁复的调用过程上，还体现在它对第三方应用提出了一个“貌似不难”的要求：第三方应用必须有应用服务器，因为第 4 步要发起服务端转向，而且要求服务端的地址必须与注册时提供的地址在同一个域内。不要觉得要求一个系统要有应用服务器是天经地义理所当然的事情，你现在阅读文章的这个网站就没有任何应用服务器的支持，里面使用到了 Gitalk 作为每篇文章的留言板，它对 GitHub 来说照样是第三方应用，需要 OAuth2 授权来解决。</p>
<h6 id="隐式授权模式"><a href="#隐式授权模式" class="headerlink" title="隐式授权模式"></a>隐式授权模式</h6><p>隐式授权<strong>省略掉了通过授权码换取令牌</strong>的步骤，整个授权过程都不需要服务端支持，一步到位。代价是在隐式授权中，授权服务器不会再去验证第三方应用的身份，因为已经没有应用服务器了，ClientSecret 没有人保管，就没有存在的意义了。但其实还是会限制第三方应用的回调 URI 地址必须与注册时提供的域名一致，尽管有可能被 DNS 污染之类的攻击所攻破，但仍算是尽可能努力一下。同样的原因，也不能避免令牌暴露给资源所有者，不能避免用户机器上可能意图不轨的其他程序、HTTP 的中间人攻击等风险了。<br>隐私授权的调用时序如图 （从此之后的授权模式，时序中笔者就不再画出资源访问部分的内容了，就是前面 opt 框中的那一部分，以便更聚焦重点）所示。<br><img data-src="https://gitee.com/littleeight/blog-images/raw/master/%E5%AF%B9%E4%BA%8E%E6%9E%B6%E6%9E%84%E7%9A%84%E6%B7%B1%E5%85%A5%E6%8E%A2%E8%AE%A8/18.png"></p>
<h6 id="密码模式"><a href="#密码模式" class="headerlink" title="密码模式"></a>密码模式</h6><p>前面所说的授权码模式和隐私模式属于纯粹的授权模式，它们与认证没有直接的联系，如何认证用户的真实身份是与进行授权互相独立的过程。但在密码模式里，认证和授权就被整合成了同一个过程了。<br>密码模式原本的设计意图是仅限于用户对第三方应用是高度可信任的场景中使用，因为用户需要把密码明文提供给第三方应用，第三方以此向授权服务器获取令牌。这种高度可信的第三方是极为较罕见的，尽管介绍 OAuth2 的材料中，经常举的例子是“操作系统作为第三方应用向授权服务器申请资源”，但真实应用中极少遇到这样的情况，合理性依然十分有限。<br>理解了密码模式的用途，它的调用过程就很简单了，就是第三方应用拿着用户名和密码向授权服务器换令牌而已。如图所示：<br><img data-src="https://gitee.com/littleeight/blog-images/raw/master/%E5%AF%B9%E4%BA%8E%E6%9E%B6%E6%9E%84%E7%9A%84%E6%B7%B1%E5%85%A5%E6%8E%A2%E8%AE%A8/19.png"></p>
<h6 id="客户端模式"><a href="#客户端模式" class="headerlink" title="客户端模式"></a>客户端模式</h6><p>客户端模式是四种模式中最简单的，它只涉及到两个主体，第三方应用和授权服务器。如果严谨一点，现在称“第三方应用”其实已经不合适了，因为已经没有了“第二方”的存在，资源所有者、操作代理在客户端模式中都是不必出现的。甚至严格来说叫“授权”都已不太恰当，资源所有者都没有了，也就不会有谁授予谁权限的过程。<br>客户端模式是指第三方应用（行文一致考虑，还是继续沿用这个称呼）以自己的名义，向授权服务器申请资源许可。此模式通常用于管理操作或者自动处理类型的场景中。举个具体例子，譬如笔者开了一家叫 Fenix’s Bookstore 的书店，因为小本经营，不像京东那样全国多个仓库可以调货，因此必须保证只要客户成功购买，书店就必须有货可发，不允许超卖。但经常有顾客下了订单又拖着不付款，导致部分货物处于冻结状态。所以 Fenix’s Bookstore 中有一个订单清理的定时服务，自动清理超过两分钟还未付款的订单。在这个场景里，订单肯定是属于下单用户自己的资源，如果把订单清理服务看作一个独立的第三方应用的话，它是不可能向下单用户去申请授权来删掉订单的，而应该直接以自己的名义向授权服务器申请一个能清理所有用户订单的授权。客户端模式的时序如图所示：<br><img data-src="https://gitee.com/littleeight/blog-images/raw/master/%E5%AF%B9%E4%BA%8E%E6%9E%B6%E6%9E%84%E7%9A%84%E6%B7%B1%E5%85%A5%E6%8E%A2%E8%AE%A8/20.png"></p>
<h4 id="凭证"><a href="#凭证" class="headerlink" title="凭证"></a>凭证</h4><p>在前面介绍 OAuth2 的内容中，每一种授权模式的最终目标都是拿到访问令牌，但从未涉及过拿回来的令牌应该长什么样子。反而还挖了一些坑没有填（为何说 OAuth2 的一个主要缺陷是令牌难以主动失效）。<br>“如何承载认证授权信息”这个问题的不同看法，代表了软件架构对待共享状态信息的两种不同思路：状态应该维护在服务端，抑或是在客户端之中？在分布式系统崛起以前，这个问题原本已是有了较为统一的结论的，以 HTTP 协议的 Cookie-Session 机制为代表的服务端状态存储在三十年来都是主流的解决方案。不过，到了最近十年，由于分布式系统中共享数据必然会受到 CAP 不兼容原理的打击限制，迫使人们重新去审视之前已基本放弃掉的客户端状态存储，这就让原本通常只在多方系统中采用的 JWT 令牌方案，在分布式系统中也有了另一块用武之地。本节的话题，也就围绕着 Cookie-Session 和 JWT 之间的相同与不同而展开。</p>
<h5 id="Cookie-Session"><a href="#Cookie-Session" class="headerlink" title="Cookie-Session"></a>Cookie-Session</h5><p>大家知道 HTTP 协议是一种无状态的传输协议，无状态是指协议对事务处理没有上下文的记忆能力，每一个请求都是完全独立的，但是我们中肯定有许多人并没有意识到 HTTP 协议无状态的重要性。<br>可是，HTTP 协议的无状态特性又有悖于我们最常见的网络应用场景，典型就是认证授权，系统总得要获知用户身份才能提供合适的服务，因此，我们也希望 HTTP 能有一种手段，让服务器至少有办法能够区分出发送请求的用户是谁。为了实现这个目的，RFC 6265规范定义了 HTTP 的状态管理机制，在 HTTP 协议中增加了 Set-Cookie 指令，该指令的含义是以键值对的方式向客户端发送一组信息，此信息将在此后一段时间内的每次 HTTP 请求中，以名为 Cookie 的 Header 附带着重新发回给服务端，以便服务端区分来自不同客户端的请求。<br>由于 Cookie 是放在请求头上的，属于额外的传输负担，不应该携带过多的内容，而且放在 Cookie 中传输也并不安全，容易被中间人窃取或被篡改，所以<strong>通常是不会设置明文信息</strong>。一般来说，系统会把状态信息保存在服务端，在 Cookie 里只传输的是一个无字面意义的、不重复的字符串，习惯上以<strong>sessionid</strong>或者<strong>jsessionid</strong>为名，服务器拿这个字符串为 Key，在内存中开辟一块空间，以 Key/Entity 的结构存储每一个在线用户的上下文状态，再辅以一些超时自动清理之类的管理措施。这种服务端的状态管理机制就是今天大家非常熟悉的 Session，<strong>Cookie-Session</strong> 也即最传统但今天依然广泛应用于大量系统中的，由服务端与客户端联动来完成的状态管理机制。</p>
<h5 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h5><p>Cookie-Session 机制在分布式环境下会遇到 CAP 不可兼得的问题，而在多方系统中，就更不可能谈什么 Session 层面的数据共享了，哪怕服务端之间能共享数据，客户端的 Cookie 也没法跨域。所以我们不得不重新捡起最初被抛弃的思路，当服务器存在多个，客户端只有一个时，把状态信息存储在客户端，每次随着请求发回服务器去。笔者才说过这样做的缺点是无法携带大量信息，而且有泄漏和篡改的安全风险。信息量受限的问题并没有太好的解决办法，但是要确保信息不被中间人篡改则还是可以实现的，JWT 便是这个问题的标准答案。<br>JWT（JSON Web Token）定义于RFC 7519标准之中，是目前广泛使用的一种令牌格式，尤其经常与 OAuth2 配合应用于分布式的、涉及多方的应用系统中。介绍 JWT 的具体构成之前，我们先来直观地看一下它是什么样子的，如图所示:<br><img data-src="https://gitee.com/littleeight/blog-images/raw/master/%E5%AF%B9%E4%BA%8E%E6%9E%B6%E6%9E%84%E7%9A%84%E6%B7%B1%E5%85%A5%E6%8E%A2%E8%AE%A8/21.png"></p>
<p>以上截图来自 JWT 官网，右边的 JSON 结构是 JWT 令牌中携带的信息，左边的字符串呈现了 JWT 令牌的本体。它最常见的使用方式是附在名为 Authorization 的 Header 发送给服务端，前缀在RFC 6750中被规定为 Bearer。如果你没有忘记“认证方案”与“OAuth 2”的内容，那看到 Authorization 这个 Header 与 Bearer 这个前缀时，便应意识到它是 HTTP 认证框架中的 OAuth 2 认证方案。<br>右边的状态信息是对令牌使用 Base64URL 转码后得到的明文，请特别注意是明文，JWT 只解决防篡改的问题，并不解决防泄漏的问题，因此令牌默认是不加密的。尽管你自己要加密也并不难做到，接收时自行解密即可，但这样做其实没有太大意义</p>
<p>从明文中可以看到 JWT 令牌是以 JSON 结构（毕竟名字就叫 JSON Web Token）存储的，结构总体上可划分为三个部分，每个部分间用点号.分隔开。<br>第一部分是<strong>令牌头</strong>（Header）:</p>
<ul>
<li>alg,令牌算法</li>
<li>typ，令牌的类型，统一为JWT</li>
</ul>
<p>令牌的第二部分是<strong>负载</strong>（Payload），这是令牌真正需要向服务端传递的信息。举个例子：<br><code>&#123;  &quot;username&quot;: &quot;icyfenix&quot;,</code><br><code>  &quot;authorities&quot;: [    &quot;ROLE_USER&quot;,    &quot;ROLE_ADMIN&quot;  ],</code><br><code>  &quot;scope&quot;: [    &quot;ALL&quot;  ],</code><br><code> &quot;exp&quot;: 1584948947,</code><br><code> &quot;jti&quot;: &quot;9d77586a-3f4f-4cbb-9924-fe2f77dfa33d&quot;,</code><br><code>  &quot;client_id&quot;: &quot;bookstore_frontend&quot;</code><br><code>&#125;</code><br>而 JWT 在 RFC 7519 中推荐（非强制约束）了七项声明名称（Claim Name），如有需要用到这些内容，建议字段名与官方的保持一致：</p>
<ul>
<li>iss（Issuer）：签发人。</li>
<li>exp（Expiration Time）：令牌过期时间。</li>
<li>sub（Subject）：主题。</li>
<li>aud （Audience）：令牌受众。</li>
<li>nbf （Not Before）：令牌生效时间。</li>
<li>iat （Issued At）：令牌签发时间。</li>
<li>jti （JWT ID）：令牌编号。</li>
</ul>
<p>令牌的第三部分是<strong>签名</strong>（Signature），签名的意思是：使用在对象头中公开的特定签名算法，通过特定的密钥（Secret，由服务器进行保密，不能公开）对前面两部分内容进行加密计算。<br>​</p>
<p>但是，JWT 也并非没有缺点的完美方案，它存在着以下几个经常被提及的缺点：</p>
<ul>
<li><strong>令牌难以主动失效</strong>：JWT 令牌一旦签发，理论上就和认证服务器再没有什么瓜葛了，在到期之前就会始终有效，除非服务器部署额外的逻辑去处理失效问题，这对某些管理功能的实现是很不利的。譬如一种颇为常见的需求是：要求一个用户只能在一台设备上登录，在 B 设备登录后，之前已经登录过的 A 设备就应该自动退出。如果采用 JWT，就必须设计一个“黑名单”的额外的逻辑，用来把要主动失效的令牌集中存储起来，而无论这个黑名单是实现在 Session、Redis 或者数据库中，都会让服务退化成有状态服务，降低了 JWT 本身的价值，但黑名单在使用 JWT 时依然是很常见的做法，需要维护的黑名单一般是很小的状态量，许多场景中还是有存在价值的。</li>
<li><strong>相对更容易遭受重放攻击</strong>：首先说明 Cookie-Session 也是有重放攻击问题的，只是因为 Session 中的数据控制在服务端手上，应对重放攻击会相对主动一些。要在 JWT 层面解决重放攻击需要付出比较大的代价，无论是加入全局序列号（HTTPS 协议的思路）、Nonce 字符串（HTTP Digest 验证的思路）、挑战应答码（当下网银动态令牌的思路）、还是缩短令牌有效期强制频繁刷新令牌，在真正应用起来时都很麻烦。真要处理重放攻击，建议的解决方案是在信道层次（譬如启用 HTTPS）上解决，而不提倡在服务层次（譬如在令牌或接口其他参数上增加额外逻辑）上解决。</li>
<li><strong>只能携带相当有限的数据</strong>：HTTP 协议并没有强制约束 Header 的最大长度，但是，各种服务器、浏览器都会有自己的约束，譬如 Tomcat 就要求 Header 最大不超过 8KB，而在 Nginx 中则默认为 4KB，因此在令牌中存储过多的数据不仅耗费传输带宽，还有额外的出错风险。</li>
<li><strong>必须考虑令牌在客户端如何存储</strong>：严谨地说，这个并不是 JWT 的问题而是系统设计的问题。如果授权之后，操作完关掉浏览器就结束了，那把令牌放到内存里面，压根不考虑持久化那是最理想的方案。但并不是谁都能忍受一个网站关闭之后下次就一定强制要重新登录的。这样的话，想想客户端该把令牌存放到哪里？Cookie？localStorage？Indexed DB？它们都有泄漏的可能，而令牌一旦泄漏，别人就可以冒充用户的身份做任何事情。</li>
<li><strong>无状态也不总是好的</strong>：这个其实不也是 JWT 的问题。如果不能想像无状态会有什么不好的话，我给你提个需求：请基于无状态 JWT 的方案，做一个在线用户实时统计功能。兄弟，难搞哦。</li>
</ul>
<p>​</p>
<h4 id="保密"><a href="#保密" class="headerlink" title="保密"></a>保密</h4><p>保密是加密和解密的统称，是指以某种特殊的算法改变原有的信息数据，使得未授权的用户即使获得了已加密的信息，但因不知解密的方法，或者知晓解密的算法但缺少解密所需的必要信息，仍然无法了解数据的真实内容。<br>保密是有成本的，追求越高的安全等级，就要付出越多的工作量与算力消耗。连国家保密法都会把秘密信息划分为秘密、机密、绝密三级来区别对待，可见即使是信息安全，也应该有所取舍。笔者以用户登录为例，列举几种不同强度的保密手段，讨论它们的防御关注点与弱点：</p>
<ol>
<li><strong>以摘要代替明文</strong>：如果密码本身比较复杂，那一次简单的哈希摘要至少可以保证即使传输过程中有信息泄漏，也不会被逆推出原信息；即使密码在一个系统中泄漏了，也不至于威胁到其他系统的使用，但这种处理不能防止弱密码被彩虹表攻击所破解。</li>
<li><strong>先加盐值再做哈希</strong>是应对弱密码的常用方法：盐值可以替弱密码建立一道防御屏障，一定程度上防御已有的彩虹表攻击，但并不能阻止加密结果被监听、窃取后，攻击者直接发送加密结果给服务端进行冒认。</li>
<li><strong>将盐值变为动态值能有效防止冒认</strong>：如果每次密码向服务端传输时都掺入了动态的盐值，让每次加密的结果都不同，那即使传输给服务端的加密结果被窃取了，也不能冒用来进行另一次调用。尽管在双方通信均可能泄漏的前提下协商出只有通信双方才知道的保密信息是完全可行的（后续介绍“传输安全层”时会提到），但这样协商出盐值的过程将变得极为复杂，而且每次协商只保护一次操作，也难以阻止对其他服务的重放攻击。</li>
<li><strong>给服务加入动态令牌</strong>，在网关或其他流量公共位置建立校验逻辑，服务端愿意付出在集群中分发令牌信息等代价的前提下，可以做到防止重放攻击，但是依然不能抵御传输过程中被嗅探而泄漏信息的问题。</li>
<li>启用 HTTPS 可以防御链路上的恶意嗅探，也能在通信层面解决了重放攻击的问题。但是依然有因客户端被攻破产生伪造根证书风险、有因服务端被攻破产生的证书泄漏而被中间人冒认的风险、有因CRL更新不及时或者OCSP Soft-fail 产生吊销证书被冒用的风险、有因 TLS 的版本过低或密码学套件选用不当产生加密强度不足的风险。</li>
<li>为了抵御上述风险，保密强度还要进一步提升，譬如银行会使用独立于客户端的存储证书的物理设备（俗称的 U 盾）来避免根证书被客户端中的恶意程序窃取伪造；大型网站涉及到账号、金钱等操作时，会使用双重验证开辟一条独立于网络的信息通道（如手机验证码、电子邮件）来显著提高冒认的难度；甚至一些关键企业（如国家电网）或机构（如军事机构）会专门建设遍布全国各地的与公网物理隔离的专用内部网络来保障通信安全。</li>
</ol>
<p>​</p>
<h4 id="传输"><a href="#传输" class="headerlink" title="传输"></a>传输</h4><p>系统如何保证通过网络传输的信息无法被第三方窃听、篡改和冒充？<br>20 世纪 70 年代中后期出现的非对称加密算法从根本上解决了密钥分发的难题，它将密钥分成公钥和私钥，公钥可以完全公开，无须安全传输的保证。私钥由用户自行保管，不参与任何通信传输。根据这两个密钥加解密方式的不同，使得算法可以提供两种不同的功能：</p>
<ul>
<li><strong>公钥加密，私钥解密</strong>，这种就是加密，用于向私钥所有者发送信息，这个信息可能被他人篡改，但是无法被他人得知。如果甲想给乙发一个安全保密的数据，那么应该甲乙各自有一个私钥，甲先用乙的公钥加密这段数据，再用自己的私钥加密这段加密后的数据。最后再发给乙，这样确保了内容即不会被读取，也不能被篡改。</li>
<li><strong>私钥加密，公钥解密</strong>，这种就是签名，用于让所有公钥所有者验证私钥所有者的身份，并且用来防止私钥所有者发布的内容被篡改。但是不用来保证内容不被他人获得。</li>
<li>​</li>
</ul>
<p>表汇总了前面提到的三种算法，并列举了它们的主要特征、用途和局限性。<br><img data-src="https://gitee.com/littleeight/blog-images/raw/master/%E5%AF%B9%E4%BA%8E%E6%9E%B6%E6%9E%84%E7%9A%84%E6%B7%B1%E5%85%A5%E6%8E%A2%E8%AE%A8/22.png"></p>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>little_eight</tag>
      </tags>
  </entry>
</search>
