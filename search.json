[{"title":"ThreadPoolExecutor类解析","url":"/2019/07/23/ThreadPoolExecutor类解析/","content":"\n  在《阿里巴巴java开发手册》中指出了线程资源必须通过线程池提供，不允许在应用中自行显示的创建线程，这样一方面是线程的创建更加规范，可以合理控制开辟线程的数量；另一方面线程的细节管理交给线程池处理，优化了资源的开销。而线程池不允许使用Executors去创建，而要通过ThreadPoolExecutor方式，这一方面是由于jdk中Executor框架虽然提供了如newFixedThreadPool()、newSingleThreadExecutor()、newCachedThreadPool()等创建线程池的方法，但都有其局限性，不够灵活；另外由于前面几种方法内部也是通过ThreadPoolExecutor方式实现，使用ThreadPoolExecutor有助于大家明确线程池的运行规则，创建符合自己的业务场景需要的线程池，避免资源耗尽的风险。\n##  成员变量\n```\n    /**\n     * 线程池的控制状态，是AtomicInteger类型的，里面包含两部分，workcount---线程的数量，\n     * runState---线程池的运行状态。这里限制了最大线程数是2^29-1，大约500百万个线程，\n     * 这也是个问题，所以ctl也可以变成AtomicLong类型的\n     */\n    private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));\n    /**\n     * 线程数量所占位数\n     */\n    private static final int COUNT_BITS = Integer.SIZE - 3;\n    /**\n     * 理论上的最大活跃线程数\n     */\n    private static final int CAPACITY   = (1 << COUNT_BITS) - 1;\n\n    /**\n     * RUNNING - 接受新任务并且继续处理阻塞队列中的任务\n     * SHUTDOWN - 不接受新任务但是会继续处理阻塞队列中的任务\n     * STOP -  不接受新任务，不在执行阻塞队列中的任务，中断正在执行的任务\n     * TIDYING - 所有任务都已经完成，线程数都被回收，线程会转到TIDYING状态会继续执行钩子方法\n     * TERMINATED - 钩子方法执行完毕\n     */\n    private static final int RUNNING    = -1 << COUNT_BITS;\n    private static final int SHUTDOWN   =  0 << COUNT_BITS;\n    private static final int STOP       =  1 << COUNT_BITS;\n    private static final int TIDYING    =  2 << COUNT_BITS;\n    private static final int TERMINATED =  3 << COUNT_BITS;\n    \n    \n    /**\n     *  存放任务的队列，只有当线程数>核心线程数，才会把其他的任务放入queue，\n     * 一般常用的是queue就是ArrayBlockingQueue，LinkedBlockingQueue，\n     * SynchronousQueue， ConcurrentLinkedQueue。\n     *\n　　 * 1）ArrayBlockingQueue：基于数组的先进先出队列，此队列创建时必须指定大小；\n     *    \n　　 * 2）LinkedBlockingQueue：基于链表的先进先出队列，如果创建时没有指定此队列大小，则默认为Integer.MAX_VALUE；\n　　 * 3）synchronousQueue：这个队列比较特殊，它不会保存提交的任务，而是将直接新建一个线程来执行新来的任务。\n　　 * 4) ConcurrentLinkedQueue: 无界线程安全队列\n     */\n    private final BlockingQueue<Runnable> workQueue;\n\n    /**\n     * 包含池中所有工作线程的集合。仅当保持主锁.\n     */\n    private final HashSet<Worker> workers = new HashSet<Worker>();\n\n    /**\n     * 支持等待终止的等待条件\n     */\n    private final Condition termination = mainLock.newCondition();\n\n    /**\n     * 跟踪获得的最大池大小。仅在主锁下访问。\n     */\n    private int largestPoolSize;\n\n    /**\n     * 已完成任务的计数器。仅在工作线程终止时更新。仅在主锁下访问\n     */\n    private long completedTaskCount;\n\n    /**\n     * 创建线程的工厂类\n     */\n    private volatile ThreadFactory threadFactory;\n\n    /**\n     * 在执行中饱和或关闭时调用的处理程序。拒绝策略；当任务太多来不及处理时，如何拒绝任务\n     */\n    private volatile RejectedExecutionHandler handler;\n\n    /**\n     * 当线程池中创建的线程超过了核心线程数的时候，这些多余的空闲线程在结束之前等待新的                  * 创建线程的工厂类任务最大的存活时间。\n     */\n    private volatile long keepAliveTime;\n\n    /**\n     * 允许核心线程被回收\n     */\n    private volatile boolean allowCoreThreadTimeOut;\n\n    /**\n     * 线程池中的核心线程数，空闲的线程也不会回收，除非把allowCoreThreadTimeOut设置为true，              * 这时核心线程才会被回收\n     */\n    private volatile int corePoolSize;\n\n    /**\n     * 线程池中可以创建的最大线程数，限定为2^29-1，大约500百万个线程。\n     * 需要注意的是，当使用无界的阻塞队列的时候，maximumPoolSize就起不到作用了。\n     */\n    private volatile int maximumPoolSize;\n\n    /**\n     * 默认被拒绝的执行处理程序\n     */\n    private static final RejectedExecutionHandler defaultHandler =\n        new AbortPolicy();\n\n    /**\n     * 终止的权限\n     */\n    private static final RuntimePermission shutdownPerm =\n        new RuntimePermission(\"modifyThread\");\n\n    /**\n     * \n     */\n    private final AccessControlContext acc;\n```\n<!--more-->\n##  构造方法\n```\n    /**\n     * 有多个构造方法，只讲最终实现的\n     */\n    public ThreadPoolExecutor(int corePoolSize,\n                              int maximumPoolSize,\n                              long keepAliveTime,\n                              TimeUnit unit,\n                              BlockingQueue<Runnable> workQueue,\n                              ThreadFactory threadFactory,\n                              RejectedExecutionHandler handler) {\n        // 设置的核心线程数小于0，或者最大线程数小于0，或者最大线程数小于核心线程数，\n        // 创建线程的工厂类任务最大的存活时间小于0都抛出异常\n        if (corePoolSize < 0 ||\n            maximumPoolSize <= 0 ||\n            maximumPoolSize < corePoolSize ||\n            keepAliveTime < 0)\n            throw new IllegalArgumentException();\n        // 存放任务的队列、线程工厂、处理程序为null也抛出异常\n        if (workQueue == null || threadFactory == null || handler == null)\n            throw new NullPointerException();\n        this.acc = System.getSecurityManager() == null ?\n                null :\n                AccessController.getContext();\n        // 下面就是设置参数了\n        this.corePoolSize = corePoolSize;\n        this.maximumPoolSize = maximumPoolSize;\n        this.workQueue = workQueue;\n        this.keepAliveTime = unit.toNanos(keepAliveTime);\n        this.threadFactory = threadFactory;\n        this.handler = handler;\n    }\n    \n```\n\n## 主要方法（从用法入手）\n\n### execute\n```\n   /**\n    * 执行入口\n    *\n    * 三步操作\n    *\n    * 1. 如果当前运行的线程数<核心线程数,创建一个新的线程执行任务,调用addWorker方法原子性地检查\n    *    运行状态和线程数,通过返回false防止不需要的时候添加线程\n    * 2. 如果一个任务能够成功的入队,仍然需要双重检查,因为我们添加了一个线程(有可能这个线程在上次检查后就已经死亡了)\n    *    或者进入此方法的时候调用了shutdown,所以需要重新检查线程池的状态,如果必要的话,当停止的时候要回滚入队操作,\n    *    或者当线程池为空的话创建一个新的线程\n    * 3. 如果不能入队,尝试着开启一个新的线程,如果开启失败,说明线程池已经是shutdown状态或饱和了,所以拒绝执行该任务\n    */\n     public void execute(Runnable command) {\n        if (command == null)\n            throw new NullPointerException();\n        // 获取当前线程池的控制状态\n        int c = ctl.get();\n        // 如果当前运行的线程数<核心线程数\n        if (workerCountOf(c) < corePoolSize) {\n            // 调用addWorker方法原子性地检查运行状态和线程数,通过返回false防止不需要的时候添加线程\n            // 添加worker,成功则返回,下面再解析这个方法\n            if (addWorker(command, true))\n                return;\n            // 不成功则再次获取线程池控制状态\n            c = ctl.get();\n        }\n        // 线程池处于RUNNING状态，将命令（用户自定义的Runnable对象）添加进workQueue队列\n        if (isRunning(c) && workQueue.offer(command)) {\n             // 再次检查，获取线程池控制状态\n            int recheck = ctl.get();\n            // 线程池不处于RUNNING状态，将命令从workQueue队列中移除\n            if (! isRunning(recheck) && remove(command))\n                // 拒绝执行命令\n                reject(command);\n            // worker数量等于0,添加worker\n            else if (workerCountOf(recheck) == 0)\n                addWorker(null, false);\n        }\n        // 添加worker失败,拒绝执行命令\n        else if (!addWorker(command, false))\n            reject(command);\n    }\n```\n### addWorker\n```\n    /**\n     * \n     */\n     private boolean addWorker(Runnable firstTask, boolean core) {\n        retry:\n        for (;;) {\n            int c = ctl.get();\n            int rs = runStateOf(c);\n\n            // 检查线程池状态是否正常，否则返回false\n            if (rs >= SHUTDOWN &&\n                ! (rs == SHUTDOWN &&\n                   firstTask == null &&\n                   ! workQueue.isEmpty()))\n                return false;\n\n            for (;;) {\n                int wc = workerCountOf(c);\n                // 检查工作线程数是否正常，否则返回false\n                if (wc >= CAPACITY ||\n                    wc >= (core ? corePoolSize : maximumPoolSize))\n                    return false;\n                // 用到了原子CAS方法比较，使用CAS增加worker计数器成功，才能进入下一步\n                if (compareAndIncrementWorkerCount(c))\n                    break retry;\n                c = ctl.get(); \n                 // 这里表示执行到这里的时候线程池的运行状态发生改变的话，需要重新跳到retry处执行\n                if (runStateOf(c) != rs)\n                    continue retry;\n            }\n        }\n        // worker开始标识\n        boolean workerStarted = false;\n        // worker被添加标识\n        boolean workerAdded = false;\n        Worker w = null;\n        try {\n            // 使用firstTask初始化Worker，first可能为null，那么则表示该worker为空闲\n            w = new Worker(firstTask);\n            // 获取worker对应的线程\n            final Thread t = w.thread;\n            if (t != null) {\n                 // 获取线程池锁\n                final ReentrantLock mainLock = this.mainLock;\n                mainLock.lock();\n                try {\n                    // 线程池的运行状态\n                    int rs = runStateOf(ctl.get());\n                    // 判断线程池状态\n                    if (rs < SHUTDOWN ||\n                        (rs == SHUTDOWN && firstTask == null)) {\n                        // 线程刚添加进来，还未启动就存活,抛出线程状态异常\n                        if (t.isAlive())\n                            throw new IllegalThreadStateException();\n                        // 添加worker\n                        workers.add(w);\n                        int s = workers.size();\n                        // 如果队列大小大于最大池大小，让后者等于前者\n                        if (s > largestPoolSize)\n                            largestPoolSize = s;\n                        // 标识worker添加成功\n                        workerAdded = true;\n                    }\n                } finally {\n                    // 解锁\n                    mainLock.unlock();\n                }\n                // 如果worker添加成功，就标识运行成功\n                if (workerAdded) {\n                    // 开始执行worker的run方法\n                    t.start();\n                    workerStarted = true;\n                }\n            }\n        } finally {\n            // worker没有运行\n            if (! workerStarted)\n                // 添加worker失败，后面解析这个方法\n                addWorkerFailed(w);\n        }\n        // 返回worker的运行状态\n        return workerStarted;\n    }\n```\n\n### addWorkerFailed\n```\n    /**\n     * \n     */\n     private void addWorkerFailed(Worker w) {\n        // 获取主锁\n        final ReentrantLock mainLock = this.mainLock;\n        mainLock.lock();\n        try {\n            if (w != null)\n                // 移除该worker\n                workers.remove(w);\n            // 数量减1\n            decrementWorkerCount();\n            // 调用tryTerminate方法来尝试中止线程池,或者是清理一下线程池，下面说\n            tryTerminate();\n        } finally {\n            mainLock.unlock();\n        }\n    }\n```\n\n### tryTerminate\n```\n    /**\n     * 尝试终止线程池\n     */\nfinal void tryTerminate() {\n        for (;;) {\n            // 获取线程池控制状态\n            int c = ctl.get();\n            // 线程池的运行状态为RUNNING\n            if (isRunning(c) ||      \n                // 线程池的运行状态最小要大于TIDYING\n                runStateAtLeast(c, TIDYING) ||   \n                 // 线程池的运行状态为SHUTDOWN并且workQueue队列不为null\n                (runStateOf(c) == SHUTDOWN && ! workQueue.isEmpty()))   \n                // 不能终止，直接返回\n                return;\n            // 线程池正在运行的worker数量不为0   \n            if (workerCountOf(c) != 0) { \n                // 仅仅中断一个空闲的worker，下面说\n                interruptIdleWorkers(ONLY_ONE);\n                return;\n            }\n            // 获取线程池的锁\n            final ReentrantLock mainLock = this.mainLock;\n            // 获取锁\n            mainLock.lock();\n            try {\n                // 比较并设置线程池控制状态为TIDYING\n                if (ctl.compareAndSet(c, ctlOf(TIDYING, 0))) { \n                    try {\n                        // 终止，钩子函数\n                        terminated();\n                    } finally {\n                        // 设置线程池控制状态为TERMINATED\n                        ctl.set(ctlOf(TERMINATED, 0));\n                        // 释放在termination条件上等待的所有线程\n                        termination.signalAll();\n                    }\n                    return;\n                }\n            } finally {\n                // 释放锁\n                mainLock.unlock();\n            }\n            // else retry on failed CAS\n        }\n    }\n```\n\n### interruptIdleWorkers\n\n```\n    /**\n     * 尝试中断线程，onlyOne标识是否只中断一个\n     */\nprivate void interruptIdleWorkers(boolean onlyOne) {\n        // 线程池的锁\n        final ReentrantLock mainLock = this.mainLock;\n        // 获取锁\n        mainLock.lock();\n        try {\n            for (Worker w : workers) { // 遍历workers队列\n                // worker对应的线程\n                Thread t = w.thread;\n                if (!t.isInterrupted() && w.tryLock()) { // 线程未被中断并且成功获得锁\n                    try {\n                        // 中断线程\n                        t.interrupt();\n                    } catch (SecurityException ignore) {\n                    } finally {\n                        // 释放锁\n                        w.unlock();\n                    }\n                }\n                if (onlyOne) // 若只中断一个，则跳出循环\n                    break;\n            }\n        } finally {\n            // 释放锁\n            mainLock.unlock();\n        }\n    }\n```\n\n\n### runWorker 重点关注这个\n```\n    /**\n     * \n     */\n     final void runWorker(Worker w) {\n        Thread wt = Thread.currentThread();\n        Runnable task = w.firstTask;\n        w.firstTask = null;\n        w.unlock(); // allow interrupts\n        boolean completedAbruptly = true;\n        try {\n             // 不断循环getTask来获取任务，getTask后面说\n            while (task != null || (task = getTask()) != null) {\n                w.lock();\n                // 如果当前线程是stop，那么将确认其为interrupted\n                if ((runStateAtLeast(ctl.get(), STOP) ||\n                     (Thread.interrupted() &&\n                      runStateAtLeast(ctl.get(), STOP))) &&\n                    !wt.isInterrupted())\n                    wt.interrupt();\n                try {\n                    // 调用钩子函数\n                    beforeExecute(wt, task);\n                    Throwable thrown = null;\n                    try {\n                        task.run();\n                    } catch (RuntimeException x) {\n                        thrown = x; throw x;\n                    } catch (Error x) {\n                        thrown = x; throw x;\n                    } catch (Throwable x) {\n                        thrown = x; throw new Error(x);\n                    } finally {\n                        // 调用钩子函数\n                        afterExecute(task, thrown);\n                    }\n                } finally {\n                    task = null;\n                    w.completedTasks++;\n                    w.unlock();\n                }\n            }\n            completedAbruptly = false;\n        } finally {\n            // 处理完成后，调用,下面会说\n            processWorkerExit(w, completedAbruptly);\n        }\n    }\n```\n\n### getTask\n```\n    /**\n     * 获取任务\n     */\n     private Runnable getTask() {\n        // 超时标识\n        boolean timedOut = false;\n\n        for (;;) {\n            int c = ctl.get();\n            int rs = runStateOf(c);\n\n            // 检验线程池状态 \n            if (rs >= SHUTDOWN && (rs >= STOP || workQueue.isEmpty())) {\n                decrementWorkerCount();\n                return null;\n            }\n\n            int wc = workerCountOf(c);\n\n            // 是否允许coreThread超时或者workerCount大于核心大小\n            boolean timed = allowCoreThreadTimeOut || wc > corePoolSize;\n            // 检查线程数量\n            if ((wc > maximumPoolSize || (timed && timedOut))\n                && (wc > 1 || workQueue.isEmpty())) {\n                if (compareAndDecrementWorkerCount(c))\n                    return null;\n                continue;\n            }\n\n            try {\n                Runnable r = timed ?\n                    // 等待指定时间\n                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :\n                    // 一直等待，直到有元素\n                    workQueue.take();\n                if (r != null)\n                    return r;\n                // 等待指定时间后，没有获取元素，则超时\n                timedOut = true;\n            } catch (InterruptedException retry) {\n                // 抛出了被中断异常，重试，没有超时\n                timedOut = false;\n            }\n        }\n    }\n```\n\n\n### processWorkerExit\n```\n    /**\n     * 根据是否中断了空闲线程来确定是否减少workerCount的值，并且将worker从workers集合中移除并且会尝试终止线程池。\n     */\n    private void processWorkerExit(Worker w, boolean completedAbruptly) {\n        // 如果被中断，则需要减少workCount\n        if (completedAbruptly)\n            decrementWorkerCount();\n        // 获取可重入锁\n        final ReentrantLock mainLock = this.mainLock;\n        // 获取锁\n        mainLock.lock();\n        try {\n            // 将worker完成的任务添加到总的完成任务中\n            completedTaskCount += w.completedTasks;\n            // 从workers集合中移除该worker\n            workers.remove(w);\n        } finally {\n            // 释放锁\n            mainLock.unlock();\n        }\n        // 尝试终止\n        tryTerminate();\n        // 获取线程池控制状态\n        int c = ctl.get();\n        // 小于STOP的运行状态\n        if (runStateLessThan(c, STOP)) { \n            if (!completedAbruptly) {\n                int min = allowCoreThreadTimeOut ? 0 : corePoolSize;\n                 // 允许核心超时并且workQueue阻塞队列不为空\n                if (min == 0 && ! workQueue.isEmpty())\n                    min = 1;\n                // workerCount大于等于min\n                if (workerCountOf(c) >= min) \n                    // 直接返回\n                    return; // replacement not needed\n            }\n            // 添加worker\n            addWorker(null, false);\n        }\n    }\n```\n\n","tags":["little_eight"],"categories":["java1.8源码"]},{"title":"java.lang.String类解析","url":"/2019/05/09/java-lang-String类解析/","content":"\n## 成员变量\n```\n    /**\n     * 底层由数组存数据\n     */\n    private final char value[];\n\n    /**\n     * hash值\n     */\n    private int hash;\n```\n## 方法\n<!--more-->\n### charAt\n```\n    /**\n     * 返回指定下标的字符\n     */\n   public char charAt(int index) {\n        if ((index < 0) || (index >= value.length)) {\n            throw new StringIndexOutOfBoundsException(index);\n        }\n        return value[index];\n    }\n```\n\n### compareTo、compareToIgnoreCase\n```\n    /**\n     * 比较两个字符串的字典顺序，anotherString在后面的话就返回负数，相等为0，前面就正数\n     */\n  public int compareTo(String anotherString) {\n        int len1 = value.length;\n        int len2 = anotherString.value.length;\n        int lim = Math.min(len1, len2);\n        char v1[] = value;\n        char v2[] = anotherString.value;\n\n        int k = 0;\n        while (k < lim) {\n            char c1 = v1[k];\n            char c2 = v2[k];\n            if (c1 != c2) {\n                return c1 - c2;\n            }\n            k++;\n        }\n        return len1 - len2;\n    }\n    /**\n     * 忽略大小写的对比\n     */\n    public int compareToIgnoreCase(String str) {\n        return CASE_INSENSITIVE_ORDER.compare(this, str);\n    }\n```\n### concat\n```\n    /**\n     * 将指定的字符串参数连接到字符串上\n     */\n    public String concat(String str) {\n        int otherLen = str.length();\n        if (otherLen == 0) {\n            return this;\n        }\n        int len = value.length;\n        char buf[] = Arrays.copyOf(value, len + otherLen);\n        str.getChars(buf, len);\n        return new String(buf, true);\n    }\n```\n### contains\n```\n    /**\n     * 是否存在此字符\n     */\n   public boolean contains(CharSequence s) {\n        return indexOf(s.toString()) > -1;\n    }\n```\n### contentEquals\n```\n    /**\n     * 比较两者的内容是否相同，不检查被比较对象的类型\n     */\n  public boolean contentEquals(CharSequence cs) {\n        // Argument is a StringBuffer, StringBuilder\n        if (cs instanceof AbstractStringBuilder) {\n            if (cs instanceof StringBuffer) {\n                synchronized(cs) {\n                   return nonSyncContentEquals((AbstractStringBuilder)cs);\n                }\n            } else {\n                return nonSyncContentEquals((AbstractStringBuilder)cs);\n            }\n        }\n        // Argument is a String\n        if (cs instanceof String) {\n            return equals(cs);\n        }\n        // Argument is a generic CharSequence\n        char v1[] = value;\n        int n = v1.length;\n        if (n != cs.length()) {\n            return false;\n        }\n        for (int i = 0; i < n; i++) {\n            if (v1[i] != cs.charAt(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * 还可以直接传入StringBuffer对比\n     */\n    public boolean contentEquals(StringBuffer sb) {\n        return contentEquals((CharSequence)sb);\n    }\n```\n### copyValueOf\n```\n    /**\n     * 根据char数组new一个新的string\n     */\n    public static String copyValueOf(char data[]) {\n        return new String(data);\n    }\n     /**\n     * 更多参数new一个新的string\n     */\n    public static String copyValueOf(char data[], int offset, int count) {\n        return new String(data, offset, count);\n    }\n```\n\n### endsWith、startsWith\n```\n    /**\n     * 比较是否与尾部的字符串一致\n     */\n    public boolean endsWith(String suffix) {\n        return startsWith(suffix, value.length - suffix.value.length);\n    }\n    \n    /**\n     * 对比指定范围的字符串是否一致\n     */\n    public boolean startsWith(String prefix, int toffset) {\n        char ta[] = value;\n        int to = toffset;\n        char pa[] = prefix.value;\n        int po = 0;\n        int pc = prefix.value.length;\n        // Note: toffset might be near -1>>>1.\n        if ((toffset < 0) || (toffset > value.length - pc)) {\n            return false;\n        }\n        while (--pc >= 0) {\n            if (ta[to++] != pa[po++]) {\n                return false;\n            }\n        }\n        return true;\n    }\n        \n    /**\n     * 比较是否与头部的字符串一致\n     */\n     public boolean startsWith(String prefix) {\n        return startsWith(prefix, 0);\n    }\n```\n\n### equals\n```\n    /**\n     * 比较两者的内容是否相同，还会检查被比较对象的类型\n     */\n  public boolean equals(Object anObject) {\n        if (this == anObject) {\n            return true;\n        }\n        if (anObject instanceof String) {\n            String anotherString = (String)anObject;\n            int n = value.length;\n            if (n == anotherString.value.length) {\n                char v1[] = value;\n                char v2[] = anotherString.value;\n                int i = 0;\n                while (n-- != 0) {\n                    if (v1[i] != v2[i])\n                        return false;\n                    i++;\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n```\n### format\n```\n    /**\n     * 字符串格式化\n     * %s 字符串类型、 %c 字符类型、 %b 布尔类型、%d 整数类型（十进制）、%f 浮点类型.....\n     */\n    public static String format(String format, Object... args) {\n        return new Formatter().format(format, args).toString();\n    }\n```\n### getBytes\n```\n    /**\n     * char数组转换成byte 数组\n     */\n   public byte[] getBytes() {\n        return StringCoding.encode(value, 0, value.length);\n    }\n```\n\n### indexOf、lastIndexOf    \n```\n    /**\n     * 其实有很多重载方法，这是最常用的，返回第一次出现该字符串的下标，不存在返回-1\n     */\n   public int indexOf(String str) {\n        return indexOf(str, 0);\n    }\n    /**\n     * 返回最后一次出现该字符串的下标，不存在返回-1\n     */\n    public int lastIndexOf(String str) {\n        return lastIndexOf(str, value.length);\n    }\n```\n\n### length\n```\n    /**\n     * 经常会提问的数组跟String是属性还是方法\n     */\n    public int length() {\n        return value.length;\n    }\n```\n\n### matches\n```\n    /**\n     * 检测字符串是否匹配给定的正则表达式\n     */\n        public boolean matches(String regex) {\n        return Pattern.matches(regex, this);\n    }\n```\n\n### replaceAll\n```\n    /**\n     * 替换指定字符串的内容\n     */\n    public String replaceAll(String regex, String replacement) {\n        return Pattern.compile(regex).matcher(this).replaceAll(replacement);\n    }\n```\n\n### split\n```\n    /**\n     * 转换成数组，regex为区分标识\n     */\n    public String[] split(String regex) {\n        return split(regex, 0);\n    }\n```\n\n\n### substring\n```\n    /**\n     * 从指定下标开始截取字符串\n     * 感觉直接返回substring(beginIndex, value.length - beginIndex)可以吧\n     */\n        public String substring(int beginIndex) {\n        if (beginIndex < 0) {\n            throw new StringIndexOutOfBoundsException(beginIndex);\n        }\n        int subLen = value.length - beginIndex;\n        if (subLen < 0) {\n            throw new StringIndexOutOfBoundsException(subLen);\n        }\n        return (beginIndex == 0) ? this : new String(value, beginIndex, subLen);\n    }\n    \n    /**\n     * 从指定下标开始截取字符串\n     */\n     public String substring(int beginIndex, int endIndex) {\n        if (beginIndex < 0) {\n            throw new StringIndexOutOfBoundsException(beginIndex);\n        }\n        if (endIndex > value.length) {\n            throw new StringIndexOutOfBoundsException(endIndex);\n        }\n        int subLen = endIndex - beginIndex;\n        if (subLen < 0) {\n            throw new StringIndexOutOfBoundsException(subLen);\n        }\n        return ((beginIndex == 0) && (endIndex == value.length)) ? this\n                : new String(value, beginIndex, subLen);\n    }\n```\n\n### toCharArray\n```\n    /**\n     * 转换成字符数组\n     */\n    public char[] toCharArray() {\n        // Cannot use Arrays.copyOf because of class initialization order issues\n        char result[] = new char[value.length];\n        System.arraycopy(value, 0, result, 0, value.length);\n        return result;\n    }\n\n```\n\n### toLowerCase、toUpperCase\n```\n    /**\n     * 全部转换小写\n     */\n     public String toLowerCase() {\n        return toLowerCase(Locale.getDefault());\n    }\n     /**\n     * 全部转换大写\n     */\n    public String toUpperCase() {\n        return toUpperCase(Locale.getDefault());\n    }\n```\n\n### valueOf\n```\n    /**\n     * 转换成z\n     */\n    public static String valueOf(boolean b) {\n        return b ? \"true\" : \"false\";\n    }\n    public static String valueOf(char data[]) {\n        return new String(data);\n    }\n    public static String valueOf(char c) {\n        char data[] = {c};\n        return new String(data, true);\n    }\n    public static String valueOf(char data[], int offset, int count) {\n        return new String(data, offset, count);\n    }\n    public static String valueOf(double d) {\n        return Double.toString(d);\n    }\n    \n   public static String valueOf(float f) {\n        return Float.toString(f);\n    }\n    public static String valueOf(int i) {\n        return Integer.toString(i);\n    }\n    \n    public static String valueOf(long l) {\n        return Long.toString(l);\n    }\n    public static String valueOf(Object obj) {\n        return (obj == null) ? \"null\" : obj.toString();\n    }\n```\n","tags":["little_eight"],"categories":["java1.8源码"]},{"title":"红黑树","url":"/2019/04/22/红黑树/","content":"\n## 特征\n\n* 节点都有颜色\n* 在插入和删除的过程中，要遵循保持这些颜色的不同排列规则\n\n## 规则\n\n* 每个节点不是红色就是黑色的\n* 根节点总是黑色的\n* 如果节点是红色的，则它的子节点必须是黑色的（反之不一定）,(也就是从每个叶子到根的所有路径上不能有两个连续的红色节点)\n* 从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）\n> 注意：新插入的节点颜色总是红色的，这是因为插入一个红色节点比插入一个黑色节点违背红-黑规则的可能性更小，原因是插入黑色节点总会改变黑色高度（违背规则4），但是插入红色节点只有一半的机会会违背规则3（因为父节点是黑色的没事，父节点是红色的就违背规则3）。\n\n## 修正\n\n插入新节点可能会破坏规则，有2种修正方法，变色跟旋转，旋转分左旋转跟右旋转\n\n### 左旋转\n\n* 子右节点Y上升为父节点\n* 父节点X降级为子左节点\n* 把旧子右节点Y的子左节点搞过来当子新左节点子X的子右节点\n\n```\n        X                                             Y\n       / \\              以X为轴旋转                  / \\\n      a   Y              ------------->>            X   c\n         / \\                                       / \\\n        b   c                                     a   b\n```\n\n### 右旋转\n\n* 子左节点Y上升为父节点\n* 父节点X降级为子右节点\n* 把旧子左节点Y的子右节点搞过来当新子右节点X的子左节点\n\n```\n        X                                             Y\n       / \\              以X为轴旋转                  / \\\n      Y   c              ------------->>            a   X\n     / \\                                               / \\\n    a   b                                             b   c\n```\n\n>多看几次就懂了，明白旋转规则即可\n","tags":["little_eight"],"categories":["杂类"]},{"title":"java.util.Optional类解析","url":"/2019/04/22/java-util-Optional类解析/","content":"\n## 成员变量\n\n```\n    /**\n     * 从后面的构造方法可以看出，这里new一个value为null的Optional\n     */\n    private static final Optional<?> EMPTY = new Optional<>();\n\n    /**\n     * 值\n     */\n    private final T value;\n```\n\n\n## 构造方法 \n```\n    /**\n     * value = null\n     */\n    private Optional() {\n        this.value = null;\n    }\n    \n    /**\n     * 自定义value值，value为null会抛异常\n     */\n    private Optional(T value) {\n        this.value = Objects.requireNonNull(value);\n    }\n    \n    public static <T> T requireNonNull(T obj) {\n        if (obj == null)\n            throw new NullPointerException();\n        return obj;\n    }\n```\n<!--more-->\n## empty\n```\n    /**\n     * 返回一个空Optional\n     */\n     public static<T> Optional<T> empty() {\n        @SuppressWarnings(\"unchecked\")\n        Optional<T> t = (Optional<T>) EMPTY;\n        return t;\n    }\n```\n\n## equals\n```\n    /**\n     * 重写equals，为了实现最后2行代码\n     */\n    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n\n        if (!(obj instanceof Optional)) {\n            return false;\n        }\n\n        Optional<?> other = (Optional<?>) obj;\n        return Objects.equals(value, other.value);\n    }\n```\n\n## filter\n\n```\n    /**\n     * 如果value不为空并且满足断言条件返回包含该值的Optional，否则返回空Optional。\n     * 用法：filter((value) -> xx())\n     */\n    public Optional<T> filter(Predicate<? super T> predicate) {\n        Objects.requireNonNull(predicate);\n        if (!isPresent())\n            return this;\n        else\n            return predicate.test(value) ? this : empty();\n    }\n```\n\n## get\n```\n    /**\n     * 获取value，为null抛异常\n     */\n    public T get() {\n        if (value == null) {\n            throw new NoSuchElementException(\"No value present\");\n        }\n        return value;\n    }\n```\n\n## isPresent\n```\n    /**\n     * value是否为null\n     */\n    public boolean isPresent() {\n        return value != null;\n    }\n    /**\n     * 跟上面一样，不过是迎合lambda，写法ifPresent((value) -> xx()）\n     */\n    public void ifPresent(Consumer<? super T> consumer) {\n        if (value != null)\n            consumer.accept(value);\n    }\n```\n\n## map\n```\n    /**\n     * 如果value不为null，则对其执行调用mapping函数得到返回值。\n     * 如果返回值不为null，则创建包含mapping返回值的Optional作为map方法返回值，否则返回空Optional。\n     */\n    public<U> Optional<U> map(Function<? super T, ? extends U> mapper) {\n        Objects.requireNonNull(mapper);\n        if (!isPresent())\n            return empty();\n        else {\n            return Optional.ofNullable(mapper.apply(value));\n        }\n    }\n```\n\n## of\n``` \n    /**\n     *  返回一个带value的Optional\n     */\n    public static <T> Optional<T> of(T value) {\n        return new Optional<>(value);\n    }\n```\n\n## ofNullable\n```\n    /**\n     *  相当于综合了empty跟of\n     */\n     public static <T> Optional<T> ofNullable(T value) {\n        return value == null ? empty() : of(value);\n    }\n```\n\n## orElse\n```\n    /**\n     * value为null就返回other，不为空返回value\n     */\n    public T orElse(T other) {\n        return value != null ? value : other;\n    }\n```\n\n## orElseGet\n```\n    /**\n     * value为null就返回other，不为空返回value\n     * 用法 orElseGet(() -> xx())\n     */\n    public T orElseGet(Supplier<? extends T> other) {\n        return value != null ? value : other.get();\n    }\n```\n## orElseThrow\n```\n    /**\n     * 如果value不为空返回value，否则抛出supplier接口创建的异常。\n     * 用法： orElseThrow(XXException::new)\n     */\n    public <X extends Throwable> T orElseThrow(Supplier<? extends X> exceptionSupplier) throws X {\n        if (value != null) {\n            return value;\n        } else {\n            throw exceptionSupplier.get();\n        }\n    }\n```\n","tags":["little_eight"],"categories":["java1.8源码"]},{"title":"java.util.LinkedHashSet类解析","url":"/2019/04/22/java-util-LinkedHashSet类解析/","content":"\n元素有序且不能重复。\n```\n/**\n    * 实现 Cloneable 接口\n    *          这个类是 java.lang.Cloneable，前面我们讲解深拷贝和浅拷贝的原理时，\n    *          我们介绍了浅拷贝可以通过调用 Object.clone() 方法来实现，\n    *          但是调用该方法的对象必须要实现 Cloneable 接口，\n    *          否则会抛出 CloneNoSupportException异常。\n    * 实现 Serializable 接口\n    *          序列化\n    */\n    public class LinkedHashSet<E> extends HashSet<E> implements Set<E>,\n    Cloneable,java.io.Serializable{}\n```\n看上面似乎LinkedHashSet 是由HashSet实现的集合，其实是LinkedHashMap实现的。从下面的构造方法即可看出。\n\n\n## 构造方法\n```\n    /**\n     * 依然是提供三种构造方法，实现都是super方法，下面我们看看是怎么实现的 \n     */\n   public LinkedHashSet() {\n        super(16, .75f, true);\n    }\n    \n   public LinkedHashSet(Collection<? extends E> c) {\n        super(Math.max(2*c.size(), 11), .75f, true);\n        addAll(c);\n    }\n    \n    public LinkedHashSet(int initialCapacity) {\n        super(initialCapacity, .75f, true);\n    }\n    \n    \n    /**\n     * 之前还疑惑这里dummy为啥没用，原来是为了用到这里做区分的\n     * 明显看出看出LinkedHashSet 是由LinkedHashMap实现的集合\n     */\n    HashSet(int initialCapacity, float loadFactor, boolean dummy) {\n        map = new LinkedHashMap<>(initialCapacity, loadFactor);\n    }    \n\n```\n\n## 其他方法基本都可以看HashSet了\n","tags":["little_eight"],"categories":["java1.8源码"]},{"title":"java.util.LinkedHashMap类解析","url":"/2019/04/22/java-util-LinkedHashMap类解析/","content":"\n\nLinkedHashMap 是基于 HashMap实现的一种集合，有序，它单独维护了一个具有所有数据的双向链表，该链表保证了元素迭代的顺序。\n\n```\n/**\n * 继承HashMap，实现Map\n */\npublic class LinkedHashMap<K,V> extends HashMap<K,V> implements Map<K,V>{}\n```\n\n## 成员变量\n\n```\n /**\n     * 双向链表头\n     */\n    transient LinkedHashMap.Entry<K,V> head;\n\n    /**\n     * 双向链表尾\n     */\n    transient LinkedHashMap.Entry<K,V> tail;\n\n    /**\n     * 决定迭代排序方法：true是根据访问顺序来排序，false是根据插入顺序来排序\n     */\n    final boolean accessOrder;\n```\n\n## 构造函数\n4种构造方法，都用HaspMap的实现方法。\n```\n    public LinkedHashMap() {\n        super();\n        accessOrder = false;\n    }\n    \n    public LinkedHashMap(int initialCapacity) {\n        super(initialCapacity);\n        accessOrder = false;\n    }\n    public LinkedHashMap(int initialCapacity, float loadFactor) {\n        super(initialCapacity, loadFactor);\n        accessOrder = false;\n    }\n\n    public LinkedHashMap(int initialCapacity,\n                         float loadFactor,\n                         boolean accessOrder) {\n        super(initialCapacity, loadFactor);\n        this.accessOrder = accessOrder;\n    }\n```\n<!--more-->\n\n## 方法\n\n### afterNodeAccess\n> 这个方法除了在LinkedHashMap的get方法用到，还在HashMap的put、replace用到，因为这些方法是直接实现HashMap的，下面的afterNodeInsertion、afterNodeRemoval同理。\n\n```\n    /**\n     *  把指定节点放到双向链表的尾部\n     */\n   void afterNodeAccess(Node<K,V> e) { // move node to last\n        LinkedHashMap.Entry<K,V> last;\n        // 当accessOrder为true，指定节点不是链表尾才有效\n        if (accessOrder && (last = tail) != e) {\n            // 把p当做指定节点，并注明它的前后节点 b，a\n            LinkedHashMap.Entry<K,V> p =\n                (LinkedHashMap.Entry<K,V>)e, b = p.before, a = p.after;\n            // 清除p的后节点指向\n            p.after = null;\n            /**\n             * 下面会分别对a跟b判空，是为了把p提取出来同时，成功接上断掉的节点\n             */\n            // 如果b是空的，说明p是链表头，把head等于p的后节点\n            if (b == null)\n                head = a;\n            // 如果b不为空，就让p的前节点的后节点指向p的后节点\n            else\n                b.after = a;\n            // 如果a不为空，就让p的后节点的前节点指向p的前节点\n            if (a != null)\n                a.before = b;\n            /**\n             * 本人对下面注释可能有问题，理解不到位吧\n             */\n            // 如果a是空的，说明链表尾tail为null（不然就解释不通p不等于tail了），last等于p的前节点\n            else\n                last = b;\n            // last为空 说明链表条还没有链表，而且p的前节点为null，链表头设置为p\n            if (last == null)\n                head = p;\n            // last不为空，就把last跟p连到一起\n            else {\n                p.before = last;\n                last.after = p;\n            }\n            // 最后把p设为链表尾\n            tail = p;\n            ++modCount;\n        }\n    }\n```\n\n### afterNodeInsertion\n```\n    /**\n     * 移除链表头\n     */\n    void afterNodeInsertion(boolean evict) {\n        LinkedHashMap.Entry<K,V> first;\n        // 当evict = true，并且 头节点不为null，removeEldestEntry(first)为true，才进行移除\n        if (evict && (first = head) != null && removeEldestEntry(first)) {\n            K key = first.key;\n            // 用到HashMap的，里面有个方法afterNodeRemoval，下面讲\n            removeNode(hash(key), key, null, false, true);\n        }\n    }\n    \n    /**\n     * 再看看这个方法，其实是返回false的，所以要想实现移除链表头，必须得继承LinkedHashMap然后重写这个方法\n     */\n    protected boolean removeEldestEntry(Map.Entry<K,V> eldest) {\n        return false;\n    }\n    \n```\n\n### afterNodeRemoval\n```\n    /**\n     * 移除了e后，保证链表条不断掉\n     */\n  void afterNodeRemoval(Node<K,V> e) {\n        LinkedHashMap.Entry<K,V> p =\n            (LinkedHashMap.Entry<K,V>)e, b = p.before, a = p.after;\n        p.before = p.after = null;\n        if (b == null)\n            head = a;\n        else\n            b.after = a;\n        if (a == null)\n            tail = b;\n        else\n            a.before = b;\n    }\n```\n\n### containsValue\n```\n    /**\n     * 是否包含此值\n     */\n    public boolean containsValue(Object value) {\n        // 很明显是遍历链表条了\n        for (LinkedHashMap.Entry<K,V> e = head; e != null; e = e.after) {\n            V v = e.value;\n            if (v == value || (value != null && value.equals(v)))\n                return true;\n        }\n        return false;\n    }\n```\n\n### get、getOrDefault\n```\n    /**\n     * 根据key获取对应值\n     */\n    public V get(Object key) {\n        Node<K,V> e;\n        if ((e = getNode(hash(key), key)) == null)\n            return null;\n        // 如果true，还会把这个链表放到尾部\n        if (accessOrder)\n            afterNodeAccess(e);\n        return e.value;\n    }\n    \n    /**\n     * 还提供一个不存在就返回默认值\n     */\n    public V getOrDefault(Object key, V defaultValue) {\n       Node<K,V> e;\n       if ((e = getNode(hash(key), key)) == null)\n           return defaultValue;\n       if (accessOrder)\n           afterNodeAccess(e);\n       return e.value;\n   }\n```\n\n### keySet\n```\n    /**\n     * 获取key集合，有兴趣可以自己看LinkedKeySet\n     */\n    public Set<K> keySet() {\n        Set<K> ks = keySet;\n        if (ks == null) {\n            ks = new LinkedKeySet();\n            keySet = ks;\n        }\n        return ks;\n    }\n    \n    final class LinkedKeySet extends AbstractSet<K> {\n        public final int size()                 { return size; }\n        public final void clear()               { LinkedHashMap.this.clear(); }\n        public final Iterator<K> iterator() {\n            return new LinkedKeyIterator();\n        }\n        public final boolean contains(Object o) { return containsKey(o); }\n        public final boolean remove(Object key) {\n            return removeNode(hash(key), key, null, false, true) != null;\n        }\n        public final Spliterator<K> spliterator()  {\n            return Spliterators.spliterator(this, Spliterator.SIZED |\n                                            Spliterator.ORDERED |\n                                            Spliterator.DISTINCT);\n        }\n        public final void forEach(Consumer<? super K> action) {\n            if (action == null)\n                throw new NullPointerException();\n            int mc = modCount;\n            for (LinkedHashMap.Entry<K,V> e = head; e != null; e = e.after)\n                action.accept(e.key);\n            if (modCount != mc)\n                throw new ConcurrentModificationException();\n        }\n    }\n```\n\n### newNode、newTreeNode\n```\n    /**\n     * 新建链表\n     */\n    Node<K,V> newNode(int hash, K key, V value, Node<K,V> e) {\n        LinkedHashMap.Entry<K,V> p =\n            new LinkedHashMap.Entry<K,V>(hash, key, value, e);\n        linkNodeLast(p);\n        return p;\n    }\n    /**\n     * 新建红黑树节点\n     */ \n    TreeNode<K,V> newTreeNode(int hash, K key, V value, Node<K,V> next) {\n        TreeNode<K,V> p = new TreeNode<K,V>(hash, key, value, next);\n        linkNodeLast(p);\n        return p;\n    }\n    \n    /**\n     * 上面都有用到，把p接到旧链表尾后面\n     */\n    private void linkNodeLast(LinkedHashMap.Entry<K,V> p) {\n        LinkedHashMap.Entry<K,V> last = tail;\n        tail = p;\n        if (last == null)\n            head = p;\n        else {\n            p.before = last;\n            last.after = p;\n        }\n    }\n    \n```\n### values\n```\n    /**\n     * 获取value集合\n     */\n    public Collection<V> values() {\n        Collection<V> vs = values;\n        if (vs == null) {\n            vs = new LinkedValues();\n            values = vs;\n        }\n        return vs;\n    }\n\n    final class LinkedValues extends AbstractCollection<V> {\n        public final int size()                 { return size; }\n        public final void clear()               { LinkedHashMap.this.clear(); }\n        public final Iterator<V> iterator() {\n            return new LinkedValueIterator();\n        }\n        public final boolean contains(Object o) { return containsValue(o); }\n        public final Spliterator<V> spliterator() {\n            return Spliterators.spliterator(this, Spliterator.SIZED |\n                                            Spliterator.ORDERED);\n        }\n        public final void forEach(Consumer<? super V> action) {\n            if (action == null)\n                throw new NullPointerException();\n            int mc = modCount;\n            for (LinkedHashMap.Entry<K,V> e = head; e != null; e = e.after)\n                action.accept(e.value);\n            if (modCount != mc)\n                throw new ConcurrentModificationException();\n        }\n    }\n```","tags":["little_eight"],"categories":["java1.8源码"]},{"title":"java.util.HashSet类解析","url":"/2019/04/16/java-util-HashSet类解析/","content":"\nHashSet 是一个由 HashMap 实现的集合，元素无序且不能重复。\n其方法基本都是HashMap的方法。\n```\n /**\n     * 继承 AbstractSet\n     *          AbstractSet也是实现了Set接口的，跟HashMap一个毛病，脱裤子放屁....\n     * 实现 Set 接口\n     *          这个接口是 Set 类集合的上层接口，定义了实现该接口的类都必须要实现的一组方法\n     * 实现 Cloneable 接口\n     *          这个类是 java.lang.Cloneable，前面我们讲解深拷贝和浅拷贝的原理时，\n     *          我们介绍了浅拷贝可以通过调用 Object.clone() 方法来实现，\n     *          但是调用该方法的对象必须要实现 Cloneable 接口，\n     *          否则会抛出 CloneNoSupportException异常。\n     * 实现 Serializable 接口\n     *          序列化\n     */\n    public class HashSet<E> extends AbstractSet<E>\n    implements Set<E>, Cloneable, java.io.Serializable{}\n```\n\n## 成员变量\n```\n    /**\n     * 就是一个HashMap，说明靠这个来存储数据了\n     */\n      private transient HashMap<E,Object> map;\n    /**\n     * 向HashSet中添加数据，数据在上面的 map 结构是作为 key 存在的，而value统一都是 PRESENT\n     */\n    private static final Object PRESENT = new Object();\n```\n<!--more-->\n## 构造函数\n```\n    /**\n     * 就是new一个HashMap\n     */\n    public HashSet() {\n        map = new HashMap<>();\n    }\n    /**\n     * 指定初始容量HashMap \n     */\n    public HashSet(int initialCapacity) {\n        map = new HashMap<>(initialCapacity);\n    }\n     \n    /**\n     * 指定初始容量和加载因子HashMap \n     */\n    public HashSet(int initialCapacity, float loadFactor) {\n        map = new HashMap<>(initialCapacity, loadFactor);\n    }\n    \n    /**\n     * 这个dummy都没用到,兼容旧版本用的吧。\n     */\n    HashSet(int initialCapacity, float loadFactor, boolean dummy) {\n        map = new LinkedHashMap<>(initialCapacity, loadFactor);\n    }\n    \n    \n    /**\n     * 构造包含指定集合中的元素\n     */\n    public HashSet(Collection<? extends E> c) {\n        map = new HashMap<>(Math.max((int) (c.size()/.75f) + 1, 16));\n        addAll(c);\n    }\n     \n```\n## 方法\n\n### add\n```\n    /**\n     * 往map里put值\n     */\n     public boolean add(E e) {\n        return map.put(e, PRESENT)==null;\n    }\n```\n\n### clear\n```\n    /**\n     * 清除map\n     */\n    public void clear() {\n        map.clear();\n    }\n```\n\n### clone\n```\n    /**\n     * 克隆\n     */\n    @SuppressWarnings(\"unchecked\")\n    public Object clone() {\n        try {\n            HashSet<E> newSet = (HashSet<E>) super.clone();\n            newSet.map = (HashMap<E, Object>) map.clone();\n            return newSet;\n        } catch (CloneNotSupportedException e) {\n            throw new InternalError(e);\n        }\n    }\n```\n\n### contains\n```\n    /**\n     * 是否包含此值，也就是判断是否包含此key\n     */\n    public boolean contains(Object o) {\n        return map.containsKey(o);\n    }\n```\n\n### isEmpty\n```\n    /**\n     * 是否为空\n     */\n    public boolean isEmpty() {\n        return map.isEmpty();\n    }\n```\n\n### iterator\n```\n    /**\n     * 迭代类\n     */\n    public Iterator<E> iterator() {\n        return map.keySet().iterator();\n    }\n```\n\n### remove\n```\n    /**\n     * 移除某值\n     */\n    public boolean remove(Object o) {\n        return map.remove(o)==PRESENT;\n    }\n```\n","tags":["little_eight"],"categories":["java1.8源码"]},{"title":"java.util.HashMap类解析","url":"/2019/04/16/java-util-HashMap类解析/","content":"## 基本知识\n\nHash表也称为散列表，也有直接译作哈希表，Hash表是一种根据关键字值（key-value）而直接进行访问的数据结构。也就是说它通过把关键码值映射到表中的一个位置来访问记录，以此来加快查找的速度。在链表、数组等数据结构中，查找某个关键字，通常要遍历整个数据结构，也就是O(N)的时间级，但是对于哈希表来说，只是O(1)的时间级。（更多知识自行百度Google）\n\nHashMap是一个利用哈希表原理来存储元素的无序不安全键值都可为空的集合。遇到冲突时，HashMap 是采用的链地址法来解决，在 JDK1.7 中，HashMap 是由 数组+链表构成的。但是在JDK1.8中，HashMap是由数组+链表+红黑树构成，新增了红黑树作为底层数据结构，结构变得复杂了，但是效率也变的更高效。\n\n\n```\n    /**\n     * 继承 AbstractMap\n     *          AbstractMap也是实现了Map类的，既继承AbstractMap又实现Map，脱裤子放屁....\n     * 实现 Map 接口\n     *          这个接口是 Map 类集合的上层接口，定义了实现该接口的类都必须要实现的一组方法\n     * 实现 Cloneable 接口\n     *          这个类是 java.lang.Cloneable，前面我们讲解深拷贝和浅拷贝的原理时，\n     *          我们介绍了浅拷贝可以通过调用 Object.clone() 方法来实现，\n     *          但是调用该方法的对象必须要实现 Cloneable 接口，\n     *          否则会抛出 CloneNoSupportException异常。\n     * 实现 Serializable 接口\n     *          序列化\n     */\n    public class HashMap<K,V> extends AbstractMap<K,V>\n        implements Map<K,V>, Cloneable, Serializable {}\n        \n```\n<!--more-->\n## 成员变量\n\n```\n /**\n     * 初始容量为16，容量都必须是偶数\n     */\n    static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16\n\n    /**\n     * 集合的最大容量，如果通过带参构造指定的最大容量超过此数，默认还是使用此数\n     */\n    static final int MAXIMUM_CAPACITY = 1 << 30;\n\n    /**\n     * 默认的填充因子\n     */\n    static final float DEFAULT_LOAD_FACTOR = 0.75f;\n\n    /**\n     * 当桶(bucket)上的结点数大于这个值时会转成红黑树\n     */\n    static final int TREEIFY_THRESHOLD = 8;\n\n    /**\n     * 当桶(bucket)上的节点数小于这个值时会转成链表\n     */\n    static final int UNTREEIFY_THRESHOLD = 6;\n\n    /**\n     * 当集合中的容量大于这个值时，表中的桶才能进行树形化 ，否则桶内元素太多时会扩容，\n     * 而不是树形化 为了避免进行扩容、树形化选择的冲突，这个值不能小于 4 * TREEIFY_THRESHOLD\n     */\n    static final int MIN_TREEIFY_CAPACITY = 64;\n\n    /**\n     * 存链表的数组，初始化使用，长度总是 2的幂\n     */\n    transient Node<K,V>[] table;\n\n    /**\n     * 保存缓存的entrySet（）\n     */\n    transient Set<Map.Entry<K,V>> entrySet;\n\n    /**\n     * 此映射中包含的键值映射的数量。（集合存储键值对的数量）\n     */\n    transient int size;\n\n    /**\n     * 跟前面ArrayList和LinkedList集合中的字段modCount一样，记录集合被修改的次数\n     * 主要用于迭代器中的快速失败\n     */\n    transient int modCount;\n\n    /**\n     * 调整大小的下一个大小值（容量*加载因子）,相当于阈值。计算公式：capacity * loadFactor。\n     * 这个值是当前已占用数组长度的最大值。过这个数目就重新resize(扩容)，\n     * 扩容后的 HashMap 容量是之前容量的两倍\n     */\n    int threshold;\n\n    /**\n     * 散列表的加载因子，是用来衡量HashMap满的程度，\n     * 计算HashMap的实时装载因子的方法为：size/capacity，而不是占用桶的数量去除以capacity。\n     * capacity 是桶的数量，也就是 table 的长度length。\n     */\n    final float loadFactor;\n```\n\n```\n    /**\n     * 链表的类\n     */\n    static class Node<K,V> implements Map.Entry<K,V> {\n        // hash值\n        final int hash;\n        final K key;\n        V value;\n        // 下一个链表\n        Node<K,V> next;\n\n        Node(int hash, K key, V value, Node<K,V> next) {\n            this.hash = hash;\n            this.key = key;\n            this.value = value;\n            this.next = next;\n        }\n\n        public final K getKey()        { return key; }\n        public final V getValue()      { return value; }\n        public final String toString() { return key + \"=\" + value; }\n\n        public final int hashCode() {\n            return Objects.hashCode(key) ^ Objects.hashCode(value);\n        }\n\n        public final V setValue(V newValue) {\n            V oldValue = value;\n            value = newValue;\n            return oldValue;\n        }\n\n        public final boolean equals(Object o) {\n            if (o == this)\n                return true;\n            if (o instanceof Map.Entry) {\n                Map.Entry<?,?> e = (Map.Entry<?,?>)o;\n                if (Objects.equals(key, e.getKey()) &&\n                    Objects.equals(value, e.getValue()))\n                    return true;\n            }\n            return false;\n        }\n    }\n\n```\n\n## 构造函数\n\n```\n    /**\n     * 默认构造函数，初始化加载因子loadFactor = 0.75\n     */\n    public HashMap() {\n        this.loadFactor = DEFAULT_LOAD_FACTOR;\n    }\n    \n    /**\n     * 指定容量，实现看下一个方法\n     */\n    public HashMap(int initialCapacity) {\n        this(initialCapacity, DEFAULT_LOAD_FACTOR);\n    }\n\n\n    /**\n     * 指定Map集合构造函数。\n     */\n    public HashMap(Map<? extends K, ? extends V> m) {\n        this.loadFactor = DEFAULT_LOAD_FACTOR;\n        // 就是把这个集合put进去，后面再详细说\n        putMapEntries(m, false);\n    }\n\n    /**\n     * 指定容量和加载因子\n     */\n    public HashMap(int initialCapacity, float loadFactor) {\n        if (initialCapacity < 0)\n            throw new IllegalArgumentException(\"Illegal initial capacity: \" +\n                                               initialCapacity);\n        // 最大容量只会设置为MAXIMUM_CAPACITY                                       \n        if (initialCapacity > MAXIMUM_CAPACITY)\n            initialCapacity = MAXIMUM_CAPACITY;\n        if (loadFactor <= 0 || Float.isNaN(loadFactor))\n            throw new IllegalArgumentException(\"Illegal load factor: \" +\n                                               loadFactor);\n        this.loadFactor = loadFactor;\n        // 调整下一个扩容值\n        this.threshold = tableSizeFor(initialCapacity);\n    }\n    \n        /**\n         * 返回给定目标容量的二次幂，\n         * | 位或运算\n         */\n      static final int tableSizeFor(int cap) {\n        int n = cap - 1;\n        // 也就是 n = n | n >>> xx\n        n |= n >>> 1;\n        n |= n >>> 2;\n        n |= n >>> 4;\n        n |= n >>> 8;\n        n |= n >>> 16;\n        return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;\n    }\n\n```\n> 位或运算  （|）\n0|0=0；   0|1=1；   1|0=1；    1|1=1\n即：两位只要有一个为1，其值为1，其它都为0。\n扩展：异或运算符（^），后面计算hash值用到\n0^0=0；  0^1=1；  1^0=1；   1^1=0；\n即：参加运算的两个对象，如果两个相应位为“异”（值不同），则该位结果为1，否则为0。\n扩展：位与运算（&），后面的取模运算用到\n0&0=0;   0&1=0;    1&0=0;     1&1=1\n即：两位同时为1，结果才为1，否则为0。\n\n## 方法\n\n### capacity\n```\n    /**\n     *  返回当前容量\n     */\n    final int capacity() {\n        return (table != null) ? table.length :\n            (threshold > 0) ? threshold :\n            DEFAULT_INITIAL_CAPACITY;\n    }\n```\n\n### clear\n```\n    /**\n     * 把所有链表都设置为null，清空hashMap\n     */\n    public void clear() {\n        Node<K,V>[] tab;\n        modCount++;\n        if ((tab = table) != null && size > 0) {\n            size = 0;\n            for (int i = 0; i < tab.length; ++i)\n                tab[i] = null;\n        }\n    }\n```\n\n### clone\n```\n    /**\n     * 浅拷贝\n     */\n        public Object clone() {\n        HashMap<K,V> result;\n        try {\n            result = (HashMap<K,V>)super.clone();\n        } catch (CloneNotSupportedException e) {\n            // this shouldn't happen, since we are Cloneable\n            throw new InternalError(e);\n        }\n        // 把关键成员变量都设置成null\n        result.reinitialize();\n        result.putMapEntries(this, false);\n        return result;\n    }\n```\n\n### containsKey\n```\n    /**\n     * 判断是否包含此key\n     */\n    public boolean containsKey(Object key) {\n        // 下面再详细说getNode\n        return getNode(hash(key), key) != null;\n    }\n```\n\n### entrySet\n```\n    /**\n     * 返回this.entrySet，没有就new一个\n     */\n    public Set<Map.Entry<K,V>> entrySet() {\n        Set<Map.Entry<K,V>> es;\n        return (es = entrySet) == null ? (entrySet = new EntrySet()) : es;\n    }\n    \n    /**\n     * 内部EntrySet类\n     */\n    final class  extends AbstractSet<Map.Entry<K,V>> {\n        public final int size()                 { return size; }\n        public final void clear()               { HashMap.this.clear(); }\n        public final Iterator<Map.Entry<K,V>> iterator() {\n            return new EntryIterator();\n        }\n        public final boolean contains(Object o) {\n            if (!(o instanceof Map.Entry))\n                return false;\n            Map.Entry<?,?> e = (Map.Entry<?,?>) o;\n            Object key = e.getKey();\n            Node<K,V> candidate = getNode(hash(key), key);\n            return candidate != null && candidate.equals(e);\n        }\n        public final boolean remove(Object o) {\n            if (o instanceof Map.Entry) {\n                Map.Entry<?,?> e = (Map.Entry<?,?>) o;\n                Object key = e.getKey();\n                Object value = e.getValue();\n                return removeNode(hash(key), key, value, true, true) != null;\n            }\n            return false;\n        }\n        public final Spliterator<Map.Entry<K,V>> spliterator() {\n            return new EntrySpliterator<>(HashMap.this, 0, -1, 0, 0);\n        }\n        public final void forEach(Consumer<? super Map.Entry<K,V>> action) {\n            Node<K,V>[] tab;\n            if (action == null)\n                throw new NullPointerException();\n            if (size > 0 && (tab = table) != null) {\n                int mc = modCount;\n                for (int i = 0; i < tab.length; ++i) {\n                    for (Node<K,V> e = tab[i]; e != null; e = e.next)\n                        action.accept(e);\n                }\n                if (modCount != mc)\n                    throw new ConcurrentModificationException();\n            }\n        }\n    }\n```\n\n### get、getNode、getOrDefault\n```\n    /**\n     * 根据key返回value\n     */\n    public V get(Object key) {\n        Node<K,V> e;\n        return (e = getNode(hash(key), key)) == null ? null : e.value;\n    }\n    \n    /**\n     * 获取对应链表\n     */\n    final Node<K,V> getNode(int hash, Object key) {\n        Node<K,V>[] tab; Node<K,V> first, e; int n; K k;\n        // 数组不为空，且hash对应的链表头也不为空\n        if ((tab = table) != null && (n = tab.length) > 0 &&\n            (first = tab[(n - 1) & hash]) != null) {\n            // 校验是否是链表头的，不是的话，就next遍历下去找到对应的链表\n            if (first.hash == hash && // always check first node\n                ((k = first.key) == key || (key != null && key.equals(k))))\n                return first;\n            if ((e = first.next) != null) {\n                // 如果是红黑树，就去getTreeNode，红黑树的部分看最后面TreeNode类解析\n                if (first instanceof TreeNode)\n                    return ((TreeNode<K,V>)first).getTreeNode(hash, key);\n                do {\n                    if (e.hash == hash &&\n                        ((k = e.key) == key || (key != null && key.equals(k))))\n                        return e;\n                } while ((e = e.next) != null);\n            }\n        }\n        return null;\n    }\n    \n    \n    /**\n     * 如果取到的链表为null，则返回设定的defaultValue，否则就返回链表的value\n     */\n    public V getOrDefault(Object key, V defaultValue，) {\n        Node<K,V> e;\n        return (e = getNode(hash(key), key)) == null ? defaultValue : e.value;\n    }\n```\n> 取模运算 (n - 1) & hash ，在计算机中 & 的效率比 % 高很多，所以采用&\n且有这么一条结论，当 lenth = 2n 时，X % length = X & (length - 1)\n具体可以去看下这篇博客分析https://blog.csdn.net/ysvae/article/details/81090894\n\n\n### hash\n```\n    /**\n     * 获取hash值，\n     * (h = key.hashCode()) ^ (h >>> 16)，这段代码叫“扰动函数”，具体可以看这篇博客解析\n     * https://www.cnblogs.com/zhengwang/p/8136164.html\n     */\n    static final int hash(Object key) {\n        int h;\n        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n    }\n```\n\n### isEmpty\n```\n    /**\n     * 根据size判断集合是否为空\n     */\n    public boolean isEmpty() {\n        return size == 0;\n    }\n```\n\n### keySet\n```\n    /**\n     * 返回所有key的Set集合\n     */\n    public Set<K> keySet() {\n        Set<K> ks = keySet;\n        if (ks == null) {\n            ks = new KeySet();\n            keySet = ks;\n        }\n        return ks;\n    }\n    /**\n     * 内部KeySet类\n     */\n    final class KeySet extends AbstractSet<K> {\n        public final int size()                 { return size; }\n        public final void clear()               { HashMap.this.clear(); }\n        public final Iterator<K> iterator()     { return new KeyIterator(); }\n        public final boolean contains(Object o) { return containsKey(o); }\n        public final boolean remove(Object key) {\n            return removeNode(hash(key), key, null, false, true) != null;\n        }\n        public final Spliterator<K> spliterator() {\n            return new KeySpliterator<>(HashMap.this, 0, -1, 0, 0);\n        }\n        public final void forEach(Consumer<? super K> action) {\n            Node<K,V>[] tab;\n            if (action == null)\n                throw new NullPointerException();\n            if (size > 0 && (tab = table) != null) {\n                int mc = modCount;\n                for (int i = 0; i < tab.length; ++i) {\n                    for (Node<K,V> e = tab[i]; e != null; e = e.next)\n                        action.accept(e.key);\n                }\n                if (modCount != mc)\n                    throw new ConcurrentModificationException();\n            }\n        }\n    }\n     \n```\n\n### put、putIfAbsent、putVal\n```\n    /**\n     * 设值\n     */\n    public V put(K key, V value) {\n        return putVal(hash(key), key, value, false, true);\n    } \n    \n    /**\n     * 如果存在此key的值，那就不设值用原值\n     */\n    public V putIfAbsent(K key, V value) {\n        return putVal(hash(key), key, value, true, true);\n    }\n    \n    /**\n     * 设值\n     * @param onlyIfAbsent 为true，就不改动原值\n     * @param evict 如果为false，则表处于创建模式\n     */\n       final V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n                   boolean evict) {\n        Node<K,V>[] tab; Node<K,V> p; int n, i;\n        // 如果数组为null，也就是第一次put值，就resize进行扩容，这个方法后面再讲\n        if ((tab = table) == null || (n = tab.length) == 0)\n            n = (tab = resize()).length;\n        // 在数组中这个下标下如果这个链表为null，就根据传进的参数新建一个给它，也就是新建成链表头\n        if ((p = tab[i = (n - 1) & hash]) == null)\n            tab[i] = newNode(hash, key, value, null);\n        else {\n            // 链表头不为null，e、k会当做循环这条链表的暂时值\n            Node<K,V> e; K k;\n            // 如果刚好就是链表头，那就是e等于链表头\n            if (p.hash == hash &&\n                ((k = p.key) == key || (key != null && key.equals(k))))\n                e = p;\n            // 红黑树的部分看TreeNode类解析\n            else if (p instanceof TreeNode)\n                e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);\n            else {\n                // 循环这条链表\n                for (int binCount = 0; ; ++binCount) {\n                    // next==null说明到链表尾了\n                    if ((e = p.next) == null) {\n                        // 根据参数新建一个链表，作为链表尾\n                        p.next = newNode(hash, key, value, null);\n                        // 如果链表长度不小于TREEIFY_THRESHOLD（8），就转换成红黑树\n                        if (binCount >= TREEIFY_THRESHOLD - 1)\n                            // 如何转换的，这个后面再详解\n                            treeifyBin(tab, hash);\n                        break;\n                    }\n                    // 如果在循环过程中发现存在此key，那就不用新建链表尾了\n                    if (e.hash == hash &&\n                        ((k = e.key) == key || (key != null && key.equals(k))))\n                        break;\n                    p = e;\n                }\n            }\n            // 如果设值的key是已存在的\n            if (e != null) {\n                V oldValue = e.value;\n                // onlyIfAbsent为false，或者原值等于null，就设置成传入参数的value\n                if (!onlyIfAbsent || oldValue == null)\n                    e.value = value;\n                // 这里是空方法，在LinkedHashMap才会实现\n                afterNodeAccess(e);\n                // 返回的旧值哦\n                return oldValue;\n            }\n        }\n        ++modCount;\n        // 超过最大容量，进行扩容\n        if (++size > threshold)\n            resize();\n        // 这里是空方法，在LinkedHashMap才会实现\n        afterNodeInsertion(evict);\n        return null;\n    }\n```\n\n### remove、removeNode\n```\n    /**\n     * 移除某个对应的值（链表），返回对应的value，没的话就返回null\n     */\n    public V remove(Object key) {\n        Node<K,V> e;\n        return (e = removeNode(hash(key), key, null, false, true)) == null ?\n            null : e.value;\n    }\n    \n    /**\n     * 移除某个对应的值（链表），有对应的value就返回true，没的话就返回false\n     */\n    public boolean remove(Object key, Object value) {\n        return removeNode(hash(key), key, value, true, true) != null;\n    }\n    \n    /**\n     * 移除某个对应的值（链表）\n     * @param matchValue 为true时，进行移除\n     * @param movable 如果为false，则在删除时不要移动其他节点\n     */\n    final Node<K,V> removeNode(int hash, Object key, Object value,\n                               boolean matchValue, boolean movable) {\n        Node<K,V>[] tab; Node<K,V> p; int n, index;\n        // 数组不为空，且hash对应的链表头也不为空\n        if ((tab = table) != null && (n = tab.length) > 0 &&\n            (p = tab[index = (n - 1) & hash]) != null) {\n            Node<K,V> node = null, e; K k; V v;\n            // 这里就是为了得到key对应的链表node\n            if (p.hash == hash &&\n                ((k = p.key) == key || (key != null && key.equals(k))))\n                node = p;\n            else if ((e = p.next) != null) {\n                if (p instanceof TreeNode)\n                    node = ((TreeNode<K,V>)p).getTreeNode(hash, key);\n                else {\n                    do {\n                        if (e.hash == hash &&\n                            ((k = e.key) == key ||\n                             (key != null && key.equals(k)))) {\n                            node = e;\n                            break;\n                        }\n                        p = e;\n                    } while ((e = e.next) != null);\n                }\n            }\n            // 是否符合移除该node的条件\n            if (node != null && (!matchValue || (v = node.value) == value ||\n                                 (value != null && value.equals(v)))) {\n                // 如果是红黑树，就去TreeNode的方法处理\n                if (node instanceof TreeNode)\n                    ((TreeNode<K,V>)node).removeTreeNode(this, tab, movable);\n                // 两者相等，说明node刚好是链表头，直接等于next即可\n                else if (node == p)\n                    tab[index] = node.next;\n                else\n                    // 不是链表头，改p的next，相当于移除下一位的node\n                    p.next = node.next;\n                ++modCount;\n                --size;\n                // 这里是空方法，在LinkedHashMap才会实现\n                afterNodeRemoval(node);\n                return node;\n            }\n        }\n        return null;\n    }\n```\n\n### replace、replaceAll\n```\n    /**\n     * 根据key替换对应value，返回旧值\n     */\n    public V replace(K key, V value) {\n        Node<K,V> e;\n        if ((e = getNode(hash(key), key)) != null) {\n            V oldValue = e.value;\n            e.value = value;\n            afterNodeAccess(e);\n            return oldValue;\n        }\n        return null;\n    }\n    \n    /**\n     * 根据key，newValue替换旧值\n     * 当旧值等于oldValue时，才会去替换，否则返回false\n     */\n    public boolean replace(K key, V oldValue, V newValue) {\n        Node<K,V> e; V v;\n        if ((e = getNode(hash(key), key)) != null &&\n            ((v = e.value) == oldValue || (v != null && v.equals(oldValue)))) {\n            e.value = newValue;\n            afterNodeAccess(e);\n            return true;\n        }\n        return false;\n    } \n    \n    /**\n     * 这个不常用，不解析了..\n     */\n    public void replaceAll(BiFunction<? super K, ? super V, ? extends V> function) {\n        Node<K,V>[] tab;\n        if (function == null)\n            throw new NullPointerException();\n        if (size > 0 && (tab = table) != null) {\n            int mc = modCount;\n            for (int i = 0; i < tab.length; ++i) {\n                for (Node<K,V> e = tab[i]; e != null; e = e.next) {\n                    e.value = function.apply(e.key, e.value);\n                }\n            }\n            if (modCount != mc)\n                throw new ConcurrentModificationException();\n        }\n    }\n```\n\n### resize\n```\n    /**\n     * 扩容\n     */\n    final Node<K,V>[] resize() {\n        Node<K,V>[] oldTab = table;\n        // 原数组的长度，也就是旧容量\n        int oldCap = (oldTab == null) ? 0 : oldTab.length;\n        // 旧阀值\n        int oldThr = threshold;\n        // 新容量、新阀值\n        int newCap, newThr = 0;\n        if (oldCap > 0) {\n            // 如果原数组已经是最大了，就不扩容了，返回原数组\n            if (oldCap >= MAXIMUM_CAPACITY) {\n                // 修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了\n                threshold = Integer.MAX_VALUE;\n                return oldTab;\n            }\n            // 否则就扩容一倍\n            else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&\n                     oldCap >= DEFAULT_INITIAL_CAPACITY)\n                newThr = oldThr << 1;\n        }\n        // 旧阀值大于0，则将新容量直接等于就阀值 \n        else if (oldThr > 0)\n            newCap = oldThr;\n        // 旧容量、旧阀值都为0，也就是未初始化，就设置新容量、新阀值为默认值\n        else {               \n            newCap = DEFAULT_INITIAL_CAPACITY;\n            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n        }\n        // 如果新阀值为0，计算新的阀值上限\n        if (newThr == 0) {\n            float ft = (float)newCap * loadFactor;\n            newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?\n                      (int)ft : Integer.MAX_VALUE);\n        }\n        threshold = newThr;\n        @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n            // 新建扩容一倍的新数组\n            Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];\n        table = newTab;\n        if (oldTab != null) {\n            // 遍历旧数组，把它们的链表搬到新数组\n            for (int j = 0; j < oldCap; ++j) {\n                Node<K,V> e;\n                if ((e = oldTab[j]) != null) {\n                    // 便于gc回收\n                    oldTab[j] = null;\n                    // 这条链表只有一个链表头\n                    if (e.next == null)\n                        newTab[e.hash & (newCap - 1)] = e;\n                    // 是红黑树，就红黑树处理\n                    else if (e instanceof TreeNode)\n                        ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);\n                    // 遍历链表条\n                    else {\n                        // loHead - loTail、hiHead - hiTail，分别对应 链表头 - 链表尾\n                        // 这样作为暂时值处理，得到链表尾\n                        Node<K,V> loHead = null, loTail = null;\n                        Node<K,V> hiHead = null, hiTail = null;\n                        Node<K,V> next;\n                        do {\n                            next = e.next;\n                            // 原索引（没懂。。）\n                            if ((e.hash & oldCap) == 0) {\n                                if (loTail == null)\n                                    loHead = e;\n                                else\n                                    loTail.next = e;\n                                loTail = e;\n                            }\n                            else {\n                                if (hiTail == null)\n                                    hiHead = e;\n                                else\n                                    hiTail.next = e;\n                                hiTail = e;\n                            }\n                        } while ((e = next) != null);\n                        // loTail链表尾不为null，\n                        // 就设链表头尾到新数组对应的下标（也就是转移对应的链表条）\n                        if (loTail != null) {\n                            loTail.next = null;\n                            newTab[j] = loHead;\n                        }\n                        // hiTail链表尾不为null，\n                        // 就设链表头尾到新数组对应的下标（也就是转移对应的链表条）\n                        if (hiTail != null) {\n                            hiTail.next = null;\n                            newTab[j + oldCap] = hiHead;\n                        }\n                    }\n                }\n            }\n        }\n        return newTab;\n    }\n```\n\n### values\n```\n    /**\n     * 返回所有value值的Collection集合，（莫名奇妙就有了这个值。。。）\n     */\n    public Collection<V> values() {\n        Collection<V> vs = values;\n        if (vs == null) {\n            vs = new Values();\n            values = vs;\n        }\n        return vs;\n    }\n```\n\n\n## TreeNode\n比较特殊，专门来讲的红黑树类\n```\nstatic final class TreeNode<K,V> extends LinkedHashMap.Entry<K,V> {}\n```\n然后看下LinkedHashMap.Entry<K,V>类，居然是继承回HashMap的Node类。。有点意思\n```\n static class Entry<K,V> extends HashMap.Node<K,V> {}\n```\n### 基本知识\n红黑树的概念\n* 每个结点都是红色的或者是黑色的\n* 根结点是黑色的\n* 每个叶结点NIL是黑色的，但是通常我们不考虑NIL叶结点。\n* 如果一个结点是红色的，它的两个子结点都是黑色的\n* 每个结点到其他所有后代叶结点的简单路径上，均包含相同数目的黑色结点，这个属性被称为黑高，记作bh(x)\n\n\n### 成员变量\n\n```\n        // 父节点\n        TreeNode<K,V> parent;\n        // 左子节点\n        TreeNode<K,V> left;\n        // 右子节点\n        TreeNode<K,V> right;\n        // 前方节点\n        TreeNode<K,V> prev;\n        // 是否红色\n        boolean red;\n```\n\n### 构造函数\n\n```\n    /**\n     * 就是用HashMap.Node的构造函数\n     */\n    TreeNode(int hash, K key, V val, Node<K,V> next) {\n        super(hash, key, val, next);\n    }\n```\n\n这里解析的方法从HashMap的get、put等入手\n\n\n### getTreeNode\n```\n    /**\n     * 得到对应的节点\n     */\n    final TreeNode<K,V> getTreeNode(int h, Object k) {\n        return ((parent != null) ? root() : this).find(h, k, null);\n    }\n    \n    \n```\n\n### root\n```\n    /**\n     * 返回根节点\n     */\n     final TreeNode<K,V> root() {\n            for (TreeNode<K,V> r = this, p;;) {\n                if ((p = r.parent) == null)\n                    return r;\n                r = p;\n            }\n        }\n```\n\n### find\n```\n    /**\n     * 从根结点p开始根据hash和key值寻找指定的结点。二叉树的查找\n     */\n      final TreeNode<K,V> find(int h, Object k, Class<?> kc) {\n            TreeNode<K,V> p = this;\n            // 遍历红黑树\n            do {\n                int ph, dir; K pk;\n                TreeNode<K,V> pl = p.left, pr = p.right, q;\n                // p.hash大于参数hash时，移向左子树\n                if ((ph = p.hash) > h)\n                    p = pl;\n                // p.hash小于参数hash时，移向右子树\n                else if (ph < h)\n                    p = pr;\n                // p.hash等于参数hash，且参数k也等于p.key，返回这个p，也就是根节点\n                else if ((pk = p.key) == k || (k != null && k.equals(pk)))\n                    return p;\n                // 若hash相等但key不等，向左右子树非空的一侧移动\n                else if (pl == null)\n                    p = pr;\n                else if (pr == null)\n                    p = pl;\n                else if ((kc != null ||\n                          (kc = comparableClassFor(k)) != null) && // kc是否是一个可比较的类\n                         (dir = compareComparables(kc, k, pk)) != 0)  // 比较k和p.key\n                    p = (dir < 0) ? pl : pr;\n                else if ((q = pr.find(h, k, kc)) != null)\n                    return q;\n                else\n                    p = pl;\n            } while (p != null);\n            return null;\n        }\n```\n\n### putTreeVal\n```\n    /**\n     * \n     */\n  final TreeNode<K,V> putTreeVal(HashMap<K,V> map, Node<K,V>[] tab,\n                                       int h, K k, V v) {\n            Class<?> kc = null;\n            boolean searched = false;\n            // 根节点\n            TreeNode<K,V> root = (parent != null) ? root() : this;\n            // \n            for (TreeNode<K,V> p = root;;) {\n                int dir, ph; K pk;\n                if ((ph = p.hash) > h)\n                    dir = -1;\n                else if (ph < h)\n                    dir = 1;\n                else if ((pk = p.key) == k || (k != null && k.equals(pk)))\n                    return p;\n                else if ((kc == null &&\n                          (kc = comparableClassFor(k)) == null) ||\n                         (dir = compareComparables(kc, k, pk)) == 0) {\n                    if (!searched) {\n                        TreeNode<K,V> q, ch;\n                        searched = true;\n                        if (((ch = p.left) != null &&\n                             (q = ch.find(h, k, kc)) != null) ||\n                            ((ch = p.right) != null &&\n                             (q = ch.find(h, k, kc)) != null))\n                            return q;\n                    }\n                    dir = tieBreakOrder(k, pk);\n                }\n\n                TreeNode<K,V> xp = p;\n                if ((p = (dir <= 0) ? p.left : p.right) == null) {\n                    Node<K,V> xpn = xp.next;\n                    TreeNode<K,V> x = map.newTreeNode(h, k, v, xpn);\n                    if (dir <= 0)\n                        xp.left = x;\n                    else\n                        xp.right = x;\n                    xp.next = x;\n                    x.parent = x.prev = xp;\n                    if (xpn != null)\n                        ((TreeNode<K,V>)xpn).prev = x;\n                    moveRootToFront(tab, balanceInsertion(root, x));\n                    return null;\n                }\n            }\n        }\n```\n\n### treeifyBin\n```\n    /**\n     * 转换成红黑树，但其实只是链表转成TreeNode，里面的treeify（）才是对链表条转换成红黑树\n     */\n  final void treeifyBin(Node<K,V>[] tab, int hash) {\n        int n, index; Node<K,V> e;\n        // 数组为空，或者数组长度小于64，只扩容不转换\n        if (tab == null || (n = tab.length) < MIN_TREEIFY_CAPACITY)\n            resize();\n        // 跳到该链表条的链表头，准备循环\n        else if ((e = tab[index = (n - 1) & hash]) != null) {\n            // 定义头尾节点，因为一直遍历，尾节点的值会一直变化\n            TreeNode<K,V> hd = null, tl = null;\n            do {\n                // 这里replacementTreeNode就是new TreeNode<>(e.hash, e.key, e.value, null)\n                // p为当前节点\n                TreeNode<K,V> p = replacementTreeNode(e, null);\n                // 尾节点为null，说明是初始化阶段，把头节点=p\n                if (tl == null)\n                    hd = p;\n                // 尾节点不为null，设置p的prev（上一个节点）为尾节点，尾节点的next为p，\n                // 也就是把p接到当前暂时的尾节点后面\n                else {\n                    p.prev = tl;\n                    tl.next = p;\n                }\n                // 把p设为暂时尾节点\n                tl = p;\n            } while ((e = e.next) != null);\n            // 上面只是把链表转换成TreeNode，现在才进行链表条转换成红黑树\n            if ((tab[index] = hd) != null)\n                // 看下面解析\n                hd.treeify(tab);\n        }\n    }\n```\n\n### treeify\n```\n    /**\n     * 把链表条转换成红黑树\n     */\n  final void treeify(Node<K,V>[] tab) {\n            TreeNode<K,V> root = null;\n            // 从this开始遍历，x为当前节点，next为当前节点的下一节点\n            for (TreeNode<K,V> x = this, next; x != null; x = next) {\n                next = (TreeNode<K,V>)x.next;\n                x.left = x.right = null;\n                // 如果还没有根节点，把x设为跟节点\n                if (root == null) {\n                    x.parent = null;\n                    x.red = false;\n                    root = x;\n                }\n                else {\n                    K k = x.key;\n                    int h = x.hash;\n                    Class<?> kc = null;\n                    /*\n                     * 从根节点开始遍历，此遍历没有设置边界，只能从内部跳出\n                     * x为要插进的节点，p为遍历到的要进行对比的节点\n                     */\n                    for (TreeNode<K,V> p = root;;) {\n                        // dir 标识方向（-1为左，1为右）、ph标识当前树节点的hash值\n                        int dir, ph;\n                        K pk = p.key;\n                        if ((ph = p.hash) > h)\n                            dir = -1;\n                        else if (ph < h)\n                            dir = 1;\n                        // 对比的两个节点x、p的hash值相等，判断hash碰撞再决定dir的值\n                        else if ((kc == null &&\n                                  (kc = comparableClassFor(k)) == null) ||\n                                 (dir = compareComparables(kc, k, pk)) == 0)\n                            dir = tieBreakOrder(k, pk);\n                        // 先保存好当前对比的p，可能要作为x即将插入的父节点\n                        TreeNode<K,V> xp = p;\n                        // 根据dir来决定下一个遍历的对比节点p，如果p为null说明到末节点了，把x插进去\n                      \n                        if ((p = (dir <= 0) ? p.left : p.right) == null) {\n                            // x的父节点\n                            x.parent = xp;\n                            // 决定x在左还是右节点\n                            if (dir <= 0)\n                                xp.left = x;\n                            else\n                                xp.right = x;\n                            // 加入新的节点，要对红黑树进行重新平衡，这个下面分析\n                            root = balanceInsertion(root, x);\n                            break;\n                        }\n                    // p不为null，就重新开始整个遍历\n                    }\n                }\n            }\n            // 把红黑树的根节点设为其所在的链表条的链表头，下面会有分析\n            moveRootToFront(tab, root);\n        }\n```\n\n### balanceInsertion\n```\n    /**\n     * 平衡红黑树，root为根节点，x为新插入的节点\n     * 有兴趣可以看这篇图文讲解，https://www.cnblogs.com/oldbai/p/9890808.html\n     * 还有这篇 https://blog.csdn.net/weixin_42340670/article/details/80550932\n     */\n  static <K,V> TreeNode<K,V> balanceInsertion(TreeNode<K,V> root,\n                                                    TreeNode<K,V> x) {\n            // 设x为红色\n            x.red = true;\n            // 循环依然只能内部跳出\n            // xp：x的父节点、xpp：x的爷爷节点、xppl：x的左叔叔节点、xppr：x的右叔叔节点\n            for (TreeNode<K,V> xp, xpp, xppl, xppr;;) {\n                // xp为x的父节点，为null说明x为根节点，设成黑色，返回x\n                if ((xp = x.parent) == null) {\n                    x.red = false;\n                    return x;\n                }\n                // xp为黑色或者x的爷爷节点xpp为null，返回root\n                else if (!xp.red || (xpp = xp.parent) == null)\n                    return root;\n                // xpp不为null，xp与xpp的左子节点相等，则说明xp在xpp的左子节点\n                if (xp == (xppl = xpp.left)) {\n                    // 如果 xpp 的右子节点xppr不为空且为红色，进行变色操作\n                    // 这里直接变色可达到关于黑色数量规则，且无连续红色，\n                    // 然后继续往上循环判断\n                    if ((xppr = xpp.right) != null && xppr.red) {\n                        xppr.red = false;\n                        xp.red = false;\n                        xpp.red = true;\n                        // x设为xpp，作为下次循环的指定节点\n                        x = xpp;\n                    }\n                    // 如果 xpp 的右子节点xppr为空，或者为黑色，变色已经不能满足红黑树规则\n                    else {\n                        // 如果x为右子节点,左旋转\n                        if (x == xp.right) {\n                            root = rotateLeft(root, x = xp);\n                            xpp = (xp = x.parent) == null ? null : xp.parent;\n                        }\n                        if (xp != null) {\n                            xp.red = false;\n                            if (xpp != null) {\n                                xpp.red = true;\n                                root = rotateRight(root, xpp);\n                            }\n                        }\n                    }\n                }\n                else {\n                    if (xppl != null && xppl.red) {\n                        xppl.red = false;\n                        xp.red = false;\n                        xpp.red = true;\n                        x = xpp;\n                    }\n                    else {\n                        if (x == xp.left) {\n                            root = rotateRight(root, x = xp);\n                            xpp = (xp = x.parent) == null ? null : xp.parent;\n                        }\n                        if (xp != null) {\n                            xp.red = false;\n                            if (xpp != null) {\n                                xpp.red = true;\n                                root = rotateLeft(root, xpp);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n```\n### rotateLeft   \n```\n    /**\n     * 左旋转\n     */\n   static <K,V> TreeNode<K,V> rotateLeft(TreeNode<K,V> root,\n                                              TreeNode<K,V> p) {\n            TreeNode<K,V> r, pp, rl;\n            if (p != null && (r = p.right) != null) {\n                if ((rl = p.right = r.left) != null)\n                    rl.parent = p;\n                if ((pp = r.parent = p.parent) == null)\n                    (root = r).red = false;\n                else if (pp.left == p)\n                    pp.left = r;\n                else\n                    pp.right = r;\n                r.left = p;\n                p.parent = r;\n            }\n            return root;\n        }\n```\n\n### rotateRight\n```\n    /**\n     * 右旋转\n     */\n    static <K,V> TreeNode<K,V> rotateRight(TreeNode<K,V> root,\n                                               TreeNode<K,V> p) {\n            TreeNode<K,V> l, pp, lr;\n            if (p != null && (l = p.left) != null) {\n                if ((lr = p.left = l.right) != null)\n                    lr.parent = p;\n                if ((pp = l.parent = p.parent) == null)\n                    (root = l).red = false;\n                else if (pp.right == p)\n                    pp.right = l;\n                else\n                    pp.left = l;\n                l.right = p;\n                p.parent = l;\n            }\n            return root;\n        }\n```\n\n方法有点难懂，深入研究红黑树后再补充。\n","tags":["little_eight"],"categories":["java1.8源码"]},{"title":"linux安装redis","url":"/2019/04/15/linux安装redis/","content":"\n## 假设没有虚拟机！\n[vm安装centos7](https://blog.csdn.net/babyxue/article/details/80970526)\n\n## redis的操作\n\n* 下载忽略，下载到/usr/local\n* 进到redis根目录，yum install gcc，下载gcc，然后make MALLOC=libc\n* 进入src, make install\n* 回到根目录，vi redis.conf\n>1、注释bind 127.0.0.1或一些bind相关的\n2、修改protected-mode=no，开放外界访问redis\n3、daemonize属性改为yes，表明需要在后台运行\n\n* 防火墙的处理\n>停止使用firewall\nsystemctl stop firewalld.service\n禁止在开机启动\nsystemctl disable firewalld.service docker ps   \n\n* 安装结束","tags":["little_eight"],"categories":["Linux"]},{"title":"部署到Linux服务器上访问很卡的排查方法","url":"/2019/04/15/部署到Linux服务器上访问很卡的排查方法/","content":"\n## 查看内存使用情况\n\nfree -g\n\n\n当观察到free栏已为0的时候，表示内存基本被吃完了，那就释放内存吧\n\n\n\n## 查看磁盘使用情况\n\ndf -h\n\n\n\n当发现磁盘使用率很高时，那就要释放磁盘空间了，删除一些不必要的文件（查看各个目录占用磁盘空间，参考之前的du命令文章）\n\n<!--more-->\n\n## 查看磁盘IO使用情况\n\niostat -x 1\n\n1表示1秒刷新一次\n\n\n当发现最右侧%util很高时，表示IO就很高了，若想看哪个进程占用IO，执行iotop命令查看\n\n你也可以测试自己的读写速率多大\n```\ndd if=/dev/zero of=test bs=64k count=4k oflag=dsync\n```\n输出的依次是:复制的大小、用时跟写速率\n\n\n## 查看cpu使用情况\n\ntop\n\n下图中红框里表是cpu使用情况，最右侧的%id表示剩余，若很低，则表示cpu被吃完了，在top界面按shift+p对进程使用cpu排序，能看到哪些进程占用cpu较多\n\n（暂时没图、、）\n","tags":["little_eight"],"categories":["Linux"]},{"title":"java.util.LinkedList类解析","url":"/2019/04/15/java-util-LinkedList类解析/","content":"\n　LinkedList 是一个用链表实现的集合，元素有序且可以重复。\n\n```\n    /**\n     * 实现 List 接口\n     *          这个接口是 List 类集合的上层接口，定义了实现该接口的类都必须要实现的一组方法\n     * 实现 Deque 接口\n     *          这是一个双向队列接口，双向队列就是两端都可以进行增加和删除操作。\n     * 实现 Cloneable 接口\n     *          这个类是 java.lang.Cloneable，前面我们讲解深拷贝和浅拷贝的原理时，\n     *          我们介绍了浅拷贝可以通过调用 Object.clone() 方法来实现，\n     *          但是调用该方法的对象必须要实现 Cloneable 接口，\n     *          否则会抛出 CloneNoSupportException异常。\n     * 实现 Serializable 接口\n     *          序列化\n     */\n    public class LinkedList<E>\n    extends AbstractSequentialList<E>\n    implements List<E>, Deque<E>, Cloneable, java.io.Serializable\n    {}\n```\n\n## 成员变量\n\n```\n    /**\n     * 链表的个数，也就是集合的大小吧\n     */\n    transient int size = 0;\n\n    /**\n     * 链表的头\n     */\n    transient Node<E> first;\n\n    /**\n     * 链表的尾\n     */\n    transient Node<E> last;\n```\n\n```\n    /**\n     * 链表的类\n     */\n   private static class Node<E> {\n        // 存的值\n        E item;\n        // 指向下一个节点的引用\n        Node<E> next;\n        // 指向上一个节点的引用\n        Node<E> prev;\n\n        Node(Node<E> prev, E element, Node<E> next) {\n            this.item = element;\n            this.next = next;\n            this.prev = prev;\n        }\n    }\n\n```\n<!--more-->\n## 构造方法\n\n```\n  /**\n     * 什么都没初始化。。。\n     */\n    public LinkedList() {\n    }\n```\n\n\n```\n    /**\n     * 就是集合c转换成LinkedList吧，addAll方法后面再说\n     */\n    public LinkedList(Collection<? extends E> c) {\n        this();\n        addAll(c);\n    }\n    \n     public boolean addAll(int index, Collection<? extends E> c) {\n        checkPositionIndex(index);\n\n        Object[] a = c.toArray();\n        int numNew = a.length;\n        if (numNew == 0)\n            return false;\n\n        Node<E> pred, succ;\n        if (index == size) {\n            succ = null;\n            pred = last;\n        } else {\n            succ = node(index);\n            pred = succ.prev;\n        }\n\n        for (Object o : a) {\n            @SuppressWarnings(\"unchecked\") E e = (E) o;\n            Node<E> newNode = new Node<>(pred, e, null);\n            if (pred == null)\n                first = newNode;    \n            else\n                pred.next = newNode;\n            pred = newNode;\n        }\n\n        if (succ == null) {\n            last = pred;\n        } else {\n            pred.next = succ;\n            succ.prev = pred;\n        }\n\n        size += numNew;\n        modCount++;\n        return true;\n    }\n\n```\n## 方法\n\n### add\n```\n /**\n  *把元素加到指定下标，也就是在指定下标插入（新建）链表\n  */\n\npublic void add(int index, E element) {\n        checkPositionIndex(index);\n        // 如果下标刚好是集合大小，就直接把这个元素加到链表尾\n        if (index == size)\n            linkLast(element);\n        else\n            linkBefore(element, node(index));\n    }\n      /**\n       * 加到链表尾的方法\n       */\n      void linkLast(E e) {\n        // 现在的链表尾赋给 l\n        final Node<E> l = last;\n        // 新建链表，上一节点为 l，下一节点为null\n        final Node<E> newNode = new Node<>(l, e, null);\n        // newNode为链表尾\n        last = newNode;\n        // 如果l为空，说明是没有链表的，把newNode也设置成链表头\n        if (l == null)\n            first = newNode;\n        // 否则的话 就把newNode赋值给l.next，让整条链表完整\n        else\n            l.next = newNode;\n        size++;\n        modCount++;\n    }\n        /**\n         * 在某个链表前面插入一个链表\n         */\n       void linkBefore(E e, Node<E> succ) {\n        final Node<E> pred = succ.prev;\n        final Node<E> newNode = new Node<>(pred, e, succ);\n        succ.prev = newNode;\n        if (pred == null)\n            first = newNode;\n        else\n            pred.next = newNode;\n        size++;\n        modCount++;\n    }\n```\n### addAll\n```\n /**\n  * 在下标index后，添加集合c\n  */\n public boolean addAll(int index, Collection<? extends E> c) {\n        checkPositionIndex(index);\n\n        Object[] a = c.toArray();\n        int numNew = a.length;\n        if (numNew == 0)\n            return false;\n\n        Node<E> pred, succ;\n        if (index == size) {\n            succ = null;\n            pred = last;\n        } else {\n            succ = node(index);\n            pred = succ.prev;\n        }\n\n        for (Object o : a) {\n            @SuppressWarnings(\"unchecked\") E e = (E) o;\n            Node<E> newNode = new Node<>(pred, e, null);\n            if (pred == null)\n                first = newNode;\n            else\n                pred.next = newNode;\n            pred = newNode;\n        }\n\n        if (succ == null) {\n            last = pred;\n        } else {\n            pred.next = succ;\n            succ.prev = pred;\n        }\n\n        size += numNew;\n        modCount++;\n        return true;\n    }\n\n```\n\n### addFirst\n```\n /**\n  * 实现的办法是这个私有的，就是在表头加链表\n  */\n private void linkFirst(E e) {\n        final Node<E> f = first;\n        final Node<E> newNode = new Node<>(null, e, f);\n        first = newNode;\n        if (f == null)\n            last = newNode;\n        else\n            f.prev = newNode;\n        size++;\n        modCount++;\n    }\n```\n\n### addLast\n```\n /**\n  * 实现的办法是这个私有的，就是在表尾加链表\n  */\n void linkLast(E e) {\n        final Node<E> l = last;\n        final Node<E> newNode = new Node<>(l, e, null);\n        last = newNode;\n        if (l == null)\n            first = newNode;\n        else\n            l.next = newNode;\n        size++;\n        modCount++;\n    }\n```\n\n### clear\n```\n /**\n  * 清除所有链表\n  */\n      public void clear() {\n        for (Node<E> x = first; x != null; ) {\n            Node<E> next = x.next;\n            x.item = null;\n            x.next = null;\n            x.prev = null;\n            x = next;\n        }\n        first = last = null;\n        size = 0;\n        modCount++;\n    }\n```\n\n### clone\n```\n /**\n  * 浅拷贝\n  */\n    public Object clone() {\n        // 就是Object.clone()实现克隆\n        LinkedList<E> clone = superClone();\n        clone.first = clone.last = null;\n        clone.size = 0;\n        clone.modCount = 0;\n\n        for (Node<E> x = first; x != null; x = x.next)\n            clone.add(x.item);\n\n        return clone;\n    }\n```\n\n### contains、indexOf、lastIndexOf\n```\n /**\n  * 是否包含此元素\n  */\n    public boolean contains(Object o) {\n        return indexOf(o) != -1;\n    }\n    /**\n     * 判断是否存在此元素，存在返回下标，否则返回-1\n     */ \n    public int indexOf(Object o) {\n        int index = 0;\n        if (o == null) {\n            for (Node<E> x = first; x != null; x = x.next) {\n                if (x.item == null)\n                    return index;\n                index++;\n            }\n        } else {\n            for (Node<E> x = first; x != null; x = x.next) {\n                if (o.equals(x.item))\n                    return index;\n                index++;\n            }\n        }\n        return -1;\n    }\n    \n     /**\n     * 从尾部开始循环，判断是否存在此元素，存在返回下标，否则返回-1\n     */ \n     public int lastIndexOf(Object o) {\n        int index = size;\n        if (o == null) {\n            for (Node<E> x = last; x != null; x = x.prev) {\n                index--;\n                if (x.item == null)\n                    return index;\n            }\n        } else {\n            for (Node<E> x = last; x != null; x = x.prev) {\n                index--;\n                if (o.equals(x.item))\n                    return index;\n            }\n        }\n        return -1;\n    }\n```\n\n### get、getFirst、getLast\n这三个get方法都必须保证元素非null的。\n\n```\n /**\n  * 根据下标返回元素（）\n  */\n public E get(int index) {\n        checkElementIndex(index);\n        return node(index).item;\n    }\n     /**\n      * 返回链表头的元素\n      */\n     public E getFirst() {\n        final Node<E> f = first;\n        if (f == null)\n            throw new NoSuchElementException();\n        return f.item;\n    }\n     /**\n      * 返回链表尾的元素\n      */\n        public E getLast() {\n        final Node<E> l = last;\n        if (l == null)\n            throw new NoSuchElementException();\n        return l.item;\n    }\n```\n\n### listIterator\n```\n /**\n  * 就是根据下标new一个内部迭代类\n  */\n   public ListIterator<E> listIterator(int index) {\n        checkPositionIndex(index);\n        return new ListItr(index);\n    }\n```\n### offer、offerFirst、offerLast\n这个跟add一样的，只不过返回一个true的结果\n```\n   public boolean offer(E e) {\n        return add(e);\n    }\n    \n    public boolean offerFirst(E e) {\n        addFirst(e);\n        return true;\n    }\n    \n      public boolean offerLast(E e) {\n        addLast(e);\n        return true;\n    }\n\n```\n\n\n\n### peek、peekFirst、peekLast\n这三个方法都不用保证元素非null的。\n```\n   /**\n    * 1.5版本的获取链表头的元素\n    */\n    public E peek() {\n        final Node<E> f = first;\n        return (f == null) ? null : f.item;\n    }\n     /**\n      *1.6版本的获取链表头的元素\n      */\n    public E peekFirst() {\n        final Node<E> f = first;\n        return (f == null) ? null : f.item;\n     }\n     \n      /**\n       *获取链表尾的元素\n       */\n    public E peekLast() {\n        final Node<E> l = last;\n        return (l == null) ? null : l.item;\n    }\n\n    \n    \n```\n\n### poll、pollFirst、pollLast\n```\n     /**\n      * 1.5版本的删除链表头\n      */\n   public E poll() {\n        final Node<E> f = first;\n        return (f == null) ? null : unlinkFirst(f);\n    }\n     /**\n      * 1.6版本删除链表头\n      */\n    public E pollFirst() {\n        final Node<E> f = first;\n        return (f == null) ? null : unlinkFirst(f);\n    }\n     /**\n      * 删除链表尾\n      */\n     public E pollLast() {\n        final Node<E> l = last;\n        return (l == null) ? null : unlinkLast(l);\n    }\n    \n    /**\n     * 把指定的链表设置为null，让gc自己去回收\n     */\n     private E unlinkLast(Node<E> l) {\n        // assert l == last && l != null;\n        final E element = l.item;\n        final Node<E> prev = l.prev;\n        l.item = null;\n        l.prev = null; // help GC\n        last = prev;\n        if (prev == null)\n            first = null;\n        else\n            prev.next = null;\n        size--;\n        modCount++;\n        return element;\n    }\n```\n\n### remove、removeFirst、removeLast\n顾名思义，就是删除链表，实现方法都是unlink（必须保证非null）\n```\n /**\n  * 删除指定链表\n  */\nE unlink(Node<E> x) {\n        // assert x != null;\n        final E element = x.item;\n        final Node<E> next = x.next;\n        final Node<E> prev = x.prev;\n\n        if (prev == null) {\n            first = next;\n        } else {\n            prev.next = next;\n            x.prev = null;\n        }\n\n        if (next == null) {\n            last = prev;\n        } else {\n            next.prev = prev;\n            x.next = null;\n        }\n\n        x.item = null;\n        size--;\n        modCount++;\n        return element;\n    }\n```\n\n### set\n```\n /**\n  * 根据下标设置对应链表的元素\n  */\n    public E set(int index, E element) {\n        checkElementIndex(index);\n        Node<E> x = node(index);\n        E oldVal = x.item;\n        x.item = element;\n        return oldVal;\n    }\n```\n\n### toArray\n```\n /**\n  * 转换成数组\n  */\n   public Object[] toArray() {\n        Object[] result = new Object[size];\n        int i = 0;\n        for (Node<E> x = first; x != null; x = x.next)\n            result[i++] = x.item;\n        return result;\n    }\n```\n","tags":["little_eight"],"categories":["java1.8源码"]},{"title":"java.util.ArrayList类解析","url":"/2019/04/11/java.util.ArrayList类解析/","content":"ArrayList 是一个用数组实现的集合，支持随机访问，元素有序且可以重复。\n\n```\n    /**\n     * 实现 List 接口\n     *          这个接口是 List 类集合的上层接口，定义了实现该接口的类都必须要实现的一组方法\n     * 实现 RandomAccess 接口\n     *          这是一个标记接口，一般此标记接口用于 List 实现，\n     *          以表明它们支持快速（通常是恒定时间）的随机访问。\n     *          该接口的主要目的是允许通用算法改变其行为，\n     *          以便在应用于随机或顺序访问列表时提供良好的性能\n     * 实现 Cloneable 接口\n     *          这个类是 java.lang.Cloneable，前面我们讲解深拷贝和浅拷贝的原理时，\n     *          我们介绍了浅拷贝可以通过调用 Object.clone() 方法来实现，\n     *          但是调用该方法的对象必须要实现 Cloneable 接口，\n     *          否则会抛出 CloneNoSupportException异常。\n     * 实现 Serializable 接口\n     *          序列化\n     */\n    public class ArrayList<E> extends AbstractList<E>\n        implements List<E>, RandomAccess, Cloneable, java.io.Serializable\n    {}\n```\n\n## 成员变量\n\n```\n    /**\n     * 默认初始大小.\n     */\n    private static final int DEFAULT_CAPACITY = 10;\n\n    /**\n     * 用于空实例的共享空数组实例。\n     */\n    private static final Object[] EMPTY_ELEMENTDATA = {};\n\n    /**\n     * 共享空数组实例，用于默认大小的空实例。我们将其与空元素数据区分开来，\n     * 以了解添加第一个元素时要加多少量。\n     */\n    private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};\n\n    /**\n     * 存储集合元素的数组缓冲区。集合的容量是这个数组缓冲区的长度。\n     * 任何带有elementdata==DEFAULTCAPACITY_EMPTY_ELEMENTDATA的空集合\n     * 将在添加第一个元素时扩展为默认容量。\n     */\n    transient Object[] elementData;\n\n    /**\n     * 集合大小\n     */\n    private int size;\n\n```\n<!--more-->\n## 构造函数\n\n```\n    /**\n     * Constructs an empty list with an initial capacity of ten.(构造初始容量为10的空列表。)\n     * 明明说是10，其实看代码只是创建了一个空数组，应该是版本更新忘了改注释了。\n     */\n    public ArrayList() {\n        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;\n    }\n\n```\n\n```\n\n    /**\n     * 构造具有指定初始容量的空列表\n     */\n    public ArrayList(int initialCapacity) {\n        if (initialCapacity > 0) {\n            this.elementData = new Object[initialCapacity];\n        } else if (initialCapacity == 0) {\n            this.elementData = EMPTY_ELEMENTDATA;\n        } else {\n            throw new IllegalArgumentException(\"Illegal Capacity: \"+\n                                               initialCapacity);\n        }\n    }\n```\n```\n    /**\n     * 按照集合迭代器返回元素的顺序构造包含指定集合的元素的列表。\n     */\n    public ArrayList(Collection<? extends E> c) {\n        elementData = c.toArray();\n        if ((size = elementData.length) != 0) {\n            // c.toArray might (incorrectly) not return Object[] (see 6260652)\n            if (elementData.getClass() != Object[].class)\n                elementData = Arrays.copyOf(elementData, size, Object[].class);\n        } else {\n            // replace with empty array.\n            this.elementData = EMPTY_ELEMENTDATA;\n        }\n    }\n```\n\n## 方法\n\n## add\n\n```\n   \n   public boolean add(E e) {\n        ensureCapacityInternal(size + 1);\n        elementData[size++] = e;\n        return true;\n    }\n```\n 看看ensureCapacityInternal方法\n```\n     private void ensureCapacityInternal(int minCapacity) {\n        ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));\n    }\n```\n再看看calculateCapacity,可以看到当elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA时，也就是这是new ArrayList后第一次加进元素的话，就会返回初始容量10，后面根据这个新建一个10容量的数组\n```\n     private static int calculateCapacity(Object[] elementData, int minCapacity) {\n        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\n            return Math.max(DEFAULT_CAPACITY, minCapacity);\n        }\n        return minCapacity;\n    }\n```\nensureExplicitCapacity是干嘛的呢，是确保数组可用，如果容量不够，就要进行扩容了，也就是grow方法\n\n```\n  private void ensureExplicitCapacity(int minCapacity) {\n        modCount++;\n        if (minCapacity - elementData.length > 0)\n            grow(minCapacity);\n    }\n```\n看看grow方法\n```\n    /**\n     * 增加容量以确保它至少能容纳最小容量参数指定的元素数。一般是扩容1.5倍\n     */\n   private void grow(int minCapacity) {\n        // 现在数组的容量\n        int oldCapacity = elementData.length;\n        // 扩容1.5倍的容量\n        int newCapacity = oldCapacity + (oldCapacity >> 1);\n        // 如果1.5倍容量小于minCapacity，那把minC赋值给newC\n        if (newCapacity - minCapacity < 0)\n            newCapacity = minCapacity;\n        // 如果1.5倍容量大于MAX_ARRAY_SIZE（int最大值 - 8）\n        if (newCapacity - MAX_ARRAY_SIZE（0x7fffffff - 8） > 0)\n            // hugeCapacity是这样的，minC > MAX_ARRAY_SIZE) ?Integer.MAX_VALUE : MAX_ARRAY_SIZE;\n            newCapacity = hugeCapacity(minCapacity);\n        // 这里用到数组复制的方法，扩容到指定大小\n        elementData = Arrays.copyOf(elementData, newCapacity);\n    }\n```\n\n\n### clear\n\n```\n    // 就是清空数组，也就是清空集合\n   public void clear() {\n        modCount++;\n\n        // clear to let GC do its work\n        for (int i = 0; i < size; i++)\n            elementData[i] = null;\n\n        size = 0;\n    }\n```\n\n### clone\n\n```\n  // 克隆集合。。\n  public Object clone() {\n        try {\n            ArrayList<?> v = (ArrayList<?>) super.clone();\n            v.elementData = Arrays.copyOf(elementData, size);\n            v.modCount = 0;\n            return v;\n        } catch (CloneNotSupportedException e) {\n            // this shouldn't happen, since we are Cloneable\n            throw new InternalError(e);\n        }\n   \n }\n```\n\n### contains\n\n```\n    public boolean contains(Object o) {\n        return indexOf(o) >= 0;\n    }\n    //  // 从前面开始遍历，返回第一个与o相等的下标，不存在返回-1\n    public int indexOf(Object o) {\n        if (o == null) {\n            for (int i = 0; i < size; i++)\n                if (elementData[i]==null)\n                    return i;\n        } else {\n            for (int i = 0; i < size; i++)\n                if (o.equals(elementData[i]))\n                    return i;\n        }\n        return -1;\n    }\n\n```\n\n### get\n\n```\n // 根据下标值获取对应元素\n public E get(int index) {\n        // 检查是否超过最大下标值\n        rangeCheck(index);\n        // 就是 elementData[index]\n        return elementData(index);\n    }\n\n```\n\n### iterator\n\n```\n  // 返回的是一个内部类 Itr，Itr这里就不做多解释了，有兴趣可以自己去看。\n  public Iterator<E> iterator() {\n        return new Itr();\n    }\n```\n### lastIndexOf\n```\n // 从后面开始遍历，返回第一个与o相等的下标，不存在返回-1\n  public int lastIndexOf(Object o) {\n        if (o == null) {\n            for (int i = size-1; i >= 0; i--)\n                if (elementData[i]==null)\n                    return i;\n        } else {\n            for (int i = size-1; i >= 0; i--)\n                if (o.equals(elementData[i]))\n                    return i;\n        }\n        return -1;\n    }\n```\n\n\n### remove\n```\n   // 移除指定下标的元素，可以看到是用System.arraycopy来实现对移除元素后数组进行重新组合，让其他元素位置不变\n   public E remove(int index) {\n        rangeCheck(index);\n\n        modCount++;\n        E oldValue = elementData(index);\n\n        int numMoved = size - index - 1;\n        if (numMoved > 0)\n            System.arraycopy(elementData, index+1, elementData, index,\n                             numMoved);\n        elementData[--size] = null; // clear to let GC do its work\n\n        return oldValue;\n    }\n```\n还有一个根据元素值来移除的，就是遍历数组，找到下标，移除，也是用System.arraycopy来实现\n\n### removeAll\n```\n   // 从此列表中删除指定集合中包含的所有元素。\n    public boolean removeAll(Collection<?> c) {\n        Objects.requireNonNull(c);\n        return batchRemove(c, false);\n    }\n```\n\n```\n // 核心还是用到了System.arraycopy\n private boolean batchRemove(Collection<?> c, boolean complement) {\n        final Object[] elementData = this.elementData;\n        int r = 0, w = 0;\n        boolean modified = false;\n        try {\n            for (; r < size; r++)\n                // complement等于false，也就是c不包含的元素，重新从下标0赋值到elementData\n                if (c.contains(elementData[r]) == complement)\n                    elementData[w++] = elementData[r];\n        } finally {\n            if (r != size) {\n                System.arraycopy(elementData, r,\n                                 elementData, w,\n                                 size - r);\n                w += size - r;\n            }\n            if (w != size) {\n                // clear to let GC do its work\n                for (int i = w; i < size; i++)\n                    elementData[i] = null;\n                modCount += size - w;\n                size = w;\n                modified = true;\n            }\n        }\n        return modified;\n    }\n```\n### set\n```\n // 设值。。\n  public E set(int index, E element) {\n        rangeCheck(index);\n\n        E oldValue = elementData(index);\n        elementData[index] = element;\n        return oldValue;\n    }\n```\n\n### sort\n```\n   // 对elementData进行排序，用Arrays.sort实现\n   public void sort(Comparator<? super E> c) {\n        final int expectedModCount = modCount;\n        Arrays.sort((E[]) elementData, 0, size, c);\n        if (modCount != expectedModCount) {\n            throw new ConcurrentModificationException();\n        }\n        modCount++;\n    }\n```\n\n### subList\n```\n // 截取指定访问的元素到SubList.,也就是生成新的集合吧\n public List<E> subList(int fromIndex, int toIndex) {\n        subListRangeCheck(fromIndex, toIndex, size);\n        return new SubList(this, 0, fromIndex, toIndex);\n    }\n```\n\n### toArray\n```\n  // 转换成size大小的数组。。。\n  public Object[] toArray() {\n        return Arrays.copyOf(elementData, size);\n    }\n```\n\n```\n // 还可以指定转换的类型\n public <T> T[] toArray(T[] a) {\n        if (a.length < size)\n            // Make a new array of a's runtime type, but my contents:\n            return (T[]) Arrays.copyOf(elementData, size, a.getClass());\n        System.arraycopy(elementData, 0, a, 0, size);\n        if (a.length > size)\n            a[size] = null;\n        return a;\n    }\n```\n\n### trimToSize\n```\n  // 把数组转换成size大小的数组\n   public void trimToSize() {\n        modCount++;\n        if (size < elementData.length) {\n            elementData = (size == 0)\n              ? EMPTY_ELEMENTDATA\n              : Arrays.copyOf(elementData, size);\n        }\n    }\n\n```","tags":["little_eight"],"categories":["java1.8源码"]},{"title":"java.util.Arrays类解析","url":"/2019/04/11/java.util.Arrays类解析/","content":"源码的类注释：This class contains various methods for manipulating arrays (such as sorting and searching). This class also contains a static factory that allows arrays to be viewed as lists.\n可见这就是一个处理数组的类，直接研究含有的方法。\n\n## asList\n\n```\n    /**\n     * 就是数组转换成List集合\n     */\n   public static <T> List<T> asList(T... a) {\n        return new ArrayList<>(a);\n    }\n```\n<!--more-->\n## binarySearch\n\n源码方法注释：Searches the specified array of longs for the specified value using the binary search algorithm. The array must be sorted\n就是 采用二进制搜索算法，而且其数组必须是要经过排序的（后面的binarySearch0的使用基础必须是已经排序好的数组），排序刚好可以使用它的sort方法。\n```\n    /**\n     * 在数组中寻找此元素，返回它的下标\n     * 参数可换成其他基本数据类型和Object\n     */\n    public static int binarySearch(long[] a, long key) {\n        return binarySearch0(a, 0, a.length, key);\n    }\n    \n     /**\n      * 遍历的二进制搜索算法\n      * @param a 数组\n      * @param fromIndex 开始下标\n      * @param toIndex 结束下标\n      * @param key 寻找的元素\n      */\n     private static int binarySearch0(long[] a, int fromIndex, int toIndex,\n                                     long key) {\n        int low = fromIndex;\n        int high = toIndex - 1;\n\n        while (low <= high) {\n            // 取中间值\n            int mid = (low + high) >>> 1;\n            long midVal = a[mid];\n\n            if (midVal < key)\n                low = mid + 1;\n            else if (midVal > key)\n                high = mid - 1;\n            else\n                return mid; // key found\n        }\n        return -(low + 1);  // key not found.\n    }\n\n```\n\n## copyOf\n\n```\n\n  /**\n   * 顾名思义，就是复制指定的数组\n   * @param newLength 指定新数组的长度，如果小于复制的数组，则截取只保留到此长度的元素\n   * @param newType 默认是复制数组的类型(注意是T[]不是T)，也可以定义成新的类型\n   */\n  public static <T,U> T[] copyOf(U[] original, int newLength, Class<? extends T[]> newType) {\n        @SuppressWarnings(\"unchecked\")\n        T[] copy = ((Object)newType == (Object)Object[].class)\n            ? (T[]) new Object[newLength]\n            : (T[]) Array.newInstance(newType.getComponentType(), newLength);\n        System.arraycopy(original, 0, copy, 0,\n                         Math.min(original.length, newLength));\n        return copy;\n    }\n\n```\n\n```\n  /**\n   * 还提供另一个可指定范围复制数组的方法\n   */\n   public static <T,U> T[] copyOfRange(U[] original, int from, int to, Class<? extends T[]> newType) {\n        int newLength = to - from;\n        if (newLength < 0)\n            throw new IllegalArgumentException(from + \" > \" + to);\n        @SuppressWarnings(\"unchecked\")\n        T[] copy = ((Object)newType == (Object)Object[].class)\n            ? (T[]) new Object[newLength]\n            : (T[]) Array.newInstance(newType.getComponentType(), newLength);\n        System.arraycopy(original, from, copy, 0,\n                         Math.min(original.length - from, newLength));\n        return copy;\n    }\n\n```\n\n可以看到最终实现的都是System.arraycopy() \n\n## deepEquals\n\n```\n /**\n  * 就是对比两个数组的值（包括类型）是否完全一致\n  */\n public static boolean deepEquals(Object[] a1, Object[] a2) {\n        if (a1 == a2)\n            return true;\n        if (a1 == null || a2==null)\n            return false;\n        int length = a1.length;\n        if (a2.length != length)\n            return false;\n\n        for (int i = 0; i < length; i++) {\n            Object e1 = a1[i];\n            Object e2 = a2[i];\n\n            if (e1 == e2)\n                continue;\n            if (e1 == null)\n                return false;\n\n            // Figure out whether the two elements are equal\n            boolean eq = deepEquals0(e1, e2);\n\n            if (!eq)\n                return false;\n        }\n        return true;\n    }\n```\n\n\n### \n\n源码方法注释：Returns a hash code based on the \"deep contents\" of the specified array. \n\n```\n/**\n * 从 result = 1起，然后从第一个元素进行 result = 31 * result + element.HashCode(); 进行循环计算。\n * elementHash ： 就是下一级元素计算出来的。\n * 当element为 引用数据类型数组时，elementHash使用\tArrays.deepHashCode(Object a[])计算。\n * 当element为 基本数据类型数组时，elementHash使用\tArrays.hashCode(Object a[])计算。\n * 当element为 非数组时，elementHash使用\telement.hashCode()计算。\n * 很少用过，不理它了。\n */\npublic static int deepHashCode(Object a[]) {\n        if (a == null)\n            return 0;\n\n        int result = 1;\n\n        for (Object element : a) {\n            int elementHash = 0;\n            if (element instanceof Object[])\n                elementHash = deepHashCode((Object[]) element);\n            else if (element instanceof byte[])\n                elementHash = hashCode((byte[]) element);\n            else if (element instanceof short[])\n                elementHash = hashCode((short[]) element);\n            else if (element instanceof int[])\n                elementHash = hashCode((int[]) element);\n            else if (element instanceof long[])\n                elementHash = hashCode((long[]) element);\n            else if (element instanceof char[])\n                elementHash = hashCode((char[]) element);\n            else if (element instanceof float[])\n                elementHash = hashCode((float[]) element);\n            else if (element instanceof double[])\n                elementHash = hashCode((double[]) element);\n            else if (element instanceof boolean[])\n                elementHash = hashCode((boolean[]) element);\n            else if (element != null)\n                elementHash = element.hashCode();\n\n            result = 31 * result + elementHash;\n        }\n\n        return result;\n    }\n\n```\n\n## deepToString\n就是把数组转换成“[xx,yy,zz...]”，这样的字符串，可转换多层次嵌套的数组。而toString方法就只能转换一层数组。\n\n\n## equals\n\n```\n /**\n  * 相比于deepEquals()，这个只要求元素的值一样就返回true了\n  */\n public static boolean equals(short[] a, short a2[]) {\n        if (a==a2)\n            return true;\n        if (a==null || a2==null)\n            return false;\n\n        int length = a.length;\n        if (a2.length != length)\n            return false;\n\n        for (int i=0; i<length; i++)\n            if (a[i] != a2[i])\n                return false;\n\n        return true;\n    }\n```\n\n## fill\n\n```\n  /**\n   * 将val值赋给每个元素..\n   */\n  public static void fill(long[] a, long val) {\n        for (int i = 0, len = a.length; i < len; i++)\n            a[i] = val;\n    }\n```\n\n```\n   /**\n    * 你还可以指定赋值的范围\n    */\n    public static void fill(long[] a, int fromIndex, int toIndex, long val) {\n        rangeCheck(a.length, fromIndex, toIndex);\n        for (int i = fromIndex; i < toIndex; i++)\n            a[i] = val;\n    }\n\n```\n\n## hashCode\n\n```\n    /**\n     * 从 result = 1起，然后从第一个元素进行 result = 31 * result +element.HashCode();进行循环计算。\n     */\n    public static int hashCode(byte a[]) {\n        if (a == null)\n            return 0;\n\n        int result = 1;\n        for (byte element : a)\n            result = 31 * result + element;\n\n        return result;\n    }\n```\n\n## legacyMergeSort\n\n源码方法注释有这玩意：/** To be removed in a future release. */，那就不看他了\n\n## parallelPrefix、parallelSetAll\n太少用了，忽略不看。\n\n## parallelSort\n\n```\n /**\n  * 就是对数组排序，还提供对指定范围内的方法\n  */\n public static void parallelSort(long[] a) {\n        int n = a.length, p, g;\n        if (n <= MIN_ARRAY_SORT_GRAN ||\n            (p = ForkJoinPool.getCommonPoolParallelism()) == 1)\n            DualPivotQuicksort.sort(a, 0, n - 1, null, 0, 0);\n        else\n            new ArraysParallelSortHelpers.FJLong.Sorter\n                (null, a, new long[n], 0, n, 0,\n                 ((g = n / (p << 2)) <= MIN_ARRAY_SORT_GRAN) ?\n                 MIN_ARRAY_SORT_GRAN : g).invoke();\n    }\n\n```\n\n## setAll\n不常用，忽略\n\n## sort\n该方法是用于数组排序，在 Arrays 类中有该方法的一系列重载方法，能对7种基本数据类型，包括 byte,char,double,float,int,long,short 等都能进行排序，还有 Object 类型（实现了Comparable接口），以及比较器 Comparator 。这里我们以 int[ ] 为例看看。\n```\n    /**\n     * 就是对数组排序，还提供对指定范围内的方法\n     */\n     public static void sort(int[] a) {\n        DualPivotQuicksort.sort(a, 0, a.length - 1, null, 0, 0);\n    }\n```\n\n在 Arrays.sort 方法内部调用 DualPivotQuicksort.sort 方法，这个方法的源码很长，分别对于数组的长度进行了各种算法的划分，包括快速排序，插入排序，冒泡排序都有使用。特意翻译了DualPivotQuicksort这个类，有兴趣可以往下看(会逐渐翻译完毕)。\n\n```\n final class DualPivotQuicksort {\n        private DualPivotQuicksort() {\n        }\n\n        /**\n         * 合并排序中的最大运行次数\n         */\n        private static final int MAX_RUN_COUNT = 67;\n\n        /**\n         * 合并排序中运行的最大长度。\n         */\n        private static final int MAX_RUN_LENGTH = 33;\n\n        /**\n         * 如果要排序的数组的长度小于此值常量，快速排序优先用于合并排序。\n         */\n        private static final int QUICKSORT_THRESHOLD = 286;\n\n        /**\n         * 如果要排序的数组的长度小于此常量，则插入排序优先于快速排序。\n         */\n        private static final int INSERTION_SORT_THRESHOLD = 47;\n\n        /**\n         * 如果要排序的字节数组的长度大于此常量，则使用计数排序优先于插入排序。\n         */\n        private static final int COUNTING_SORT_THRESHOLD_FOR_BYTE = 29;\n\n        /**\n         * 如果要排序的短数组或字符数组的长度大于此常量，则计数排序优先于快速排序。\n         */\n        private static final int COUNTING_SORT_THRESHOLD_FOR_SHORT_OR_CHAR = 3200;\n\n        /**\n         * 如果可以合并，请使用给定的工作区数组切片对数组的指定范围进行排序\n         *\n         * @param a        要排序的数组\n         * @param left     排序开始位置\n         * @param right    排序结束位置\n         * @param work     工作区数组（切片）\n         * @param workBase 工作阵列中可用空间的原点\n         * @param workLen  工作阵列的可用大小\n         */\n         static void sort(int[] a, int left, int right,\n                         int[] work, int workBase, int workLen) {\n            // 在小数组上使用快速排序\n            if (right - left < QUICKSORT_THRESHOLD) {\n                sort(a, left, right, true);\n                return;\n            }\n\n        /*\n         * 索引运行[i]是第i次运行的开始（升序或降序）。\n         */\n            int[] run = new int[MAX_RUN_COUNT + 1];\n            int count = 0;\n            run[0] = left;\n\n            // 检查数组是否接近排序\n            for (int k = left; k < right; run[count] = k) {\n                if (a[k] < a[k + 1]) { //\n                    while (++k <= right && a[k - 1] <= a[k]) ;\n                } else if (a[k] > a[k + 1]) { // descending\n                    while (++k <= right && a[k - 1] >= a[k]) ;\n                    for (int lo = run[count] - 1, hi = k; ++lo < --hi; ) {\n                        int t = a[lo];\n                        a[lo] = a[hi];\n                        a[hi] = t;\n                    }\n                } else {\n                    for (int m = MAX_RUN_LENGTH; ++k <= right && a[k - 1] == a[k]; ) {\n                        if (--m == 0) {\n                            sort(a, left, right, true);\n                            return;\n                        }\n                    }\n                }\n\n            /*\n             * 数组不是高度结构化的，请使用快速排序而不是合并排序。\n             */\n                if (++count == MAX_RUN_COUNT) {\n                    sort(a, left, right, true);\n                    return;\n                }\n            }\n\n            // 检查特殊情况\n            // 实施说明：变量“right”增加1。\n            if (run[count] == right++) { // 上次运行包含一个元素\n                run[++count] = right;\n            } else if (count == 1) { // 数组已排序\n                return;\n            }\n\n            // 确定合并的替换基\n            byte odd = 0;\n            for (int n = 1; (n <<= 1) < count; odd ^= 1) ;\n\n            // 使用或创建用于合并的临时数组B\n            int[] b;                 // 临时数组；替换为 a\n            int ao, bo;              // 从“左”开始的数组偏移量\n            int blen = right - left; // B所需空间\n            if (work == null || workLen < blen || workBase + blen > work.length) {\n                work = new int[blen];\n                workBase = 0;\n            }\n            if (odd == 0) {\n                System.arraycopy(a, left, work, workBase, blen);\n                b = a;\n                bo = 0;\n                a = work;\n                ao = workBase - left;\n            } else {\n                b = work;\n                ao = 0;\n                bo = workBase - left;\n            }\n\n            // 合并\n            for (int last; count > 1; count = last) {\n                for (int k = (last = 0) + 2; k <= count; k += 2) {\n                    int hi = run[k], mi = run[k - 1];\n                    for (int i = run[k - 2], p = i, q = mi; i < hi; ++i) {\n                        if (q >= hi || p < mi && a[p + ao] <= a[q + ao]) {\n                            b[i + bo] = a[p++ + ao];\n                        } else {\n                            b[i + bo] = a[q++ + ao];\n                        }\n                    }\n                    run[++last] = hi;\n                }\n                if ((count & 1) != 0) {\n                    for (int i = right, lo = run[count - 1]; --i >= lo;\n                         b[i + bo] = a[i + ao]\n                            )\n                        ;\n                    run[++last] = right;\n                }\n                int[] t = a;\n                a = b;\n                b = t;\n                int o = ao;\n                ao = bo;\n                bo = o;\n            }\n        }\n\n        /**\n         * 快速排序\n         *\n         * @param leftmost 指示此部分是否在范围内最左边\n         */\n        private static void sort(int[] a, int left, int right, boolean leftmost) {\n            int length = right - left + 1;\n\n            // 在小数组上使用插入排序\n            if (length < INSERTION_SORT_THRESHOLD) {\n                if (leftmost) {\n                /*\n                 * 传统的（不带sentinel）插入排序，针对服务器虚拟机进行了优化，用于最左边的部分。\n                 */\n                    for (int i = left, j = i; i < right; j = ++i) {\n                        int ai = a[i + 1];\n                        while (ai < a[j]) {\n                            a[j + 1] = a[j];\n                            if (j-- == left) {\n                                break;\n                            }\n                        }\n                        a[j + 1] = ai;\n                    }\n                } else {\n                /*\n                 * 跳过最长的升序。\n                 */\n                    do {\n                        if (left >= right) {\n                            return;\n                        }\n                    } while (a[++left] >= a[left - 1]);\n\n                /*\n                 * 相邻部分的每一个元素都扮演着哨兵的角色，\n                 * 因此这允许我们避免在每次迭代中进行左范围检查。\n                 * 此外，我们使用了更优化的算法，即对插入排序，\n                 * 这比传统的插入排序实现更快（在快速排序的上下文中）。\n                 */\n                    for (int k = left; ++left <= right; k = ++left) {\n                        int a1 = a[k], a2 = a[left];\n\n                        if (a1 < a2) {\n                            a2 = a1;\n                            a1 = a[left];\n                        }\n                        while (a1 < a[--k]) {\n                            a[k + 2] = a[k];\n                        }\n                        a[++k + 1] = a1;\n\n                        while (a2 < a[--k]) {\n                            a[k + 1] = a[k];\n                        }\n                        a[k + 1] = a2;\n                    }\n                    int last = a[right];\n\n                    while (last < a[--right]) {\n                        a[right + 1] = a[right];\n                    }\n                    a[right + 1] = last;\n                }\n                return;\n            }\n\n            // 长度的廉价近似值/7\n            int seventh = (length >> 3) + (length >> 6) + 1;\n\n        /*\n         * 在范围内的中心元素周围（包括中心元素）对五个等距元素进行排序。\n         * 这些元素将用于如下所述的轴选择。\n         * 选择这些元素的间距是根据经验确定的，可以很好地处理各种输入。\n         */\n            int e3 = (left + right) >>> 1; // The midpoint\n            int e2 = e3 - seventh;\n            int e1 = e2 - seventh;\n            int e4 = e3 + seventh;\n            int e5 = e4 + seventh;\n\n            // 使用插入排序对这些元素排序\n            if (a[e2] < a[e1]) {\n                int t = a[e2];\n                a[e2] = a[e1];\n                a[e1] = t;\n            }\n\n            if (a[e3] < a[e2]) {\n                int t = a[e3];\n                a[e3] = a[e2];\n                a[e2] = t;\n                if (t < a[e1]) {\n                    a[e2] = a[e1];\n                    a[e1] = t;\n                }\n            }\n            if (a[e4] < a[e3]) {\n                int t = a[e4];\n                a[e4] = a[e3];\n                a[e3] = t;\n                if (t < a[e2]) {\n                    a[e3] = a[e2];\n                    a[e2] = t;\n                    if (t < a[e1]) {\n                        a[e2] = a[e1];\n                        a[e1] = t;\n                    }\n                }\n            }\n            if (a[e5] < a[e4]) {\n                int t = a[e5];\n                a[e5] = a[e4];\n                a[e4] = t;\n                if (t < a[e3]) {\n                    a[e4] = a[e3];\n                    a[e3] = t;\n                    if (t < a[e2]) {\n                        a[e3] = a[e2];\n                        a[e2] = t;\n                        if (t < a[e1]) {\n                            a[e2] = a[e1];\n                            a[e1] = t;\n                        }\n                    }\n                }\n            }\n\n            // 指针\n            int less = left;  // 中心部分第一个元素的索引\n            int great = right; // 右部分第一个元素前的索引\n\n            if (a[e1] != a[e2] && a[e2] != a[e3] && a[e3] != a[e4] && a[e4] != a[e5]) {\n            /*\n             * 使用五个已排序元素中的第二个和第四个元素作为轴心。\n             * 这些值是数组第一和第二个词组的廉价近似值。注意，Pivot1<=Pivot2。\n             */\n                int pivot1 = a[e2];\n                int pivot2 = a[e4];\n\n            /*\n             * 要排序的第一个和最后一个元素将移动到以前由枢轴占用的位置。\n             * 当分区完成时，数据透视被交换回它们的最终位置，并从随后的排序中排除。\n             */\n                a[e2] = a[left];\n                a[e4] = a[right];\n\n            /*\n             * 跳过小于或大于透视值的元素。\n             */\n                while (a[++less] < pivot1) ;\n                while (a[--great] > pivot2) ;\n\n            /*\n             * 划分:\n             *\n             *   左边部分           中间部分                   右边部分\n             * +--------------------------------------------------------------+\n             * |  < pivot1  |  pivot1 <= && <= pivot2  |    ?    |  > pivot2  |\n             * +--------------------------------------------------------------+\n             *               ^                          ^       ^\n             *               |                          |       |\n             *              less                        k     great\n             *\n             * 不变式:\n             *\n             *              all in (左边, less)   < pivot1\n             *    pivot1 <= all in [less, k)     <= pivot2\n             *              all in (great, 右边) > pivot2\n             *\n             * Pointer k is the first index of ?-part.\n             */\n                outer:\n                for (int k = less - 1; ++k <= great; ) {\n                    int ak = a[k];\n                    if (ak < pivot1) { // 移动 a[k] 到左边\n                        a[k] = a[less];\n                    /*\n                     * 由于性能问题，这里和我们使用下面的 \"a[i] = b; i++;\" 而不是\"a[i++] = b;\"\n                     */\n                        a[less] = ak;\n                        ++less;\n                    } else if (ak > pivot2) { // 移动 a[k] to 到右边\n                        while (a[great] > pivot2) {\n                            if (great-- == k) {\n                                break outer;\n                            }\n                        }\n                        if (a[great] < pivot1) { // a[great] <= pivot2\n                            a[k] = a[less];\n                            a[less] = a[great];\n                            ++less;\n                        } else { // pivot1 <= a[great] <= pivot2\n                            a[k] = a[great];\n                        }\n                    /*\n                     * 由于性能问题，这里和我们使用下面的 \"a[i] = b; i--;\"  而不是\"a[i--] = b;\"\n                     */\n                        a[great] = ak;\n                        --great;\n                    }\n                }\n\n                // 将pivots调到最终位置\n                a[left] = a[less - 1];\n                a[less - 1] = pivot1;\n                a[right] = a[great + 1];\n                a[great + 1] = pivot2;\n\n                // 以递归方式对左右部分排序，不包括已知的数据透视\n                sort(a, left, less - 2, leftmost);\n                sort(a, great + 2, right, false);\n\n            /*\n             * 如果中心部分太大（包括数组的4/7以上），请将内部轴值交换到末端。\n             */\n                if (less < e1 && e5 < great) {\n                /*\n                 * 跳过与透视值相等的元素。\n                 */\n                    while (a[less] == pivot1) {\n                        ++less;\n                    }\n\n                    while (a[great] == pivot2) {\n                        --great;\n                    }\n\n                /*\n                 * 划分:\n                 *\n                 *   左边部分           中间部分                   右边部分\n                 * +----------------------------------------------------------+\n                 * | == pivot1 |  pivot1 < && < pivot2  |    ?    | == pivot2 |\n                 * +----------------------------------------------------------+\n                 *              ^                        ^       ^\n                 *              |                        |       |\n                 *             less                      k     great\n                 *\n                 * 不变式:\n                 *\n                 *              all in (*,  less) == pivot1\n                 *     pivot1 < all in [less,  k)  < pivot2\n                 *              all in (great, *) == pivot2\n                 *\n                 * Pointer k is the first index of ?-part.\n                 */\n                    outer:\n                    for (int k = less - 1; ++k <= great; ) {\n                        int ak = a[k];\n                        if (ak == pivot1) { // 移动 a[k] 到左边\n                            a[k] = a[less];\n                            a[less] = ak;\n                            ++less;\n                        } else if (ak == pivot2) { // 移动 a[k] 到右边\n                            while (a[great] == pivot2) {\n                                if (great-- == k) {\n                                    break outer;\n                                }\n                            }\n                            if (a[great] == pivot1) { // a[great] < pivot2\n                                a[k] = a[less];\n                            /*\n                             * 即使[great]等于Pivot1，如果[great]和Pivot1是不同符号的浮点零，\n                             * 则赋值a[less]=Pivot1可能不正确。\n                             * 因此，在浮动和双重排序方法中，\n                             * 我们必须使用更精确的赋值a[less]=a[great]。\n                             */\n                                a[less] = pivot1;\n                                ++less;\n                            } else { // pivot1 < a[great] < pivot2\n                                a[k] = a[great];\n                            }\n                            a[great] = ak;\n                            --great;\n                        }\n                    }\n                }\n\n                // 递归排序中心部分\n                sort(a, less, great, false);\n\n            } else { // Partitioning with one pivot\n            /*\n             * Use the third of the five sorted elements as pivot.\n             * This value is inexpensive approximation of the median.\n             */\n                int pivot = a[e3];\n\n            /*\n             * Partitioning degenerates to the traditional 3-way\n             * (or \"Dutch National Flag\") schema:\n             *\n             *   left part    center part              right part\n             * +-------------------------------------------------+\n             * |  < pivot  |   == pivot   |     ?    |  > pivot  |\n             * +-------------------------------------------------+\n             *              ^              ^        ^\n             *              |              |        |\n             *             less            k      great\n             *\n             * Invariants:\n             *\n             *   all in (left, less)   < pivot\n             *   all in [less, k)     == pivot\n             *   all in (great, right) > pivot\n             *\n             * Pointer k is the first index of ?-part.\n             */\n                for (int k = less; k <= great; ++k) {\n                    if (a[k] == pivot) {\n                        continue;\n                    }\n                    int ak = a[k];\n                    if (ak < pivot) { // Move a[k] to left part\n                        a[k] = a[less];\n                        a[less] = ak;\n                        ++less;\n                    } else { // a[k] > pivot - Move a[k] to right part\n                        while (a[great] > pivot) {\n                            --great;\n                        }\n                        if (a[great] < pivot) { // a[great] <= pivot\n                            a[k] = a[less];\n                            a[less] = a[great];\n                            ++less;\n                        } else { // a[great] == pivot\n                        /*\n                         * Even though a[great] equals to pivot, the\n                         * assignment a[k] = pivot may be incorrect,\n                         * if a[great] and pivot are floating-point\n                         * zeros of different signs. Therefore in float\n                         * and double sorting methods we have to use\n                         * more accurate assignment a[k] = a[great].\n                         */\n                            a[k] = pivot;\n                        }\n                        a[great] = ak;\n                        --great;\n                    }\n                }\n\n            /*\n             * Sort left and right parts recursively.\n             * All elements from center part are equal\n             * and, therefore, already sorted.\n             */\n                sort(a, left, less - 1, leftmost);\n                sort(a, great + 1, right, false);\n            }\n        }\n\n        /**\n         * Sorts the specified range of the array using the given\n         * workspace array slice if possible for merging\n         *\n         * @param a        the array to be sorted\n         * @param left     the index of the first element, inclusive, to be sorted\n         * @param right    the index of the last element, inclusive, to be sorted\n         * @param work     a workspace array (slice)\n         * @param workBase origin of usable space in work array\n         * @param workLen  usable size of work array\n         */\n        static void sort(long[] a, int left, int right,\n                         long[] work, int workBase, int workLen) {\n            // Use Quicksort on small arrays\n            if (right - left < QUICKSORT_THRESHOLD) {\n                sort(a, left, right, true);\n                return;\n            }\n\n        /*\n         * Index run[i] is the start of i-th run\n         * (ascending or descending sequence).\n         */\n            int[] run = new int[MAX_RUN_COUNT + 1];\n            int count = 0;\n            run[0] = left;\n\n            // Check if the array is nearly sorted\n            for (int k = left; k < right; run[count] = k) {\n                if (a[k] < a[k + 1]) { // ascending\n                    while (++k <= right && a[k - 1] <= a[k]) ;\n                } else if (a[k] > a[k + 1]) { // descending\n                    while (++k <= right && a[k - 1] >= a[k]) ;\n                    for (int lo = run[count] - 1, hi = k; ++lo < --hi; ) {\n                        long t = a[lo];\n                        a[lo] = a[hi];\n                        a[hi] = t;\n                    }\n                } else { // equal\n                    for (int m = MAX_RUN_LENGTH; ++k <= right && a[k - 1] == a[k]; ) {\n                        if (--m == 0) {\n                            sort(a, left, right, true);\n                            return;\n                        }\n                    }\n                }\n\n            /*\n             * The array is not highly structured,\n             * use Quicksort instead of merge sort.\n             */\n                if (++count == MAX_RUN_COUNT) {\n                    sort(a, left, right, true);\n                    return;\n                }\n            }\n\n            // Check special cases\n            // Implementation note: variable \"right\" is increased by 1.\n            if (run[count] == right++) { // The last run contains one element\n                run[++count] = right;\n            } else if (count == 1) { // The array is already sorted\n                return;\n            }\n\n            // Determine alternation base for merge\n            byte odd = 0;\n            for (int n = 1; (n <<= 1) < count; odd ^= 1) ;\n\n            // Use or create temporary array b for merging\n            long[] b;                 // temp array; alternates with a\n            int ao, bo;              // array offsets from 'left'\n            int blen = right - left; // space needed for b\n            if (work == null || workLen < blen || workBase + blen > work.length) {\n                work = new long[blen];\n                workBase = 0;\n            }\n            if (odd == 0) {\n                System.arraycopy(a, left, work, workBase, blen);\n                b = a;\n                bo = 0;\n                a = work;\n                ao = workBase - left;\n            } else {\n                b = work;\n                ao = 0;\n                bo = workBase - left;\n            }\n\n            // Merging\n            for (int last; count > 1; count = last) {\n                for (int k = (last = 0) + 2; k <= count; k += 2) {\n                    int hi = run[k], mi = run[k - 1];\n                    for (int i = run[k - 2], p = i, q = mi; i < hi; ++i) {\n                        if (q >= hi || p < mi && a[p + ao] <= a[q + ao]) {\n                            b[i + bo] = a[p++ + ao];\n                        } else {\n                            b[i + bo] = a[q++ + ao];\n                        }\n                    }\n                    run[++last] = hi;\n                }\n                if ((count & 1) != 0) {\n                    for (int i = right, lo = run[count - 1]; --i >= lo;\n                         b[i + bo] = a[i + ao]\n                            )\n                        ;\n                    run[++last] = right;\n                }\n                long[] t = a;\n                a = b;\n                b = t;\n                int o = ao;\n                ao = bo;\n                bo = o;\n            }\n        }\n\n        /**\n         * Sorts the specified range of the array by Dual-Pivot Quicksort.\n         *\n         * @param a        the array to be sorted\n         * @param left     the index of the first element, inclusive, to be sorted\n         * @param right    the index of the last element, inclusive, to be sorted\n         * @param leftmost indicates if this part is the leftmost in the range\n         */\n        private static void sort(long[] a, int left, int right, boolean leftmost) {\n            int length = right - left + 1;\n\n            // Use insertion sort on tiny arrays\n            if (length < INSERTION_SORT_THRESHOLD) {\n                if (leftmost) {\n                /*\n                 * Traditional (without sentinel) insertion sort,\n                 * optimized for server VM, is used in case of\n                 * the leftmost part.\n                 */\n                    for (int i = left, j = i; i < right; j = ++i) {\n                        long ai = a[i + 1];\n                        while (ai < a[j]) {\n                            a[j + 1] = a[j];\n                            if (j-- == left) {\n                                break;\n                            }\n                        }\n                        a[j + 1] = ai;\n                    }\n                } else {\n                /*\n                 * Skip the longest ascending sequence.\n                 */\n                    do {\n                        if (left >= right) {\n                            return;\n                        }\n                    } while (a[++left] >= a[left - 1]);\n\n                /*\n                 * Every element from adjoining part plays the role\n                 * of sentinel, therefore this allows us to avoid the\n                 * left range check on each iteration. Moreover, we use\n                 * the more optimized algorithm, so called pair insertion\n                 * sort, which is faster (in the context of Quicksort)\n                 * than traditional implementation of insertion sort.\n                 */\n                    for (int k = left; ++left <= right; k = ++left) {\n                        long a1 = a[k], a2 = a[left];\n\n                        if (a1 < a2) {\n                            a2 = a1;\n                            a1 = a[left];\n                        }\n                        while (a1 < a[--k]) {\n                            a[k + 2] = a[k];\n                        }\n                        a[++k + 1] = a1;\n\n                        while (a2 < a[--k]) {\n                            a[k + 1] = a[k];\n                        }\n                        a[k + 1] = a2;\n                    }\n                    long last = a[right];\n\n                    while (last < a[--right]) {\n                        a[right + 1] = a[right];\n                    }\n                    a[right + 1] = last;\n                }\n                return;\n            }\n\n            // Inexpensive approximation of length / 7\n            int seventh = (length >> 3) + (length >> 6) + 1;\n\n        /*\n         * Sort five evenly spaced elements around (and including) the\n         * center element in the range. These elements will be used for\n         * pivot selection as described below. The choice for spacing\n         * these elements was empirically determined to work well on\n         * a wide variety of inputs.\n         */\n            int e3 = (left + right) >>> 1; // The midpoint\n            int e2 = e3 - seventh;\n            int e1 = e2 - seventh;\n            int e4 = e3 + seventh;\n            int e5 = e4 + seventh;\n\n            // Sort these elements using insertion sort\n            if (a[e2] < a[e1]) {\n                long t = a[e2];\n                a[e2] = a[e1];\n                a[e1] = t;\n            }\n\n            if (a[e3] < a[e2]) {\n                long t = a[e3];\n                a[e3] = a[e2];\n                a[e2] = t;\n                if (t < a[e1]) {\n                    a[e2] = a[e1];\n                    a[e1] = t;\n                }\n            }\n            if (a[e4] < a[e3]) {\n                long t = a[e4];\n                a[e4] = a[e3];\n                a[e3] = t;\n                if (t < a[e2]) {\n                    a[e3] = a[e2];\n                    a[e2] = t;\n                    if (t < a[e1]) {\n                        a[e2] = a[e1];\n                        a[e1] = t;\n                    }\n                }\n            }\n            if (a[e5] < a[e4]) {\n                long t = a[e5];\n                a[e5] = a[e4];\n                a[e4] = t;\n                if (t < a[e3]) {\n                    a[e4] = a[e3];\n                    a[e3] = t;\n                    if (t < a[e2]) {\n                        a[e3] = a[e2];\n                        a[e2] = t;\n                        if (t < a[e1]) {\n                            a[e2] = a[e1];\n                            a[e1] = t;\n                        }\n                    }\n                }\n            }\n\n            // Pointers\n            int less = left;  // The index of the first element of center part\n            int great = right; // The index before the first element of right part\n\n            if (a[e1] != a[e2] && a[e2] != a[e3] && a[e3] != a[e4] && a[e4] != a[e5]) {\n            /*\n             * Use the second and fourth of the five sorted elements as pivots.\n             * These values are inexpensive approximations of the first and\n             * second terciles of the array. Note that pivot1 <= pivot2.\n             */\n                long pivot1 = a[e2];\n                long pivot2 = a[e4];\n\n            /*\n             * The first and the last elements to be sorted are moved to the\n             * locations formerly occupied by the pivots. When partitioning\n             * is complete, the pivots are swapped back into their final\n             * positions, and excluded from subsequent sorting.\n             */\n                a[e2] = a[left];\n                a[e4] = a[right];\n\n            /*\n             * Skip elements, which are less or greater than pivot values.\n             */\n                while (a[++less] < pivot1) ;\n                while (a[--great] > pivot2) ;\n\n            /*\n             * Partitioning:\n             *\n             *   left part           center part                   right part\n             * +--------------------------------------------------------------+\n             * |  < pivot1  |  pivot1 <= && <= pivot2  |    ?    |  > pivot2  |\n             * +--------------------------------------------------------------+\n             *               ^                          ^       ^\n             *               |                          |       |\n             *              less                        k     great\n             *\n             * Invariants:\n             *\n             *              all in (left, less)   < pivot1\n             *    pivot1 <= all in [less, k)     <= pivot2\n             *              all in (great, right) > pivot2\n             *\n             * Pointer k is the first index of ?-part.\n             */\n                outer:\n                for (int k = less - 1; ++k <= great; ) {\n                    long ak = a[k];\n                    if (ak < pivot1) { // Move a[k] to left part\n                        a[k] = a[less];\n                    /*\n                     * Here and below we use \"a[i] = b; i++;\" instead\n                     * of \"a[i++] = b;\" due to performance issue.\n                     */\n                        a[less] = ak;\n                        ++less;\n                    } else if (ak > pivot2) { // Move a[k] to right part\n                        while (a[great] > pivot2) {\n                            if (great-- == k) {\n                                break outer;\n                            }\n                        }\n                        if (a[great] < pivot1) { // a[great] <= pivot2\n                            a[k] = a[less];\n                            a[less] = a[great];\n                            ++less;\n                        } else { // pivot1 <= a[great] <= pivot2\n                            a[k] = a[great];\n                        }\n                    /*\n                     * Here and below we use \"a[i] = b; i--;\" instead\n                     * of \"a[i--] = b;\" due to performance issue.\n                     */\n                        a[great] = ak;\n                        --great;\n                    }\n                }\n\n                // Swap pivots into their final positions\n                a[left] = a[less - 1];\n                a[less - 1] = pivot1;\n                a[right] = a[great + 1];\n                a[great + 1] = pivot2;\n\n                // Sort left and right parts recursively, excluding known pivots\n                sort(a, left, less - 2, leftmost);\n                sort(a, great + 2, right, false);\n\n            /*\n             * If center part is too large (comprises > 4/7 of the array),\n             * swap internal pivot values to ends.\n             */\n                if (less < e1 && e5 < great) {\n                /*\n                 * Skip elements, which are equal to pivot values.\n                 */\n                    while (a[less] == pivot1) {\n                        ++less;\n                    }\n\n                    while (a[great] == pivot2) {\n                        --great;\n                    }\n\n                /*\n                 * Partitioning:\n                 *\n                 *   left part         center part                  right part\n                 * +----------------------------------------------------------+\n                 * | == pivot1 |  pivot1 < && < pivot2  |    ?    | == pivot2 |\n                 * +----------------------------------------------------------+\n                 *              ^                        ^       ^\n                 *              |                        |       |\n                 *             less                      k     great\n                 *\n                 * Invariants:\n                 *\n                 *              all in (*,  less) == pivot1\n                 *     pivot1 < all in [less,  k)  < pivot2\n                 *              all in (great, *) == pivot2\n                 *\n                 * Pointer k is the first index of ?-part.\n                 */\n                    outer:\n                    for (int k = less - 1; ++k <= great; ) {\n                        long ak = a[k];\n                        if (ak == pivot1) { // Move a[k] to left part\n                            a[k] = a[less];\n                            a[less] = ak;\n                            ++less;\n                        } else if (ak == pivot2) { // Move a[k] to right part\n                            while (a[great] == pivot2) {\n                                if (great-- == k) {\n                                    break outer;\n                                }\n                            }\n                            if (a[great] == pivot1) { // a[great] < pivot2\n                                a[k] = a[less];\n                            /*\n                             * Even though a[great] equals to pivot1, the\n                             * assignment a[less] = pivot1 may be incorrect,\n                             * if a[great] and pivot1 are floating-point zeros\n                             * of different signs. Therefore in float and\n                             * double sorting methods we have to use more\n                             * accurate assignment a[less] = a[great].\n                             */\n                                a[less] = pivot1;\n                                ++less;\n                            } else { // pivot1 < a[great] < pivot2\n                                a[k] = a[great];\n                            }\n                            a[great] = ak;\n                            --great;\n                        }\n                    }\n                }\n\n                // Sort center part recursively\n                sort(a, less, great, false);\n\n            } else { // Partitioning with one pivot\n            /*\n             * Use the third of the five sorted elements as pivot.\n             * This value is inexpensive approximation of the median.\n             */\n                long pivot = a[e3];\n\n            /*\n             * Partitioning degenerates to the traditional 3-way\n             * (or \"Dutch National Flag\") schema:\n             *\n             *   left part    center part              right part\n             * +-------------------------------------------------+\n             * |  < pivot  |   == pivot   |     ?    |  > pivot  |\n             * +-------------------------------------------------+\n             *              ^              ^        ^\n             *              |              |        |\n             *             less            k      great\n             *\n             * Invariants:\n             *\n             *   all in (left, less)   < pivot\n             *   all in [less, k)     == pivot\n             *   all in (great, right) > pivot\n             *\n             * Pointer k is the first index of ?-part.\n             */\n                for (int k = less; k <= great; ++k) {\n                    if (a[k] == pivot) {\n                        continue;\n                    }\n                    long ak = a[k];\n                    if (ak < pivot) { // Move a[k] to left part\n                        a[k] = a[less];\n                        a[less] = ak;\n                        ++less;\n                    } else { // a[k] > pivot - Move a[k] to right part\n                        while (a[great] > pivot) {\n                            --great;\n                        }\n                        if (a[great] < pivot) { // a[great] <= pivot\n                            a[k] = a[less];\n                            a[less] = a[great];\n                            ++less;\n                        } else { // a[great] == pivot\n                        /*\n                         * Even though a[great] equals to pivot, the\n                         * assignment a[k] = pivot may be incorrect,\n                         * if a[great] and pivot are floating-point\n                         * zeros of different signs. Therefore in float\n                         * and double sorting methods we have to use\n                         * more accurate assignment a[k] = a[great].\n                         */\n                            a[k] = pivot;\n                        }\n                        a[great] = ak;\n                        --great;\n                    }\n                }\n\n            /*\n             * Sort left and right parts recursively.\n             * All elements from center part are equal\n             * and, therefore, already sorted.\n             */\n                sort(a, left, less - 1, leftmost);\n                sort(a, great + 1, right, false);\n            }\n        }\n\n        /**\n         * Sorts the specified range of the array using the given\n         * workspace array slice if possible for merging\n         *\n         * @param a        the array to be sorted\n         * @param left     the index of the first element, inclusive, to be sorted\n         * @param right    the index of the last element, inclusive, to be sorted\n         * @param work     a workspace array (slice)\n         * @param workBase origin of usable space in work array\n         * @param workLen  usable size of work array\n         */\n        static void sort(short[] a, int left, int right,\n                         short[] work, int workBase, int workLen) {\n            // Use counting sort on large arrays\n            if (right - left > COUNTING_SORT_THRESHOLD_FOR_SHORT_OR_CHAR) {\n                int[] count = new int[NUM_SHORT_VALUES];\n\n                for (int i = left - 1; ++i <= right;\n                     count[a[i] - Short.MIN_VALUE]++\n                        )\n                    ;\n                for (int i = NUM_SHORT_VALUES, k = right + 1; k > left; ) {\n                    while (count[--i] == 0) ;\n                    short value = (short) (i + Short.MIN_VALUE);\n                    int s = count[i];\n\n                    do {\n                        a[--k] = value;\n                    } while (--s > 0);\n                }\n            } else { // Use Dual-Pivot Quicksort on small arrays\n                doSort(a, left, right, work, workBase, workLen);\n            }\n        }\n\n        /**\n         * The number of distinct short values.\n         */\n        private static final int NUM_SHORT_VALUES = 1 << 16;\n\n        /**\n         * Sorts the specified range of the array.\n         *\n         * @param a        the array to be sorted\n         * @param left     the index of the first element, inclusive, to be sorted\n         * @param right    the index of the last element, inclusive, to be sorted\n         * @param work     a workspace array (slice)\n         * @param workBase origin of usable space in work array\n         * @param workLen  usable size of work array\n         */\n        private static void doSort(short[] a, int left, int right,\n                                   short[] work, int workBase, int workLen) {\n            // Use Quicksort on small arrays\n            if (right - left < QUICKSORT_THRESHOLD) {\n                sort(a, left, right, true);\n                return;\n            }\n\n        /*\n         * Index run[i] is the start of i-th run\n         * (ascending or descending sequence).\n         */\n            int[] run = new int[MAX_RUN_COUNT + 1];\n            int count = 0;\n            run[0] = left;\n\n            // Check if the array is nearly sorted\n            for (int k = left; k < right; run[count] = k) {\n                if (a[k] < a[k + 1]) { // ascending\n                    while (++k <= right && a[k - 1] <= a[k]) ;\n                } else if (a[k] > a[k + 1]) { // descending\n                    while (++k <= right && a[k - 1] >= a[k]) ;\n                    for (int lo = run[count] - 1, hi = k; ++lo < --hi; ) {\n                        short t = a[lo];\n                        a[lo] = a[hi];\n                        a[hi] = t;\n                    }\n                } else { // equal\n                    for (int m = MAX_RUN_LENGTH; ++k <= right && a[k - 1] == a[k]; ) {\n                        if (--m == 0) {\n                            sort(a, left, right, true);\n                            return;\n                        }\n                    }\n                }\n\n            /*\n             * The array is not highly structured,\n             * use Quicksort instead of merge sort.\n             */\n                if (++count == MAX_RUN_COUNT) {\n                    sort(a, left, right, true);\n                    return;\n                }\n            }\n\n            // Check special cases\n            // Implementation note: variable \"right\" is increased by 1.\n            if (run[count] == right++) { // The last run contains one element\n                run[++count] = right;\n            } else if (count == 1) { // The array is already sorted\n                return;\n            }\n\n            // Determine alternation base for merge\n            byte odd = 0;\n            for (int n = 1; (n <<= 1) < count; odd ^= 1) ;\n\n            // Use or create temporary array b for merging\n            short[] b;                 // temp array; alternates with a\n            int ao, bo;              // array offsets from 'left'\n            int blen = right - left; // space needed for b\n            if (work == null || workLen < blen || workBase + blen > work.length) {\n                work = new short[blen];\n                workBase = 0;\n            }\n            if (odd == 0) {\n                System.arraycopy(a, left, work, workBase, blen);\n                b = a;\n                bo = 0;\n                a = work;\n                ao = workBase - left;\n            } else {\n                b = work;\n                ao = 0;\n                bo = workBase - left;\n            }\n\n            // Merging\n            for (int last; count > 1; count = last) {\n                for (int k = (last = 0) + 2; k <= count; k += 2) {\n                    int hi = run[k], mi = run[k - 1];\n                    for (int i = run[k - 2], p = i, q = mi; i < hi; ++i) {\n                        if (q >= hi || p < mi && a[p + ao] <= a[q + ao]) {\n                            b[i + bo] = a[p++ + ao];\n                        } else {\n                            b[i + bo] = a[q++ + ao];\n                        }\n                    }\n                    run[++last] = hi;\n                }\n                if ((count & 1) != 0) {\n                    for (int i = right, lo = run[count - 1]; --i >= lo;\n                         b[i + bo] = a[i + ao]\n                            )\n                        ;\n                    run[++last] = right;\n                }\n                short[] t = a;\n                a = b;\n                b = t;\n                int o = ao;\n                ao = bo;\n                bo = o;\n            }\n        }\n\n        /**\n         * Sorts the specified range of the array by Dual-Pivot Quicksort.\n         *\n         * @param a        the array to be sorted\n         * @param left     the index of the first element, inclusive, to be sorted\n         * @param right    the index of the last element, inclusive, to be sorted\n         * @param leftmost indicates if this part is the leftmost in the range\n         */\n        private static void sort(short[] a, int left, int right, boolean leftmost) {\n            int length = right - left + 1;\n\n            // Use insertion sort on tiny arrays\n            if (length < INSERTION_SORT_THRESHOLD) {\n                if (leftmost) {\n                /*\n                 * Traditional (without sentinel) insertion sort,\n                 * optimized for server VM, is used in case of\n                 * the leftmost part.\n                 */\n                    for (int i = left, j = i; i < right; j = ++i) {\n                        short ai = a[i + 1];\n                        while (ai < a[j]) {\n                            a[j + 1] = a[j];\n                            if (j-- == left) {\n                                break;\n                            }\n                        }\n                        a[j + 1] = ai;\n                    }\n                } else {\n                /*\n                 * Skip the longest ascending sequence.\n                 */\n                    do {\n                        if (left >= right) {\n                            return;\n                        }\n                    } while (a[++left] >= a[left - 1]);\n\n                /*\n                 * Every element from adjoining part plays the role\n                 * of sentinel, therefore this allows us to avoid the\n                 * left range check on each iteration. Moreover, we use\n                 * the more optimized algorithm, so called pair insertion\n                 * sort, which is faster (in the context of Quicksort)\n                 * than traditional implementation of insertion sort.\n                 */\n                    for (int k = left; ++left <= right; k = ++left) {\n                        short a1 = a[k], a2 = a[left];\n\n                        if (a1 < a2) {\n                            a2 = a1;\n                            a1 = a[left];\n                        }\n                        while (a1 < a[--k]) {\n                            a[k + 2] = a[k];\n                        }\n                        a[++k + 1] = a1;\n\n                        while (a2 < a[--k]) {\n                            a[k + 1] = a[k];\n                        }\n                        a[k + 1] = a2;\n                    }\n                    short last = a[right];\n\n                    while (last < a[--right]) {\n                        a[right + 1] = a[right];\n                    }\n                    a[right + 1] = last;\n                }\n                return;\n            }\n\n            // Inexpensive approximation of length / 7\n            int seventh = (length >> 3) + (length >> 6) + 1;\n\n        /*\n         * Sort five evenly spaced elements around (and including) the\n         * center element in the range. These elements will be used for\n         * pivot selection as described below. The choice for spacing\n         * these elements was empirically determined to work well on\n         * a wide variety of inputs.\n         */\n            int e3 = (left + right) >>> 1; // The midpoint\n            int e2 = e3 - seventh;\n            int e1 = e2 - seventh;\n            int e4 = e3 + seventh;\n            int e5 = e4 + seventh;\n\n            // Sort these elements using insertion sort\n            if (a[e2] < a[e1]) {\n                short t = a[e2];\n                a[e2] = a[e1];\n                a[e1] = t;\n            }\n\n            if (a[e3] < a[e2]) {\n                short t = a[e3];\n                a[e3] = a[e2];\n                a[e2] = t;\n                if (t < a[e1]) {\n                    a[e2] = a[e1];\n                    a[e1] = t;\n                }\n            }\n            if (a[e4] < a[e3]) {\n                short t = a[e4];\n                a[e4] = a[e3];\n                a[e3] = t;\n                if (t < a[e2]) {\n                    a[e3] = a[e2];\n                    a[e2] = t;\n                    if (t < a[e1]) {\n                        a[e2] = a[e1];\n                        a[e1] = t;\n                    }\n                }\n            }\n            if (a[e5] < a[e4]) {\n                short t = a[e5];\n                a[e5] = a[e4];\n                a[e4] = t;\n                if (t < a[e3]) {\n                    a[e4] = a[e3];\n                    a[e3] = t;\n                    if (t < a[e2]) {\n                        a[e3] = a[e2];\n                        a[e2] = t;\n                        if (t < a[e1]) {\n                            a[e2] = a[e1];\n                            a[e1] = t;\n                        }\n                    }\n                }\n            }\n\n            // Pointers\n            int less = left;  // The index of the first element of center part\n            int great = right; // The index before the first element of right part\n\n            if (a[e1] != a[e2] && a[e2] != a[e3] && a[e3] != a[e4] && a[e4] != a[e5]) {\n            /*\n             * Use the second and fourth of the five sorted elements as pivots.\n             * These values are inexpensive approximations of the first and\n             * second terciles of the array. Note that pivot1 <= pivot2.\n             */\n                short pivot1 = a[e2];\n                short pivot2 = a[e4];\n\n            /*\n             * The first and the last elements to be sorted are moved to the\n             * locations formerly occupied by the pivots. When partitioning\n             * is complete, the pivots are swapped back into their final\n             * positions, and excluded from subsequent sorting.\n             */\n                a[e2] = a[left];\n                a[e4] = a[right];\n\n            /*\n             * Skip elements, which are less or greater than pivot values.\n             */\n                while (a[++less] < pivot1) ;\n                while (a[--great] > pivot2) ;\n\n            /*\n             * Partitioning:\n             *\n             *   left part           center part                   right part\n             * +--------------------------------------------------------------+\n             * |  < pivot1  |  pivot1 <= && <= pivot2  |    ?    |  > pivot2  |\n             * +--------------------------------------------------------------+\n             *               ^                          ^       ^\n             *               |                          |       |\n             *              less                        k     great\n             *\n             * Invariants:\n             *\n             *              all in (left, less)   < pivot1\n             *    pivot1 <= all in [less, k)     <= pivot2\n             *              all in (great, right) > pivot2\n             *\n             * Pointer k is the first index of ?-part.\n             */\n                outer:\n                for (int k = less - 1; ++k <= great; ) {\n                    short ak = a[k];\n                    if (ak < pivot1) { // Move a[k] to left part\n                        a[k] = a[less];\n                    /*\n                     * Here and below we use \"a[i] = b; i++;\" instead\n                     * of \"a[i++] = b;\" due to performance issue.\n                     */\n                        a[less] = ak;\n                        ++less;\n                    } else if (ak > pivot2) { // Move a[k] to right part\n                        while (a[great] > pivot2) {\n                            if (great-- == k) {\n                                break outer;\n                            }\n                        }\n                        if (a[great] < pivot1) { // a[great] <= pivot2\n                            a[k] = a[less];\n                            a[less] = a[great];\n                            ++less;\n                        } else { // pivot1 <= a[great] <= pivot2\n                            a[k] = a[great];\n                        }\n                    /*\n                     * Here and below we use \"a[i] = b; i--;\" instead\n                     * of \"a[i--] = b;\" due to performance issue.\n                     */\n                        a[great] = ak;\n                        --great;\n                    }\n                }\n\n                // Swap pivots into their final positions\n                a[left] = a[less - 1];\n                a[less - 1] = pivot1;\n                a[right] = a[great + 1];\n                a[great + 1] = pivot2;\n\n                // Sort left and right parts recursively, excluding known pivots\n                sort(a, left, less - 2, leftmost);\n                sort(a, great + 2, right, false);\n\n            /*\n             * If center part is too large (comprises > 4/7 of the array),\n             * swap internal pivot values to ends.\n             */\n                if (less < e1 && e5 < great) {\n                /*\n                 * Skip elements, which are equal to pivot values.\n                 */\n                    while (a[less] == pivot1) {\n                        ++less;\n                    }\n\n                    while (a[great] == pivot2) {\n                        --great;\n                    }\n\n                /*\n                 * Partitioning:\n                 *\n                 *   left part         center part                  right part\n                 * +----------------------------------------------------------+\n                 * | == pivot1 |  pivot1 < && < pivot2  |    ?    | == pivot2 |\n                 * +----------------------------------------------------------+\n                 *              ^                        ^       ^\n                 *              |                        |       |\n                 *             less                      k     great\n                 *\n                 * Invariants:\n                 *\n                 *              all in (*,  less) == pivot1\n                 *     pivot1 < all in [less,  k)  < pivot2\n                 *              all in (great, *) == pivot2\n                 *\n                 * Pointer k is the first index of ?-part.\n                 */\n                    outer:\n                    for (int k = less - 1; ++k <= great; ) {\n                        short ak = a[k];\n                        if (ak == pivot1) { // Move a[k] to left part\n                            a[k] = a[less];\n                            a[less] = ak;\n                            ++less;\n                        } else if (ak == pivot2) { // Move a[k] to right part\n                            while (a[great] == pivot2) {\n                                if (great-- == k) {\n                                    break outer;\n                                }\n                            }\n                            if (a[great] == pivot1) { // a[great] < pivot2\n                                a[k] = a[less];\n                            /*\n                             * Even though a[great] equals to pivot1, the\n                             * assignment a[less] = pivot1 may be incorrect,\n                             * if a[great] and pivot1 are floating-point zeros\n                             * of different signs. Therefore in float and\n                             * double sorting methods we have to use more\n                             * accurate assignment a[less] = a[great].\n                             */\n                                a[less] = pivot1;\n                                ++less;\n                            } else { // pivot1 < a[great] < pivot2\n                                a[k] = a[great];\n                            }\n                            a[great] = ak;\n                            --great;\n                        }\n                    }\n                }\n\n                // Sort center part recursively\n                sort(a, less, great, false);\n\n            } else { // Partitioning with one pivot\n            /*\n             * Use the third of the five sorted elements as pivot.\n             * This value is inexpensive approximation of the median.\n             */\n                short pivot = a[e3];\n\n            /*\n             * Partitioning degenerates to the traditional 3-way\n             * (or \"Dutch National Flag\") schema:\n             *\n             *   left part    center part              right part\n             * +-------------------------------------------------+\n             * |  < pivot  |   == pivot   |     ?    |  > pivot  |\n             * +-------------------------------------------------+\n             *              ^              ^        ^\n             *              |              |        |\n             *             less            k      great\n             *\n             * Invariants:\n             *\n             *   all in (left, less)   < pivot\n             *   all in [less, k)     == pivot\n             *   all in (great, right) > pivot\n             *\n             * Pointer k is the first index of ?-part.\n             */\n                for (int k = less; k <= great; ++k) {\n                    if (a[k] == pivot) {\n                        continue;\n                    }\n                    short ak = a[k];\n                    if (ak < pivot) { // Move a[k] to left part\n                        a[k] = a[less];\n                        a[less] = ak;\n                        ++less;\n                    } else { // a[k] > pivot - Move a[k] to right part\n                        while (a[great] > pivot) {\n                            --great;\n                        }\n                        if (a[great] < pivot) { // a[great] <= pivot\n                            a[k] = a[less];\n                            a[less] = a[great];\n                            ++less;\n                        } else { // a[great] == pivot\n                        /*\n                         * Even though a[great] equals to pivot, the\n                         * assignment a[k] = pivot may be incorrect,\n                         * if a[great] and pivot are floating-point\n                         * zeros of different signs. Therefore in float\n                         * and double sorting methods we have to use\n                         * more accurate assignment a[k] = a[great].\n                         */\n                            a[k] = pivot;\n                        }\n                        a[great] = ak;\n                        --great;\n                    }\n                }\n\n            /*\n             * Sort left and right parts recursively.\n             * All elements from center part are equal\n             * and, therefore, already sorted.\n             */\n                sort(a, left, less - 1, leftmost);\n                sort(a, great + 1, right, false);\n            }\n        }\n\n        /**\n         * Sorts the specified range of the array using the given\n         * workspace array slice if possible for merging\n         *\n         * @param a        the array to be sorted\n         * @param left     the index of the first element, inclusive, to be sorted\n         * @param right    the index of the last element, inclusive, to be sorted\n         * @param work     a workspace array (slice)\n         * @param workBase origin of usable space in work array\n         * @param workLen  usable size of work array\n         */\n        static void sort(char[] a, int left, int right,\n                         char[] work, int workBase, int workLen) {\n            // Use counting sort on large arrays\n            if (right - left > COUNTING_SORT_THRESHOLD_FOR_SHORT_OR_CHAR) {\n                int[] count = new int[NUM_CHAR_VALUES];\n\n                for (int i = left - 1; ++i <= right;\n                     count[a[i]]++\n                        )\n                    ;\n                for (int i = NUM_CHAR_VALUES, k = right + 1; k > left; ) {\n                    while (count[--i] == 0) ;\n                    char value = (char) i;\n                    int s = count[i];\n\n                    do {\n                        a[--k] = value;\n                    } while (--s > 0);\n                }\n            } else { // Use Dual-Pivot Quicksort on small arrays\n                doSort(a, left, right, work, workBase, workLen);\n            }\n        }\n\n        /**\n         * The number of distinct char values.\n         */\n        private static final int NUM_CHAR_VALUES = 1 << 16;\n\n        /**\n         * Sorts the specified range of the array.\n         *\n         * @param a        the array to be sorted\n         * @param left     the index of the first element, inclusive, to be sorted\n         * @param right    the index of the last element, inclusive, to be sorted\n         * @param work     a workspace array (slice)\n         * @param workBase origin of usable space in work array\n         * @param workLen  usable size of work array\n         */\n        private static void doSort(char[] a, int left, int right,\n                                   char[] work, int workBase, int workLen) {\n            // Use Quicksort on small arrays\n            if (right - left < QUICKSORT_THRESHOLD) {\n                sort(a, left, right, true);\n                return;\n            }\n\n        /*\n         * Index run[i] is the start of i-th run\n         * (ascending or descending sequence).\n         */\n            int[] run = new int[MAX_RUN_COUNT + 1];\n            int count = 0;\n            run[0] = left;\n\n            // Check if the array is nearly sorted\n            for (int k = left; k < right; run[count] = k) {\n                if (a[k] < a[k + 1]) { // ascending\n                    while (++k <= right && a[k - 1] <= a[k]) ;\n                } else if (a[k] > a[k + 1]) { // descending\n                    while (++k <= right && a[k - 1] >= a[k]) ;\n                    for (int lo = run[count] - 1, hi = k; ++lo < --hi; ) {\n                        char t = a[lo];\n                        a[lo] = a[hi];\n                        a[hi] = t;\n                    }\n                } else { // equal\n                    for (int m = MAX_RUN_LENGTH; ++k <= right && a[k - 1] == a[k]; ) {\n                        if (--m == 0) {\n                            sort(a, left, right, true);\n                            return;\n                        }\n                    }\n                }\n\n            /*\n             * The array is not highly structured,\n             * use Quicksort instead of merge sort.\n             */\n                if (++count == MAX_RUN_COUNT) {\n                    sort(a, left, right, true);\n                    return;\n                }\n            }\n\n            // Check special cases\n            // Implementation note: variable \"right\" is increased by 1.\n            if (run[count] == right++) { // The last run contains one element\n                run[++count] = right;\n            } else if (count == 1) { // The array is already sorted\n                return;\n            }\n\n            // Determine alternation base for merge\n            byte odd = 0;\n            for (int n = 1; (n <<= 1) < count; odd ^= 1) ;\n\n            // Use or create temporary array b for merging\n            char[] b;                 // temp array; alternates with a\n            int ao, bo;              // array offsets from 'left'\n            int blen = right - left; // space needed for b\n            if (work == null || workLen < blen || workBase + blen > work.length) {\n                work = new char[blen];\n                workBase = 0;\n            }\n            if (odd == 0) {\n                System.arraycopy(a, left, work, workBase, blen);\n                b = a;\n                bo = 0;\n                a = work;\n                ao = workBase - left;\n            } else {\n                b = work;\n                ao = 0;\n                bo = workBase - left;\n            }\n\n            // Merging\n            for (int last; count > 1; count = last) {\n                for (int k = (last = 0) + 2; k <= count; k += 2) {\n                    int hi = run[k], mi = run[k - 1];\n                    for (int i = run[k - 2], p = i, q = mi; i < hi; ++i) {\n                        if (q >= hi || p < mi && a[p + ao] <= a[q + ao]) {\n                            b[i + bo] = a[p++ + ao];\n                        } else {\n                            b[i + bo] = a[q++ + ao];\n                        }\n                    }\n                    run[++last] = hi;\n                }\n                if ((count & 1) != 0) {\n                    for (int i = right, lo = run[count - 1]; --i >= lo;\n                         b[i + bo] = a[i + ao]\n                            )\n                        ;\n                    run[++last] = right;\n                }\n                char[] t = a;\n                a = b;\n                b = t;\n                int o = ao;\n                ao = bo;\n                bo = o;\n            }\n        }\n\n        /**\n         * Sorts the specified range of the array by Dual-Pivot Quicksort.\n         *\n         * @param a        the array to be sorted\n         * @param left     the index of the first element, inclusive, to be sorted\n         * @param right    the index of the last element, inclusive, to be sorted\n         * @param leftmost indicates if this part is the leftmost in the range\n         */\n        private static void sort(char[] a, int left, int right, boolean leftmost) {\n            int length = right - left + 1;\n\n            // Use insertion sort on tiny arrays\n            if (length < INSERTION_SORT_THRESHOLD) {\n                if (leftmost) {\n                /*\n                 * Traditional (without sentinel) insertion sort,\n                 * optimized for server VM, is used in case of\n                 * the leftmost part.\n                 */\n                    for (int i = left, j = i; i < right; j = ++i) {\n                        char ai = a[i + 1];\n                        while (ai < a[j]) {\n                            a[j + 1] = a[j];\n                            if (j-- == left) {\n                                break;\n                            }\n                        }\n                        a[j + 1] = ai;\n                    }\n                } else {\n                /*\n                 * Skip the longest ascending sequence.\n                 */\n                    do {\n                        if (left >= right) {\n                            return;\n                        }\n                    } while (a[++left] >= a[left - 1]);\n\n                /*\n                 * Every element from adjoining part plays the role\n                 * of sentinel, therefore this allows us to avoid the\n                 * left range check on each iteration. Moreover, we use\n                 * the more optimized algorithm, so called pair insertion\n                 * sort, which is faster (in the context of Quicksort)\n                 * than traditional implementation of insertion sort.\n                 */\n                    for (int k = left; ++left <= right; k = ++left) {\n                        char a1 = a[k], a2 = a[left];\n\n                        if (a1 < a2) {\n                            a2 = a1;\n                            a1 = a[left];\n                        }\n                        while (a1 < a[--k]) {\n                            a[k + 2] = a[k];\n                        }\n                        a[++k + 1] = a1;\n\n                        while (a2 < a[--k]) {\n                            a[k + 1] = a[k];\n                        }\n                        a[k + 1] = a2;\n                    }\n                    char last = a[right];\n\n                    while (last < a[--right]) {\n                        a[right + 1] = a[right];\n                    }\n                    a[right + 1] = last;\n                }\n                return;\n            }\n\n            // Inexpensive approximation of length / 7\n            int seventh = (length >> 3) + (length >> 6) + 1;\n\n        /*\n         * Sort five evenly spaced elements around (and including) the\n         * center element in the range. These elements will be used for\n         * pivot selection as described below. The choice for spacing\n         * these elements was empirically determined to work well on\n         * a wide variety of inputs.\n         */\n            int e3 = (left + right) >>> 1; // The midpoint\n            int e2 = e3 - seventh;\n            int e1 = e2 - seventh;\n            int e4 = e3 + seventh;\n            int e5 = e4 + seventh;\n\n            // Sort these elements using insertion sort\n            if (a[e2] < a[e1]) {\n                char t = a[e2];\n                a[e2] = a[e1];\n                a[e1] = t;\n            }\n\n            if (a[e3] < a[e2]) {\n                char t = a[e3];\n                a[e3] = a[e2];\n                a[e2] = t;\n                if (t < a[e1]) {\n                    a[e2] = a[e1];\n                    a[e1] = t;\n                }\n            }\n            if (a[e4] < a[e3]) {\n                char t = a[e4];\n                a[e4] = a[e3];\n                a[e3] = t;\n                if (t < a[e2]) {\n                    a[e3] = a[e2];\n                    a[e2] = t;\n                    if (t < a[e1]) {\n                        a[e2] = a[e1];\n                        a[e1] = t;\n                    }\n                }\n            }\n            if (a[e5] < a[e4]) {\n                char t = a[e5];\n                a[e5] = a[e4];\n                a[e4] = t;\n                if (t < a[e3]) {\n                    a[e4] = a[e3];\n                    a[e3] = t;\n                    if (t < a[e2]) {\n                        a[e3] = a[e2];\n                        a[e2] = t;\n                        if (t < a[e1]) {\n                            a[e2] = a[e1];\n                            a[e1] = t;\n                        }\n                    }\n                }\n            }\n\n            // Pointers\n            int less = left;  // The index of the first element of center part\n            int great = right; // The index before the first element of right part\n\n            if (a[e1] != a[e2] && a[e2] != a[e3] && a[e3] != a[e4] && a[e4] != a[e5]) {\n            /*\n             * Use the second and fourth of the five sorted elements as pivots.\n             * These values are inexpensive approximations of the first and\n             * second terciles of the array. Note that pivot1 <= pivot2.\n             */\n                char pivot1 = a[e2];\n                char pivot2 = a[e4];\n\n            /*\n             * The first and the last elements to be sorted are moved to the\n             * locations formerly occupied by the pivots. When partitioning\n             * is complete, the pivots are swapped back into their final\n             * positions, and excluded from subsequent sorting.\n             */\n                a[e2] = a[left];\n                a[e4] = a[right];\n\n            /*\n             * Skip elements, which are less or greater than pivot values.\n             */\n                while (a[++less] < pivot1) ;\n                while (a[--great] > pivot2) ;\n\n            /*\n             * Partitioning:\n             *\n             *   left part           center part                   right part\n             * +--------------------------------------------------------------+\n             * |  < pivot1  |  pivot1 <= && <= pivot2  |    ?    |  > pivot2  |\n             * +--------------------------------------------------------------+\n             *               ^                          ^       ^\n             *               |                          |       |\n             *              less                        k     great\n             *\n             * Invariants:\n             *\n             *              all in (left, less)   < pivot1\n             *    pivot1 <= all in [less, k)     <= pivot2\n             *              all in (great, right) > pivot2\n             *\n             * Pointer k is the first index of ?-part.\n             */\n                outer:\n                for (int k = less - 1; ++k <= great; ) {\n                    char ak = a[k];\n                    if (ak < pivot1) { // Move a[k] to left part\n                        a[k] = a[less];\n                    /*\n                     * Here and below we use \"a[i] = b; i++;\" instead\n                     * of \"a[i++] = b;\" due to performance issue.\n                     */\n                        a[less] = ak;\n                        ++less;\n                    } else if (ak > pivot2) { // Move a[k] to right part\n                        while (a[great] > pivot2) {\n                            if (great-- == k) {\n                                break outer;\n                            }\n                        }\n                        if (a[great] < pivot1) { // a[great] <= pivot2\n                            a[k] = a[less];\n                            a[less] = a[great];\n                            ++less;\n                        } else { // pivot1 <= a[great] <= pivot2\n                            a[k] = a[great];\n                        }\n                    /*\n                     * Here and below we use \"a[i] = b; i--;\" instead\n                     * of \"a[i--] = b;\" due to performance issue.\n                     */\n                        a[great] = ak;\n                        --great;\n                    }\n                }\n\n                // Swap pivots into their final positions\n                a[left] = a[less - 1];\n                a[less - 1] = pivot1;\n                a[right] = a[great + 1];\n                a[great + 1] = pivot2;\n\n                // Sort left and right parts recursively, excluding known pivots\n                sort(a, left, less - 2, leftmost);\n                sort(a, great + 2, right, false);\n\n            /*\n             * If center part is too large (comprises > 4/7 of the array),\n             * swap internal pivot values to ends.\n             */\n                if (less < e1 && e5 < great) {\n                /*\n                 * Skip elements, which are equal to pivot values.\n                 */\n                    while (a[less] == pivot1) {\n                        ++less;\n                    }\n\n                    while (a[great] == pivot2) {\n                        --great;\n                    }\n\n                /*\n                 * Partitioning:\n                 *\n                 *   left part         center part                  right part\n                 * +----------------------------------------------------------+\n                 * | == pivot1 |  pivot1 < && < pivot2  |    ?    | == pivot2 |\n                 * +----------------------------------------------------------+\n                 *              ^                        ^       ^\n                 *              |                        |       |\n                 *             less                      k     great\n                 *\n                 * Invariants:\n                 *\n                 *              all in (*,  less) == pivot1\n                 *     pivot1 < all in [less,  k)  < pivot2\n                 *              all in (great, *) == pivot2\n                 *\n                 * Pointer k is the first index of ?-part.\n                 */\n                    outer:\n                    for (int k = less - 1; ++k <= great; ) {\n                        char ak = a[k];\n                        if (ak == pivot1) { // Move a[k] to left part\n                            a[k] = a[less];\n                            a[less] = ak;\n                            ++less;\n                        } else if (ak == pivot2) { // Move a[k] to right part\n                            while (a[great] == pivot2) {\n                                if (great-- == k) {\n                                    break outer;\n                                }\n                            }\n                            if (a[great] == pivot1) { // a[great] < pivot2\n                                a[k] = a[less];\n                            /*\n                             * Even though a[great] equals to pivot1, the\n                             * assignment a[less] = pivot1 may be incorrect,\n                             * if a[great] and pivot1 are floating-point zeros\n                             * of different signs. Therefore in float and\n                             * double sorting methods we have to use more\n                             * accurate assignment a[less] = a[great].\n                             */\n                                a[less] = pivot1;\n                                ++less;\n                            } else { // pivot1 < a[great] < pivot2\n                                a[k] = a[great];\n                            }\n                            a[great] = ak;\n                            --great;\n                        }\n                    }\n                }\n\n                // Sort center part recursively\n                sort(a, less, great, false);\n\n            } else { // Partitioning with one pivot\n            /*\n             * Use the third of the five sorted elements as pivot.\n             * This value is inexpensive approximation of the median.\n             */\n                char pivot = a[e3];\n\n            /*\n             * Partitioning degenerates to the traditional 3-way\n             * (or \"Dutch National Flag\") schema:\n             *\n             *   left part    center part              right part\n             * +-------------------------------------------------+\n             * |  < pivot  |   == pivot   |     ?    |  > pivot  |\n             * +-------------------------------------------------+\n             *              ^              ^        ^\n             *              |              |        |\n             *             less            k      great\n             *\n             * Invariants:\n             *\n             *   all in (left, less)   < pivot\n             *   all in [less, k)     == pivot\n             *   all in (great, right) > pivot\n             *\n             * Pointer k is the first index of ?-part.\n             */\n                for (int k = less; k <= great; ++k) {\n                    if (a[k] == pivot) {\n                        continue;\n                    }\n                    char ak = a[k];\n                    if (ak < pivot) { // Move a[k] to left part\n                        a[k] = a[less];\n                        a[less] = ak;\n                        ++less;\n                    } else { // a[k] > pivot - Move a[k] to right part\n                        while (a[great] > pivot) {\n                            --great;\n                        }\n                        if (a[great] < pivot) { // a[great] <= pivot\n                            a[k] = a[less];\n                            a[less] = a[great];\n                            ++less;\n                        } else { // a[great] == pivot\n                        /*\n                         * Even though a[great] equals to pivot, the\n                         * assignment a[k] = pivot may be incorrect,\n                         * if a[great] and pivot are floating-point\n                         * zeros of different signs. Therefore in float\n                         * and double sorting methods we have to use\n                         * more accurate assignment a[k] = a[great].\n                         */\n                            a[k] = pivot;\n                        }\n                        a[great] = ak;\n                        --great;\n                    }\n                }\n\n            /*\n             * Sort left and right parts recursively.\n             * All elements from center part are equal\n             * and, therefore, already sorted.\n             */\n                sort(a, left, less - 1, leftmost);\n                sort(a, great + 1, right, false);\n            }\n        }\n\n        /**\n         * The number of distinct byte values.\n         */\n        private static final int NUM_BYTE_VALUES = 1 << 8;\n\n        /**\n         * Sorts the specified range of the array.\n         *\n         * @param a     the array to be sorted\n         * @param left  the index of the first element, inclusive, to be sorted\n         * @param right the index of the last element, inclusive, to be sorted\n         */\n        static void sort(byte[] a, int left, int right) {\n            // Use counting sort on large arrays\n            if (right - left > COUNTING_SORT_THRESHOLD_FOR_BYTE) {\n                int[] count = new int[NUM_BYTE_VALUES];\n\n                for (int i = left - 1; ++i <= right;\n                     count[a[i] - Byte.MIN_VALUE]++\n                        )\n                    ;\n                for (int i = NUM_BYTE_VALUES, k = right + 1; k > left; ) {\n                    while (count[--i] == 0) ;\n                    byte value = (byte) (i + Byte.MIN_VALUE);\n                    int s = count[i];\n\n                    do {\n                        a[--k] = value;\n                    } while (--s > 0);\n                }\n            } else { // Use insertion sort on small arrays\n                for (int i = left, j = i; i < right; j = ++i) {\n                    byte ai = a[i + 1];\n                    while (ai < a[j]) {\n                        a[j + 1] = a[j];\n                        if (j-- == left) {\n                            break;\n                        }\n                    }\n                    a[j + 1] = ai;\n                }\n            }\n        }\n\n        /**\n         * Sorts the specified range of the array using the given\n         * workspace array slice if possible for merging\n         *\n         * @param a        the array to be sorted\n         * @param left     the index of the first element, inclusive, to be sorted\n         * @param right    the index of the last element, inclusive, to be sorted\n         * @param work     a workspace array (slice)\n         * @param workBase origin of usable space in work array\n         * @param workLen  usable size of work array\n         */\n        static void sort(float[] a, int left, int right,\n                         float[] work, int workBase, int workLen) {\n        /*\n         * Phase 1: Move NaNs to the end of the array.\n         */\n            while (left <= right && Float.isNaN(a[right])) {\n                --right;\n            }\n            for (int k = right; --k >= left; ) {\n                float ak = a[k];\n                if (ak != ak) { // a[k] is NaN\n                    a[k] = a[right];\n                    a[right] = ak;\n                    --right;\n                }\n            }\n\n        /*\n         * Phase 2: Sort everything except NaNs (which are already in place).\n         */\n            doSort(a, left, right, work, workBase, workLen);\n\n        /*\n         * Phase 3: Place negative zeros before positive zeros.\n         */\n            int hi = right;\n\n        /*\n         * Find the first zero, or first positive, or last negative element.\n         */\n            while (left < hi) {\n                int middle = (left + hi) >>> 1;\n                float middleValue = a[middle];\n\n                if (middleValue < 0.0f) {\n                    left = middle + 1;\n                } else {\n                    hi = middle;\n                }\n            }\n\n        /*\n         * Skip the last negative value (if any) or all leading negative zeros.\n         */\n            while (left <= right && Float.floatToRawIntBits(a[left]) < 0) {\n                ++left;\n            }\n\n        /*\n         * Move negative zeros to the beginning of the sub-range.\n         *\n         * Partitioning:\n         *\n         * +----------------------------------------------------+\n         * |   < 0.0   |   -0.0   |   0.0   |   ?  ( >= 0.0 )   |\n         * +----------------------------------------------------+\n         *              ^          ^         ^\n         *              |          |         |\n         *             left        p         k\n         *\n         * Invariants:\n         *\n         *   all in (*,  left)  <  0.0\n         *   all in [left,  p) == -0.0\n         *   all in [p,     k) ==  0.0\n         *   all in [k, right] >=  0.0\n         *\n         * Pointer k is the first index of ?-part.\n         */\n            for (int k = left, p = left - 1; ++k <= right; ) {\n                float ak = a[k];\n                if (ak != 0.0f) {\n                    break;\n                }\n                if (Float.floatToRawIntBits(ak) < 0) { // ak is -0.0f\n                    a[k] = 0.0f;\n                    a[++p] = -0.0f;\n                }\n            }\n        }\n\n        /**\n         * Sorts the specified range of the array.\n         *\n         * @param a        the array to be sorted\n         * @param left     the index of the first element, inclusive, to be sorted\n         * @param right    the index of the last element, inclusive, to be sorted\n         * @param work     a workspace array (slice)\n         * @param workBase origin of usable space in work array\n         * @param workLen  usable size of work array\n         */\n        private static void doSort(float[] a, int left, int right,\n                                   float[] work, int workBase, int workLen) {\n            // Use Quicksort on small arrays\n            if (right - left < QUICKSORT_THRESHOLD) {\n                sort(a, left, right, true);\n                return;\n            }\n\n        /*\n         * Index run[i] is the start of i-th run\n         * (ascending or descending sequence).\n         */\n            int[] run = new int[MAX_RUN_COUNT + 1];\n            int count = 0;\n            run[0] = left;\n\n            // Check if the array is nearly sorted\n            for (int k = left; k < right; run[count] = k) {\n                if (a[k] < a[k + 1]) { // ascending\n                    while (++k <= right && a[k - 1] <= a[k]) ;\n                } else if (a[k] > a[k + 1]) { // descending\n                    while (++k <= right && a[k - 1] >= a[k]) ;\n                    for (int lo = run[count] - 1, hi = k; ++lo < --hi; ) {\n                        float t = a[lo];\n                        a[lo] = a[hi];\n                        a[hi] = t;\n                    }\n                } else { // equal\n                    for (int m = MAX_RUN_LENGTH; ++k <= right && a[k - 1] == a[k]; ) {\n                        if (--m == 0) {\n                            sort(a, left, right, true);\n                            return;\n                        }\n                    }\n                }\n\n            /*\n             * The array is not highly structured,\n             * use Quicksort instead of merge sort.\n             */\n                if (++count == MAX_RUN_COUNT) {\n                    sort(a, left, right, true);\n                    return;\n                }\n            }\n\n            // Check special cases\n            // Implementation note: variable \"right\" is increased by 1.\n            if (run[count] == right++) { // The last run contains one element\n                run[++count] = right;\n            } else if (count == 1) { // The array is already sorted\n                return;\n            }\n\n            // Determine alternation base for merge\n            byte odd = 0;\n            for (int n = 1; (n <<= 1) < count; odd ^= 1) ;\n\n            // Use or create temporary array b for merging\n            float[] b;                 // temp array; alternates with a\n            int ao, bo;              // array offsets from 'left'\n            int blen = right - left; // space needed for b\n            if (work == null || workLen < blen || workBase + blen > work.length) {\n                work = new float[blen];\n                workBase = 0;\n            }\n            if (odd == 0) {\n                System.arraycopy(a, left, work, workBase, blen);\n                b = a;\n                bo = 0;\n                a = work;\n                ao = workBase - left;\n            } else {\n                b = work;\n                ao = 0;\n                bo = workBase - left;\n            }\n\n            // Merging\n            for (int last; count > 1; count = last) {\n                for (int k = (last = 0) + 2; k <= count; k += 2) {\n                    int hi = run[k], mi = run[k - 1];\n                    for (int i = run[k - 2], p = i, q = mi; i < hi; ++i) {\n                        if (q >= hi || p < mi && a[p + ao] <= a[q + ao]) {\n                            b[i + bo] = a[p++ + ao];\n                        } else {\n                            b[i + bo] = a[q++ + ao];\n                        }\n                    }\n                    run[++last] = hi;\n                }\n                if ((count & 1) != 0) {\n                    for (int i = right, lo = run[count - 1]; --i >= lo;\n                         b[i + bo] = a[i + ao]\n                            )\n                        ;\n                    run[++last] = right;\n                }\n                float[] t = a;\n                a = b;\n                b = t;\n                int o = ao;\n                ao = bo;\n                bo = o;\n            }\n        }\n\n        /**\n         * Sorts the specified range of the array by Dual-Pivot Quicksort.\n         *\n         * @param a        the array to be sorted\n         * @param left     the index of the first element, inclusive, to be sorted\n         * @param right    the index of the last element, inclusive, to be sorted\n         * @param leftmost indicates if this part is the leftmost in the range\n         */\n        private static void sort(float[] a, int left, int right, boolean leftmost) {\n            int length = right - left + 1;\n\n            // Use insertion sort on tiny arrays\n            if (length < INSERTION_SORT_THRESHOLD) {\n                if (leftmost) {\n                /*\n                 * Traditional (without sentinel) insertion sort,\n                 * optimized for server VM, is used in case of\n                 * the leftmost part.\n                 */\n                    for (int i = left, j = i; i < right; j = ++i) {\n                        float ai = a[i + 1];\n                        while (ai < a[j]) {\n                            a[j + 1] = a[j];\n                            if (j-- == left) {\n                                break;\n                            }\n                        }\n                        a[j + 1] = ai;\n                    }\n                } else {\n                /*\n                 * Skip the longest ascending sequence.\n                 */\n                    do {\n                        if (left >= right) {\n                            return;\n                        }\n                    } while (a[++left] >= a[left - 1]);\n\n                /*\n                 * Every element from adjoining part plays the role\n                 * of sentinel, therefore this allows us to avoid the\n                 * left range check on each iteration. Moreover, we use\n                 * the more optimized algorithm, so called pair insertion\n                 * sort, which is faster (in the context of Quicksort)\n                 * than traditional implementation of insertion sort.\n                 */\n                    for (int k = left; ++left <= right; k = ++left) {\n                        float a1 = a[k], a2 = a[left];\n\n                        if (a1 < a2) {\n                            a2 = a1;\n                            a1 = a[left];\n                        }\n                        while (a1 < a[--k]) {\n                            a[k + 2] = a[k];\n                        }\n                        a[++k + 1] = a1;\n\n                        while (a2 < a[--k]) {\n                            a[k + 1] = a[k];\n                        }\n                        a[k + 1] = a2;\n                    }\n                    float last = a[right];\n\n                    while (last < a[--right]) {\n                        a[right + 1] = a[right];\n                    }\n                    a[right + 1] = last;\n                }\n                return;\n            }\n\n            // Inexpensive approximation of length / 7\n            int seventh = (length >> 3) + (length >> 6) + 1;\n\n        /*\n         * Sort five evenly spaced elements around (and including) the\n         * center element in the range. These elements will be used for\n         * pivot selection as described below. The choice for spacing\n         * these elements was empirically determined to work well on\n         * a wide variety of inputs.\n         */\n            int e3 = (left + right) >>> 1; // The midpoint\n            int e2 = e3 - seventh;\n            int e1 = e2 - seventh;\n            int e4 = e3 + seventh;\n            int e5 = e4 + seventh;\n\n            // Sort these elements using insertion sort\n            if (a[e2] < a[e1]) {\n                float t = a[e2];\n                a[e2] = a[e1];\n                a[e1] = t;\n            }\n\n            if (a[e3] < a[e2]) {\n                float t = a[e3];\n                a[e3] = a[e2];\n                a[e2] = t;\n                if (t < a[e1]) {\n                    a[e2] = a[e1];\n                    a[e1] = t;\n                }\n            }\n            if (a[e4] < a[e3]) {\n                float t = a[e4];\n                a[e4] = a[e3];\n                a[e3] = t;\n                if (t < a[e2]) {\n                    a[e3] = a[e2];\n                    a[e2] = t;\n                    if (t < a[e1]) {\n                        a[e2] = a[e1];\n                        a[e1] = t;\n                    }\n                }\n            }\n            if (a[e5] < a[e4]) {\n                float t = a[e5];\n                a[e5] = a[e4];\n                a[e4] = t;\n                if (t < a[e3]) {\n                    a[e4] = a[e3];\n                    a[e3] = t;\n                    if (t < a[e2]) {\n                        a[e3] = a[e2];\n                        a[e2] = t;\n                        if (t < a[e1]) {\n                            a[e2] = a[e1];\n                            a[e1] = t;\n                        }\n                    }\n                }\n            }\n\n            // Pointers\n            int less = left;  // The index of the first element of center part\n            int great = right; // The index before the first element of right part\n\n            if (a[e1] != a[e2] && a[e2] != a[e3] && a[e3] != a[e4] && a[e4] != a[e5]) {\n            /*\n             * Use the second and fourth of the five sorted elements as pivots.\n             * These values are inexpensive approximations of the first and\n             * second terciles of the array. Note that pivot1 <= pivot2.\n             */\n                float pivot1 = a[e2];\n                float pivot2 = a[e4];\n\n            /*\n             * The first and the last elements to be sorted are moved to the\n             * locations formerly occupied by the pivots. When partitioning\n             * is complete, the pivots are swapped back into their final\n             * positions, and excluded from subsequent sorting.\n             */\n                a[e2] = a[left];\n                a[e4] = a[right];\n\n            /*\n             * Skip elements, which are less or greater than pivot values.\n             */\n                while (a[++less] < pivot1) ;\n                while (a[--great] > pivot2) ;\n\n            /*\n             * Partitioning:\n             *\n             *   left part           center part                   right part\n             * +--------------------------------------------------------------+\n             * |  < pivot1  |  pivot1 <= && <= pivot2  |    ?    |  > pivot2  |\n             * +--------------------------------------------------------------+\n             *               ^                          ^       ^\n             *               |                          |       |\n             *              less                        k     great\n             *\n             * Invariants:\n             *\n             *              all in (left, less)   < pivot1\n             *    pivot1 <= all in [less, k)     <= pivot2\n             *              all in (great, right) > pivot2\n             *\n             * Pointer k is the first index of ?-part.\n             */\n                outer:\n                for (int k = less - 1; ++k <= great; ) {\n                    float ak = a[k];\n                    if (ak < pivot1) { // Move a[k] to left part\n                        a[k] = a[less];\n                    /*\n                     * Here and below we use \"a[i] = b; i++;\" instead\n                     * of \"a[i++] = b;\" due to performance issue.\n                     */\n                        a[less] = ak;\n                        ++less;\n                    } else if (ak > pivot2) { // Move a[k] to right part\n                        while (a[great] > pivot2) {\n                            if (great-- == k) {\n                                break outer;\n                            }\n                        }\n                        if (a[great] < pivot1) { // a[great] <= pivot2\n                            a[k] = a[less];\n                            a[less] = a[great];\n                            ++less;\n                        } else { // pivot1 <= a[great] <= pivot2\n                            a[k] = a[great];\n                        }\n                    /*\n                     * Here and below we use \"a[i] = b; i--;\" instead\n                     * of \"a[i--] = b;\" due to performance issue.\n                     */\n                        a[great] = ak;\n                        --great;\n                    }\n                }\n\n                // Swap pivots into their final positions\n                a[left] = a[less - 1];\n                a[less - 1] = pivot1;\n                a[right] = a[great + 1];\n                a[great + 1] = pivot2;\n\n                // Sort left and right parts recursively, excluding known pivots\n                sort(a, left, less - 2, leftmost);\n                sort(a, great + 2, right, false);\n\n            /*\n             * If center part is too large (comprises > 4/7 of the array),\n             * swap internal pivot values to ends.\n             */\n                if (less < e1 && e5 < great) {\n                /*\n                 * Skip elements, which are equal to pivot values.\n                 */\n                    while (a[less] == pivot1) {\n                        ++less;\n                    }\n\n                    while (a[great] == pivot2) {\n                        --great;\n                    }\n\n                /*\n                 * Partitioning:\n                 *\n                 *   left part         center part                  right part\n                 * +----------------------------------------------------------+\n                 * | == pivot1 |  pivot1 < && < pivot2  |    ?    | == pivot2 |\n                 * +----------------------------------------------------------+\n                 *              ^                        ^       ^\n                 *              |                        |       |\n                 *             less                      k     great\n                 *\n                 * Invariants:\n                 *\n                 *              all in (*,  less) == pivot1\n                 *     pivot1 < all in [less,  k)  < pivot2\n                 *              all in (great, *) == pivot2\n                 *\n                 * Pointer k is the first index of ?-part.\n                 */\n                    outer:\n                    for (int k = less - 1; ++k <= great; ) {\n                        float ak = a[k];\n                        if (ak == pivot1) { // Move a[k] to left part\n                            a[k] = a[less];\n                            a[less] = ak;\n                            ++less;\n                        } else if (ak == pivot2) { // Move a[k] to right part\n                            while (a[great] == pivot2) {\n                                if (great-- == k) {\n                                    break outer;\n                                }\n                            }\n                            if (a[great] == pivot1) { // a[great] < pivot2\n                                a[k] = a[less];\n                            /*\n                             * Even though a[great] equals to pivot1, the\n                             * assignment a[less] = pivot1 may be incorrect,\n                             * if a[great] and pivot1 are floating-point zeros\n                             * of different signs. Therefore in float and\n                             * double sorting methods we have to use more\n                             * accurate assignment a[less] = a[great].\n                             */\n                                a[less] = a[great];\n                                ++less;\n                            } else { // pivot1 < a[great] < pivot2\n                                a[k] = a[great];\n                            }\n                            a[great] = ak;\n                            --great;\n                        }\n                    }\n                }\n\n                // Sort center part recursively\n                sort(a, less, great, false);\n\n            } else { // Partitioning with one pivot\n            /*\n             * Use the third of the five sorted elements as pivot.\n             * This value is inexpensive approximation of the median.\n             */\n                float pivot = a[e3];\n\n            /*\n             * Partitioning degenerates to the traditional 3-way\n             * (or \"Dutch National Flag\") schema:\n             *\n             *   left part    center part              right part\n             * +-------------------------------------------------+\n             * |  < pivot  |   == pivot   |     ?    |  > pivot  |\n             * +-------------------------------------------------+\n             *              ^              ^        ^\n             *              |              |        |\n             *             less            k      great\n             *\n             * Invariants:\n             *\n             *   all in (left, less)   < pivot\n             *   all in [less, k)     == pivot\n             *   all in (great, right) > pivot\n             *\n             * Pointer k is the first index of ?-part.\n             */\n                for (int k = less; k <= great; ++k) {\n                    if (a[k] == pivot) {\n                        continue;\n                    }\n                    float ak = a[k];\n                    if (ak < pivot) { // Move a[k] to left part\n                        a[k] = a[less];\n                        a[less] = ak;\n                        ++less;\n                    } else { // a[k] > pivot - Move a[k] to right part\n                        while (a[great] > pivot) {\n                            --great;\n                        }\n                        if (a[great] < pivot) { // a[great] <= pivot\n                            a[k] = a[less];\n                            a[less] = a[great];\n                            ++less;\n                        } else { // a[great] == pivot\n                        /*\n                         * Even though a[great] equals to pivot, the\n                         * assignment a[k] = pivot may be incorrect,\n                         * if a[great] and pivot are floating-point\n                         * zeros of different signs. Therefore in float\n                         * and double sorting methods we have to use\n                         * more accurate assignment a[k] = a[great].\n                         */\n                            a[k] = a[great];\n                        }\n                        a[great] = ak;\n                        --great;\n                    }\n                }\n\n            /*\n             * Sort left and right parts recursively.\n             * All elements from center part are equal\n             * and, therefore, already sorted.\n             */\n                sort(a, left, less - 1, leftmost);\n                sort(a, great + 1, right, false);\n            }\n        }\n\n        /**\n         * Sorts the specified range of the array using the given\n         * workspace array slice if possible for merging\n         *\n         * @param a        the array to be sorted\n         * @param left     the index of the first element, inclusive, to be sorted\n         * @param right    the index of the last element, inclusive, to be sorted\n         * @param work     a workspace array (slice)\n         * @param workBase origin of usable space in work array\n         * @param workLen  usable size of work array\n         */\n        static void sort(double[] a, int left, int right,\n                         double[] work, int workBase, int workLen) {\n        /*\n         * Phase 1: Move NaNs to the end of the array.\n         */\n            while (left <= right && Double.isNaN(a[right])) {\n                --right;\n            }\n            for (int k = right; --k >= left; ) {\n                double ak = a[k];\n                if (ak != ak) { // a[k] is NaN\n                    a[k] = a[right];\n                    a[right] = ak;\n                    --right;\n                }\n            }\n\n        /*\n         * Phase 2: Sort everything except NaNs (which are already in place).\n         */\n            doSort(a, left, right, work, workBase, workLen);\n\n        /*\n         * Phase 3: Place negative zeros before positive zeros.\n         */\n            int hi = right;\n\n        /*\n         * Find the first zero, or first positive, or last negative element.\n         */\n            while (left < hi) {\n                int middle = (left + hi) >>> 1;\n                double middleValue = a[middle];\n\n                if (middleValue < 0.0d) {\n                    left = middle + 1;\n                } else {\n                    hi = middle;\n                }\n            }\n\n        /*\n         * Skip the last negative value (if any) or all leading negative zeros.\n         */\n            while (left <= right && Double.doubleToRawLongBits(a[left]) < 0) {\n                ++left;\n            }\n\n        /*\n         * Move negative zeros to the beginning of the sub-range.\n         *\n         * Partitioning:\n         *\n         * +----------------------------------------------------+\n         * |   < 0.0   |   -0.0   |   0.0   |   ?  ( >= 0.0 )   |\n         * +----------------------------------------------------+\n         *              ^          ^         ^\n         *              |          |         |\n         *             left        p         k\n         *\n         * Invariants:\n         *\n         *   all in (*,  left)  <  0.0\n         *   all in [left,  p) == -0.0\n         *   all in [p,     k) ==  0.0\n         *   all in [k, right] >=  0.0\n         *\n         * Pointer k is the first index of ?-part.\n         */\n            for (int k = left, p = left - 1; ++k <= right; ) {\n                double ak = a[k];\n                if (ak != 0.0d) {\n                    break;\n                }\n                if (Double.doubleToRawLongBits(ak) < 0) { // ak is -0.0d\n                    a[k] = 0.0d;\n                    a[++p] = -0.0d;\n                }\n            }\n        }\n\n        /**\n         * Sorts the specified range of the array.\n         *\n         * @param a        the array to be sorted\n         * @param left     the index of the first element, inclusive, to be sorted\n         * @param right    the index of the last element, inclusive, to be sorted\n         * @param work     a workspace array (slice)\n         * @param workBase origin of usable space in work array\n         * @param workLen  usable size of work array\n         */\n        private static void doSort(double[] a, int left, int right,\n                                   double[] work, int workBase, int workLen) {\n            // Use Quicksort on small arrays\n            if (right - left < QUICKSORT_THRESHOLD) {\n                sort(a, left, right, true);\n                return;\n            }\n\n        /*\n         * Index run[i] is the start of i-th run\n         * (ascending or descending sequence).\n         */\n            int[] run = new int[MAX_RUN_COUNT + 1];\n            int count = 0;\n            run[0] = left;\n\n            // Check if the array is nearly sorted\n            for (int k = left; k < right; run[count] = k) {\n                if (a[k] < a[k + 1]) { // ascending\n                    while (++k <= right && a[k - 1] <= a[k]) ;\n                } else if (a[k] > a[k + 1]) { // descending\n                    while (++k <= right && a[k - 1] >= a[k]) ;\n                    for (int lo = run[count] - 1, hi = k; ++lo < --hi; ) {\n                        double t = a[lo];\n                        a[lo] = a[hi];\n                        a[hi] = t;\n                    }\n                } else { // equal\n                    for (int m = MAX_RUN_LENGTH; ++k <= right && a[k - 1] == a[k]; ) {\n                        if (--m == 0) {\n                            sort(a, left, right, true);\n                            return;\n                        }\n                    }\n                }\n\n            /*\n             * The array is not highly structured,\n             * use Quicksort instead of merge sort.\n             */\n                if (++count == MAX_RUN_COUNT) {\n                    sort(a, left, right, true);\n                    return;\n                }\n            }\n\n            // Check special cases\n            // Implementation note: variable \"right\" is increased by 1.\n            if (run[count] == right++) { // The last run contains one element\n                run[++count] = right;\n            } else if (count == 1) { // The array is already sorted\n                return;\n            }\n\n            // Determine alternation base for merge\n            byte odd = 0;\n            for (int n = 1; (n <<= 1) < count; odd ^= 1) ;\n\n            // Use or create temporary array b for merging\n            double[] b;                 // temp array; alternates with a\n            int ao, bo;              // array offsets from 'left'\n            int blen = right - left; // space needed for b\n            if (work == null || workLen < blen || workBase + blen > work.length) {\n                work = new double[blen];\n                workBase = 0;\n            }\n            if (odd == 0) {\n                System.arraycopy(a, left, work, workBase, blen);\n                b = a;\n                bo = 0;\n                a = work;\n                ao = workBase - left;\n            } else {\n                b = work;\n                ao = 0;\n                bo = workBase - left;\n            }\n\n            // Merging\n            for (int last; count > 1; count = last) {\n                for (int k = (last = 0) + 2; k <= count; k += 2) {\n                    int hi = run[k], mi = run[k - 1];\n                    for (int i = run[k - 2], p = i, q = mi; i < hi; ++i) {\n                        if (q >= hi || p < mi && a[p + ao] <= a[q + ao]) {\n                            b[i + bo] = a[p++ + ao];\n                        } else {\n                            b[i + bo] = a[q++ + ao];\n                        }\n                    }\n                    run[++last] = hi;\n                }\n                if ((count & 1) != 0) {\n                    for (int i = right, lo = run[count - 1]; --i >= lo;\n                         b[i + bo] = a[i + ao]\n                            )\n                        ;\n                    run[++last] = right;\n                }\n                double[] t = a;\n                a = b;\n                b = t;\n                int o = ao;\n                ao = bo;\n                bo = o;\n            }\n        }\n\n        /**\n         * Sorts the specified range of the array by Dual-Pivot Quicksort.\n         *\n         * @param a        the array to be sorted\n         * @param left     the index of the first element, inclusive, to be sorted\n         * @param right    the index of the last element, inclusive, to be sorted\n         * @param leftmost indicates if this part is the leftmost in the range\n         */\n        private static void sort(double[] a, int left, int right, boolean leftmost) {\n            int length = right - left + 1;\n\n            // Use insertion sort on tiny arrays\n            if (length < INSERTION_SORT_THRESHOLD) {\n                if (leftmost) {\n                /*\n                 * Traditional (without sentinel) insertion sort,\n                 * optimized for server VM, is used in case of\n                 * the leftmost part.\n                 */\n                    for (int i = left, j = i; i < right; j = ++i) {\n                        double ai = a[i + 1];\n                        while (ai < a[j]) {\n                            a[j + 1] = a[j];\n                            if (j-- == left) {\n                                break;\n                            }\n                        }\n                        a[j + 1] = ai;\n                    }\n                } else {\n                /*\n                 * Skip the longest ascending sequence.\n                 */\n                    do {\n                        if (left >= right) {\n                            return;\n                        }\n                    } while (a[++left] >= a[left - 1]);\n\n                /*\n                 * Every element from adjoining part plays the role\n                 * of sentinel, therefore this allows us to avoid the\n                 * left range check on each iteration. Moreover, we use\n                 * the more optimized algorithm, so called pair insertion\n                 * sort, which is faster (in the context of Quicksort)\n                 * than traditional implementation of insertion sort.\n                 */\n                    for (int k = left; ++left <= right; k = ++left) {\n                        double a1 = a[k], a2 = a[left];\n\n                        if (a1 < a2) {\n                            a2 = a1;\n                            a1 = a[left];\n                        }\n                        while (a1 < a[--k]) {\n                            a[k + 2] = a[k];\n                        }\n                        a[++k + 1] = a1;\n\n                        while (a2 < a[--k]) {\n                            a[k + 1] = a[k];\n                        }\n                        a[k + 1] = a2;\n                    }\n                    double last = a[right];\n\n                    while (last < a[--right]) {\n                        a[right + 1] = a[right];\n                    }\n                    a[right + 1] = last;\n                }\n                return;\n            }\n\n            // Inexpensive approximation of length / 7\n            int seventh = (length >> 3) + (length >> 6) + 1;\n\n        /*\n         * Sort five evenly spaced elements around (and including) the\n         * center element in the range. These elements will be used for\n         * pivot selection as described below. The choice for spacing\n         * these elements was empirically determined to work well on\n         * a wide variety of inputs.\n         */\n            int e3 = (left + right) >>> 1; // The midpoint\n            int e2 = e3 - seventh;\n            int e1 = e2 - seventh;\n            int e4 = e3 + seventh;\n            int e5 = e4 + seventh;\n\n            // Sort these elements using insertion sort\n            if (a[e2] < a[e1]) {\n                double t = a[e2];\n                a[e2] = a[e1];\n                a[e1] = t;\n            }\n\n            if (a[e3] < a[e2]) {\n                double t = a[e3];\n                a[e3] = a[e2];\n                a[e2] = t;\n                if (t < a[e1]) {\n                    a[e2] = a[e1];\n                    a[e1] = t;\n                }\n            }\n            if (a[e4] < a[e3]) {\n                double t = a[e4];\n                a[e4] = a[e3];\n                a[e3] = t;\n                if (t < a[e2]) {\n                    a[e3] = a[e2];\n                    a[e2] = t;\n                    if (t < a[e1]) {\n                        a[e2] = a[e1];\n                        a[e1] = t;\n                    }\n                }\n            }\n            if (a[e5] < a[e4]) {\n                double t = a[e5];\n                a[e5] = a[e4];\n                a[e4] = t;\n                if (t < a[e3]) {\n                    a[e4] = a[e3];\n                    a[e3] = t;\n                    if (t < a[e2]) {\n                        a[e3] = a[e2];\n                        a[e2] = t;\n                        if (t < a[e1]) {\n                            a[e2] = a[e1];\n                            a[e1] = t;\n                        }\n                    }\n                }\n            }\n\n            // Pointers\n            int less = left;  // The index of the first element of center part\n            int great = right; // The index before the first element of right part\n\n            if (a[e1] != a[e2] && a[e2] != a[e3] && a[e3] != a[e4] && a[e4] != a[e5]) {\n            /*\n             * Use the second and fourth of the five sorted elements as pivots.\n             * These values are inexpensive approximations of the first and\n             * second terciles of the array. Note that pivot1 <= pivot2.\n             */\n                double pivot1 = a[e2];\n                double pivot2 = a[e4];\n\n            /*\n             * The first and the last elements to be sorted are moved to the\n             * locations formerly occupied by the pivots. When partitioning\n             * is complete, the pivots are swapped back into their final\n             * positions, and excluded from subsequent sorting.\n             */\n                a[e2] = a[left];\n                a[e4] = a[right];\n\n            /*\n             * Skip elements, which are less or greater than pivot values.\n             */\n                while (a[++less] < pivot1) ;\n                while (a[--great] > pivot2) ;\n\n            /*\n             * Partitioning:\n             *\n             *   left part           center part                   right part\n             * +--------------------------------------------------------------+\n             * |  < pivot1  |  pivot1 <= && <= pivot2  |    ?    |  > pivot2  |\n             * +--------------------------------------------------------------+\n             *               ^                          ^       ^\n             *               |                          |       |\n             *              less                        k     great\n             *\n             * Invariants:\n             *\n             *              all in (left, less)   < pivot1\n             *    pivot1 <= all in [less, k)     <= pivot2\n             *              all in (great, right) > pivot2\n             *\n             * Pointer k is the first index of ?-part.\n             */\n                outer:\n                for (int k = less - 1; ++k <= great; ) {\n                    double ak = a[k];\n                    if (ak < pivot1) { // Move a[k] to left part\n                        a[k] = a[less];\n                    /*\n                     * Here and below we use \"a[i] = b; i++;\" instead\n                     * of \"a[i++] = b;\" due to performance issue.\n                     */\n                        a[less] = ak;\n                        ++less;\n                    } else if (ak > pivot2) { // Move a[k] to right part\n                        while (a[great] > pivot2) {\n                            if (great-- == k) {\n                                break outer;\n                            }\n                        }\n                        if (a[great] < pivot1) { // a[great] <= pivot2\n                            a[k] = a[less];\n                            a[less] = a[great];\n                            ++less;\n                        } else { // pivot1 <= a[great] <= pivot2\n                            a[k] = a[great];\n                        }\n                    /*\n                     * Here and below we use \"a[i] = b; i--;\" instead\n                     * of \"a[i--] = b;\" due to performance issue.\n                     */\n                        a[great] = ak;\n                        --great;\n                    }\n                }\n\n                // Swap pivots into their final positions\n                a[left] = a[less - 1];\n                a[less - 1] = pivot1;\n                a[right] = a[great + 1];\n                a[great + 1] = pivot2;\n\n                // Sort left and right parts recursively, excluding known pivots\n                sort(a, left, less - 2, leftmost);\n                sort(a, great + 2, right, false);\n\n            /*\n             * If center part is too large (comprises > 4/7 of the array),\n             * swap internal pivot values to ends.\n             */\n                if (less < e1 && e5 < great) {\n                /*\n                 * Skip elements, which are equal to pivot values.\n                 */\n                    while (a[less] == pivot1) {\n                        ++less;\n                    }\n\n                    while (a[great] == pivot2) {\n                        --great;\n                    }\n\n                /*\n                 * Partitioning:\n                 *\n                 *   left part         center part                  right part\n                 * +----------------------------------------------------------+\n                 * | == pivot1 |  pivot1 < && < pivot2  |    ?    | == pivot2 |\n                 * +----------------------------------------------------------+\n                 *              ^                        ^       ^\n                 *              |                        |       |\n                 *             less                      k     great\n                 *\n                 * Invariants:\n                 *\n                 *              all in (*,  less) == pivot1\n                 *     pivot1 < all in [less,  k)  < pivot2\n                 *              all in (great, *) == pivot2\n                 *\n                 * Pointer k is the first index of ?-part.\n                 */\n                    outer:\n                    for (int k = less - 1; ++k <= great; ) {\n                        double ak = a[k];\n                        if (ak == pivot1) { // Move a[k] to left part\n                            a[k] = a[less];\n                            a[less] = ak;\n                            ++less;\n                        } else if (ak == pivot2) { // Move a[k] to right part\n                            while (a[great] == pivot2) {\n                                if (great-- == k) {\n                                    break outer;\n                                }\n                            }\n                            if (a[great] == pivot1) { // a[great] < pivot2\n                                a[k] = a[less];\n                            /*\n                             * Even though a[great] equals to pivot1, the\n                             * assignment a[less] = pivot1 may be incorrect,\n                             * if a[great] and pivot1 are floating-point zeros\n                             * of different signs. Therefore in float and\n                             * double sorting methods we have to use more\n                             * accurate assignment a[less] = a[great].\n                             */\n                                a[less] = a[great];\n                                ++less;\n                            } else { // pivot1 < a[great] < pivot2\n                                a[k] = a[great];\n                            }\n                            a[great] = ak;\n                            --great;\n                        }\n                    }\n                }\n\n                // Sort center part recursively\n                sort(a, less, great, false);\n\n            } else { // Partitioning with one pivot\n            /*\n             * Use the third of the five sorted elements as pivot.\n             * This value is inexpensive approximation of the median.\n             */\n                double pivot = a[e3];\n\n            /*\n             * Partitioning degenerates to the traditional 3-way\n             * (or \"Dutch National Flag\") schema:\n             *\n             *   left part    center part              right part\n             * +-------------------------------------------------+\n             * |  < pivot  |   == pivot   |     ?    |  > pivot  |\n             * +-------------------------------------------------+\n             *              ^              ^        ^\n             *              |              |        |\n             *             less            k      great\n             *\n             * Invariants:\n             *\n             *   all in (left, less)   < pivot\n             *   all in [less, k)     == pivot\n             *   all in (great, right) > pivot\n             *\n             * Pointer k is the first index of ?-part.\n             */\n                for (int k = less; k <= great; ++k) {\n                    if (a[k] == pivot) {\n                        continue;\n                    }\n                    double ak = a[k];\n                    if (ak < pivot) { // Move a[k] to left part\n                        a[k] = a[less];\n                        a[less] = ak;\n                        ++less;\n                    } else { // a[k] > pivot - Move a[k] to right part\n                        while (a[great] > pivot) {\n                            --great;\n                        }\n                        if (a[great] < pivot) { // a[great] <= pivot\n                            a[k] = a[less];\n                            a[less] = a[great];\n                            ++less;\n                        } else { // a[great] == pivot\n                        /*\n                         * Even though a[great] equals to pivot, the\n                         * assignment a[k] = pivot may be incorrect,\n                         * if a[great] and pivot are floating-point\n                         * zeros of different signs. Therefore in float\n                         * and double sorting methods we have to use\n                         * more accurate assignment a[k] = a[great].\n                         */\n                            a[k] = a[great];\n                        }\n                        a[great] = ak;\n                        --great;\n                    }\n                }\n\n            /*\n             * Sort left and right parts recursively.\n             * All elements from center part are equal\n             * and, therefore, already sorted.\n             */\n                sort(a, left, less - 1, leftmost);\n                sort(a, great + 1, right, false);\n            }\n        }\n    }\n\n```","tags":["little_eight"],"categories":["java1.8源码"]},{"title":"Dockerfile命令","url":"/2019/03/12/Dockerfile命令/","content":"## FROM指令\n\n脚本的第1行是FROM指令。通过FROM指令，docker编译程序能够知道在哪个基础镜像执行来进行编译。所有的Dockerfile都必须以FROM指令开始。\n\n```\nFROM devops-reg.io/public/openjdk:8\n```\n\n## MAINTAINER指令\n\n第二条指令MAINTAINER，用来标明这个镜像的维护者信息。\n\n```\n#MAINTAINER xxxx@qq.com\n```\n\n## RUN指令\n接下来是RUN指令。这条指令用来在docker的编译环境中运行指定命令。上面这条指令会在编译环境运行/bin/sh -c \"apt-get update && apt-get -y install ...\"。RUN指令还有另外一种格式：\n```\nRUN [\"程序名\", \"参数1\", \"参数2\"]\n```\n<!--more-->\n这种格式运行程序，可以免除运行/bin/sh的消耗。这种格式使用Json格式将程序名与所需参数组成一个字符串数组，所以如果参数中有引号等特殊字符，需要进行转义。\n\n## ENV指令\nENV指令用来指定在执行docker run命令运行镜像时，自动设置的环境变量。这些环境变量可以通过docker run命令的--evn参数来进行修改。\n\n## COPY指令和ADD指令\n\nCOPY指令用来将本地（Dockerfile所在位置）的文件或文件夹复制到编译环境的指定路径下。上面的例子里，boot2docker的Dockerfile希望将与Dockerfile同一目录下的kernel_config文件复制到编译环境的/linux-kernal/.config。Dockerfile还提供了另外一个类似的指令：ADD。在复制文件方面ADD指令和COPY指令的格式和效果是完全一样的。这两个指令的区别主要由两点：\n\n* ADD指令可以从一个URL地址下载内容复制到容器的文件系统中\n* ADD指令会将压缩打包格式的文件解开后复制到指定位置，而COPY指令只做复制操作\n\n## CMD指令\n\n这是整个Dockerfile脚本的最后一条指令。当Dockerfile已经完成了所有环境的安装与配置，通过CMD指令来指示docker run命令运行镜像时要执行的命令。上面的例子里，在完成所有工作后，boot2docker的编译脚本将编译结果输出到本地环境下。\n\n### 其他指令\n\n### EXPOSE指令\n\nEXPOSE <端口> [<端口>...]指令用于标明，这个镜像中的应用将会侦听某个端口，并且希望能将这个端口映射到主机的网络界面上。但是，为了安全，docker run命令如果没有带上响应的端口映射参数，docker并不会将端口映射出了。\n\n### ENTRYPOINT指令\n\nENTRYPOINT指令和前面介绍过的CMD一样，用于标明一个镜像作为容器运行时，最后要执行的程序或命令。这两个指令有相同之处，也有区别。通过两个指令的配合使用可以配置出不同的效果。\n\nENTRYPOINT指令有两种格式，CMD指令有三种格式：\n```\nENTRYPOINT [\"程序名\", \"参数1\", \"参数2\"]\nENTRYPOINT 命令 参数1 参数2\n\nCMD [\"程序名\", \"参数1\", \"参数2\"]\nCMD 命令 参数1 参数2\nCMD 参数1 参数2\n```\n\nENTRYPOINT是容器运行程序的入口。也就是说，在docker run命令中指定的命令都将作为参数提供给ENTRYPOINT指定的程序。同样，上面列举的CMD指令格式的后面两种格式也将作为参数提供给ENTRYPOINT指定的程序。\n\n默认的ENTRYPOINT是/bin/sh -c。你可以根据实际需要任意设置。但是如果在一个Dockerfile中出现了多个ENTRYPOINT指令，那么，只有最后一个ENTRYPOINT指令是起效的。\n\n一种常用的设置是将命令与必要参数设置到ENTRYPOINT中，而运行时只提供其他选项。例如：你有一个MySQL的客户端程序运行在容器中，而客户端所需要的主机地址、用户名和密码你不希望每次都输入，你就可以将ENTRYPOINT设置成：ENTRYPOINT mysql -u <用户名> -p <密码> -h <主机名>。而你运行时，只需要指定数据库名。\n\n### VOLUME指令\n```\nVOLUME [\"路径\"]\n```\nVOLUME指令用于在容器内创建一个或多个卷。而更多的时候，是在执行docker run时指定要创建的卷以及本地路径来进行映射。关于这个用法将在后面的章节学习到。\n\n### USER指令\n\n```\nUSER 用户名或用户ID\n```\nUSER指令用于容器内运行RUN指令或CMD指令的用户。例如，在构建一个nginx镜像时，你希望最后运行nginx的用户为nginx，就可以在CMD [\"nginx\"]之前将用户设置为nginx。\n\n如果在运行docker run命令时设置了-u 用户名参数，那么将覆盖USER指令设置的用户。\n\n### WORKDIR指令\n```\nWORKDIR 路径\n```\nWORKDIR指令用于设置执行RUN指令、CMD指令和ENTRYPOINT指令执行时的工作目录。在Dockerfile中可以多次设置WORKDIR，在每次设置之后的命令将使用新的路径。\n\n### ONBUILD指令\n```\nONBUILD 指令\n```\nONBUILD指令用于设置一些指令，当本镜像作为基础镜像被其他Dockerfile用FROM指令引用时，在所有其他指令执行之前先执行这些指令。","tags":["little_eight"],"categories":["杂类"]},{"title":"Docker简单介绍","url":"/2019/02/27/Docker简单介绍/","content":"\n# Docker\n\n* 镜像（ Image ）\n* 容器（ Container ）\n* 仓库（ Repository ）\n\n## Docker镜像\nDocker 镜像（Image），就相当于是一个 root 文件系统，它除了提供容器运行时所需的程序、库、资\n源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。\n\n### 分层存储\n因为镜像体积庞大，就将其设计成分层存储的架构，所以严格来说镜像由一组文件系统组成。\n镜像构建时，会一层层构建，前一层是后一层的基础。。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。\n\n## Docker 容器\n容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。\n\n## Docker仓库\n镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker仓库就是这样的服务。\n一个 Docker Registry 中可以包含多个仓库（ Repository ）；每个仓库可以包含多个标签（ Tag ）；每个标签对应一个镜像。\n通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 <仓库名>:<标签> 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签。\n以 Ubuntu 镜像 为例， ubuntu 是仓库的名字，其内包含有不同的版本标签，如， 16.04 , 18.04。我们可以通过 ubuntu:14.04，或者ubuntu:18.04来具体指定所需哪个版本的镜像。如果忽略了标签，比如 ubuntu ，那将视为ubuntu:latest 。\n\n### 私有 Docker仓库\n除了使用公开服务外，用户还可以在本地搭建私有Docker仓库。Docker官方提供了Docker仓库镜像，可以直接使用做为私有 Registry 服务。\n\n## 使用 Docker 镜像\n\n### 获取镜像\n从 Docker 镜像仓库获取镜像的命令是 docker pull 。其命令格式为：\n> docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]\n\n* Docker 镜像仓库地址：地址的格式一般是 <域名/IP>[:端口号] 。默认地址是 Docker Hub。\n* 仓库名：如之前所说，这里的仓库名是两段式名称，即<用户名>/<软件名>。对于DockerHub，如果不给出用户名，则默认为 library ，也就是官方镜像。\n比如\n<!--more-->\n> $ docker pull ubuntu:18.04\n18.04: Pulling from library/ubuntu\nbf5d46315322: Pull complete\n9f13e0ac480c: Pull complete\ne8988b5b3097: Pull complete\n40af181810e7: Pull complete\ne6f7c7e5c03e: Pull complete\nDigest: sha256:147913621d9cdea08853f6ba9116c2e27a3ceffecf3b49298\n3ae97c3d643fbbe\nStatus: Downloaded newer image for ubuntu:18.04\n\n上面的命令中没有给出 Docker 镜像仓库地址，因此将会从 Docker Hub 获取镜像。而镜像名称是 ubuntu:18.04 ，因此将会获取官方镜像 library/ubuntu仓库中标签为 18.04 的镜像。\n\n### 运行\n\n有了镜像后，我们就能够以这个镜像为基础启动并运行一个容器。以上面的\nubuntu:18.04 为例，如果我们打算启动里面的 bash 并且进行交互式操作的\n话，可以执行下面的命令。\n\n> $ docker run -it --rm \\\nubuntu:18.04 \\\nbash\nroot@e7009c6ce357:/# cat /etc/os-release\nNAME=\"Ubuntu\"\nVERSION=\"18.04.1 LTS (Bionic Beaver)\"\nID=ubuntu\nID_LIKE=debian\nPRETTY_NAME=\"Ubuntu 18.04.1 LTS\"\nVERSION_ID=\"18.04\"\nHOME_URL=\"https://www.ubuntu.com/\"\nSUPPORT_URL=\"https://help.ubuntu.com/\"\nBUG_REPORT_URL=\"https://bugs.launchpad.net/ubuntu/\"\nPRIVACY_POLICY_URL=\"https://www.ubuntu.com/legal/terms-and-polic\nies/privacy-policy\"\nVERSION_CODENAME=bionic\nUBUNTU_CODENAME=bionic\n\n* docker run 就是运行容器的命令\n* -it ：这是两个参数，一个是 -i ：交互式操作，一个是 -t 终端。我们\n这里打算进入 bash 执行一些命令并查看返回结果，因此我们需要交互式终\n端。\n* --rm ：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需\n求，退出的容器并不会立即删除，除非手动 docker rm 。我们这里只是随便\n执行个命令，看看结果，不需要排障和保留结果，因此使用 --rm 可以避免\n浪费空间。\n* ubuntu:18.04 ：这是指用 ubuntu:18.04 镜像为基础来启动容器。\n* bash ：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的\n是 bash 。\n\n### 列出镜像\n要想列出已经下载下来的镜像，可以使用 docker image ls 命令。\n> $ docker image ls\nREPOSITORY TAG IMAGE ID CRE\nATED SIZE\nredis latest 5f515359c7f8 5 d\nays ago 183 MB\nnginx latest 05a60462f8ba 5 d\nays ago 181 MB\nmongo 3.2 fe9198c04d62 5 d\nays ago 342 MB\n<none> <none> 00285df0df87 5 d\nays ago 342 MB\nubuntu 18.04 f753707788c5 4 w\neeks ago 127 MB\nubuntu latest f753707788c5 4 w\neeks ago 127 MB\n\n列表包含了 仓库名 、 标签 、 镜像 ID 、 创建时间 以及 所占用的空间 。\n\n### 删除本地镜像\n如果要删除本地的镜像，可以使用 docker image rm 命令\n\n## 使用 Dockerfile 定制镜像\n\nDockerfile 是一个文本文件，其内包含了一条条的指令(Instruction)，每一条指令\n构建一层，因此每一条指令的内容，就是描述该层应当如何构建。\n\n看一个Dockerfile文件\n```xml\nFROM nginx\nRUN echo '<h1>Hello, Docker!</h1>' > /usr/share/nginx/html/index\n.html\n```\n\n### FROM 指定基础镜像\n\n所谓定制镜像，那一定是以一个镜像为基础，在其上进行定制。就像我们之前运行\n了一个 nginx 镜像的容器，再进行修改一样，基础镜像是必须指定的。而\nFROM 就是指定基础镜像，因此一个 Dockerfile 中 FROM 是必备的指令，并\n且必须是第一条指令。\n\n### RUN 执行命令\nRUN 指令是用来执行命令行命令的。由于命令行的强大能力， RUN 指令在定制\n镜像时是最常用的指令之一。其格式有两种：\n\n* shell 格式： RUN <命令> ，就像直接在命令行中输入的命令一样。刚才写的\nDockerfile 中的 RUN 指令就是这种格式。\n```\nRUN echo '<h1>Hello, Docker!</h1>' > /usr/share/nginx/html/index\n.html\n```\n* exec 格式： RUN [\"可执行文件\", \"参数1\", \"参数2\"] ，这更像是函数调用中\n的格式。\n\nDockerfile 支持 Shell 类的行尾添加 \\ 的\n命令换行方式，以及行首 # 进行注释的格式。良好的格式，比如换行、缩进、注\n释等，会让维护、排障更为容易，这是一个比较好的习惯。\n\n### 构建镜像\n\n在 Dockerfile 文件所在目录执行：\n```\n$ docker build -t nginx:v3 .\nSending build context to Docker daemon 2.048 kB\nStep 1 : FROM nginx\n---> e43d811ce2f4\nStep 2 : RUN echo '<h1>Hello, Docker!</h1>' > /usr/share/nginx/h\ntml/index.html\n---> Running in 9cdc27646c7b\n---> 44aa4490ce2c\nRemoving intermediate container 9cdc27646c7b\nSuccessfully built 44aa4490ce2c\n\n```\n\n这里我们使用了 docker build 命令进行镜像构建。其格式为：\n> docker build [选项] <上下文路径/URL/->\n\n在这里我们指定了最终镜像的名称 -t nginx:v3 ，构建成功后，我们可以像之前\n运行 nginx:v2 那样来运行这个镜像，其结果会和 nginx:v2 一样。\n\n更多Dockerfile命令可参考官方文档：https://docs.docker.com/engine/reference/builder/\n\n\n\n## docker使用\n\n### docker安装\n\n* 使用 sudo 或 root 权限登录 Centos，确保 yum 包更新到最新。\n```\n$ sudo yum update\n```\n\n* 执行 Docker 安装脚本。\n```\n$ curl -fsSL https://get.docker.com -o get-docker.sh\n$ sudo sh get-docker.sh\n```\n* 启动 Docker 进程。\n```\nsudo systemctl start docker\n```\n\n\n后期可能会出现这样的错误信息：\n>Got permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Get http://%2Fvar%2Frun%2Fdocker.sock/v1.39/images/json: dial unix /var/run/docker.sock: connect: permission denied\n\n原因：\n>docker守护进程启动的时候，会默认赋予名字为docker的用户组读写Unix socket的权限，因此只要创建docker用户组，并将当前用户加入到docker用户组中，那么当前用户就有权限访问Unix socket了，进而也就可以执行docker相关命令。\n\n解决方案\n> .#添加docker用户组\nsudo groupadd docker    \n #添加将登陆用户加入到docker用户组中\nsudo gpasswd -a $USER docker    \n #将登陆用户加入到docker更新用户组中\nnewgrp docker     #更新用户组\ndocker ps   \n #测试docker命令是否可以使用sudo正常使用\n\n\n## Kubernetes（太多，后期再补充吧）\n\nKubernetes，因为首尾字母中间有8个字符，所以被简写成 K8s。\n\n\n","tags":["little_eight"],"categories":["杂类"]},{"title":"使用Nacos实现服务注册与发现","url":"/2019/02/15/使用Nacos实现服务注册与发现/","content":"\n# 使用Nacos实现服务注册与发现\n\n## 什么是 Nacos\n\n官网解释：\nNacos 致力于帮助您发现、配置和管理微服务。Nacos 提供了一组简单易用的特性集，帮助您快速实现动态服务发现、服务配置、服务元数据及流量管理。\n\nNacos 帮助您更敏捷和容易地构建、交付和管理微服务平台。 Nacos 是构建以“服务”为中心的现代应用架构 (例如微服务范式、云原生范式) 的服务基础设施。\n\n个人解释：\n微服务管理平台\n\n## Nacos优缺点\n\n### 优点\n* 开箱即用，适用于dubbo，spring cloud\n* AP模型，数据最终一致性\n* 注册中心，配置中心二合一，提供控制台管理\n* 纯国产，久经双十一考验\n\n### 缺点\n* 刚刚开源不久，社区热度不够，依然存在bug\n> 优缺点4比1，肯定选它呀，\n\n## 快速开始\n\n### 下载Nacos\n\n[下载地址(本文版本：0.8.0)](ttps://github.com/alibaba/nacos/releases)\n\n下载完成之后，解压。根据不同平台，执行不同命令。本人windows，直接点击bin包下的startup.cmd\n\n启动完成之后，访问：http://127.0.0.1:8848/nacos/，默认账号密码均为nacos，进入Nacos的服务管理页面，如下图\n![图片1](https://raw.githubusercontent.com/little-eight-china/image/master/bdbk/nacos/1.jpg?raw=true)\n### 创建服务提供和消费者\n\n#### 项目架构\n\n```\n└─springboot-nacos\n    └─nacos-server\n        └─pom.xml\n    └─nacos-client\n        └─pom.xml\n    └─pom.xml\n```\n* 创建一个名为springboot-nacos的springboot项目，然后项目里只留pom.xml文件，其余全部删除。pom.xml的依赖如下\n\n```\n\t<dependencies>\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-starter</artifactId>\n\t\t</dependency>\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-starter-test</artifactId>\n\t\t</dependency>\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-starter-web</artifactId>\n\t\t</dependency>\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.cloud</groupId>\n\t\t\t<artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>\n\t\t</dependency>\n\t</dependencies>\n\t<dependencyManagement>\n\t\t<dependencies>\n\t\t\t<dependency>\n\t\t\t\t<groupId>org.springframework.cloud</groupId>\n\t\t\t\t<artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>\n\t\t\t\t<version>0.2.1.RELEASE</version>\n\t\t\t</dependency>\n\t\t</dependencies>\n\t</dependencyManagement>\n```\n> 注意，版本兼容性官方说明：版本 0.2.x.RELEASE 对应的是 Spring Boot 2.0.x 版本，版本 0.1.x.RELEASE 对应的是 Spring Boot 1.x 版本，所以要看清楚自己的springboot是什么版本，如果是2.1.x,会有未知的bug(比如服务注册不上)，本人使用2.0.6\n\n* 在父项目中new一个module，名为nacos-server作为服务提供者，由于依赖可全继承父层，所以pom.xml可删除其它，只留 parent\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\txsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n\t<parent>\n\t\t<groupId>bdbk</groupId>\n\t\t<artifactId>springboot-nacos</artifactId>\n\t\t<version>1.0.0</version>\n\t</parent>\n\t<modelVersion>4.0.0</modelVersion>\n\t<artifactId>nacos-server</artifactId>\n\t<version>1.0.0</version>\n</project>\n```\n\n* 配置好application.yml\n\n```\nserver:\n  port: 8080\nspring:\n  application:\n    name: nacos-server #服务名\n  cloud:\n    nacos:\n      discovery:\n        server-addr: 127.0.0.1:8848 #nacos地址\n```\n\n* 在启动类里写内部接口服务提供类\n```\n// 开启Spring Cloud的服务注册与发现\n@EnableDiscoveryClient\n@SpringBootApplication\npublic class NacosServerApplication {\n\n\tpublic static void main(String[] args) {\nSpringApplication.run(NacosServerApplication.class, args);\n\t}\n\n\t// 开放服务接口\n\t@RestController\n\tstatic class ServerController {\n\t\t@GetMapping(\"/\")\n\t\tpublic String hello() {\n\t\t\treturn \"hello clien\";\n\t\t}\n\t}\n}\n```\n\n* 启动，如果控制台日志看到如下说明注册成功 即可在nacos的管理界面看到我们的服务注册了上去，你可以点击详情查看服务的具体信息。此时还可以改下端口开2个服务，后面做负载均衡的测试\n![图片2](https://raw.githubusercontent.com/little-eight-china/image/master/bdbk/nacos/2.jpg?raw=true)\n```\no.s.c.a.n.registry.NacosServiceRegistry  : nacos registry, nacos-client 192.168.96.122:8090 register finished\n```\n\n* 同理创建nacos-client作为服务消费者，配置好application.yml\n```\nserver:\n  port: 8090\nspring:\n  application:\n    name: nacos-client\n  cloud:\n    nacos:\n      discovery:\n        server-addr: 127.0.0.1:8848\n\n```\n\n* 在启动类里写内部接口服务消费类\n\n```\n// 开启Spring Cloud的服务注册与发现\n@EnableDiscoveryClient\n@SpringBootApplication\npublic class NacosClientApplication {\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(NacosClientApplication.class, args);\n\t}\n\n\t// 调用服务接口\n\t@RestController\n\tstatic class ClientController {\n\t\t@Autowired\n\t\tprivate LoadBalancerClient loadBalancerClient;\n\t\t@GetMapping(\"/\")\n\t\tpublic String test() {\n\t\t\t// 负载均衡接口选取服务提供节点实现接口调用\n\t\t\tServiceInstance serviceInstance = loadBalancerClient.choose(\"nacos-server\");\n\t\t\tRestTemplate restTemplate = new RestTemplate();\n\t\t\tString result = restTemplate.getForObject(serviceInstance.getUri().toString(), String.class);\n\t\t\treturn \"端口号为 : \" + serviceInstance.getPort() + \", 返回结果 : \" + result;\n\t\t}\n\t}\n```\n\n* 启动，注册成功后，访问localhost:8090,可以看到结果显示在2个端口不断切换，说明不同请求真正实际调用的服务提供者实例是不同的，也就是说，通过LoadBalancerClient接口在获取服务实例的时候，已经实现了对服务提供方实例的负载均衡。\n\n### 参考资料\n\n[Nacos官方文档](https://nacos.io/zh-cn/docs/quick-start-spring-cloud.html)\n\n### 代码示例\n\n[springboot-nacos](https://github.com/little-eight-china/springboot-project/tree/master/springboot-nacos)\n\n\n\n\n","tags":["little_eight"],"categories":["springboot"]},{"title":"十大基础排序算法","url":"/2019/01/30/十大基础排序算法/","content":"\n## 十大基础排序算法\n\n### 冒泡排序\n\n* 基本思路\n对n个数进行排序，每次都是由前一个数跟后一个数比较，每循环一轮， 就可以将最大的数移到数组的最后， 总共循环n-1轮，完成对数组排序。\n\n* 动图演示\n\n![这里写图片描述](https://user-gold-cdn.xitu.io/2019/1/17/1685c01b1a3ac5e8?imageslim)\n\n* 编码\n``` JAVA\npublic static void sort(int[] arr) {\n\t\tif (arr == null)\n\t\t\treturn;\n\t\tint len = arr.length;\n\t\t// i控制循环次数，长度为len的数组只需要循环len-1次，i的起始值为0所以i<len-1\n\t\tfor (int i = 0; i < len - 1; i++) {\n\t\t\tfor (int j = 0; j < len - i - 1; j++) {\n\t\t\t\t// 如果前一个数比后一个数大，则交换位置将大的数往后放。\n\t\t\t\tif (arr[j] > arr[j + 1]) {\n\t\t\t\t\tint temp = arr[j + 1];\n\t\t\t\t\tarr[j + 1] = arr[j];\n\t\t\t\t\tarr[j] = temp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n```\n<!-- more -->\n### 选择排序\n\n* 基本思路\n选择排序可以说是冒泡排序的改良版,通过循环对比，记录最小的数字下标与目标互换 这样相对于冒泡排序来说，比较的次数并没有改变，但是数据交换的次数大大减少。\n\n* 动图演示\n\n![这里写图片描述](https://user-gold-cdn.xitu.io/2019/1/17/1685c01b2349fb70?imageslim)\n\n* 编码\n``` JAVA\npublic static void sort(int[] arr) {\n\t\tif (arr == null)\n\t\t\treturn;\n\t\tint len = arr.length;\n\t\t// 用来保存每次比较后较小数的下标\n\t\tint minIndex;\n\t\t// i控制循环次数，长度为len的数组只需要循环len-1次，i的起始值为0所以i<len-1\n\t\tfor (int i = 0; i < len - 1; i++) {\n\t\t\tminIndex = i;\n\t\t\t//j控制比较次数，因为每次循环结束之后最小的数都已经放在了最前面，\n\t\t\t//所以下一次循环的时候就可以跳过这个数，所以j的初始值为i+1而不需要每次循环都从0开始，并且j<len即可\n\t\t\tfor (int j = i + 1; j < len; j++) {\n\t\t\t\t// 每比较一次都需要将较小数的下标记录下来\n\t\t\t\tif (arr[minIndex] > arr[j]) {\n\t\t\t\t\tminIndex = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// 当完成一次循环时，就需要将本次循环选取的最小数移动到本次循环开始的位置。\n\t\t\tif (minIndex != i) {\n\t\t\t\tint temp = arr[i];\n\t\t\t\tarr[i] = arr[minIndex];\n\t\t\t\tarr[minIndex] = temp;\n\t\t\t}\n\t\t}\n\t}\n```\n\n### 插入排序\n\n* 基本思路\n首先就默认数组中的第一个数的位置是正确的，即已经排序。然后取下一个数，与已经排序的数按从后向前的顺序依次比较， 如果该数比当前位置排好序的数小，则将排好序的数的位置向后移一位。 重复上一步骤，直到找到合适的位置。找到位置后就结束比较的循环，将该数放到相应的位置。\n\n* 动图演示\n\n![这里写图片描述](https://user-gold-cdn.xitu.io/2019/1/17/1685c01b284a6b98?imageslim)\n\n* 编码\n``` JAVA\npublic static void sort(int[] arr) {\n\t\tif (arr == null)\n\t\t\treturn;\n\t\tint len = arr.length;\n\t\t// target用来记录即将要排序的那个数的值即目标值\n\t\tint target;\n\t\t// index用来记录要交换的那个值的下标\n\t\tint index;\n\t\t// i控制循环次数，因为已经默认第一个数的位置是正确的，所以i的起始值为1，i<len，循环len-1次\n\t\tfor (int i = 1; i < len; i++) {\n\t\t\ttarget = arr[i];\n\t\t\tindex = i;\n\t\t\tfor (int j = i; j > 0; j--) {\n\t\t\t\t// 如果前一个数大于target，则设值成后一个数，并记录前一个数下标\n\t\t\t\tif (target < arr[j - 1]) {\n\t\t\t\t\tarr[j] = arr[j - 1];\n\t\t\t\t\tindex = j - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// 更目标数的位置。\n\t\t\tarr[index] = target;\n\t\t}\n\t}\n```\n\n\n### 希尔排序\n\n* 基本思路\n希尔排序也称为\"缩小增量排序\"，原理是先将需要排的数组分成多个子序列，这样每个子序列的元素个数就很少，再分别对每个对子序列进行插入排序。在该数组基本有序后 再进行一次直接插入排序就能完成对整个数组的排序。所以，要采用跳跃分割的策略。这里引入“增量”的概念，将相距某个增量的记录两两组合成一个子序列，然后对每个子序列进行直接插入排序， 这样得到的结果才会使基本有序（即小的在前边，大的在后边，不大不小的在中间）。希尔排序就是 直接插入排序的升级版。\n\n* 动图演示\n\n![这里写图片描述](https://user-gold-cdn.xitu.io/2019/1/17/1685c01b7d4cfe55?imageslim)\n\n* 编码\n``` JAVA\n    public static void sort(int[] arr) {\n\t\tif (arr == null)\n\t\t\treturn;\n\t\t// 数组的长度\n\t\tint len = arr.length;\n\t\t// 初始的增量为数组长度的一半\n\t\tint k = len / 2;\n\t\t// while循环控制按增量的值来划不同分子序列，每完成一次增量就减少为原来的一半\n\t\t// 增量的最小值为1，即最后一次对整个数组做直接插入排序\n\t\twhile (k > 0) {\n\t\t\t// 里边其实就是升级版的直接插入排序了，是对每一个子序列进行直接插入排序，\n\t\t\t// 所以直接将直接插入排序中的‘1’变为‘k’就可以了。\n\t\t\tfor (int i = k; i < len; i++) {\n\t\t\t\tint j = i;\n\t\t\t\tint target = arr[i];\n\t\t\t\twhile (j >= k && target < arr[j - k]) {\n\t\t\t\t\tarr[j] = arr[j - k];\n\t\t\t\t\tj -= k;\n\t\t\t\t}\n\t\t\t\tarr[j] = target;\n\t\t\t}\n\t\t\tk /= 2;\n\t\t}\n\t}\n\n```\n\n\n### 归并排序\n\n* 基本思路\n总体概括就是从上到下递归拆分，然后从下到上逐步合并。\n\n* 动图演示\n\n![这里写图片描述](https://user-gold-cdn.xitu.io/2019/1/17/1685c01b7f84849b?imageslim)\n\n* 编码\n``` JAVA\n/**\n\t * 递归拆分\n\t *\n\t * @param arr   待拆分数组\n\t * @param left  待拆分数组最小下标\n\t * @param right 待拆分数组最大下标\n\t */\n\tpublic static void mergeSort(int[] arr, int left, int right) {\n\t\t// 中间下标\n\t\tint mid = (left + right) / 2;\n\t\tif (left < right) {\n\t\t\t// 递归拆分左边\n\t\t\tmergeSort(arr, left, mid);\n\t\t\t// 递归拆分右边\n\t\t\tmergeSort(arr, mid + 1, right);\n\t\t\t// 合并左右\n\t\t\tsort(arr, left, mid, right);\n\t\t}\n\t}\n\n\t/**\n\t * 合并两个有序子序列\n\t *\n\t * @param arr   待合并数组\n\t * @param left  待合并数组最小下标\n\t * @param mid   待合并数组中间下标\n\t * @param right 待合并数组最大下标\n\t */\n\tpublic static void sort(int[] arr, int left, int mid, int right) {\n\t\t// 临时数组，用来保存每次合并年之后的结果\n\t\tint[] temp = new int[right - left + 1];\n\t\tint i = left;\n\t\tint j = mid + 1;\n\t\t// 临时数组的初始下标\n\t\tint k = 0;\n\t\t// 这个while循环能够初步筛选出待合并的了两个子序列中的较小数\n\t\twhile (i <= mid && j <= right) {\n\t\t\tif (arr[i] <= arr[j]) {\n\t\t\t\ttemp[k++] = arr[i++];\n\t\t\t} else {\n\t\t\t\ttemp[k++] = arr[j++];\n\t\t\t}\n\t\t}\n\t\t// 将左边序列中剩余的数放入临时数组\n\t\twhile (i <= mid) {\n\t\t\ttemp[k++] = arr[i++];\n\t\t}\n\t\t// 将右边序列中剩余的数放入临时数组\n\t\twhile (j <= right) {\n\t\t\ttemp[k++] = arr[j++];\n\t\t}\n\t\t// 将临时数组中的元素位置对应到真真实的数组中\n\t\tfor (int m = 0; m < temp.length; m++) {\n\t\t\tarr[m + left] = temp[m];\n\t\t}\n\t}\n\n```\n\n\n### 快速排序\n\n* 基本思路\n快速排序也采用了分治的策略，这里引入了‘基准数’的概念。\n    * 找一个基准数（一般将待排序的数组的第一个数作为基准数）\n    * 对数组进行分区，将小于等于基准数的全部放在左边，大于基准数的全部放在右边。\n    * 重复1，2步骤，分别对左右两个子分区进行分区，一直到各分区只有一个数为止。\n\n* 动图演示\n\n![这里写图片描述](https://user-gold-cdn.xitu.io/2019/1/17/1685c01b83823cd8?imageslim)\n\n* 编码\n``` JAVA\n/**\n\t * 分区过程\n\t *\n\t * @param arr   待分区数组\n\t * @param left  待分区数组最小下标\n\t * @param right 待分区数组最大下标\n\t */\n\tpublic static void quickSort(int[] arr, int left, int right) {\n\t\tif (left < right) {\n\t\t\tint temp = qSort(arr, left, right);\n\t\t\tquickSort(arr, left, temp - 1);\n\t\t\tquickSort(arr, temp + 1, right);\n\t\t}\n\t}\n\n\t/**\n\t * 排序过程\n\t *\n\t * @param arr   待排序数组\n\t * @param left  待排序数组最小下标\n\t * @param right 待排序数组最大下标\n\t * @return 排好序之后基准数的位置下标，方便下次的分区\n\t */\n\tpublic static int qSort(int[] arr, int left, int right) {\n\t\t// 定义基准数，默认为数组的第一个元素\n\t\tint temp = arr[left];\n\t\t// 循环执行的条件\n\t\twhile (left < right) {\n\t\t\t// 因为默认的基准数是在最左边，所以首先从右边开始比较进入while循环的判断条件\n\t\t\t// 如果当前arr[right]比基准数大，则直接将右指针左移一位，当然还要保证left<right\n\t\t\twhile (left < right && arr[right] > temp) {\n\t\t\t\tright--;\n\t\t\t}\n\t\t\t// 跳出循环说明当前的arr[right]比基准数要小，那么直接将当前数移动到基准数所在的位置，并且左指针向右移一位（left++）\n\t\t\t// 这时当前数（arr[right]）所在的位置空出，需要从左边找一个比基准数大的数来填充。\n\t\t\tif (left < right) {\n\t\t\t\tarr[left++] = arr[right];\n\t\t\t}\n\t\t\t// 下面的步骤是为了在左边找到比基准数大的数填充到right的位置。\n\t\t\t// 因为现在需要填充的位置在右边，所以左边的指针移动，如果arr[left]小于或者等于基准数，则直接将左指针右移一位\n\t\t\twhile (left < right && arr[left] <= temp) {\n\t\t\t\tleft++;\n\t\t\t}\n\t\t\t// 跳出上一个循环说明当前的arr[left]的值大于基准数，需要将该值填充到右边空出的位置，然后当前位置空出。\n\t\t\tif (left < right) {\n\t\t\t\tarr[right--] = arr[left];\n\t\t\t}\n\t\t}\n\t\t// 当循环结束说明左指针和右指针已经相遇。并且相遇的位置是一个空出的位置，\n\t\t// 这时候将基准数填入该位置，并返回该位置的下标，为分区做准备。\n\t\tarr[left] = temp;\n\t\treturn left;\n\t}\n\n```\n\n### 堆排序\n\n* 基本思路\n堆是一种特殊的完全二叉树，分为大顶堆和小顶堆。大顶堆：每个结点的值都大于它的左右子结点的值，升序排序用大顶堆。小顶堆：每个结点的值都小于它的左右子结点的值，降序排序用小顶堆。\n所以，需要先将待排序数组构造成大顶堆的格式，这时候该堆的顶结点就是最大的数，将其与堆的最后一个结点的元素交换。再将剩余的树重新调整成堆，再次首节点与尾结点交换，重复执行直到只剩下最后一个结点完成排序。\n\n* 动图演示\n\n![这里写图片描述](https://user-gold-cdn.xitu.io/2019/1/17/1685c01bbe480b52?imageslim)\n\n* 编码\n``` JAVA\n\tpublic static void heapSort(int[] arr) {\n\t\tif (arr == null) {\n\t\t\treturn;\n\t\t}\n\t\tint len = arr.length;\n\t\t// 初始化大顶堆（从最后一个非叶节点开始，从左到右，由下到上）\n\t\tfor (int i = len / 2 - 1; i >= 0; i--) {\n\t\t\tadjustHeap(arr, i, len);\n\t\t}\n\t\t// 将顶节点和最后一个节点互换位置，再将剩下的堆进行调整\n\t\tfor (int j = len - 1; j > 0; j--) {\n\t\t\tswap(arr, 0, j);\n\t\t\tadjustHeap(arr, 0, j);\n\t\t}\n\t}\n\n\t/**\n\t * 整理树让其变成堆\n\t *\n\t * @param arr 待整理的数组\n\t * @param i   开始的结点\n\t * @param j   数组的长度\n\t */\n\tpublic static void adjustHeap(int[] arr, int i, int j) {\n\t\t// 定义一个变量保存开始的结点\n\t\tint temp = arr[i];\n\t\t// k就是该结点的左子结点下标\n\t\tfor (int k = 2 * i + 1; k < j; k = 2 * k + 1) {\n\t\t\t// 比较左右两个子结点的大小，k始终记录两者中较大值的下标\n\t\t\tif (k + 1 < j && arr[k] < arr[k + 1]) {\n\t\t\t\tk++;\n\t\t\t}\n\t\t\t// 经子结点中的较大值和当前的结点比较，比较结果的较大值放在当前结点位置\n\t\t\tif (arr[k] > temp) {\n\t\t\t\tarr[i] = arr[k];\n\t\t\t\ti = k;\n\t\t\t} else {\n\t\t\t\t// 说明已经是大顶堆\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tarr[i] = temp;\n\t}\n\n\t/**\n\t * 交换数据\n\t *\n\t * @param arr  待整理的数组\n\t * @param num1 开始的结点\n\t * @param num2 交换的节点\n\t */\n\tpublic static void swap(int[] arr, int num1, int num2) {\n\t\tint temp = arr[num1];\n\t\tarr[num1] = arr[num2];\n\t\tarr[num2] = temp;\n\t}\n```\n\n### 基数排序\n\n* 基本思路\n就是将待排序数据拆分成多个关键字进行排序，也就是说，基数排序的实质是多关键字排序。多关键字排序的思路是将待排数据里德排序关键字拆分成多个排序关键字；第1个排序关键字，第2个排序关键字，第3个排序关键字......然后，根据子关键字对待排序数据进行排序。\n\n* 动图演示\n\n![这里写图片描述](https://user-gold-cdn.xitu.io/2019/1/17/1685c01bd10a5893?imageslim)\n\n* 编码\n``` JAVA\npublic static void sort(int[] arr, int radix, int d) {\n\t\t// 缓存数组  \n\t\tint[] tmp = new int[arr.length];\n\t\t// buckets用于记录待排序元素的信息  \n\t\t// buckets数组定义了max-min个桶  \n\t\tint[] buckets = new int[radix];\n\n\t\tfor (int i = 0, rate = 1; i < d; i++) {\n\n\t\t\t// 重置count数组，开始统计下一个关键字  \n\t\t\tjava.util.Arrays.fill(buckets, 0);\n\t\t\t// 将data中的元素完全复制到tmp数组中  \n\t\t\tSystem.arraycopy(arr, 0, tmp, 0, arr.length);\n\n\t\t\t// 计算每个待排序数据的子关键字  \n\t\t\tfor (int j = 0; j < arr.length; j++) {\n\t\t\t\tint subKey = (tmp[j] / rate) % radix;\n\t\t\t\tbuckets[subKey]++;\n\t\t\t}\n\n\t\t\tfor (int j = 1; j < radix; j++) {\n\t\t\t\tbuckets[j] = buckets[j] + buckets[j - 1];\n\t\t\t}\n\n\t\t\t// 按子关键字对指定的数据进行排序  \n\t\t\tfor (int m = arr.length - 1; m >= 0; m--) {\n\t\t\t\tint subKey = (tmp[m] / rate) % radix;\n\t\t\t\tarr[--buckets[subKey]] = tmp[m];\n\t\t\t}\n\t\t\trate *= radix;\n\t\t}\n\t}\n```\n\n### 计数排序\n\n* 基本思路\n计数排序采用了一种全新的思路，不再是通过比较来排序，而是将待排序数组中的最大值+1作为一个临时数组的长度，然后用临时数组记录待排序数组中每个元素出现的次数。最后再遍历临时数组，因为是升序，所以从前到后遍历，将临时数组中值>0的数的下标循环取出，依次放入待排序数组中，即可完成排序。计数排序的效率很高，但是实在牺牲内存的前提下，并且有着限制，那就是待排序数组的值必须 限制在一个确定的范围。\n\n* 动图演示\n\n![这里写图片描述](https://user-gold-cdn.xitu.io/2019/1/17/1685c01bbf2b9faf?imageslim)\n\n* 编码\n``` JAVA\npublic static void sort(int[] arr) {\n\t\tif (arr == null)\n\t\t\treturn;\n\t\tint len = arr.length;\n\t\t// 保存待排序数组中的最大值，目的是确定临时数组的长度（必须）\n\t\tint maxNum = arr[0];\n\t\t// 保存待排序数组中的最小值，目的是确定最终遍历临时数组时下标的初始值（非必需，只是这样可以加快速度，减少循环次数）\n\t\tint minNum = arr[0];\n\t\t// for循环就是为了找到待排序数组的最大值和最小值\n\t\tfor (int i = 1; i < len; i++) {\n\t\t\tmaxNum = maxNum > arr[i] ? maxNum : arr[i];\n\t\t\tminNum = minNum < arr[i] ? minNum : arr[i];\n\t\t}\n\t\t// 创建一个临时数组\n\t\tint[] temp = new int[maxNum + 1];\n\t\t// for循环是为了记录待排序数组中每个元素出现的次数，并将该次数保存到临时数组中\n\t\tfor (int anArr : arr) {\n\t\t\ttemp[anArr]++;\n\t\t}\n\t\t// k=0用来记录待排序数组的下标\n\t\tint k = 0;\n\t\t// 遍历临时数组，重新为待排序数组赋值。\n\t\tfor (int i = minNum; i < temp.length; i++) {\n\t\t\twhile (temp[i] > 0) {\n\t\t\t\tarr[k++] = i;\n\t\t\t\ttemp[i]--;\n\t\t\t}\n\t\t}\n\t}\n```\n\n### 桶排序\n\n* 基本思路\n桶排序其实就是计数排序的强化版，需要利用一个映射函数首先定义有限个数个桶，然后将待排序数组内的元素按照函数映射的关系分别放入不同的桶里边，现在不同的桶里边的数据已经做了区分，比如A桶里的数要么全部大于B桶，要么全部小于B桶里的数。但是A，B桶各自里边的数还是乱序的。所以要借助其他排序方式（快速，插入，归并）分别对每一个元素个数大于一的桶里边的数据进行排序。最后再将桶里边的元素按照顺序依次放入待排序数组中即可。\n\n* 动图演示\n无。。。。。\n\n* 编码\n``` JAVA\npublic static void sort(int[] arr) {\n\t\tif (arr == null)\n\t\t\treturn;\n\t\tint len = arr.length;\n\t\t// 定义桶的个数，这里k的值要视情况而定，这里我们假设待排序数组里的数都是[0,100)之间的。\n\t\tint k = 10;\n\t\t// 用嵌套集合来模拟桶，外层集合表示桶，内层集合表示桶里边装的元素。\n\t\tjava.util.List<java.util.List<Integer>> bucket = new java.util.ArrayList<>();\n\t\t// for循环初始化外层集合即初始化桶\n\t\tfor (int i = 0; i < k; i++) {\n\t\t\tbucket.add(new java.util.ArrayList<>());\n\t\t}\n\t\t// 循环是为了将待排序数组中的元素通过映射函数分别放入不同的桶里边\n\t\tfor (int anArr : arr) {\n\t\t\tbucket.get(anArr / 10).add(anArr);\n\t\t}\n\t\t// 这个循环是为了将所有的元素个数大于1的桶里边的数据进行排序。\n\t\tfor (int i = 0; i < k; i++) {\n\t\t\tif (bucket.size() > 1) {\n\t\t\t\t// 因为这里是用集合来模拟的桶所以用java写好的对集合排序的方法。\n\t\t\t\t// 其实应该自己写一个方法来排序的。\n\t\t\t\tjava.util.Collections.sort(bucket.get(i));\n\t\t\t}\n\n\t\t}\n\t\t// 将排好序的数重新放入待排序数组中\n\t\tint m = 0;\n\t\tfor (java.util.List<Integer> list : bucket) {\n\t\t\tif (list.size() > 0) {\n\t\t\t\tfor (Integer a : list) {\n\t\t\t\t\tarr[m++] = a;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n```","tags":["little_eight"],"categories":["杂类"]},{"title":"Linux命令大全","url":"/2018/12/28/Linux命令大全/","content":"\n# Linux命令大全\n\n## linux 系统管理命令\n\n### adduser\n\n**功能说明**：新增用户帐号。\n**语 法**：adduser\n**补充说明**：在 Slackware 中，adduser 指令是个 script 程序，利用交谈的方式取得\n输入的用户帐号资料，然后再交由真正建立帐号的 useradd 指令建立新用户，如\n此可方便管理员建立用户帐号。在 Red Hat Linux 中，adduser 指令则是 useradd\n指令的符号连接，两者实际上是同一个指令。\n\n### chfn(change finger information)\n**功能说明**：改变 finger 指令显示的信息。\n**语 法**：chfn [-f <真实姓名>][-h <家中电话>][-o <办公地址>][-p <办公电话>][-uv][帐号名称]\n**补充说明**：chfn 指令可用来更改执行 finger 指令时所显示的信息，这些信息都存\n放在/etc 目录里的 asswd 文件里。若不指定任何参数，则 chfn 指令会进入问答式\n界面。\n**参 数**：\n\n* -f<真实姓名>或--full-name<真实姓名> 设置真实姓名。\n* -h<家中电话>或--home-phone<家中电话> 设置家中的电话号码。\n* -o<办公地址>或--office<办公地址> 设置办公室的地址。\n* -p<办公电话>或--office-phone<办公电话> 设置办公室的电话号码。\n* -u 或--help 在线帮助。\n* -v 或-version 显示版本信息。\n### chsh(change shell)\n**功能说明**：更换登入系统时使用的 shell。\n**语 法**：chsh [-luv][-s <shell 名称>][用户名称]\n**补充说明**：每位用户在登入系统时，都会拥有预设的 shell 环境，这个指令可更\n改其预设值。若不指定任何参数与用户名称，则 chsh 会以应答的方式进行设置。\n**参 数**：\n\n* -s<shell 名称>或--shell<shell 名称> 更改系统预设的 shell 环境。\n* -l 或--list-shells 列出目前系统可用的 shell 清单。\n* -u 或--help 在线帮助。\n* -v 或-version 显示版本信息。\n\n<!-- more -->\n### date\n\n**功能说明**：显示或设置系统时间与日期。\n\n**语 法**：\ndate [-d < 字符串>][-u][+%H%I%K%l%M%P%r%s%S%T%X%Z%a%A%b%B%c%d%D%j%m%U\n%w%x%y%Y%n%t] 或 date [-s < 字符串>][-u][MMDDhhmmCCYYss] 或 date [--help][--version]\n\n**补充说明**：第一种语法可用来显示系统日期或时间，以%为开头的参数为格式参\n数，可指定日期或时间的显示格式。第二种语法可用来设置系统日期与时间。只\n有管理员才有设置日期与时间的权限。若不加任何参数，data 会显示目前的日期\n与时间。\n\n**参 数**：\n\n* %H 小时(以 00-23 来表示)。\n* %I 小时(以 01-12 来表示)。\n* %K 小时(以 0-23 来表示)。\n* %l 小时(以 0-12 来表示)。\n* %M 分钟(以 00-59 来表示)。\n* %P AM 或 PM。\n* %r 时间(含时分秒，小时以 12 小时 AM/PM 来表示)。\n* %s 总秒数。起算时间为 1970-01-01 00:00:00 UTC。\n* %S 秒(以本地的惯用法来表示)。\n* %T 时间(含时分秒，小时以 24小时制来表示)。\n* %X 时间(以本地的惯用法来表示)。\n* %Z 市区。\n* %a 星期的缩写。\n* %A 星期的完整名称。\n* %b 月份英文名的缩写。\n* %B 月份的完整英文名称。\n* %c 日期与时间。只输入 date 指令也会显示同样的结果。\n* %d 日期(以 01-31 来表示)。\n* %D 日期(含年月日)。\n* %j 该年中的第几天。\n* %m 月份(以 01-12 来表示)。\n* %U 该年中的周数。\n* %w 该周的天数，0 代表周日，1 代表周一，异词类推。\n* %x 日期(以本地的惯用法来表示)。\n* %y 年份(以 00-99 来表示)。\n* %Y 年份(以四位数来表示)。\n* %n 在显示时，插入新的一行。\n* %t 在显示时，插入 tab。\n* MM 月份(必要)。\n* DD 日期(必要)。\n* hh 小时(必要)。\n* mm 分钟(必要)。\n* CC 年份的前两位数(选择性)。\n* YY 年份的后两位数(选择性)。\n* ss 秒(选择性)。\n* -d<字符串> 显示字符串所指的日期与时间。字符串前后必须加上双引号。\n* -s<字符串> 根据字符串来设置日期与时间。字符串前后必须加上双引号。\n* -u 显示 GMT。\n* --help 在线帮助。\n* --version 显示版本信息。\n* \n### exit\n**功能说明**：退出目前的 shell。\n\n**语 法**：exit [状态值]\n**补充说明**：执行 exit 可使 shell 以指定的状态值退出。若不设置状态值参数，则\nshell 以预设值退出。状态值 0 代表执行成功，其他值代表执行失败。exit 也可用\n在 script，离开正在执行的 script，回到 shell。\n### finger\n**功能说明**：查找并显示用户信息。\n**语 法**：finger [-lmsp][帐号名称...]\n**补充说明**：finger 指令会去查找，并显示指定帐号的用户相关信息，\n包括本地与远端主机的用户皆可，帐号名称没有大小写的差别。单独\n执行 finger 指令，它会显示本地主机现在所有的用户的登陆信息，包\n括帐号名称，真实姓名，登入终端机，闲置时间，登入时间以及地址\n和电话。\n**参 数**：\n\n* -l 列出该用户的帐号名称，真实姓名，用户专属目录，登入所用\n的 Shell，登入时间，转信地址，电子邮件状态，还有计划文件和方\n案文件内容。\n* -m 排除查找用户的真实姓名。\n* -s 列出该用户的帐号名称，真实姓名，登入终端机，闲置时间，\n登入时间以及地址和电话。\n* -p 列出该用户的帐号名称，真实姓名，用户专属目录，登入所用\n的 Shell，登入时间，转信地址，电子邮件状态，但不显示该用户的\n计划文件和方案文件内容。\n\n### free\n**功能说明**：显示内存状态。\n**语 法**： free [-bkmotV][-s <间隔秒数>]\n**补充说明**：free 指令会显示内存的使用情况，包括实体内存，虚拟的交换文件内\n存，共享内存区段，以及系统核心使用的缓冲区等。\n**参 数**：\n\n* -b 以 Byte 为单位显示内存使用情况。\n* -k 以 KB 为单位显示内存使用情况。\n* -m 以 MB 为单位显示内存使用情况。\n* -o 不显示缓冲区调节列。\n* -s<间隔秒数> 持续观察内存使用状况。\n* -t 显示内存总和列。\n* -V 显示版本信息。\n\n### gitps(gnu interactive tools process status)\n**功能说明**：报告程序状况。\n**语 法**：gitps [acefgjlnrsSTuvwxX][p <程序识别码>][t <终端机编号>][U <帐号\n名称>]\n**补充说明**：gitps 是用来报告并管理程序执行的指令，基本上它就是通过 ps 指令\n来报告，管理程序，也能通过 gitps 指令随时中断，删除不必要的程序。因为 gitps\n指令会去执行 ps 指令，所以其参数和 ps 指令相当类似。\n**参 数**：\n\n* a 显示 现行终端机下的所有程序，包括其他用户的程序。 \n* c 列出程序时，显示每个程序真正的指令名称，而不包含路径，参数或是常\n* 驻服务的标示．\n* e 列出程序时，显示每个程序所使用的环境变量。\n* f 用 ASCII 字符显示树状结构，表达程序间的相互关系。\n* g 显示现行终端机下的所有程序，包括群组领导者的程序。\n* j 采用工作控制的格式来显示程序状况。\n* l 采用纤细的格式来显示程序状况。\n* n 以数字来表示 USER 和 WCHAN 栏位。\n* p<程序识别码> 指定程序识别码，并列出该程序的状况。\n* r 只列出现行终端机正在执行中的程序。\n* s 采用程序信号的格式显示程序状况。\n* S 列出程序时，包括已中断的子程序信息。\n* t<终端机机标号> 指定终端机编号，并列出属于该终端机的程序的状况。\n* T 显示现行终端机下的所有程序。\n* u 以用户为主的格式来显示程序状况。\n* U<帐号名称> 列出属于该用户的程序的状况。\n* v 采用虚拟内存的格式显示程序状况。\n* w 采用宽阔的格式来显示程序状况。\n* x 显示所有程序，不以终端机来区分。\n* X 采用旧试的 Linux i386 登陆格式显示程序状况。\n\n### groupdel(group delete)\n**功能说明**：删除群组。\n**语 法**：groupdel [群组名称]\n**补充说明**：需要从系统上删除群组时，可用 groupdel 指令来完成这项工作。倘若\n该群组中仍包括某些用户，则必须先删除这些用户后，方能删除群组。\n### groupmod(group modify)\n**功能说明**：更改群组识别码或名称。\n**语 法**：`groupmod [-g <群组识别码> <-o> ][-n <新群组名称>][群组名称]`\n**补充说明**：需要更改群组的识别码或名称时，可用 groupmod 指令来完成这项工作。\n**参 数**：\n\n* -g <群组识别码> 设置欲使用的群组识别码。\n* -o 重复使用群组识别码。\n* -n <新群组名称> 设置欲使用的群组名称。\n\n### id\n**功能说明**：显示用户的 ID，以及所属群组的 ID。\n**语 法**：id [-gGnru][--help][--version][用户名称]\n**补充说明**：id 会显示用户以及所属群组的实际与有效 ID。若两个 ID 相同，则仅\n显示实际 ID。若仅指定用户名称，则显示目前用户的 ID。\n**参 数**：\n\n* -g 或--group 显示用户所属群组的 ID。\n* -G 或--groups 显示用户所属附加群组的 ID。\n* -n 或--name 显示用户，所属群组或附加群组的名称。\n* -r 或--real 显示实际 ID。\n* -u 或--user 显示用户 ID。\n* -help 显示帮助。 \n* -version 显示版本信息。\n\n### kill\n**功能说明**：删除执行中的程序或工作。\n**语 法**：kill [-s <信息名称或编号>][程序] 或 kill [-l <信息编号>]\n**补充说明**：kill 可将指定的信息送至程序。预设的信息为 SIGTERM(15)，可将指\n定程序终止。若仍无法终止该程序，可使用 SIGKILL(9)信息尝试强制删除程序。\n程序或工作的编号可利用 ps 指令或 jobs 指令查看。\n**参 数**：\n\n* -l <信息编号> 若不加<信息编号>选项，则-l 参数会列出全部的信息名称。\n* -s <信息名称或编号> 指定要送出的信息。\n[程序] [程序]可以是程序的 PID 或是 PGID，也可以是工作编号。\n\n### ps(process status)\n**功能说明**：报告程序状况。\n**语 法**：ps [-aAcdefHjlmNVwy][acefghLnrsSTuvxX][-C <指令名称>][-g <群组\n名称>][-G <群组识别码>][-p <程序识别码>][p <程序识别码>][-s <阶段作业>][-t <终端机编号>][t <终端机编号>][-u <用户识别码>][-U <用户识别码>][U <\n用户名称>][-<程序识别码>][--cols <每列字符数>][--columns <每列字符数>][--cumulative][--deselect][--forest][--headers][--help][--info][--lines < 显示列数>][--no-headers][--group <群组名称>][-Group <群组识别码>][--pid <程序识别码>][--rows <显示列数>][--sid <阶段作业>][--tty <终端机编号>][--user <用户名称>][--User <用户识别码>][--version][--width <每列字符数>] \n**补充说明**：ps 是用来报告程序执行状况的指令，您可以搭配 kill 指令随时中断，\n删除不必要的程序。\n**参 数**：\n\n* -a 显示所有终端机下执行的程序，除了阶段作业领导者之外。\n* a 显示现行终端机下的所有程序，包括其他用户的程序。\n* -A 显示所有程序。\n* -c 显示 CLS 和 PRI 栏位。\n* c 列出程序时，显示每个程序真正的指令名称，而不包含路径，参数或常驻\n服务的标示。\n* -C<指令名称> 指定执行指令的名称，并列出该指令的程序的状况。\n* -d 显示所有程序，但不包括阶段作业领导者的程序。\n* -e 此参数的效果和指定\"A\"参数相同。\n* e 列出程序时，显示每个程序所使用的环境变量。\n* -f 显示 UID,PPIP,C 与 STIME 栏位。\n* f 用 ASCII 字符显示树状结构，表达程序间的相互关系。\n* -g<群组名称> 此参数的效果和指定\"-G\"参数相同，当亦能使用阶段作业领导\n者的名称来指定。\n* g 显示现行终端机下的所有程序，包括群组领导者的程序。\n* -G<群组识别码> 列出属于该群组的程序的状况，也可使用群组名称来指\n定。\n* h 不显示标题列。\n* -H 显示树状结构，表示程序间的相互关系。\n* -j 或 j 采用工作控制的格式显示程序状况。\n* -l 或 l 采用详细的格式来显示程序状况。\n* L 列出栏位的相关信息。\n* -m 或 m 显示所有的执行绪。\n* n 以数字来表示 USER 和 WCHAN 栏位。\n* -N 显示所有的程序，除了执行 ps 指令终端机下的程序之外。\n* -p<程序识别码> 指定程序识别码，并列出该程序的状况。\n* p<程序识别码> 此参数的效果和指定\"-p\"参数相同，只在列表格式方面稍有\n差异。\n* r 只列出现行终端机正在执行中的程序。\n* -s<阶段作业> 指定阶段作业的程序识别码，并列出隶属该阶段作业的程序的\n状况。\n* s 采用程序信号的格式显示程序状况。\n* S 列出程序时，包括已中断的子程序资料。\n* -t<终端机编号> 指定终端机编号，并列出属于该终端机的程序的状况。\n* t<终端机编号> 此参数的效果和指定\"-t\"参数相同，只在列表格式方面稍有差\n异。\n* -T 显示现行终端机下的所有程序。\n* -u<用户识别码> 此参数的效果和指定\"-U\"参数相同。\n* u 以用户为主的格式来显示程序状况。\n* -U<用户识别码> 列出属于该用户的程序的状况，也可使用用户名称来指\n定。\n* U<用户名称> 列出属于该用户的程序的状况。\n* v 采用虚拟内存的格式显示程序状况。\n* -V 或 V 显示版本信息。\n* -w 或 w 采用宽阔的格式来显示程序状况。\n* x 显示所有程序，不以终端机来区分。\n* X 采用旧式的 Linux i386 登陆格式显示程序状况。\n* -y 配合参数\"-l\"使用时，不显示 F(flag)栏位，并以 RSS 栏位取代 ADDR 栏\n位 。\n* -<程序识别码> 此参数的效果和指定\"p\"参数相同。\n* --cols<每列字符数> 设置每列的最大字符数。\n* --columns<每列字符数> 此参数的效果和指定\"--cols\"参数相同。\n13\n* --cumulative 此参数的效果和指定\"S\"参数相同。\n* --deselect 此参数的效果和指定\"-N\"参数相同。\n* --forest 此参数的效果和指定\"f\"参数相同。\n* --headers 重复显示标题列。\n* --help 在线帮助。\n* --info 显示排错信息。\n* --lines<显示列数> 设置显示画面的列数。\n* --no-headers 此参数的效果和指定\"h\"参数相同，只在列表格式方面稍有差\n异。\n* --group<群组名称> 此参数的效果和指定\"-G\"参数相同。\n* --Group<群组识别码> 此参数的效果和指定\"-G\"参数相同。\n* --pid<程序识别码> 此参数的效果和指定\"-p\"参数相同。\n* --rows<显示列数> 此参数的效果和指定\"--lines\"参数相同。\n* --sid<阶段作业> 此参数的效果和指定\"-s\"参数相同。\n* --tty<终端机编号> 此参数的效果和指定\"-t\"参数相同。\n* --user<用户名称> 此参数的效果和指定\"-U\"参数相同。\n* --User<用户识别码> 此参数的效果和指定\"-U\"参数相同。\n* --version 此参数的效果和指定\"-V\"参数相同。\n* --widty<每列字符数> 此参数的效果和指定\"-cols\"参数相同。\n\n### pstree(process status tree)\n**功能说明**：以树状图显示程序。\n**语 法**：pstree [-acGhlnpuUV][-H <程序识别码>][<程序识别码>/<用户名称>]\n**补充说明**：pstree 指令用 ASCII 字符显示树状结构，清楚地表达程序间的相互关\n系。如果不指定程序识别码或用户名称，则会把系统启动时的第一个程序视为基\n层，并显示之后的所有程序。若指定用户名称，便会以隶属该用户的第一个程序\n当作基层，然后显示该用户的所有程序。\n**参 数**：\n\n* -a 显示每个程序的完整指令，包含路径，参数或是常驻服务的标示。\n* -c 不使用精简标示法。 \n* -G 使用 VT100 终端机的列绘图字符。\n* -h 列出树状图时，特别标明现在执行的程序。\n* -H<程序识别码> 此参数的效果和指定\"-h\"参数类似，但特别标明指定的程\n序。\n* -l 采用长列格式显示树状图。\n* -n 用程序识别码排序。预设是以程序名称来排序。\n* -p 显示程序识别码。\n* -u 显示用户名称。\n* -U 使用 UTF-8 列绘图字符。\n* -V 显示版本信息。\n\n### su(super user)\n**功能说明**：变更用户身份。\n**语 法**：su [-flmp][--help][--version][-][-c <指令>][-s <shell>][用户帐号]\n**补充说明**：su 可让用户暂时变更登入的身份。变更时须输入所要变更的用户帐\n号与密码。\n**参 数**：\n\n* -c<指令>或--command=<指令> 执行完指定的指令后，即恢复原来的身份。\n* -f 或--fast 适用于 csh 与 tsch，使 shell 不用去读取启动文件。\n* -.-l 或 --login 改变身份时，也同时变更工作目录，以及HOME,SHELL,USER,LOGNAME。此外，也会变更 PATH 变量。\n* -m,-p 或--preserve-environment 变更身份时，不要变更环境变量。\n* -s<shell>或--shell=<shell> 指定要执行的 shell。\n* --help 显示帮助。\n* --version 显示版本信息。\n[用户帐号] 指定要变更的用户。若不指定此参数，则预设变更为 root。\n\n### sudo\n**功能说明：以其他身份来执行指令。**\n**语 法**：sudo [-bhHpV][-s <shell>][-u <用户>][指令] 或 sudo [-klv]\n**补充说明**：sudo 可让用户以其他的身份来执行指定的指令，预设的身份为 root。\n在/etc/sudoers 中设置了可执行 sudo 指令的用户。若其未经授权的用户企图使用\nsudo，则会发出警告的邮件给管理员。用户使用 sudo 时，必须先输入密码，之\n后有 5 分钟的有效期限，超过期限则必须重新输入密码。\n**参 数**：\n\n* -b 在后台执行指令。\n* -h 显示帮助。\n* -H 将 HOME 环境变量设为新身份的 HOME 环境变量。\n* -k 结束密码的有效期限，也就是下次再执行 sudo 时便需要输入密码。\n* -l 列出目前用户可执行与无法执行的指令。\n* -p 改变询问密码的提示符号。\n* -s<shell> 执行指定的 shell。\n* -u<用户> 以指定的用户作为新的身份。若不加上此参数，则预设以 root 作\n为新的身份。\n* -v 延长密码有效期限 5 分钟。\n* -V 显示版本信息。\n\n### uname\n**功能说明**：显示系统信息。\n**语 法**：uname [-amnrsv][--help][--version]\n**补充说明**：uname 可显示电脑以及操作系统的相关信息。\n**参 数**：\n\n* -a 或--all 显示全部的信息。\n* -m 或--machine 显示电脑类型。\n* -n 或-nodename 显示在网络上的主机名称。\n* -r 或--release 显示操作系统的发行编号。\n* -s 或--sysname 显示操作系统名称。\n* -v 显示操作系统的版本。 \n* --help 显示帮助。\n* --version 显示版本信息。\n###　useradd\n**功能说明**：建立用户帐号。\n**语 法**：useradd [-mMnr][-c <备注>][-d <登入目录>][-e <有效期限>][-f <缓冲\n天 数 >][-g < 群 组 >][-G < 群 组 >][-s <shell>][-u <uid>][ 用户帐\n号] 或 useradd -D [-b][-e < 有效期限>][-f < 缓冲天数>][-g < 群组>][-G < 群组>][-s <shell>]\n**补充说明**：useradd 可用来建立用户帐号。帐号建好之后，再用 passwd 设定帐号\n的密码．而可用 userdel 删除帐号。使用 useradd 指令所建立的帐号，实际上是保\n存在/etc/passwd 文本文件中。\n**参 数**：\n\n* -c<备注> 加上备注文字。备注文字会保存在 passwd 的备注栏位中。\n* -d<登入目录> 指定用户登入时的启始目录。\n* -D 变更预设值．\n* -e<有效期限> 指定帐号的有效期限。\n* -f<缓冲天数> 指定在密码过期后多少天即关闭该帐号。\n* -g<群组> 指定用户所属的群组。\n* -G<群组> 指定用户所属的附加群组。\n* -m 自动建立用户的登入目录。\n* -M 不要自动建立用户的登入目录。\n* -n 取消建立以用户名称为名的群组．\n* -r 建立系统帐号。\n* -s<shell> 指定用户登入后所使用的 shell。\n* -u<uid> 指定用户 ID。\n\n### who\n**功能说明**：显示目前登入系统的用户信息。\n**语 法**：who [-Himqsw][--help][--version][am i][记录文件]\n**补充说明**：执行这项指令可得知目前有那些用户登入系统，单独执行 who 指令\n会列出登入帐号，使用的 终端机，登入时间以及从何处登入或正在使用哪个 X\n显示器。\n**参 数**：\n\n* -H 或--heading 显示各栏位的标题信息列。\n* -i 或-u 或--idle 显示闲置时间，若该用户在前一分钟之内有进行任何动作，\n将标示成\".\"号，如果该用户已超过 24小时没有任何动作，则标示出\"old\"字符串。\n* -m 此参数的效果和指定\"am i\"字符串相同。\n* -q 或--count 只显示登入系统的帐号名称和总人数。\n* -s 此参数将忽略不予处理，仅负责解决 who 指令其他版本的兼容性问题。\n* -w 或-T 或--mesg 或--message 或--writable 显示用户的信息状态栏。\n* --help 在线帮助。\n* --version 显示版本信息。\n\n## linux 系统设置命令\n\n### crontab\n**功能说明**：设置计时器。\n**语 法**：crontab [-u <用户名称>][配置文件] 或 crontab [-u <用户名称>][-elr]\n**补充说明**：cron 是一个常驻服务，它提供计时器的功能，让用户在特定的时间得\n以执行预设的指令或程序。只要用户会编辑计时器的配置文件，就可以使用计时\n器的功能。其配置文件格式如下：\n Minute Hour Day Month DayOFWeek Command\n**参 数**：\n\n* -e 编辑该用户的计时器设置。\n* -l 列出该用户的计时器设置。\n* -r 删除该用户的计时器设置。\n* -u<用户名称> 指定要设定计时器的用户名称。\n\n### dircolors\n**功能说明**：设置 ls 指令在显示目录或文件时所用的色彩。\n**语 法**：dircolors [色彩配置文件] 或 dircolors [-bcp][--help][--version]\n**补充说明**：dircolors 可根据[色彩配置文件]来设置 LS_COLORS 环境变量或是显\n示设置 LS_COLORS 环境变量的 shell 指令。\n**参 数**：\n\n* -b 或--sh 或--bourne-shell 显示在 Boume shell 中，将 LS_COLORS 设为目前\n预设置的 shell 指令。\n* -c 或--csh 或--c-shell 显示在 C shell 中，将 LS_COLORS 设为目前预设置的\nshell 指令。\n* -p 或--print-database 显示预设置\n* -help 显示帮助。\n* -version 显示版本信息。\n\n### rpm(redhat package manager)\n**功能说明**：管理套件。\n**补充说明**：rmp 原本是 Red Hat Linux 发行版专门用来管理 Linux 各项套件的程\n序，由于它遵循 GPL 规则且功能强大方便，因而广受欢迎。逐渐受到其他发行\n版的采用。RPM 套件管理方式的出现，让 Linux 易于安装，升级，间接提升了\nLinux 的适用度。\n**参 数**：省略。\n\n## linux 文档编辑命令\n\n### comm(common)\n**功能说明**：比较两个已排过序的文件。\n**语 法**：comm [-123][--help][--version][第 1 个文件][第 2 个文件]\n**补充说明**：这项指令会一列列地比较两个已排序文件的差异，并将其结果显示出\n来，如果没有指定任何参数，则会把结果分成 3 行显示：第 1 行仅是在第 1 个文\n件中出现过的列，第 2 行是仅在第 2 个文件中出现过的列，第 3 行则是在第 1\n与第 2 个文件里都出现过的列。若给予的文件名称为\"-\"，则 comm 指令会从标\n准输入设备读取数据。\n**参 数**：\n\n * -1 不显示只在第 1 个文件里出现过的列。\n * -2 不显示只在第 2 个文件里出现过的列。\n * -3 不显示只在第 1 和第 2 个文件里出现过的列。\n * --help 在线帮助。\n * --version 显示版本信息。\n \n### egrep\n**功能说明**：在文件内查找指定的字符串。egrep 执行效果如 grep -E，使用的语法\n及参数可参照 grep 指令，与 grep 不同点在于解读字符串的方法，egrep 是用\nextended regular expression 语法来解读，而 grep 则用 basic regular expression 语法，extended regular expression 比 basic regular expression 有更完整的表达规范。\n\n### fgrep(fixed regexp)\n**功能说明**：查找文件里符合条件的字符串。\n**语 法**：fgrep [范本样式][文件或目录...]\n**补充说明**：本指令相当于执行 grep 指令加上参数\"-F\"，详见 grep 指令说明。\n\n### grep\n**功能说明**：查找文件里符合条件的字符串。\n**语 法**：grep [-abcEFGhHilLnqrsvVwxy][-A<显示列数>][-B<显示列数>][-C<\n显示列数>][-d<进行动作>][-e<范本样式>][-f<范本文件>][--help][范本样式][文件\n或目录...] \n**补充说明**：grep 指令用于查找内容包含指定的范本样式的文件，如果发现某文件\n的内容符合所指定的范本样式，预设 grep 指令会把含有范本样式的那一列显示\n出来。若不指定任何文件名称，或是所给予的文件名为“-”，则 grep 指令会从标\n准输入设备读取数据。\n**参 数**：\n\n * -a 或--text 不要忽略二进制的数据。\n * -A<显示列数>或--after-context=<显示列数> 除了显示符合范本样式的那一列\n之外，并显示该列之后的内容。\n * -b 或--byte-offset 在显示符合范本样式的那一列之前，标示出该列第一个字符\n的位编号。\n * -B<显示列数>或--before-context=<显示列数> 除了显示符合范本样式的那一列\n之外，并显示该列之前的内容。\n * -c 或--count 计算符合范本样式的列数。\n * -C<显示列数>或--context=<显示列数>或-<显示列数> 除了显示符合范本样式\n的那一列之外，并显示该列之前后的内容。\n * -d<进行动作>或--directories=<进行动作> 当指定要查找的是目录而非文件时，\n必须使用这项参数，否则 grep 指令将回报信息并停止动作。\n * -e<范本样式>或--regexp=<范本样式> 指定字符串做为查找文件内容的范本样\n式。\n * -E 或--extended-regexp 将范本样式为延伸的普通表示法来使用。\n * -f<范本文件>或--file=<范本文件> 指定范本文件，其内容含有一个或多个范本\n样式，让 grep 查找符合范本条件的文件内容，格式为每列一个范本样式。\n * -F 或--fixed-regexp 将范本样式视为固定字符串的列表。\n * -G 或--basic-regexp 将范本样式视为普通的表示法来使用。\n * -h 或--no-filename 在显示符合范本样式的那一列之前，不标示该列所属的文件\n名称。\n * -H 或--with-filename 在显示符合范本样式的那一列之前，表示该列所属的文件\n名称。\n * -i 或--ignore-case 忽略字符大小写的差别。\n56\n * -l 或--file-with-matches 列出文件内容符合指定的范本样式的文件名称。\n * -L 或--files-without-match 列出文件内容不符合指定的范本样式的文件名称。\n * -n 或--line-number 在显示符合范本样式的那一列之前，标示出该列的列数编\n号。\n * -q 或--quiet 或--silent 不显示任何信息。\n * -r 或--recursive 此参数的效果和指定“-d recurse”参数相同。\n * -s 或--no-messages 不显示错误信息。\n * -v 或--revert-match 反转查找。\n * -V 或--version 显示版本信息。\n * -w 或--word-regexp 只显示全字符合的列。\n * -x 或--line-regexp 只显示全列符合的列。\n * -y 此参数的效果和指定“-i”参数相同。\n * --help 在线帮助。\n \n### look\n**功能说明**：查询单字。\n**语 法**：look [-adf][-t<字尾字符串>][字首字符串][字典文件]\n**补充说明**：look 指令用于英文单字的查询。您仅需给予它欲查询的字首字符串，\n它会显示所有开头字符串符合该条件的单字。\n**参 数**：\n\n * -a 使用另一个字典文件 web2，该文件也位于/usr/dict 目录下。\n * -d 只对比英文字母和数字，其余一慨忽略不予比对。\n * -f 忽略字符大小写差别。\n * -t<字尾字符串> 设置字尾字符串。\n \n### wc(word count)\n**功能说明**：计算字数。\n**语 法**：wc [-clw][--help][--version][文件...]\n**补充说明**：利用 wc 指令我们可以计算文件的 Byte 数、字数、或是列数，若不指\n定文件名称、或是所给予的文件名为“-”，则 wc 指令会从标准输入设备读取数据。\n**参 数**：\n\n * -c 或--bytes 或--chars 只显示 Bytes 数。\n * -l 或--lines 只显示列数。\n * -w 或--words 只显示字数。\n * --help 在线帮助。\n * --version 显示版本信息。\n\n## linux 压缩备份命令\n\n### gunzip(gnu unzip)\n**功能说明**：解压文件。\n**语 法**： gunzip [-acfhlLnNqrtvV][-s < 压缩字尾字符串 >][ 文\n件...] 或 gunzip [-acfhlLnNqrtvV][-s <压缩字尾字符串>][目录]\n**补充说明**：gunzip 是个使用广泛的解压缩程序，它用于解开被 gzip 压缩过的文件，这些\n压缩文件预设最后的扩展名为\".gz\"。事实上 gunzip 就是 gzip 的硬连接，因此不论是压缩\n或解压缩，都可通过 gzip 指令单独完成。\n**参 数**：\n\n* -a 或--ascii 使用 ASCII 文字模式。\n* -c 或--stdout 或--to-stdout 把解压后的文件输出到标准输出设备。\n* -f 或-force 强行解开压缩文件，不理会文件名称或硬连接是否存在以及该文件是否为\n符号连接。\n* -h 或--help 在线帮助。\n* -l 或--list 列出压缩文件的相关信息。\n* -L 或--license 显示版本与版权信息。\n* -n 或--no-name 解压缩时，若压缩文件内含有远来的文件名称及时间戳记，则将其忽\n略不予处理。\n* -N 或--name 解压缩时，若压缩文件内含有原来的文件名称及时间戳记，则将其回存到\n解开的文件上。\n* -q 或--quiet 不显示警告信息。\n* -r 或--recursive 递归处理，将指定目录下的所有文件及子目录一并处理。\n* -S<压缩字尾字符串>或--suffix<压缩字尾字符串> 更改压缩字尾字符串。\n* -t 或--test 测试压缩文件是否正确无误。\n* -v 或--verbose 显示指令执行过程。\n* -V 或--version 显示版本信息。\n\n### gzexe(gzip executable)\n**功能说明**：压缩执行文件。\n**语 法**：gzexe [-d][执行文件...]\n**补充说明**：gzexe 是用来压缩执行文件的程序。当您去执行被压缩过的执行文件时，该文件会自动解压然后继续执行，和使用一般的执行文件相同。\n**参 数**：\n\n* -d 解开压缩文件。\n\n### gzip(gnu zip)\n**功能说明**：压缩文件。\n**语 法**： gzip [-acdfhlLnNqrtvV][-S < 压缩字尾字符串 >][-< 压缩效率>][--best/fast][文件...] 或 gzip [-acdfhlLnNqrtvV][-S <压缩字尾字符串>][-<压缩效率>][--best/fast][目录]\n**补充说明**：gzip 是个使用广泛的压缩程序，文件经它压缩过后，其名称后面会多出\".gz\"的扩展名。\n**参 数**：\n\n* -a 或--ascii 使用 ASCII 文字模式。\n* -c 或--stdout 或--to-stdout 把压缩后的文件输出到标准输出设备，不去更动原始文件。\n* -d 或--decompress 或----uncompress 解开压缩文件。\n* -f 或--force 强行压缩文件。不理会文件名称或硬连接是否存在以及该文件是否为符号\n连接。\n* -h 或--help 在线帮助。\n* -l 或--list 列出压缩文件的相关信息。\n* -L 或--license 显示版本与版权信息。\n* -n 或--no-name 压缩文件时，不保存原来的文件名称及时间戳记。\n* -N 或--name 压缩文件时，保存原来的文件名称及时间戳记。\n* -q 或--quiet 不显示警告信息。\n* -r 或--recursive 递归处理，将指定目录下的所有文件及子目录一并处理。\n* -S<压缩字尾字符串>或----suffix<压缩字尾字符串> 更改压缩字尾字符串。\n* -t 或--test 测试压缩文件是否正确无误。\n* -v 或--verbose 显示指令执行过程。\n* -V 或--version 显示版本信息。\n* -<压缩效率> 压缩效率是一个介于 1－9 的数值，预设值为\"6\"，指定愈大的数值，压\n缩效率就会愈高。\n* --best 此参数的效果和指定\"-9\"参数相同。\n* --fast 此参数的效果和指定\"-1\"参数相同。\n\n### tar(tape archive)\n**功能说明**：备份文件。\n**语 法**：tar [-ABcdgGhiklmMoOpPrRsStuUvwWxzZ][-b <区块数目>][-C <目的目\n录>][-f <备份文件>][-F <Script文件>][-K <文件>][-L <媒体容量>][-N <日期时间>][-T < 范本文件 >][-V < 卷册名称 >][-X < 范本文件 >][-< 设备编号 >< 存储密度>][--after-date=< 日期时间 >][--atime-preserve][--backuup=< 备份方式>][--checkpoint][--concatenate][--confirmation][--delete][--exclude=< 范本样式>][--force-local][--group=< 群组名称>][--help][--ignore-failed-read][--new-volume-script=<Script文件>][--newer-mtime][--no-recursion][--null][--numeric-owner][--owner=< 用户名称>][--posix][--erve][--preserve-order][--preserve-permissions][--record-size=<区块数目>][--recursive-unlink][--remove-files][--rsh-command=< 执行指令>][--same-owner][--suffix=<备份字尾字符串>][--totals][--use-compress-program=<执行指令>][--version][--volno-file=<编号文件>][文件或目录...]\n**补充说明**：tar 是用来建立，还原备份文件的工具程序，它可以加入，解开备份文件内的文件。\n **参数**：\n \n* -A 或--catenate 新增温暖件到已存在的备份文件。\n* -b<区块数目>或--blocking-factor=<区块数目> 设置每笔记录的区块数目，每个区块大小为 12Bytes。\n* -B 或--read-full-records 读取数据时重设区块大小。\n* -c 或--create 建立新的备份文件。\n* -C<目的目录>或--directory=<目的目录> 切换到指定的目录。\n* -d 或--diff 或--compare 对比备份文件内和文件系统上的文件的差异。\n* -f<备份文件>或--file=<备份文件> 指定备份文件。\n* -F<Script文件>或--info-script=<Script文件> 每次更换磁带时，就执行指定的 Script文件。 \n* * -g 或--listed-incremental 处理 GNU 格式的大量备份。\n* -G 或--incremental 处理旧的 GNU 格式的大量备份。\n* -h 或--dereference 不建立符号连接，直接复制该连接所指向的原始文件。\n* -i 或--ignore-zeros 忽略备份文件中的 0 Byte 区块，也就是 EOF。\n* -k 或--keep-old-files 解开备份文件时，不覆盖已有的文件。\n* -K<文件>或--starting-file=<文件> 从指定的文件开始还原。\n* -l 或--one-file-system 复制的文件或目录存放的文件系统，必须与 tar 指令执行时所处的\n文件系统相同，否则不予复制。\n* -L<媒体容量>或-tape-length=<媒体容量> 设置存放每体的容量，单位以 1024 Bytes\n计算。\n*  -m 或--modification-time 还原文件时，不变更文件的更改时间。\n* -M 或--multi-volume 在建立，还原备份文件或列出其中的内容时，采用多卷册模式。\n* -N<日期格式>或--newer=<日期时间> 只将较指定日期更新的文件保存到备份文件里。\n* -o 或--old-archive 或--portability 将资料写入备份文件时使用 V7 格式。\n* -O 或--stdout 把从备份文件里还原的文件输出到标准输出设备。\n* -p 或--same-permissions 用原来的文件权限还原文件。\n* -P 或--absolute-names 文件名使用绝对名称，不移除文件名称前的\"/\"号。\n* -r 或--append 新增文件到已存在的备份文件的结尾部分。\n*  -R 或--block-number 列出每个信息在备份文件中的区块编号。\n*  -s 或--same-order 还原文件的顺序和备份文件内的存放顺序相同。\n*  -S 或--sparse 倘若一个文件内含大量的连续 0 字节，则将此文件存成稀疏文件。\n*  -t 或--list 列出备份文件的内容。\n*  -T<范本文件>或--files-from=<范本文件>指定范本文件，其内含有一个或多个范本样\n式，让 tar 解开或建立符合设置条件的文件。\n*  -u 或--update 仅置换较备份文件内的文件更新的文件。\n*  -U 或--unlink-first 解开压缩文件还原文件之前，先解除文件的连接。\n*  -v 或--verbose 显示指令执行过程。\n*  -V<卷册名称>或--label=<卷册名称> 建立使用指定的卷册名称的备份文件。\n*  -w 或--interactive 遭遇问题时先询问用户。\n* -W 或--verify 写入备份文件后，确认文件正确无误。\n* -x 或--extract 或--get 从备份文件中还原文件。\n*  -X<范本文件>或--exclude-from=<范本文件> 指定范本文件，其内含有一个或多个范本样式，让 ar 排除符合设置条件的文件。\n*  -z 或--gzip 或--ungzip 通过 gzip 指令处理备份文件。\n*  -Z 或--compress 或--uncompress 通过 compress 指令处理备份文件。\n* -<设备编号><存储密度> 设置备份用的外围设备编号及存放数据的密度。\n*  --after-date=<日期时间> 此参数的效果和指定\"-N\"参数相同。\n*  --atime-preserve 不变更文件的存取时间。\n*  --backup=<备份方式>或--backup 移除文件前先进行备份。\n*  --checkpoint 读取备份文件时列出目录名称。\n*  --concatenate 此参数的效果和指定\"-A\"参数相同。\n*  --confirmation 此参数的效果和指定\"-w\"参数相同。\n*  --delete 从备份文件中删除指定的文件。\n*  --exclude=<范本样式> 排除符合范本样式的问家。\n*  --group=<群组名称> 把加入设备文件中的文件的所属群组设成指定的群组。\n*  --help 在线帮助。\n*   --ignore-failed-read 忽略数据读取错误，不中断程序的执行。\n* --new-volume-script=<Script文件> 此参数的效果和指定\"-F\"参数相同。\n*  --newer-mtime 只保存更改过的文件。\n*  --no-recursion 不做递归处理，也就是指定目录下的所有文件及子目录不予处理。\n*  --null 从 null 设备读取文件名称。\n*  --numeric-owner 以用户识别码及群组识别码取代用户名称和群组名称。\n*  --owner=<用户名称> 把加入备份文件中的文件的拥有者设成指定的用户。\n*  --posix 将数据写入备份文件时使用 POSIX 格式。\n*  --preserve 此参数的效果和指定\"-ps\"参数相同。\n*  --preserve-order 此参数的效果和指定\"-A\"参数相同。\n*  --preserve-permissions 此参数的效果和指定\"-p\"参数相同。\n*  --record-size=<区块数目> 此参数的效果和指定\"-b\"参数相同。\n*  --recursive-unlink　解开压缩文件还原目录之前，先解除整个目录下所有文件的连接。\n* --remove-files 文件加入备份文件后，就将其删除。\n*  --rsh-command=<执行指令> 设置要在远端主机上执行的指令，以取代 rsh 指令。\n*  --same-owner 尝试以相同的文件拥有者还原问家你。\n* --suffix=<备份字尾字符串> 移除文件前先行备份。\n* --totals 备份文件建立后，列出文件大小。\n* --use-compress-program=<执行指令> 通过指定的指令处理备份文件。\n*  --version 显示版本信息。\n*  --volno-file=<编号文件> 使用指定文件内的编号取代预设的卷册编号。\n \n### unarj\n**功能说明**：解压缩.arj 文件。\n**语 法**：unarj [eltx][.arj 压缩文件]\n**补充说明**：unarj 为.arj 压缩文件的压缩程序。\n**参 数**：\n\n*  e 解压缩.arj 文件。\n*  l 显示压缩文件内所包含的文件。\n*  t 检查压缩文件是否正确。\n*  x 解压缩时保留原有的路径。\n \n### unzip\n**功能说明**：解压缩 zip 文件\n**语 法**：unzip [-cflptuvz][-agCjLMnoqsVX][-P <密码>][.zip 文件][文件][-d <目录>][-x <文件>] 或 unzip [-Z]\n**补充说明**：unzip 为.zip 压缩文件的解压缩程序。\n**参 数**：\n\n*  -c 将解压缩的结果显示到屏幕上，并对字符做适当的转换。\n*  -f 更新现有的文件。\n*  -l 显示压缩文件内所包含的文件。\n*  -p 与-c 参数类似，会将解压缩的结果显示到屏幕上，但不会执行任何的转换。\n*  -t 检查压缩文件是否正确。\n*  -u 与-f 参数类似，但是除了更新现有的文件外，也会将压缩文件中的其他文件解压缩到目录中。\n*  -v 执行是时显示详细的信息。\n*  -z 仅显示压缩文件的备注文字。\n*  -a 对文本文件进行必要的字符转换。\n*  -b 不要对文本文件进行字符转换。\n*  -C 压缩文件中的文件名称区分大小写。\n*  -j 不处理压缩文件中原有的目录路径。\n*  -L 将压缩文件中的全部文件名改为小写。\n*  -M 将输出结果送到 more 程序处理。\n*  -n 解压缩时不要覆盖原有的文件。\n*  -o 不必先询问用户，unzip 执行后覆盖原有文件。\n*  -P<密码> 使用 zip 的密码选项。\n*  -q 执行时不显示任何信息。\n*  -s 将文件名中的空白字符转换为底线字符。\n*  -V 保留 VMS 的文件版本信息。\n*  -X 解压缩时同时回存文件原来的 UID/GID。\n [.zip 文件] 指定.zip 压缩文件。\n [文件] 指定要处理.zip 压缩文件中的哪些文件。\n*  -d<目录> 指定文件解压缩后所要存储的目录。\n*  -x<文件> 指定不要处理.zip 压缩文件中的哪些文件。\n*  -Z unzip -Z 等于执行 zipinfo 指令。\n \n### zip\n**功能说明**：压缩文件。\n**语 法**：zip [-AcdDfFghjJKlLmoqrSTuvVwXyz$][-b <工作目录>][-ll][-n <字尾字\n符串>][-t <日期时间>][-<压缩效率>][压缩文件][文件...][-i <范本样式>][-x <范本样式>]\n**补充说明**：zip 是个使用广泛的压缩程序，文件经它压缩后会另外产生具有\".zip\"扩展名的压缩文件。\n**参 数**：\n\n*  -A 调整可执行的自动解压缩文件。\n*  -b<工作目录> 指定暂时存放文件的目录。\n*  -c 替每个被压缩的文件加上注释。\n*  -d 从压缩文件内删除指定的文件。\n*  -D 压缩文件内不建立目录名称。\n*  -f 此参数的效果和指定\"-u\"参数类似，但不仅更新既有文件，如果某些文件原本不存在于压缩文件内，使用本参数会一并将其加入压缩文件中。\n*  -F 尝试修复已损坏的压缩文件。\n*  -g 将文件压缩后附加在既有的压缩文件之后，而非另行建立新的压缩文件。\n*  -h 在线帮助。\n*  -i<范本样式> 只压缩符合条件的文件。\n*  -j 只保存文件名称及其内容，而不存放任何目录名称。\n*  -J 删除压缩文件前面不必要的数据。\n*  -k 使用 MS-DOS 兼容格式的文件名称。\n*  -l 压缩文件时，把 LF 字符置换成 LF+CR 字符。\n*  -ll 压缩文件时，把 LF+CR 字符置换成 LF 字符。\n*  -L 显示版权信息。\n*  -m 将文件压缩并加入压缩文件后，删除原始文件，即把文件移到压缩文件中。\n*  -n<字尾字符串> 不压缩具有特定字尾字符串的文件。\n*  -o 以压缩文件内拥有最新更改时间的文件为准，将压缩文件的更改时间设成和该文件相同。\n*  -q 不显示指令执行过程。\n*  -r 递归处理，将指定目录下的所有文件和子目录一并处理。\n*  -S 包含系统和隐藏文件。\n*  -t<日期时间> 把压缩文件的日期设成指定的日期。\n*  -T 检查备份文件内的每个文件是否正确无误。\n* -u 更换较新的文件到压缩文件内。\n*  -v 显示指令执行过程或显示版本信息。\n*  -V 保存 VMS 操作系统的文件属性。\n*  -w 在文件名称里假如版本编号，本参数仅在 VMS 操作系统下有效。\n*  -x<范本样式> 压缩时排除符合条件的文件。\n*  -X 不保存额外的文件属性。\n*  -y 直接保存符号连接，而非该连接所指向的文件，本参数仅在 UNIX 之类的系统下有效。\n*  -z 替压缩文件加上注释。\n*  -$ 保存第一个被压缩文件所在磁盘的卷册名称。\n*  -<压缩效率> 压缩效率是一个介于 1-9 的数值。\n \n## linux 文件管理命令\n\n### diff(differential)\n**功能说明**：比较文件的差异。\n**语 法**：diff [-abBcdefHilnNpPqrstTuvwy][-<行数>][-C <行数>][-D <巨集名称\n>][-I < 字符或字符串 >][-S < 文 件 >][-W < 宽 度 >][-x < 文件或目录 >][-X < 文 件>][--help][--left-column][--suppress-common-line][文件或目录 1][文件或目录 2]\n**补充说明**：diff 以逐行的方式，比较文本文件的异同处。所是指定要比较目录，则 diff 会比较目录中相同文件名的文件，但不会比较其中子目录。\n**参 数**：\n\n* -<行数> 指定要显示多少行的文本。此参数必须与-c 或-u 参数一并使用。\n* -a 或--text diff 预设只会逐行比较文本文件。\n* -b 或--ignore-space-change 不检查空格字符的不同。\n* -B 或--ignore-blank-lines 不检查空白行。\n* -c 显示全部内文，并标出不同之处。\n* -C<行数>或--context<行数> 与执行\"-c-<行数>\"指令相同。\n* -d 或--minimal 使用不同的演算法，以较小的单位来做比较。\n* -D<巨集名称>或 ifdef<巨集名称> 此参数的输出格式可用于前置处理器巨集。\n* -e 或--ed 此参数的输出格式可用于 ed 的 script 文件。\n* -f 或-forward-ed 输出的格式类似 ed 的script文件，但按照原来文件的顺序来显示不同处。\n* -H 或--speed-large-files 比较大文件时，可加快速度。\n* -l<字符或字符串>或--ignore-matching-lines<字符或字符串> 若两个文件在某几行有\n所不同，而这几行同时都包含了选项中指定的字符或字符串，则不显示这两个文件的差异。\n* -i 或--ignore-case 不检查大小写的不同。\n* -l 或--paginate 将结果交由 pr 程序来分页。\n* -n 或--rcs 将比较结果以 RCS 的格式来显示。\n* -N 或--new-file 在比较目录时，若文件 A 仅出现在某个目录中，预设会显示：\nOnly in 目录：文件 A 若使用-N 参数，则 diff 会将文件 A 与一个空白的文件比较。\n* -p 若比较的文件为 C 语言的程序码文件时，显示差异所在的函数名称。\n* -P 或--unidirectional-new-file 与-N 类似，但只有当第二个目录包含了一个第一个目\n录所没有的文件时，才会将这个文件与空白的文件做比较。\n* -q 或--brief 仅显示有无差异，不显示详细的信息。\n* -r 或--recursive 比较子目录中的文件。\n* -s 或--report-identical-files 若没有发现任何差异，仍然显示信息。\n* -S<文件>或--starting-file<文件> 在比较目录时，从指定的文件开始比较。\n* -t 或--expand-tabs 在输出时，将 tab 字符展开。\n* -T 或--initial-tab 在每行前面加上 tab 字符以便对齐。\n* -u,-U<列数>或--unified=<列数> 以合并的方式来显示文件内容的不同。\n* -v 或--version 显示版本信息。\n* -w 或--ignore-all-space 忽略全部的空格字符。\n* -W<宽度>或--width<宽度> 在使用-y 参数时，指定栏宽。\n* -x<文件名或目录>或--exclude<文件名或目录> 不比较选项中所指定的文件或目录。\n* -X<文件>或--exclude-from<文件> 您可以将文件或目录类型存成文本文件，然后在\n=<文件>中指定此文本文件。\n* -y 或--side-by-side 以并列的方式显示文件的异同之处。\n* --help 显示帮助。\n* --left-column 在使用-y 参数时，若两个文件某一行内容相同，则仅在左侧的栏位显示该行内容。\n* --suppress-common-lines 在使用-y 参数时，仅显示不同之处。\n \n### find\n**功能说明**：查找文件或目录。\n**语 法**：find [目录...][-amin <分钟>][-anewer <参考文件或目录>][-atime <24小时数 >][-cmin < 分 钟 >][-cnewer < 参考文件或目录 >][-ctime <24小时数>][-daystart][-depyh][-empty][-exec < 执行指令 >][-false][-fls < 列表文件>][-follow][-fprint <列表文件>][-fprint0 <列表文件>][-fprintf<列表文件><输出格式>][-fstype <文件系统类型>][-gid <群组识别码>][-group <群组名称>][-help][-ilname <\n范本样式>][-iname <范本样式>][-inum <inode 编号>][-ipath <范本样式>][-iregex <范本样式 >][-links < 连接数目 >][-lname < 范本样式 >][-ls][-maxdepth < 目录层级>][-mindepth <目录层级>][-mmin <分钟>][-mount]\n[-mtime <24小时数 >][-name < 范本样式 >][-newer < 参考文件或目录>][-nogroup][noleaf] [-nouser][-ok <执行指令>][-path <范本样式>][-perm <权限数值>][-print][-print0][-printf <输出格式>][-prune][-regex <范本样式>][-size <文件大小>][-true][-type <文件类型>][-uid <用户识别码>][-used <日数>][-user <拥有者名称>][-version][-xdev][-xtype <文件类型>]\n**补充说明**：find 指令用于查找符合条件的文件。任何位于参数之前的字符串都将被视为欲查找的目录。\n**参 数**：\n\n* -amin<分钟> 查找在指定时间曾被存取过的文件或目录，单位以分钟计算。\n* -anewer<参考文件或目录> 查找其存取时间较指定文件或目录的存取时间更接近现在\n的文件或目录。\n* -atime<24小时数> 查找在指定时间曾被存取过的文件或目录，单位以 24小时计算。\n* -cmin<分钟> 查找在指定时间之时被更改的文件或目录。\n* -cnewer<参考文件或目录> 查找其更改时间较指定文件或目录的更改时间更接近现在\n的文件或目录。\n* -ctime<24小时数> 查找在指定时间之时被更改的文件或目录，单位以 24小时计算。\n* -daystart 从本日开始计算时间。\n* -depth 从指定目录下最深层的子目录开始查找。\n* -expty 寻找文件大小为 0 Byte 的文件，或目录下没有任何子目录或文件的空目录。\n* -exec<执行指令> 假设 find 指令的回传值为 True，就执行该指令。\n* -false 将 find 指令的回传值皆设为 False。\n* -fls<列表文件> 此参数的效果和指定\"-ls\"参数类似，但会把结果保存为指定的列表文\n件。\n* -follow 排除符号连接。\n* -fprint<列表文件> 此参数的效果和指定\"-print\"参数类似，但会把结果保存成指定的列表文件。\n* -fprint0<列表文件> 此参数的效果和指定\"-print0\"参数类似，但会把结果保存成指定\n的列表文件。\n* -fprintf<列表文件><输出格式> 此参数的效果和指定\"-printf\"参数类似，但会把结果保存成指定的列表文件。\n* -fstype<文件系统类型> 只寻找该文件系统类型下的文件或目录。\n* -gid<群组识别码> 查找符合指定之群组识别码的文件或目录。\n* -group<群组名称> 查找符合指定之群组名称的文件或目录。\n* -help 或--help 在线帮助。\n* -ilname<范本样式> 此参数的效果和指定\"-lname\"参数类似，但忽略字符大小写的差\n别。\n* -iname<范本样式> 此参数的效果和指定\"-name\"参数类似，但忽略字符大小写的差\n别。\n* -inum<inode 编号> 查找符合指定的 inode 编号的文件或目录。\n* -ipath<范本样式> 此参数的效果和指定\"-ipath\"参数类似，但忽略字符大小写的差别。\n* -iregex<范本样式> 此参数的效果和指定\"-regexe\"参数类似，但忽略字符大小写的差\n别。\n* -links<连接数目> 查找符合指定的硬连接数目的文件或目录。\n* -iname<范本样式> 指定字符串作为寻找符号连接的范本样式。\n* -ls 假设 find 指令的回传值为 True，就将文件或目录名称列出到标准输出。\n* -maxdepth<目录层级> 设置最大目录层级。\n* -mindepth<目录层级> 设置最小目录层级。\n* -mmin<分钟> 查找在指定时间曾被更改过的文件或目录，单位以分钟计算。\n* -mount 此参数的效果和指定\"-xdev\"相同。\n* -mtime<24小时数> 查找在指定时间曾被更改过的文件或目录，单位以 24小时计算。\n* -name<范本样式> 指定字符串作为寻找文件或目录的范本样式。\n* -newer<参考文件或目录> 查找其更改时间较指定文件或目录的更改时间更接近现在\n的文件或目录。\n* -nogroup 找出不属于本地主机群组识别码的文件或目录。\n* -noleaf 不去考虑目录至少需拥有两个硬连接存在。\n* -nouser 找出不属于本地主机用户识别码的文件或目录。\n* -ok<执行指令> 此参数的效果和指定\"-exec\"参数类似，但在执行指令之前会先询问用\n户，若回答\"y\"或\"Y\"，则放弃执行指令。\n* -path<范本样式> 指定字符串作为寻找目录的范本样式。\n* -perm<权限数值> 查找符合指定的权限数值的文件或目录。\n* -print 假设 find 指令的回传值为True，就将文件或目录名称列出到标准输出。格式为每列一个名称，每个名称之前皆有\"./\"字符串。\n* -print0 假设 find 指令的回传值为 True，就将文件或目录名称列出到标准输出。格式\n为全部的名称皆在同一行。\n* -printf<输出格式> 假设find指令的回传值为True，就将文件或目录名称列出到标准输出。格式可以自行指定。\n* -prune 不寻找字符串作为寻找文件或目录的范本样式。\n* -regex<范本样式> 指定字符串作为寻找文件或目录的范本样式。\n* -size<文件大小> 查找符合指定的文件大小的文件。\n* -true 将 find 指令的回传值皆设为 True。\n* -typ<文件类型> 只寻找符合指定的文件类型的文件。\n* -uid<用户识别码> 查找符合指定的用户识别码的文件或目录。\n* -used<日数> 查找文件或目录被更改之后在指定时间曾被存取过的文件或目录，单位以\n日计算。\n* -user<拥有者名称> 查找符合指定的拥有者名称的文件或目录。\n* -version 或--version 显示版本信息。\n* -xdev 将范围局限在先行的文件系统中。\n* -xtype<文件类型> 此参数的效果和指定\"-type\"参数类似，差别在于它针对符号连接检\n查。\n\n### git(gnu interactive tools)\n**功能说明**：文字模式下的文件管理员。\n**语 法**：git\n**补充说明**：git 是用来管理文件的程序，它十分类似 DOS 下的 Norton Commander，具\n有互动式操作界面。它的操作方法和 Norton Commander 几乎一样，略诉如下：\n\n*  F1 ：执行 info 指令，查询指令相关信息，会要求您输入欲查询的名称。\n*  F2 ：执行 cat 指令，列出文件内容。\n*  F3 ：执行 gitview 指令，观看文件内容。\n*  F4 ：执行 vi 指令，编辑文件内容。\n*  F5 ：执行 cp 指令，复制文件或目录，会要求您输入目标文件或目录。\n*  F6 ：执行 mv 指令，移动文件或目录，或是更改其名称，会要求您输入目标文件或目录。\n*  F7 ：执行 mkdir 指令，建立目录。\n*  F8 ：执行 rm 指令，删除文件或目录。\n*  F9 ：执行 make 指令，批处理执行指令或编译程序时，会要求您输入相关命令。\n*  F10 ：离开 git 文件管理员。\n\n### lsattr(list attribute)\n**功能说明**：显示文件属性。\n**语 法**：lsattr [-adlRvV][文件或目录...]\n**补充说明**：用 chattr 执行改变文件或目录的属性，可执行lsattr指令查询其属性。\n**参 数**：\n\n*  -a 显示所有文件和目录，包括以\".\"为名称开头字符的额外内建，现行目录\".\"与上层目录\"..\"。\n*  -d 显示，目录名称，而非其内容。\n*  -l 此参数目前没有任何作用。\n*  -R 递归处理，将指定目录下的所有文件及子目录一并处理。\n*  -v 显示文件或目录版本。\n*  -V 显示版本信息。\n\n### rcp(remote copy)\n**功能说明**：远端复制文件或目录。\n**语 法**：rcp [-pr][源文件或目录][目标文件或目录] 或 rcp [-pr][源文件或目\n录...][目标文件]\n**补充说明**：rcp 指令用在远端复制文件或目录，如同时指定两个以上的文件或目\n录，且最后的目的地是一个已经存在的目录，则它灰把前面指定的所有文件或目\n录复制到该目录中。\n**参 数**：\n\n*  -p 保留源文件或目录的属性，包括拥有者，所属群组，权限与时间。\n*  -r 递归处理，将指定目录下的文件与子目录一并处理。\n\n### rm(remove)\n**功能说明**：删除文件或目录。\n**语 法**：rm [-dfirv][--help][--version][文件或目录...]\n**补充说明**：执行 rm 指令可删除文件或目录，如欲删除目录必须加上参数\"-r\"，\n否则预设仅会删除文件。\n**参 数**：\n\n* -d 或--directory 直接把欲删除的目录的硬连接数据删成 0，删除该目录。\n* -f 或--force 强制删除文件或目录。\n* -i 或--interactive 删除既有文件或目录之前先询问用户。\n* -r 或-R 或--recursive 递归处理，将指定目录下的所有文件及子目录一并处理。\n* -v 或--verbose 显示指令执行过程。\n* --help 在线帮助。\n* --version 显示版本信息。\n\n### touch\n**功能说明**：改变文件或目录时间。\n**语 法**：touch [-acfm][-d <日期时间>][-r <参考文件或目录>][-t <日期时间>][--help] [--version][文件或目录...] 或touch[-acfm][--help][--version][日期时间][文件或目录...]\n**补充说明**：使用 touch 指令可更改文件或目录的日期时间，包括存取时间和更改\n时间。\n**参 数**：\n\n* -a 或--time=atime 或--time=access 或--time=use 只更改存取时间。\n* -c 或--no-create 不建立任何文件。\n* -d<时间日期> 使用指定的日期时间，而非现在的时间。\n* -f 此参数将忽略不予处理，仅负责解决 BSD 版本 touch 指令的兼容性问题。\n* -m 或--time=mtime 或--time=modify 只更改变动时间。\n* -r<参考文件或目录> 把指定文件或目录的日期时间，统统设成和参考文件或\n目录的日期时间相同。\n* -t<日期时间> 使用指定的日期时间，而非现在的时间。\n* --help 在线帮助。\n* --version 显示版本信息。\n\n### cat\n**使用权限**：所有使用者\n**使用方式**：cat [-AbeEnstTuv] [--help] [--version] fileName\n**说明**：把档案串连接后传到基本输出（萤幕或加 > fileName 到另一个档案）\n**参数**：\n\n* -n 或 --number 由 1 开始对所有输出的行数编号\n* -b 或 --number-nonblank 和 -n 相似，只不过对于空白行不编号\n* -s 或 --squeeze-blank 当遇到有连续两行以上的空白行，就代换为一行的空白行\n* -v 或 --show-nonprinting\n**范例**：\n* cat -n textfile1 > textfile2 把 textfile1 的档案内容加上行号后输入 textfile2 这个档案里\n* cat -b textfile1 textfile2 >> textfile3 把 textfile1 和 textfile2 的档案内容加上行号（空白行不加）之后将内容附加到 textfile3 里。\n\n### chgrp(change group)\n**功能说明**：变更文件或目录的所属群组。\n**语 法**： chgrp [-cfhRv][--help][--version][ 所属群组 ][ 文件或目录...] 或 chgrp [-cfhRv][--help][--reference=<参考文件或目录>][--version][文件或目录...]\n**补充说明**：在 UNIX 系统家族里，文件或目录权限的掌控以拥有者及所属群组来\n管理。您可以使用 chgrp 指令去变更文件与目录的所属群组，设置方式采用群组\n名称或群组识别码皆可。\n**参 数**：\n\n* -c 或--changes 效果类似\"-v\"参数，但仅回报更改的部分。\n* -f 或--quiet 或--silent 不显示错误信息。\n* -h 或--no-dereference 只对符号连接的文件作修改，而不更动其他任何相关文\n件。\n* -R 或--recursive 递归处理，将指定目录下的所有文件及子目录一并处理。\n* -v 或--verbose 显示指令执行过程。\n* --help 在线帮助。\n* --reference=<参考文件或目录> 把指定文件或目录的所属群组全部设成和参\n考文件或目录的所属群组相同。\n* --version 显示版本信息。\n\n### chmod(change mode)\n**功能说明**：变更文件或目录的权限。\n**语 法**：chmod [-cfRv][--help][--version][<权限范围>+/-/=<权限设置...>][文件\n或目录 ...] 或 chmod [-cfRv][--help][--version][ 数字代号 ][ 文件或目\n录...] 或 chmod [-cfRv][--help][--reference=<参考文件或目录>][--version][文件或目录...]\n**补充说明**：在 UNIX 系统家族里，文件或目录权限的控制分别以读取，写入，执\n行 3 种一般权限来区分，另有 3 种特殊权限可供运用，再搭配拥有者与所属群组\n管理权限范围。您可以使用 chmod 指令去变更文件与目录的权限，设置方式采\n用文字或数字代号皆可。符号连接的权限无法变更，如果您对符号连接修改权限，\n其改变会作用在被连接的原始文件。权限范围的表示法如下：\n\n* u：User，即文件或目录的拥有者。\n* g：Group，即文件或目录的所属群组。\n* o：Other，除了文件或目录拥有者或所属群组之外，其他用户皆属于这个范围。\n* a：All，即全部的用户，包含拥有者，所属群组以及其他用户。\n 有关权限代号的部分，列表于下：\n* r：读取权限，数字代号为\"4\"。\n* w：写入权限，数字代号为\"2\"。\n* x：执行或切换权限，数字代号为\"1\"。\n* -：不具任何权限，数字代号为\"0\"。\n* s：特殊?b>功能说明：变更文件或目录的权限。\n参 数：\n* -c 或--changes 效果类似\"-v\"参数，但仅回报更改的部分。\n* -f 或--quiet 或--silent 不显示错误信息。\n* -R 或--recursive 递归处理，将指定目录下的所有文件及子目录一并处理。\n* -v 或--verbose 显示指令执行过程。\n* --help 在线帮助。\n* --reference=<参考文件或目录> 把指定文件或目录的权限全部设成和参考文件或目录的权限相同\n* --version 显示版本信息。\n\n### chown(change owner)\n**功能说明**：变更文件或目录的拥有者或所属群组。\n**语 法**：chown [-cfhRv][--dereference][--help][--version][拥有者.<所属群组>][文件或目录..] 或 chown [-chfRv][--dereference][--help][--version][.所属群组][文件或\n目录... ...] 或 chown[-cfhRv][--dereference][--help][--reference=<参考文件或目录>][--version][文件或目录...]\n**补充说明**：在 UNIX 系统家族里，文件或目录权限的掌控以拥有者及所属群组来\n管理。您可以使用 chown 指令去变更文件与目录的拥有者或所属群组，设置方\n式采用用户名称或用户识别码皆可，设置群组则用群组名称或群组识别码。\n**参 数**：\n* -c 或--changes 效果类似\"-v\"参数，但仅回报更改的部分。\n* -f 或--quite 或--silent 不显示错误信息。\n* -h 或--no-dereference 之对符号连接的文件作修改，而不更动其他任何相关文\n件。\n* -R 或--recursive 递归处理，将指定目录下的所有文件及子目录一并处理。\n* -v 或--version 显示指令执行过程。\n* --dereference 效果和\"-h\"参数相同。\n* --help 在线帮助。\n* --reference=<参考文件或目录> 把指定文件或目录的拥有者与所属群组全部\n设成和参考文件或目 录的拥有者与所属群组相同。\n* --version 显示版本信息。\n\n### cp(copy)\n**功能说明**：复制文件或目录。\n**语 法**： cp [-abdfilpPrRsuvx][-S < 备份字尾字符串 >][-V < 备份方式>][--help][--spares=<使用时机>][--version][源文件或目录][目标文件或目录] [目的目录]\n**补充说明**：cp 指令用在复制文件或目录，如同时指定两个以上的文件或目录，\n且最后的目的地是一个已经存在的目录，则它会把前面指定的所有文件或目录复\n制到该目录中。若同时指定多个文件或目录，而最后的目的地并非是一个已存在\n的目录，则会出现错误信息。\n**参 数**：\n\n* -a 或--archive 此参数的效果和同时指定\"-dpR\"参数相同。\n* -b 或--backup 删除，覆盖目标文件之前的备份，备份文件会在字尾加上一个\n备份字符串。\n* -d 或--no-dereference 当复制符号连接时，把目标文件或目录也建立为符号连\n接，并指向与源文件或目录连接的原始文件或目录。\n* -f 或--force 强行复制文件或目录，不论目标文件或目录是否已存在。\n* -i 或--interactive 覆盖既有文件之前先询问用户。\n* -l 或--link 对源文件建立硬连接，而非复制文件。\n* -p 或--preserve 保留源文件或目录的属性。\n* -P 或--parents 保留源文件或目录的路径。\n* -r 递归处理，将指定目录下的文件与子目录一并处理。\n* -R 或--recursive 递归处理，将指定目录下的所有文件与子目录一并处理。\n* -s 或--symbolic-link 对源文件建立符号连接，而非复制文件。\n* -S<备份字尾字符串>或--suffix=<备份字尾字符串> 用\"-b\"参数备份目标文件\n后，备份文件的字尾会被加上一个备份字符串，预设的备份字尾字符串是符号\n\"~\"。\n* -u 或--update 使用这项参数后只会在源文件的更改时间较目标文件更新时或\n是 名称相互对应的目标文件并不存在，才复制文件。\n* -v 或--verbose 显示指令执行过程。\n* -V<备份方式>或--version-control=<备份方式> 用\"-b\"参数备份目标文件后，\n备份文件的字尾会被加上一个备份字符串，这字符串不仅可用\"-S\"参数变更，当\n使用\"-V\"参数指定不同备份方式时，也会产生不同字尾的备份字串。\n* -x 或--one-file-system 复制的文件或目录存放的文件系统，必须与 cp 指令执\n行时所处的文件系统相同，否则不予复制。\n* --help 在线帮助。\n* --sparse=<使用时机> 设置保存稀疏文件的时机。\n* --version 显示版本信息。\n\n### cut\n**使用权限**：所有使用者\n**用法**：cut -cnum1-num2 filename\n**说明**：显示每行从开头算起 num1 到 num2 的文字。\n**范例**：\n shell>> cat example\n test2\n this is test1\n shell>> cut -c0-6 example ## print 开头算起前 6 个字元\n test2\n this i \n \n ## linux 文件传输命令\n \n### ncftp(nc file transfer protocol)\n**功能说明**：传输文件。\n**语 法**：ncftp [主机或 IP 地址]\n**补充说明**：FTP 让用户得以下载存放于服务器主机的文件，也能将文件上传到远\n端主机放置。NcFTP 是文字模式 FTP 程序的佼佼者，它具备多样特色， 包括显\n示传输速率，下载进度，自动续传，标住书签，可通过防火墙和代理服务器等。\n\n### tftp(trivial file transfer protocol)\n**功能说明**：传输文件。\n**语 法**：tftp [主机名称或 IP 地址]\n**补充说明**：FTP 让用户得以下载存放于远端主机的文件，也能将文件上传到远端\n主机放置。tftp 是简单的文字模式 ftp 程序，它所使用的指令和 FTP 类似。\n\n### uucp\n**功能说明**：在 Unix 系统之间传送文件。\n**语 法**：uucp [-cCdfjmrRtvW][-g<等级>][-I<配置文件>][-n<用户>][-x<类型\n>][--help][...来源][目的]\n**补充说明**：UUCP 为 Unix 系统之间，通过序列线来连线的协议。uucp 使用 UUCP\n协议，主要的功能为传送文件。\n**参 数**：\n\n*  -c 或--nocopy 不用将文件复制到缓冲区。\n*  -C 或--copy 将文件复制到缓冲区。\n*  -d 或--directiories 在传送文件时，自动在[目的]建立必要的目录。\n*  -f 或--nodirectiories 在传送文件时，若需要在[目的]建立目录，则放弃执行该作\n业。\n*  -g<等级>或--grade<等级> 指定文件传送作业的优先顺序。\n*  -I<配置文件>或--config<配置文件> 指定 uucp 配置文件。\n*  -j 或--jobid 显示作业编号。\n*  -m 或--mail 作业结束后，以电子邮件报告作业是否顺利完成。\n*  -n<用户>或--notify<用户> 作业结束后，以电子邮件向指定的用户报告作业是\n否顺利完成。\n*  -r 或--nouucico 不要立即启动 uucico 服务程序，仅将作业送到队列中，待稍后\n再执行。\n*  -R 或--recursive 若[来源]为目录，则将整个目录包含子目录复制到[目的]。\n*  -t 或--uuto 将最后一个参数视为\"主机名!用户\"。\n*  -v 或--version 显示版本信息。\n*  -W 或--noexpand 不要将目前所在的目录加入路径。\n*  -x<类型>或--debug<类型>启动指定的排错模式。\n*  --help 显示帮助。\n [源...] 指定源文件或路径。\n [目的] 指定目标文件或路径。\n\n##  linux 磁盘管理命令\n\n### cd(change directory)\n**功能说明**：切换目录。\n**语 法**：cd [目的目录]\n**补充说明**：cd 指令可让用户在不同的目录间切换，但该用户必须拥有足够的权\n限进入目的目录。\n\n### df(disk free)\n**功能说明**：显示磁盘的相关信息。\n**语 法**：df [-ahHiklmPT][--block-size=<区块大小>][-t <文件系统类型>][-x <文\n件系统类型>][--help][--no-sync][--sync][--version][文件或设备]\n补充说明：df 可显示磁盘的文件系统与使用情形。\n**参 数**：\n\n*  -a 或--all 包含全部的文件系统。\n*  --block-size=<区块大小> 以指定的区块大小来显示区块数目。\n*  -h 或--human-readable 以可读性较高的方式来显示信息。\n*  -H 或--si 与-h 参数相同，但在计算时是以 1000 Bytes 为换算单位而非\n1024 Bytes。\n*  -i 或--inodes 显示 inode 的信息。\n*  -k 或--kilobytes 指定区块大小为 1024 字节。\n*  -l 或--local 仅显示本地端的文件系统。\n*  -m 或--megabytes 指定区块大小为 1048576 字节。\n*  --no-sync 在取得磁盘使用信息前，不要执行 sync 指令，此为预设值。\n*  -P 或--portability 使用 POSIX 的输出格式。\n*  --sync 在取得磁盘使用信息前，先执行 sync 指令。\n*  -t<文件系统类型>或--type=<文件系统类型> 仅显示指定文件系统类型的磁盘\n信息。\n*  -T 或--print-type 显示文件系统的类型。\n*  -x<文件系统类型>或--exclude-type=<文件系统类型> 不要显示指定文件系统\n类型的磁盘信息。\n*  --help 显示帮助。\n*  --version 显示版本信息。\n [文件或设备] 指定磁盘设备。\n\n### du(disk usage)\n**功能说明**：显示目录或文件的大小。\n**语 法**： du [-abcDhHklmsSx][-L < 符号连接 >][-X <文件>][--block-size][--exclude=< 目录或文件 >][--max-depth=< 目录层数>][--help][--version][目录或文件]\n**补充说明**：du 会显示指定的目录或文件所占用的磁盘空间。\n**参 数**：\n\n*  -a 或-all 显示目录中个别文件的大小。\n*  -b 或-bytes 显示目录或文件大小时，以 byte 为单位。\n*  -c 或--total 除了显示个别目录或文件的大小外，同时也显示所有目录或文件的\n总和。\n*  -D 或--dereference-args 显示指定符号连接的源文件大小。\n*  -h 或--human-readable 以 K，M，G 为单位，提高信息的可读性。\n*  -H 或--si 与-h 参数相同，但是 K，M，G 是以 1000 为换算单位。\n*  -k 或--kilobytes 以 1024 bytes 为单位。\n*  -l 或--count-links 重复计算硬件连接的文件。\n*  -L<符号连接>或--dereference<符号连接> 显示选项中所指定符号连接的源文\n件大小。\n*  -m 或--megabytes 以 1MB 为单位。\n*  -s 或--summarize 仅显示总计。\n*  -S 或--separate-dirs 显示个别目录的大小时，并不含其子目录的大小。\n*  -x 或--one-file-xystem 以一开始处理时的文件系统为准，若遇上其它不同的文\n件系统目录则略过。\n*  -X<文件>或--exclude-from=<文件> 在<文件>指定目录或文件。\n*  --exclude=<目录或文件> 略过指定的目录或文件。\n*  --max-depth=<目录层数> 超过指定层数的目录后，予以忽略。\n*  --help 显示帮助。\n*  --version 显示版本信息。\n\n### ls(list)\n**功能说明**：列出目录内容。\n**语 法**： ls [-1aAbBcCdDfFgGhHiklLmnNopqQrRsStuUvxX][-I < 范本样式\n>][-T <跳格字数>][-w <每列字符数>][--block-size=<区块大小>][--color=<使用时\n机 >][--format=< 列表格式 >][--full-time][--help][--indicator-style=< 标注样式\n>][--quoting-style=< 引号样式 >][--show-control-chars][--sort=< 排序方式\n>][--time=<时间戳记>][--version][文件或目录...]\n**补充说明**：执行 ls 指令可列出目录的内容，包括文件和子目录的名称。\n**参 数**：\n\n* -1 每列仅显示一个文件或目录名称。\n*  -a 或--all 下所有文件和目录。\n*  -A 或--almost-all 显示所有文件和目录，但不显示现行目录和上层目录。\n*  -b 或--escape 显示脱离字符。\n*  -B 或--ignore-backups 忽略备份文件和目录。\n*  -c 以更改时间排序，显示文件和目录。\n*  -C 以又上至下，从左到右的直行方式显示文件和目录名称。\n*  -d 或--directory 显示目录名称而非其内容。\n*  -D 或--dired 用 Emacs 的模式产生文件和目录列表。\n*  -f 此参数的效果和同时指定\"aU\"参数相同，并关闭\"lst\"参数的效果。\n*  -F 或--classify 在执行文件，目录，Socket，符号连接，管道名称后面，各自加\n上\"*\",\"/\",\"=\",\"@\",\"|\"号。\n*  -g 次参数将忽略不予处理。\n*  -G 或--no-group 不显示群组名称。\n*  -h 或--human-readable 用\"K\",\"M\",\"G\"来显示文件和目录的大小。\n*  -H 或--si 此参数的效果和指定\"-h\"参数类似，但计算单位是 1000Bytes 而非\n1024Bytes。\n*  -i 或--inode 显示文件和目录的 inode 编号。\n*  -I<范本样式>或--ignore=<范本样式> 不显示符合范本样式的文件或目录名称。\n*  -k 或--kilobytes 此参数的效果和指定\"block-size=1024\"参数相同。\n*  -l 使用详细格式列表。\n*  -L 或--dereference 如遇到性质为符号连接的文件或目录，直接列出该连接所指\n向的原始文件或目录。\n*  -m 用\",\"号区隔每个文件和目录的名称。\n*  -n 或--numeric-uid-gid 以用户识别码和群组识别码替代其名称。\n*  -N 或--literal 直接列出文件和目录名称，包括控制字符。\n*  -o 此参数的效果和指定\"-l\" 参数类似，但不列出群组名称或识别码。\n*  -p 或--file-type 此参数的效果和指定\"-F\"参数类似，但不会在执行文件名称后面\n加上\"*\"号。\n*  -q 或--hide-control-chars 用\"?\"号取代控制字符，列出文件和目录名称。\n*  -Q 或--quote-name 把文件和目录名称以\"\"号标示起来。\n*  -r 或--reverse 反向排序。\n*  -R 或--recursive 递归处理，将指定目录下的所有文件及子目录一并处理。\n*  -s 或--size 显示文件和目录的大小，以区块为单位。\n*  -S 用文件和目录的大小排序。\n*  -t 用文件和目录的更改时间排序。\n*  -T<跳格字符>或--tabsize=<跳格字数> 设置跳格字符所对应的空白字符数。\n*  -u 以最后存取时间排序，显示文件和目录。\n*  -U 列出文件和目录名称时不予排序。\n*  -v 文件和目录的名称列表以版本进行排序。\n*  -w<每列字符数>或--width=<每列字符数> 设置每列的最大字符数。\n*  -x 以从左到右，由上至下的横列方式显示文件和目录名称。\n*  -X 以文件和目录的最后一个扩展名排序。\n*  --block-size=<区块大小> 指定存放文件的区块大小。\n*  --color=<列表格式> 培植文件和目录的列表格式。\n*  --full-time 列出完整的日期与时间。\n*  --help 在线帮助。\n*  --indicator-style=<标注样式> 在文件和目录等名称后面加上标注，易于辨识该\n名称所属的类型。\n*  --quoting-syte=<引号样式> 把文件和目录名称以指定的引号样式标示起来。\n*  --show-control-chars 在文件和目录列表时，使用控制字符。\n*  --sort=<排序方式> 配置文件和目录列表的排序方式。\n*  --time=<时间戳记> 用指定的时间戳记取代更改时间。\n*  --version 显示版本信息。\n\n### mkdir(make directories)\n**功能说明**：建立目录\n**语 法**：mkdir [-p][--help][--version][-m <目录属性>][目录名称]\n**补充说明**：mkdir 可建立目录并同时设置目录的权限。\n**参 数**：\n\n*  -m<目录属性>或--mode<目录属性> 建立目录时同时设置目录的权限。\n*  -p 或--parents 若所要建立目录的上层目录目前尚未建立，则会一并建立上层目\n录。\n*  --help 显示帮助。\n*  --verbose 执行时显示详细的信息。\n*  --version 显示版本信息。\n\n### quota\n**功能说明**：显示磁盘已使用的空间与限制。\n**语 法**：quota [-quvV][用户名称...] 或 quota [-gqvV][群组名称...]\n**补充说明**：执行 quota 指令，可查询磁盘空间的限制，并得知已使用多少空间。\n**参 数**：\n\n*   -g 列出群组的磁盘空间限制。\n*   -q 简明列表，只列出超过限制的部分。\n*   -u 列出用户的磁盘空间限制。\n*   -v 显示该用户或群组，在所有挂入系统的存储设备的空间限制。\n*   -V 显示版本信息。\n\n### rmdir(remove directory)\n**功能说明**：删除目录。\n**语 法**：rmdir [-p][--help][--ignore-fail-on-non-empty][--verbose][--version][目\n录...]\n**补充说明**：当有空目录要删除时，可使用 rmdir 指令。\n**参 数**：\n\n*  -p 或--parents 删除指定目录后，若该目录的上层目录已变成空目录，则将其一\n并删除。\n*  --help 在线帮助。\n*  --ignore-fail-on-non-empty 忽略非空目录的错误信息。\n*  --verbose 显示指令执行过程。\n*  --version 显示版本信息。\n\n## linux 网络通讯命令\n\n### ifconfig\n**功能说明**：显示或设置网络设备。\n**语 法**：ifconfig [网络设备][down up -allmulti -arp -promisc][add<地址>][del<\n地址>][<hw<网络设备类型><硬件地址>][io_addr<I/O 地址>][irq<IRQ 地址>][media<网络媒介类型>][mem_start<内存地址>][metric<数目>][mtu<字节>][netmask<子网掩码>][tunnel<地址>][-broadcast<地址>][-pointopoint<地址>][IP地址]\n**补充说明**：ifconfig 可设置网络设备的状态，或是显示目前的设置。\n**参 数**：\n\n*  add<地址> 设置网络设备 IPv6 的 IP 地址。\n* del<地址> 删除网络设备 IPv6 的 IP 地址。\n* down 关闭指定的网络设备。\n*  <hw<网络设备类型><硬件地址> 设置网络设备的类型与硬件地址。\n*  io_addr<I/O 地址> 设置网络设备的 I/O 地址。\n*  irq<IRQ 地址> 设置网络设备的 IRQ。\n*  media<网络媒介类型> 设置网络设备的媒介类型。\n*  mem_start<内存地址> 设置网络设备在主内存所占用的起始地址。\n metric<数目> 指定在计算数据包的转送次数时，所要加上的数目。\n mtu<字节> 设置网络设备的 MTU。\n netmask<子网掩码> 设置网络设备的子网掩码。\n tunnel<地址> 建立 IPv4 与 IPv6 之间的隧道通信地址。\n up 启动指定的网络设备。\n -broadcast<地址> 将要送往指定地址的数据包当成广播数据包来处理。\n -pointopoint<地址> 与指定地址的网络设备建立直接连线，此模式具有保密功\n能。\n*  -promisc 关闭或启动指定网络设备的 promiscuous 模式。\n*  [IP 地址] 指定网络设备的 IP 地址。\n*  [网络设备] 指定网络设备的名称。\n\n### nc\n**功能说明**：设置路由器。\n**语 法**：nc [-hlnruz][-g<网关...>][-G<指向器数目>][-i<延迟秒数>][-o<输出文\n件>][-p<通信端口>][-s<来源位址>][-v...][-w<超时秒数>][主机名称][通信端口...]\n补充说明：执行本指令可设置路由器的相关参数。\n**参 数**：\n\n*  -g<网关> 设置路由器跃程通信网关，最丢哦可设置 8 个。\n*  -G<指向器数目> 设置来源路由指向器，其数值为 4 的倍数。\n*  -h 在线帮助。\n*  -i<延迟秒数> 设置时间间隔，以便传送信息及扫描通信端口。\n*  -l 使用监听模式，管控传入的资料。\n*  -n 直接使用 IP 地址，而不通过域名服务器。\n*  -o<输出文件> 指定文件名称，把往来传输的数据以 16 进制字码倾倒成该文件\n保存。\n*  -p<通信端口> 设置本地主机使用的通信端口。\n*  -r 乱数指定本地与远端主机的通信端口。\n*  -s<来源位址> 设置本地主机送出数据包的 IP 地址。\n*  -u 使用 UDP 传输协议。\n*  -v 显示指令执行过程。\n*  -w<超时秒数> 设置等待连线的时间。\n*  -z 使用 0 输入/输出模式，只在扫描通信端口时使用。\n \n### netconf\n**功能说明**：设置各项网络功能。\n**语 法**：netconf\n**补充说明**：netconf 是 Red Hat Linux 发行版专门用来调整 Linux 各项设置的程序。\n\n### netconfig\n**功能说明**：设置网络环境。\n**语 法**：netconfig\n**补充说明**：这是 Slackware 发行版内附程序，它具有互动式的问答界面，让用户\n轻易完成网络环境的设置。\n\n### netstat\n**功能说明**：显示网络状态。\n**语 法**：netstat [-acCeFghilMnNoprstuvVwx][-A<网络类型>][--ip]\n**补充说明**：利用 netstat 指令可让你得知整个 Linux 系统的网络情况。\n**参 数**：\n\n*  -a 或--all 显示所有连线中的 Socket。\n*  -A<网络类型>或--<网络类型> 列出该网络类型连线中的相关地址。\n*  -c 或--continuous 持续列出网络状态。\n*  -C 或--cache 显示路由器配置的快取信息。\n*  -e 或--extend 显示网络其他相关信息。\n*  -F 或--fib 显示 FIB。\n*  -g 或--groups 显示多重广播功能群组组员名单。\n*  -h 或--help 在线帮助。\n*  -i 或--interfaces 显示网络界面信息表单。\n*  -l 或--listening 显示监控中的服务器的 Socket。\n*  -M 或--masquerade 显示伪装的网络连线。\n*  -n 或--numeric 直接使用 IP 地址，而不通过域名服务器。\n*  -N 或--netlink 或--symbolic 显示网络硬件外围设备的符号连接名称。\n*  -o 或--timers 显示计时器。\n*  -p 或--programs 显示正在使用 Socket 的程序识别码和程序名称。\n*  -r 或--route 显示 Routing Table。\n*  -s 或--statistice 显示网络工作信息统计表。\n*  -t 或--tcp 显示 TCP 传输协议的连线状况。\n*  -u 或--udp 显示 UDP 传输协议的连线状况。\n*  -v 或--verbose 显示指令执行过程。\n*  -V 或--version 显示版本信息。\n*  -w 或--raw 显示 RAW 传输协议的连线状况。\n*  -x 或--unix 此参数的效果和指定\"-A unix\"参数相同。\n* --ip 或--inet 此参数的效果和指定\"-A inet\"参数相同。\n \n### ping\n**功能说明**：检测主机。\n**语 法**：ping [-dfnqrRv][-c<完成次数>][-i<间隔秒数>][-I<网络界面>][-l<前置\n载入>][-p<范本样式>][-s<数据包大小>][-t<存活数值>][主机名称或IP地址]\n**补充说明**：执行ping指令会使用ICMP传输协议，发出要求回应的信息，若远端\n主机的网络功能没有问题，就会回应该信息，因而得知该主机运作正常。\n**参 数**：\n\n*  -d 使用Socket的SO_DEBUG功能。\n*  -c<完成次数> 设置完成要求回应的次数。\n*  -f 极限检测。\n*  -i<间隔秒数> 指定收发信息的间隔时间。\n*  -I<网络界面> 使用指定的网络界面送出数据包。\n*  -l<前置载入> 设置在送出要求信息之前，先行发出的数据包。\n*  -n 只输出数值。\n*  -p<范本样式> 设置填满数据包的范本样式。\n*  -q 不显示指令执行过程，开头和结尾的相关信息除外。\n*  -r 忽略普通的Routing Table，直接将数据包送到远端主机上。\n*  -R 记录路由过程。\n*  -s<数据包大小> 设置数据包的大小。\n*  -t<存活数值> 设置存活数值TTL的大小。\n*  -v 详细显示指令的执行过程。\n\n### statserial(status ofserial port)\n**功能说明**：显示串口状态。\n**语 法**：statserial [-dnx][串口设备名称]\n**补充说明**：statserial 可显示各个接脚的状态，常用来判断串口是否正常。\n**参 数**：\n\n*  -d 以 10 进制数字来表示串口的状态。\n*  -n 仅显示一次串口的状态后即结束程序。\n*  -x 与-n 参数类似，但是以 16 进制来表示。\n","tags":["little_eight"],"categories":["Linux"]},{"title":"Java多线程","url":"/2018/12/10/Java多线程/","content":"\n## 线程基础\n### 什么是线程？ \n几乎每种操作系统都支持进程的概念 —— 进程就是在某种程度上相互隔离的、独立运行的程序。\n\n线程化是允许多个活动共存于一个进程中的工具。大多数现代的操作系统都支持线程，而且线程的\n概念以各种形式已存在了好多年。Java 是第一个在语言本身中显式地包含线程的主流编程语言，它没有把线程化看作是底层操作系统的工具。 \n\n有时候，线程也称作轻量级进程。就象进程一样，线程在程序中是独立的、并发的执行路径，每个线程有它自己的堆栈、自己的程序计数器和自己的局部变量。但是，与分隔的进程相比，进程中的线程之间的隔离程度要小。它们共享内存、文件句柄和其它每个进程应有的状态。 \n\n进程可以支持多个线程，它们看似同时执行，但互相之间并不同步。一个进程中的多个线程共享相同的内存地址空间，这就意味着它们可以访问相同的变量和对象，而且它们从同一堆中分配对象。尽管这让线程之间共享信息变得更容易，但您必须小心，确保它们不会妨碍同一进程里的其它线程。\n\nJava 线程工具和 API 看似简单。但是，编写有效使用线程的复杂程序并不十分容易。因为有多个线程共存在相同的内存空间中并共享相同的变量，所以您必须小心，确保您的线程不会互相干扰。 \n\n### 每个 Java 程序都使用线程\n\n每个 Java 程序都至少有一个线程 — 主线程。当一个 Java 程序启动时，JVM 会创建主线程，并在该线程中调用程序的 main() 方法。 JVM 还创建了其它线程，您通常都看不到它们 — 例如，与垃圾收集、对象终止和其它 JVM 内务处理任务相关的线程。其它工具也创建线程，如 AWT（抽象窗口工具箱（Abstract Windowing Toolkit））或 Swing UI 工具箱、servlet 容器、应用程序服务器和 RMI（远程方法调用（Remote Method Invocation）） \n\n###  Java 线程的风险\n\n虽然 Java 线程工具非常易于使用，但当我们创建多线程程序时，应该尽量避免一些风险。 \n当多个线程访问同一数据项（如静态字段、可全局访问对象的实例字段或共享集合）时，需要确保它们协调了对数据的访问，这样它们都可以看到数据的一致视图，而且相互不会干扰另一方的更改。\n为了实现这个目的，Java 语言提供了两个关键字：synchronized 和 volatile。当从多个线程中访问变量时，必须确保对该访问正确地进行了同步。对于简单变量，将变量声明成volatile 也许就足够了，但在大多数情况下，需要使用同步。 \n如果将要使用同步来保护对共享变量的访问，那么必须确保在程序中所有访问该变量的地方都使用同步。\n\n虽然线程可以大大简化许多类型的应用程序，过度使用线程可能会危及程序的性能及其可维护性。\n线程消耗了资源。因此，在不降低性能的情况下，可以创建的线程的数量是有限制的。 尤其在单处理器系统中，使用多个线程不会使主要消耗 CPU 资源的程序运行得更快。 \n<!--more-->\n### 例子\n\n以下示例使用两个线程，一个用于计时，一个用于执行实际工作。主线程使用非常简单的算法计算\n素数。 \n在它启动之前，它创建并启动一个计时器线程，这个线程会休眠十秒钟，然后设置一个主线程要检查的标志。十秒钟之后，主线程将停止。请注意，共享标志被声明成 volatile。 \n\n```java\npublic class CalculatePrimes extends Thread { \n    public static final int MAX_PRIMES = 1000000; \n    public static final int TEN_SECONDS = 10000; \n    public volatile boolean finished = false; \n    public void run() { \n        int[] primes = new int[MAX_PRIMES]; \n        int count = 0; \n        for (int i=2; count<MAX_PRIMES; i++) { \n        // Check to see if the timer has expired \n            if (finished) { \n            break; } \n        boolean prime = true; \n        for (int j=0; j<count; j++) { \n            if (i % primes[j] == 0) { \n                  prime = false; \n               break; \n            } \n        } \n        if (prime) { \n            primes[count++] = i; \n            System.out.println(\"Found prime: \" + i); \n        } \n    } \n } \n public static void main(String[] args) { \n    CalculatePrimes calculator = new CalculatePrimes(); \n    calculator.start(); \n    try { \n    Thread.sleep(TEN_SECONDS); \n    } \n    catch (InterruptedException e) { \n    // fall through \n    } \n    calculator.finished = true; \n    } \n} \n```\n\n## 线程的生命\n\n### 创建线程\n\n在 Java 程序中创建线程有几种方法。每个 Java程序至少包含一个线程：主线程。其它线程都是通过 Thread 构造器或实例化继承类 Thread 的类来创建的。\n\nJava 线程可以通过直接实例化 Thread 对象或实例化继承 Thread 的对象来创建其它线程。在线程基础中的示例（其中，我们在十秒钟之内计算尽量多的素数）中，我们通过实例化 CalculatePrimes 类型的对象（它继承了 Thread），创建了一个线程。 \n\n当我们讨论 Java 程序中的线程时，也许会提到两个相关实体：完成工作的实际线程或代表线程的Thread 对象。正在运行的线程通常是由操作系统创建的；Thread 对象是由 Java VM 创建的，作为控制相关线程的一种方式。 \n\n### 创建线程和启动线程并不相同\n\n在一个线程对新线程的 Thread 对象调用 start() 方法之前，这个新线程并没有真正开始执行。\nThread 对象在其线程真正启动之前就已经存在了，而且其线程退出之后仍然存在。这可以让您控制或获取关于已创建的线程的信息，即使线程还没有启动或已经完成了。 \n\n通常在构造器中通过 start()启动线程并不是好主意。这样做，会把部分构造的对象暴露给新的线程。如果对象拥有一个线程，那么它应该提供一个启动该线程的 start() 或 init() 方法，而不是从构造器中启动它。\n\n### 结束线程\n\n线程会以以下三种方式之一结束：\n\n * 线程到达其 run() 方法的末尾。\n * 线程抛出一个未捕获到的 Exception 或 Error。\n * 另一个线程调用一个弃用的stop()方法。弃用是指这些方法仍然存在，但是您不应该在新代码中使用它们，并且应该尽量从现有代码中除去它们。 \n当 Java 程序中的所有线程都完成时，程序就退出了。\n\n### 加入线程\n\nThread API 包含了等待另一个线程完成的方法：join() 方法。当调用 Thread.join() 时，调用线程将阻塞，直到目标线程完成为止。\n\nThread.join() 通常由使用线程的程序使用，以将大问题划分成许多小问题，每个小问题分配一个线程。本章结尾处的示例创建了十个线程，启动它们，然后使用Thread.join() 等待它们全部完成。 \n\n### 调度\n\n除了何时使用 Thread.join() 和 Object.wait() 外，线程调度和执行的计时是不确定的。如果两个线程同时运行，而且都不等待，您必须假设在任何两个指令之间，其它线程都可以运行并修改程序变量。如果线程要访问其它线程可以看见的变量，如从静态字段（全局变量）直接或间接引用的数据，则必须使用同步以确保数据一致性。 \n\n在以下的简单示例中，我们将创建并启动两个线程，每个线程都打印两行到 System.out\n\n```java\npublic class TwoThreads { \n    public static class Thread1 extends Thread { \n    public void run() { \n        System.out.println(\"A\"); \n        System.out.println(\"B\"); \n    } \n } \n    public static class Thread2 extends Thread { \n        public void run() { \n            System.out.println(\"1\"); \n            System.out.println(\"2\"); \n        } \n    } \n    public static void main(String[] args) { \n        new Thread1().start(); \n        new Thread2().start(); \n    } \n } \n```\n我们并不知道这些行按什么顺序执行，只知道“1”在“2”之前打印，以及“A”在“B”之前打印,输出可能是\"12AB\"、\"1A2B\"等等的任何一种。\n     \n### 休眠\n\nThread API 包含了一个sleep()方法，它将使当前线程进入等待状态，直到过了一段指定时间，或者直到另一个线程对当前线程的 Thread 对象调用了 Thread.interrupt()，从而中断了线程。当过了指定时间后，线程又将变成可运行的，并且回到调度程序的可运行线程队列中。 \n\n如果线程是由对 Thread.interrupt() 的调用而中断的，那么休眠的线程会抛出\nInterruptedException，这样线程就知道它是由中断唤醒的，就不必查看计时器是否过期。 \n\nThread.yield() 方法就象 Thread.sleep() 一样，但它并不引起休眠，而只是暂停当前线程片刻，这样其它线程就可以运行了。在大多数实现中，当较高优先级的线程调用 Thread.yield() 时，较低优先级的线程就不会运行。 \n\nCalculatePrimes 示例使用了一个后台线程计算素数，然后休眠十秒钟。当计时器过期后，它就会设置一个标志，表示已经过了十秒。\n\n### 守护程序线程\n\n我们提到过当 Java 程序的所有线程都完成时，该程序就退出，但这并不完全正确。隐藏的系统线程，如垃圾收集线程和由JVM创建的其它线程会怎么样？我们没有办法停止这些线程。如果那些线程正在运行，那么 Java 程序怎么退出呢？ \n\n这些系统线程称作守护程序线程。Java程序实际上是在它的所有非守护程序线程完成后退出的。 \n\n任何线程都可以变成守护程序线程。可以通过调用 Thread.setDaemon() 方法来指明某个线程是守护程序线程。您也许想要使用守护程序线程作为在程序中创建的后台线程，如计时器线程或其它延迟的事件线程，只有当其它非守护程序线程正在运行时，这些线程才有用。 \n\n### 例子\n\n在这个示例中，TenThreads显示了一个创建了十个线程的程序，每个线程都执行一部分工作。该程序等待所有线程全部完成，然后收集结果。 \n\n```java\npublic class TenThreads { \n    private static class WorkerThread extends Thread { \n    int max = Integer.MIN_VALUE; \n    int[] ourArray; \n    public WorkerThread(int[] ourArray) { \n        this.ourArray = ourArray; \n    } \n    // Find the maximum value in our particular piece of the array \n    public void run() { \n        for (int i = 0; i < ourArray.length; i++) \n            max = Math.max(max, ourArray[i]); \n        } \n        public int getMax() { \n            return max; \n        } \n    } \n    public static void main(String[] args) { \n        WorkerThread[] threads = new WorkerThread[10]; \n        int[][] bigMatrix = getBigHairyMatrix(); \n        int max = Integer.MIN_VALUE; \n \n        // Give each thread a slice of the matrix to work with \n        for (int i=0; i < 10; i++) { \n            threads[i] = new WorkerThread(bigMatrix[i]); \n             threads[i].start(); \n             } \n        // Wait for each thread to finish \n        try { \n             for (int i=0; i < 10; i++) { \n             threads[i].join(); \n             max = Math.max(max, threads[i].getMax()); \n            } \n        } \n        catch (InterruptedException e) { \n         // fall through \n        } \n        System.out.println(\"Maximum value was \" + max); \n    } \n} \n\n```\n### 小结\n\n就象程序一样，线程有生命周期：它们启动、执行，然后完成。一个程序或进程也许包含多个线程，而这些线程看来互相单独地执行。 \n\n线程是通过实例化 Thread 对象或实例化继承 Thread 的对象来创建的，但在对新的 Thread 对象调用 start() 方法之前，这个线程并没有开始执行。当线程运行到其 run() 方法的末尾或抛出未经处理的异常时，它们就结束了。 \n\nsleep() 方法可以用于等待一段特定时间；而 join()方法可能用于等到另一个线程完成。\n\n## 共享对数据的访问\n\n### 受控访问的同步\n\n为了确保可以在线程之间以受控方式共享数据，Java语言提供了两个关键字：synchronized 和volatile。 \n\nSynchronized 有两个重要含义：它确保了一次只有一个线程可以执行代码的受保护部分（互斥，mutual exclusion或者说mutex），而且它确保了一个线程更改的数据对于其它线程是可见的（更改的可见性）。 \n\n如果没有同步，数据很容易就处于不一致状态。例如，如果一个线程正在更新两个相关值（比如，粒子的位置和速率），而另一个线程正在读取这两个值，有可能在第一个线程只写了一个值，还没有写另一个值的时候，调度第二个线程运行，这样它就会看到一个旧值和一个新值。同步让我们可以定义必须原子地运行的代码块，这样对于其他线程而言，它们要么都执行，要么都不执行。 \n\n同步的原子执行或互斥方面类似于其它操作环境中的临界段的概念。 \n\n### 用锁保护的原子代码块\n\nVolatile 对于确保每个线程看到最新的变量值非常有用，但有时我们需要保护比较大的代码片段，如涉及更新多个变量的片段。 \n\n同步使用监控器（monitor）或锁的概念，以协调对特定代码块的访问。 \n\n每个 Java 对象都有一个相关的锁。同一时间只能有一个线程持有 Java 锁。当线程进入synchronized代码块时，线程会阻塞并等待，直到锁可用，当它可用时，就会获得这个锁，然后执行代码块。当控制退出受保护的代码块时，即到达了代码块末尾或者抛出了没有在 synchronized 块中捕获的异常时，它就会释放该锁。 \n\n这样，每次只有一个线程可以执行受给定监控器保护的代码块。从其它线程的角度看，该代码块可以看作是原子的，它要么全部执行，要么根本不执行。 \n\n### 同步例子\n\n使用 synchronized 块可以让您将一组相关更新作为一个集合来执行，而不必担心其它线程中断或看到计算的中间结果。以下示例代码将打印“1 0”或“01”。如果没有同步，它还会打印“1 1”（或“0 0”，随便您信不信）。 \n\n```java\npublic class SyncExample { \n     private static lockObject = new Object(); \n     private static class Thread1 extends Thread { \n         public void run() { \n            synchronized (lockObject) { \n                x = y = 0; \n                System.out.println(x); \n            } \n        } \n     } \n    private static class Thread2 extends Thread { \n        public void run() { \n             synchronized (lockObject) { \n             x = y = 1; \n             System.out.println(y); \n            } \n        } \n    } \n    public static void main(String[] args) { \n     new Thread1().run(); \n     new Thread2().run(); \n    } \n} \n```\n\n在这两个线程中都必须使用同步，以便使这个程序正确工作。\n\n### Java 锁定\n\nJava 锁定合并了一种互斥形式。每次只有一个线程可以持有锁。锁用于保护代码块或整个方法，必须记住是锁的身份保护了代码块，而不是代码块本身，这一点很重要。一个锁可以保护许多代码块或方法。 \n\n反之，仅仅因为代码块由锁保护并不表示两个线程不能同时执行该代码块。它只表示如果两个线程正在等待相同的锁，则它们不能同时执行该代码。 \n\n在以下示例中，两个线程可以同时不受限制地执行 setLastAccess() 中的 synchronized 块，因为每个线程有一个不同的 thingie 值。因此，synchronized 代码块受到两个正在执行的线程中不同锁的保护。 \n\n```java\npublic class SyncExample { \n     public static class Thingie { \n         private Date lastAccess; \n         public synchronized void setLastAccess(Date date) { \n            this.lastAccess = date; \n         } \n     }\n     public static class MyThread extends Thread { \n         private Thingie thingie; \n         public MyThread(Thingie thingie) { \n         this.thingie = thingie; \n         } \n        public void run() { \n            thingie.setLastAccess(new Date()); \n        } \n    } \n    public static void main() { \n         Thingie thingie1 = new Thingie(), \n         thingie2 = new Thingie(); \n         new MyThread(thingie1).start(); \n         new MyThread(thingie2).start(); \n     } \n} \n```\n\n### 同步的方法\n\n创建 synchronized 块的最简单方法是将方法声明成synchronized。这表示在进入方法主体之前，调用者必须获得锁： \n\n```java\npublic class Point { \n     public synchronized void setXY(int x, int y) { \n         this.x = x; \n         this.y = y; \n     } \n} \n```\n\n对于普通的 synchronized 方法，这个锁是一个对象，将针对它调用方法。对于静态 synchronized 方法，这个锁是与 Class 对象相关的监控器，在该对象中声明了方法。 \n\n仅仅因为 setXY() 被声明成 synchronized 并不表示两个不同的线程不能同时执行 setXY()，只要它们调用不同的 Point 实例的 setXY() 就可同时执行。对于一个 Point 实例，一次只能有一个线程执行 setXY()，或 Point 的任何其它 synchronized 方法。 \n### 同步的块\n\nsynchronized 块的语法比synchronized方法稍微复杂一点，因为还需要显式地指定锁要保护哪个块。Point 的以下版本等价于前一页中显示的版本： \n\n```java\n\n\npublic class Point { \n     public void setXY(int x, int y) { \n         synchronized (this) { \n             this.x = x; \n             this.y = y; \n         } \n    } \n} \n```\n使用 this 引用作为锁很常见，但这并不是必需的。这表示该代码块将与这个类中的 synchronized 方法使用同一个锁。 \n\n由于同步防止了多个线程同时执行一个代码块，因此性能上就有问题，即使是在单处理器系统上。最好在尽可能最小的需要保护的代码块上使用同步。 \n\n访问局部（基于堆栈的）变量从来不需要受到保护，因为它们只能被自己所属的线程访问。 \n\n### 大多数类并没有同步\n\n因为同步会带来小小的性能损失，大多数通用类，如 java.util 中的 Collection 类，不在内部使用同步。这表示在没有附加同步的情况下，不能在多个线程中使用诸如 HashMap 这样的类。 \n\n通过每次访问共享集合中的方法时使用同步，可以在多线程应用程序中使用 Collection 类。对于任何给定的集合，每次必须用同一个锁进行同步。通常可以选择集合对象本身作为锁。\n\n下一页中的示例类 SimpleCache显示了如何使用HashMap以线程安全的方式提供高速缓存。但是，通常适当的同步并不只是意味着同步每个方法。 \n\nCollections 类提供了一组便利的用于 List、Map 和 Set 接口的封装器。您可以用Collections.synchronizedMap 封装Map，它将确保所有对该映射的访问都被正确同步。 \n如果类的文档没有说明它是线程安全的，那么您必须假设它不是。 \n\n### 示例：简单的线程安全的高速缓存\n\n如以下代码样本所示，SimpleCache.java使用HashMap为对象装入器提供了一个简单的高速缓存。load() 方法知道怎样按对象的键装入对象。在一次装入对象之后，该对象就被存储到高速缓存中，这样以后的访问就会从高速缓存中检索它，而不是每次都全部地装入它。对共享高速缓存的每个访问都受到synchronized块保护。由于它被正确同步，所以多个线程可以同时调用 getObject 和clearCache 方法，而没有数据损坏的风险。 \n\n```java\npublic class SimpleCache { \n     private final Map cache = new HashMap(); \n         public Object load(String objectName) { \n         // load the object somehow \n     } \n     public void clearCache() { \n         synchronized (cache) { \n            cache.clear(); \n         } \n     } \n     public Object getObject(String objectName) { \n         synchronized (cache) { \n             Object o = cache.get(objectName); \n             if (o == null) { \n                 o = load(objectName); \n                 cache.put(objectName, o); \n             } \n         } \n     return o; \n     } \n} \n```\n\n### 小结\n\n由于线程执行的计时是不确定的，我们需要小心，以控制线程对共享数据的访问。否则，多个并发线程会互相干扰对方的更改，从而损坏数据，或者其它线程也许不能及时看到对共享数据的更改。 \n\n通过使用同步来保护对共享变量的访问，我们可以确保线程以可预料的方式与程序变量进行交互.\n\n每个 Java 对象都可以充当锁，synchronized块可以确保一次只有一个线程执行由给定锁保护的synchronized 代码。 \n","tags":["little_eight"],"categories":["java"]},{"title":"SpringBoot整合Dubbo(入门篇)","url":"/2018/12/03/SpringBoot整合Dubbo（入门篇)/","content":"## 遇到的坑\n\n> * zookeeper版本不一致问题\n> * 虚拟机防火墙没关\n\n\n## 如何搭建\n### Linux上安装zookeeper\n因为最近在学习Linux，所以这个东西直接安装在本机的虚拟机上。（你也可以直接在windows上安装和启用zookeeper，道理是一样的，这里不多描述了。）\n\n* linux命令直接下载\n```\nwget https://archive.apache.org/dist/zookeeper/zookeeper-3.4.8/zookeeper-3.4.8.tar.gz\n```\n> 这里有个坑，就是版本必须与程序里的依赖对应的版本一致，否则会出bug，而且不容易发现。\n\n* 解压下载的tar,然后进入zookeeper根目录，新建data和logs俩个目录\n* 用pwd复制目录名字，后面有用\n* 从根目录进入conf目录下，把zoo_sample.cfg命名为zoo.cfg，删除zoo_sample.cfg\n* 编辑zoo.cfg，把里面的dataDir=...删除，加上下面2行代码\n```\ndataDir=/粘贴你自己zookeeper的目录/data\ndataLogDir=/粘贴你自己zookeeper的目录/logs\n```\n<!--more-->\n* 返回zookeeper根目录，进入bin，然后运行以下代码\n\n```\n./zkServer.sh start\n```\n> 输出Starting zookeeper ... STARTED,代表启动成功。你也可以用\n./zkServer.sh status 查看，输出Mode: standalone 代表启动中\n\n* 关闭zookeeper是./zkServer.sh stop，暂时用不上\n* 记得要把防火墙关了\n```\nsystemctl stop firewalld.service\n\n这个你选择性用。关闭开机自启动：systemctl disable firewalld.service\n```\n\n### 搭建springboot项目\n这里会分服务端跟消费端\n#### 先新建主项目，作版本控制 springboot-dubbo\n* 我用的是idea，File -> new-> Project ,选择maven，第一页不用勾选任何东西，点next，填好项目的一些信息，一直next下去即可。\n* 新建完成后，把不要的文件夹删除（.idea和src），然后在pom.xml里加入必要的依赖\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n  <modelVersion>4.0.0</modelVersion>\n\n  <groupId>bdbk</groupId>\n  <artifactId>springboot-dubbo</artifactId>\n  <version>1.0-SNAPSHOT</version>\n  <packaging>war</packaging>\n\n  <name>springboot-dubbo Maven Webapp</name>\n\n  <parent>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-parent</artifactId>\n    <version>2.1.1.RELEASE</version>\n    <relativePath/> <!-- lookup parent from repository -->\n  </parent>\n\n  <dependencies>\n    <!--web必要-->\n    <dependency>\n      <groupId>org.springframework.boot</groupId>\n      <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n    <!--test必要-->\n    <dependency>\n      <groupId>org.springframework.boot</groupId>\n      <artifactId>spring-boot-starter-test</artifactId>\n    </dependency>\n    <!--引入dubbo的依赖-->\n    <dependency>\n      <groupId>com.alibaba.spring.boot</groupId>\n      <artifactId>dubbo-spring-boot-starter</artifactId>\n      <version>2.0.0</version>\n    </dependency>\n    <!-- 引入zookeeper的依赖，就是这里引用的zookeeper版本必须对应服务器上的 -->\n    <dependency>\n      <groupId>com.101tec</groupId>\n      <artifactId>zkclient</artifactId>\n      <version>0.9</version>\n    </dependency>\n  </dependencies>\n</project>\n\n```\n\n#### 然后新建服务端 dubbo-server\n* 直接在 springboot-dubbo 项目上右键 选择new -> Module\n* 不用勾选next，然后输入 dubbo-server\n* 新建后，在java目录下创建你自己的包（这里是bdbk），然后创建启动类 DubboServerApplication\n```java\n\npackage bdbk;\n\nimport com.alibaba.dubbo.spring.boot.annotation.EnableDubboConfiguration;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\n@EnableDubboConfiguration\npublic class DubboServerApplication {\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(DubboServerApplication.class, args);\n\t}\n}\n\n```\n\n* 同包下（或者你再自己创建一个 service 包，因为是入门篇东西比较简单就不再区分结构了）创建接口类 HelloService\n```java\npackage bdbk;\n\n/**\n * 接口类\n * @author little_eight\n * @since 2018/12/3\n */\npublic interface HelloService {\n    public  String sayHello(String name);\n}\n```\n\n* 创建实现类 HelloServiceImpl\n\n```java\npackage bdbk;\n\nimport com.alibaba.dubbo.config.annotation.Service;\nimport org.springframework.stereotype.Component;\n\n/**\n * 接口实现类\n * @author little_eight\n * @since 2018/12/3\n */\n@Component\n@Service\npublic class HelloServiceImpl implements HelloService {\n    public String sayHello(String name) {\n        return \"Hello \" + name;\n    }\n}\n```\n\n* 在resources目录下新建 application.yml 配置文件\n```\n# 配置端口\nserver:\n    port: 8081\n\n# dubbo配置\nspring:\n    dubbo:\n        application:\n            # 应用名称\n            name: dubbo-server\n            # 注册中心地址 这里要填你自己zookeeper的地址\n            registry: zookeeper://192.168.211.128:2181\n        protocol:\n            # 协议端口\n            port: 20880\n```\n\n#### 再创建消费端项目 dubbo-client ,新建跟 dubbo-server 一样\n* 因为要引用服务端，所以先在pom.xml里添加对应的依赖\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\txsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n\t<modelVersion>4.0.0</modelVersion>\n\n\t<groupId>bdbk</groupId>\n\t<artifactId>dubbo-client</artifactId>\n\t<version>0.0.1-SNAPSHOT</version>\n\t<packaging>jar</packaging>\n\n\t<name>dubbo-client</name>\n\t<description>Demo project for Spring Boot</description>\n\n\t<parent>\n\t\t<groupId>bdbk</groupId>\n\t\t<artifactId>springboot-dubbo</artifactId>\n\t\t<version>1.0-SNAPSHOT</version>\n\t</parent>\n\t<!-- 添加服务端 -->\n\t<dependencies>\n\t\t<dependency>\n\t\t\t<groupId>bdbk</groupId>\n\t\t\t<artifactId>dubbo-server</artifactId>\n\t\t\t<version>0.0.1-SNAPSHOT</version>\n\t\t</dependency>\n\t</dependencies>\n</project>\n```\n* 新建包bdbk,然后创建启动类 DubboClientApplication\n```java\npackage bdbk;\n\nimport com.alibaba.dubbo.spring.boot.annotation.EnableDubboConfiguration;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\n@EnableDubboConfiguration\npublic class DubboClientApplication {\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(DubboClientApplication.class, args);\n\t}\n}\n\n```\n\n* 再写个控制类 HelloController，作为测试\n```java\npackage bdbk;\n\nimport com.alibaba.dubbo.config.annotation.Reference;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n/**\n * 控制类 用于测试\n * @author little_eight\n * @since 2018/12/3\n */\n@RestController\npublic class HelloController {\n    @Reference\n    private HelloService helloService;\n\n    @RequestMapping(\"/\")\n    public String hello() {\n        String hello = helloService.sayHello(\"World\");\n        return hello;\n    }\n}\n```\n\n* 在resources目录下新建application.yml配置文件\n```\n# 配置端口\nserver:\n    port: 8082\n\n# dubbo配置\nspring:\n    dubbo:\n        application:\n            # 应用名称\n            name: dubbo-client\n            # 注册中心地址 这里要填你自己zookeeper的地址\n            registry: zookeeper://192.168.211.128:2181\n        protocol:\n            # 协议端口\n            port: 20881\n```\n\n#### 最后先启动服务端，再启动消费端。\n\n[点击访问](http://localhost:8082),页面输出Hello World即为成功。\n\n#### 源码地址\n[github源码](https://github.com/little-eight-china/springboot-project/tree/master/springboot-dubbo)","tags":["little_eight"],"categories":["springboot"]},{"title":"java面试题（三）","url":"/2018/10/10/java面试题（三）/","content":"## 转发（forward）和重定向（redirect）的区别？ \n答：forward是容器中控制权的转向，是服务器请求资源，服务器直接访问目标地址的URL，把那个URL 的响应内容读取过来，然后把这些内容再发给浏览器，浏览器根本不知道服务器发送的内容是从哪儿来的，所以它的地址栏中还是原来的地址。redirect就是服务器端根据逻辑，发送一个状态码，告诉浏览器重新去请求那个地址，因此从浏览器的地址栏中可以看到跳转后的链接地址，很明显redirect无法访问到服务器保护起来资源，但是可以从一个网站redirect到其他网站。forward更加高效，所以在满足需要时尽量使用forward（通过调用RequestDispatcher对象的forward()方法，该对象可以通过ServletRequest对象的getRequestDispatcher()方法获得），并且这样也有助于隐藏实际的链接；在有些情况下，比如需要访问一个其它服务器上的资源，则必须使用重定向（通过HttpServletResponse对象调用其sendRedirect()方法实现）。\n\n## JSP有哪些内置对象？作用分别是什么？ \n答：JSP有9个内置对象： \n * request：封装客户端的请求，其中包含来自GET或POST请求的参数； \n * response：封装服务器对客户端的响应； \n * pageContext：通过该对象可以获取其他对象； \n * session：封装用户会话的对象； \n * application：封装服务器运行环境的对象； \n * out：输出服务器响应的输出流对象； \n * config：Web应用的配置对象； \n * page：JSP页面本身（相当于Java程序中的this）； \n * exception：封装页面抛出异常的对象。\n\n> 补充：如果用Servlet来生成网页中的动态内容无疑是非常繁琐的工作，另一方面，所有的文本和HTML标签都是硬编码，即使做出微小的修改，都需要进行重新编译。JSP解决了Servlet的这些问题，它是Servlet很好的补充，可以专门用作为用户呈现视图（View），而Servlet作为控制器（Controller）专门负责处理用户请求并转发或重定向到某个页面。基于Java的Web开发很多都同时使用了Servlet和JSP。JSP页面其实是一个Servlet，能够运行Servlet的服务器（Servlet容器）通常也是JSP容器，可以提供JSP页面的运行环境，Tomcat就是一个Servlet/JSP容器。第一次请求一个JSP页面时，Servlet/JSP容器首先将JSP页面转换成一个JSP页面的实现类，这是一个实现了JspPage接口或其子接口HttpJspPage的Java类。JspPage接口是Servlet的子接口，因此每个JSP页面都是一个Servlet。转换成功后，容器会编译Servlet类，之后容器加载和实例化Java字节码，并执行它通常对Servlet所做的生命周期操作。对同一个JSP页面的后续请求，容器会查看这个JSP页面是否被修改过，如果修改过就会重新转换并重新编译并执行。如果没有则执行内存中已经存在的Servlet实例。我们可以看一段JSP代码对应的Java程序就知道一切了，而且9个内置对象的神秘面纱也会被揭开。\n\nJSP页面：\n```\n<%@ page pageEncoding=\"UTF-8\"%>\n<%\nString path = request.getContextPath();\nString basePath = request.getScheme() + \"://\" + request.getServerName() + \":\" + request.getServerPort() + path + \"/\";\n%>\n\n<!DOCTYPE html>\n<html>\n  <head>\n    <base href=\"<%=basePath%>\">\n    <title>首页</title>\n    <style type=\"text/css\">\n        * { font-family: \"Arial\"; }\n    </style>\n  </head>\n\n  <body>\n    <h1>Hello, World!</h1>\n    <hr/>\n    <h2>Current time is: <%= new java.util.Date().toString() %></h2>\n  </body>\n</html>\n```\n<!--more-->\n对应的Java代码：\n\n```java\nimport javax.servlet.*;\nimport javax.servlet.http.*;\nimport javax.servlet.jsp.*;\n\npublic final class index_jsp extends org.apache.jasper.runtime.HttpJspBase\n        implements org.apache.jasper.runtime.JspSourceDependent {\n\n    private static final javax.servlet.jsp.JspFactory _jspxFactory = javax.servlet.jsp.JspFactory\n            .getDefaultFactory();\n\n    private static java.util.Map<java.lang.String, java.lang.Long> _jspx_dependants;\n\n    private javax.el.ExpressionFactory _el_expressionfactory;\n    private org.apache.tomcat.InstanceManager _jsp_instancemanager;\n\n    public java.util.Map<java.lang.String, java.lang.Long> getDependants() {\n        return _jspx_dependants;\n    }\n\n    public void _jspInit() {\n        _el_expressionfactory = _jspxFactory.getJspApplicationContext(\n                getServletConfig().getServletContext()).getExpressionFactory();\n        _jsp_instancemanager = org.apache.jasper.runtime.InstanceManagerFactory\n                .getInstanceManager(getServletConfig());\n    }\n\n    public void _jspDestroy() {\n    }\n\n    public void _jspService(\n            final javax.servlet.http.HttpServletRequest request,\n            final javax.servlet.http.HttpServletResponse response)\n            throws java.io.IOException, javax.servlet.ServletException {\n        // 内置对象就是在这里定义的\n        final javax.servlet.jsp.PageContext pageContext;\n        javax.servlet.http.HttpSession session = null;\n        final javax.servlet.ServletContext application;\n        final javax.servlet.ServletConfig config;\n        javax.servlet.jsp.JspWriter out = null;\n        final java.lang.Object page = this;\n        javax.servlet.jsp.JspWriter _jspx_out = null;\n        javax.servlet.jsp.PageContext _jspx_page_context = null;\n\n        try {\n            response.setContentType(\"text/html;charset=UTF-8\");\n            pageContext = _jspxFactory.getPageContext(this, request, response,\n                    null, true, 8192, true);\n            _jspx_page_context = pageContext;\n            application = pageContext.getServletContext();\n            config = pageContext.getServletConfig();\n            session = pageContext.getSession();\n            out = pageContext.getOut();\n            _jspx_out = out;\n\n            out.write('\\r');\n            out.write('\\n');\n\n            String path = request.getContextPath();\n            String basePath = request.getScheme() + \"://\"\n                    + request.getServerName() + \":\" + request.getServerPort()\n                    + path + \"/\";\n// 以下代码通过输出流将HTML标签输出到浏览器中\n            out.write(\"\\r\\n\");\n            out.write(\"\\r\\n\");\n            out.write(\"<!DOCTYPE html>\\r\\n\");\n            out.write(\"<html>\\r\\n\");\n            out.write(\"  <head>\\r\\n\");\n            out.write(\"    <base href=\\\"\");\n            out.print(basePath);\n            out.write(\"\\\">\\r\\n\");\n            out.write(\"    <title>首页</title>\\r\\n\");\n            out.write(\"    <style type=\\\"text/css\\\">\\r\\n\");\n            out.write(\"    \\t* { font-family: \\\"Arial\\\"; }\\r\\n\");\n            out.write(\"    </style>\\r\\n\");\n            out.write(\"  </head>\\r\\n\");\n            out.write(\"  \\r\\n\");\n            out.write(\"  <body>\\r\\n\");\n            out.write(\"    <h1>Hello, World!</h1>\\r\\n\");\n            out.write(\"    <hr/>\\r\\n\");\n            out.write(\"    <h2>Current time is: \");\n            out.print(new java.util.Date().toString());\n            out.write(\"</h2>\\r\\n\");\n            out.write(\"  </body>\\r\\n\");\n            out.write(\"</html>\\r\\n\");\n        } catch (java.lang.Throwable t) {\n            if (!(t instanceof javax.servlet.jsp.SkipPageException)) {\n                out = _jspx_out;\n                if (out != null && out.getBufferSize() != 0)\n                    try {\n                        out.clearBuffer();\n                    } catch (java.io.IOException e) {\n                    }\n                if (_jspx_page_context != null)\n                    _jspx_page_context.handlePageException(t);\n                else\n                    throw new ServletException(t);\n            }\n        } finally {\n            _jspxFactory.releasePageContext(_jspx_page_context);\n        }\n    }\n}\n\n```\n## get和post请求的区别？ \n答： \n* get请求用来从服务器上获得资源，而post是用来向服务器提交数据； \n* get将表单中数据按照name=value的形式，添加到action 所指向的URL 后面，并且两者使用\"?\"连接，而各个变量之间使用\"&\"连接；post是将表单中的数据放在HTTP协议的请求头或消息体中，传递到action所指向URL； \n* get传输的数据要受到URL长度限制（1024字节）；而post可以传输大量的数据，上传文件通常要使用post方式； \n* 使用get时参数会显示在地址栏上，如果这些数据不是敏感数据，那么可以使用get；对于敏感数据还是应用使用post； \n* get使用MIME类型application/x-www-form-urlencoded的URL编码（也叫百分号编码）文本的格式传递参数，保证被传送的参数由遵循规范的文本组成，例如一个空格的编码是\"%20\"。\n\n## 常用的Web服务器有哪些？ \n答：Unix和Linux平台下使用最广泛的免费HTTP服务器是Apache服务器，而Windows平台的服务器通常使用IIS作为Web服务器。选择Web服务器应考虑的因素有：性能、安全性、日志和统计、虚拟主机、代理服务器、缓冲服务和集成应用程序等。下面是对常见服务器的简介： \n* IIS：Microsoft的Web服务器产品，全称是Internet Information Services。IIS是允许在公共Intranet或Internet上发布信息的Web服务器。IIS是目前最流行的Web服务器产品之一，很多著名的网站都是建立在IIS的平台上。IIS提供了一个图形界面的管理工具，称为Internet服务管理器，可用于监视配置和控制Internet服务。IIS是一种Web服务组件，其中包括Web服务器、FTP服务器、NNTP服务器和SMTP服务器，分别用于网页浏览、文件传输、新闻服务和邮件发送等方面，它使得在网络（包括互联网和局域网）上发布信息成了一件很容易的事。它提供ISAPI(Intranet Server API）作为扩展Web服务器功能的编程接口；同时，它还提供一个Internet数据库连接器，可以实现对数据库的查询和更新。 \n* Kangle：Kangle Web服务器是一款跨平台、功能强大、安全稳定、易操作的高性能Web服务器和反向代理服务器软件。此外，Kangle也是一款专为做虚拟主机研发的Web服务器。实现虚拟主机独立进程、独立身份运行。用户之间安全隔离，一个用户出问题不影响其他用户。支持PHP、ASP、ASP.NET、Java、Ruby等多种动态开发语言。 \n* WebSphere：WebSphere Application Server是功能完善、开放的Web应用程序服务器，是IBM电子商务计划的核心部分，它是基于Java的应用环境，用于建立、部署和管理Internet和Intranet Web应用程序，适应各种Web应用程序服务器的需要。 \n* WebLogic：WebLogic Server是一款多功能、基于标准的Web应用服务器，为企业构建企业应用提供了坚实的基础。针对各种应用开发、关键性任务的部署，各种系统和数据库的集成、跨Internet协作等Weblogic都提供了相应的支持。由于它具有全面的功能、对开放标准的遵从性、多层架构、支持基于组件的开发等优势，很多公司的企业级应用都选择它来作为开发和部署的环境。WebLogic Server在使应用服务器成为企业应用架构的基础方面一直处于领先地位，为构建集成化的企业级应用提供了稳固的基础。 \n* Apache：目前Apache仍然是世界上用得最多的Web服务器，其市场占有率很长时间都保持在60%以上（目前的市场份额约40%左右）。世界上很多著名的网站都是Apache的产物，它的成功之处主要在于它的源代码开放、有一支强大的开发团队、支持跨平台的应用（可以运行在几乎所有的Unix、Windows、Linux系统平台上）以及它的可移植性等方面。 \n* Tomcat：Tomcat是一个开放源代码、运行Servlet和JSP的容器。Tomcat实现了Servlet和JSP规范。此外，Tomcat还实现了Apache-Jakarta规范而且比绝大多数商业应用软件服务器要好，因此目前也有不少的Web服务器都选择了Tomcat。 \n* Nginx：读作\"engine x\"，是一个高性能的HTTP和反向代理服务器，也是一个IMAP/POP3/SMTP代理服务器。 Nginx是由Igor Sysoev为俄罗斯访问量第二的Rambler站点开发的，第一个公开版本0.1.0发布于2004年10月4日。其将源代码以类BSD许可证的形式发布，因它的稳定性、丰富的功能集、示例配置文件和低系统资源的消耗而闻名。在2014年下半年，Nginx的市场份额达到了14%。\n\n## JSP和Servlet是什么关系？\n答：其实这个问题在上面已经阐述过了，Servlet是一个特殊的Java程序，它运行于服务器的JVM中，能够依靠服务器的支持向浏览器提供显示内容。JSP本质上是Servlet的一种简易形式，JSP会被服务器处理成一个类似于Servlet的Java程序，可以简化页面内容的生成。Servlet和JSP最主要的不同点在于，Servlet的应用逻辑是在Java文件中，并且完全从表示层中的HTML分离开来。而JSP的情况是Java和HTML可以组合成一个扩展名为.jsp的文件。有人说，Servlet就是在Java中写HTML，而JSP就是在HTML中写Java代码，当然这个说法是很片面且不够准确的。JSP侧重于视图，Servlet更侧重于控制逻辑，在MVC架构模式中，JSP适合充当视图（view）而Servlet适合充当控制器（controller）。\n\n## 讲解JSP中的四种作用域。 \n答：JSP中的四种作用域包括page、request、session和application，具体来说： \n - page代表与一个页面相关的对象和属性。 \n - request代表与Web客户机发出的一个请求相关的对象和属性。一个请求可能跨越多个页面，涉及多个Web组件；需要在页面显示的临时数据可以置于此作用域。 \n - session代表与某个用户与服务器建立的一次会话相关的对象和属性。跟某个用户相关的数据应该放在用户自己的session中。 \n - application代表与整个Web应用程序相关的对象和属性，它实质上是跨越整个Web应用程序，包括多个页面、请求和会话的一个全局作用域。\n\n## 说一下表达式语言（EL）的隐式对象及其作用。\n答：EL的隐式对象包括：pageContext、initParam（访问上下文参数）、param（访问请求参数）、paramValues、header（访问请求头）、headerValues、cookie（访问cookie）、applicationScope（访问application作用域）、sessionScope（访问session作用域）、requestScope（访问request作用域）、pageScope（访问page作用域）。\n\n用法如下所示：\n```\n${pageContext.request.method}\n${pageContext[\"request\"][\"method\"]}\n${pageContext.request[\"method\"]}\n${pageContext[\"request\"].method}\n${initParam.defaultEncoding}\n${header[\"accept-language\"]}\n${headerValues[\"accept-language\"][0]}\n${cookie.jsessionid.value}\n${sessionScope.loginUser.username}\n```\n> 补充：表达式语言的.和[]运算作用是一致的，唯一的差别在于如果访问的属性名不符合Java标识符命名规则，例如上面的accept-language就不是一个有效的Java标识符，那么这时候就只能用[]运算符而不能使用.运算符获取它的值\n\n## 解释一下网络应用的模式及其特点。 \n答：典型的网络应用模式大致有三类：B/S、C/S、P2P。其中B代表浏览器（Browser）、C代表客户端（Client）、S代表服务器（Server），P2P是对等模式，不区分客户端和服务器。B/S应用模式中可以视为特殊的C/S应用模式，只是将C/S应用模式中的特殊的客户端换成了浏览器，因为几乎所有的系统上都有浏览器，那么只要打开浏览器就可以使用应用，没有安装、配置、升级客户端所带来的各种开销。P2P应用模式中，成千上万台彼此连接的计算机都处于对等的地位，整个网络一般来说不依赖专用的集中服务器。网络中的每一台计算机既能充当网络服务的请求者，又对其它计算机的请求作出响应，提供资源和服务。通常这些资源和服务包括：信息的共享和交换、计算资源（如CPU的共享）、存储共享（如缓存和磁盘空间的使用）等，这种应用模式最大的阻力安全性、版本等问题，目前有很多应用都混合使用了多种应用模型，最常见的网络视频应用，它几乎把三种模式都用上了。\n\n> 补充：此题要跟\"电子商务模式\"区分开，因为有很多人被问到这个问题的时候马上想到的是B2B（如阿里巴巴）、B2C（如当当、亚马逊、京东）、C2C（如淘宝、拍拍）、C2B（如威客）、O2O（如美团、饿了么）。对于这类问题，可以去百度上面科普一下。\n\n## 什么是Web Service（Web服务）？\n答：从表面上看，Web Service就是一个应用程序，它向外界暴露出一个能够通过Web进行调用的API。这就是说，你能够用编程的方法透明的调用这个应用程序，不需要了解它的任何细节，跟你使用的编程语言也没有关系。例如可以创建一个提供天气预报的Web Service，那么无论你用哪种编程语言开发的应用都可以通过调用它的API并传入城市信息来获得该城市的天气预报。之所以称之为Web Service，是因为它基于HTTP协议传输数据，这使得运行在不同机器上的不同应用无须借助附加的、专门的第三方软件或硬件，就可相互交换数据或集成。\n\n> 补充：这里必须要提及的一个概念是SOA（Service-Oriented Architecture，面向服务的架构），SOA是一种思想，它将应用程序的不同功能单元通过中立的契约联系起来，独立于硬件平台、操作系统和编程语言，使得各种形式的功能单元能够更好的集成。显然，Web Service是SOA的一种较好的解决方案，它更多的是一种标准，而不是一种具体的技术。\n\n## 概念解释：SOAP、WSDL、UDDI。\n* SOAP：简单对象访问协议（Simple Object Access Protocol），是Web Service中交换数据的一种协议规范。 \n* WSDL：Web服务描述语言（Web Service Description Language），它描述了Web服务的公共接口。这是一个基于XML的关于如何与Web服务通讯和使用的服务描述；也就是描述与目录中列出的Web服务进行交互时需要绑定的协议和信息格式。通常采用抽象语言描述该服务支持的操作和信息，使用的时候再将实际的网络协议和信息格式绑定给该服务。 \n* UDDI：统一描述、发现和集成（Universal Description, Discovery and Integration），它是一个基于XML的跨平台的描述规范，可以使世界范围内的企业在互联网上发布自己所提供的服务。简单的说，UDDI是访问各种WSDL的一个门面（可以参考设计模式中的门面模式）。\n \n## 什么是ORM？\n答：对象关系映射（Object-Relational Mapping，简称ORM）是一种为了解决程序的面向对象模型与数据库的关系模型互不匹配问题的技术；简单的说，ORM是通过使用描述对象和数据库之间映射的元数据（在Java中可以用XML或者是注解），将程序中的对象自动持久化到关系数据库中或者将关系数据库表中的行转换成Java对象，其本质上就是将数据从一种形式转换到另外一种形式。\n\n## 持久层设计要考虑的问题有哪些？你用过的持久层框架有哪些？ \n答：所谓\"持久\"就是将数据保存到可掉电式存储设备中以便今后使用，简单的说，就是将内存中的数据保存到关系型数据库、文件系统、消息队列等提供持久化支持的设备中。持久层就是系统中专注于实现数据持久化的相对独立的层面。\n\n持久层设计的目标包括： \n* 数据存储逻辑的分离，提供抽象化的数据访问接口。 \n* 数据访问底层实现的分离，可以在不修改代码的情况下切换底层实现。 \n* 资源管理和调度的分离，在数据访问层实现统一的资源调度（如缓存机制）。 \n* 数据抽象，提供更面向对象的数据操作。\n持久层框架有： \n* Hibernate \n* MyBatis \n* TopLink \n* Guzz \n* jOOQ \n* Spring Data \n* ActiveJDBC\n## Hibernate中SessionFactory是线程安全的吗？Session是线程安全的吗（两个线程能够共享同一个Session吗）？ \n答：SessionFactory对应Hibernate的一个数据存储的概念，它是线程安全的，可以被多个线程并发访问。SessionFactory一般只会在启动的时候构建。对于应用程序，最好将SessionFactory通过单例模式进行封装以便于访问。Session是一个轻量级非线程安全的对象（线程间不能共享session），它表示与数据库进行交互的一个工作单元。Session是由SessionFactory创建的，在任务完成之后它会被关闭。Session是持久层服务对外提供的主要接口。Session会延迟获取数据库连接（也就是在需要的时候才会获取）。为了避免创建太多的session，可以使用ThreadLocal将session和当前线程绑定在一起，这样可以让同一个线程获得的总是同一个session。Hibernate 3中SessionFactory的getCurrentSession()方法就可以做到。\n\n## Hibernate中Session的load和get方法的区别是什么？ \n答：主要有以下三项区别： \n* 如果没有找到符合条件的记录，get方法返回null，load方法抛出异常。 \n* get方法直接返回实体类对象，load方法返回实体类对象的代理。 \n* 在Hibernate 3之前，get方法只在一级缓存中进行数据查找，如果没有找到对应的数据则越过二级缓存，直接发出SQL语句完成数据读取；load方法则可以从二级缓存中获取数据；从Hibernate 3开始，get方法不再是对二级缓存只写不读，它也是可以访问二级缓存的。\n\n> 说明：对于load()方法Hibernate认为该数据在数据库中一定存在可以放心的使用代理来实现延迟加载，如果没有数据就抛出异常，而通过get()方法获取的数据可以不存在。\n\n## Session的save()、update()、merge()、lock()、saveOrUpdate()和persist()方法分别是做什么的？有什么区别？\n答：Hibernate的对象有三种状态：瞬时态（transient）、持久态（persistent）和游离态（detached），如第135题中的图所示。瞬时态的实例可以通过调用save()、persist()或者saveOrUpdate()方法变成持久态；游离态的实例可以通过调用 update()、saveOrUpdate()、lock()或者replicate()变成持久态。save()和persist()将会引发SQL的INSERT语句，而update()或merge()会引发UPDATE语句。save()和update()的区别在于一个是将瞬时态对象变成持久态，一个是将游离态对象变为持久态。merge()方法可以完成save()和update()方法的功能，它的意图是将新的状态合并到已有的持久化对象上或创建新的持久化对象。对于persist()方法，按照官方文档的说明：① persist()方法把一个瞬时态的实例持久化，但是并不保证标识符被立刻填入到持久化实例中，标识符的填入可能被推迟到flush的时间；② persist()方法保证当它在一个事务外部被调用的时候并不触发一个INSERT语句，当需要封装一个长会话流程的时候，persist()方法是很有必要的；③ save()方法不保证第②条，它要返回标识符，所以它会立即执行INSERT语句，不管是在事务内部还是外部。至于lock()方法和update()方法的区别，update()方法是把一个已经更改过的脱管状态的对象变成持久状态；lock()方法是把一个没有更改过的脱管状态的对象变成持久状态。\n\n## 阐述Session加载实体对象的过程。 \n答：Session加载实体对象的步骤是： \n* Session在调用数据库查询功能之前，首先会在一级缓存中通过实体类型和主键进行查找，如果一级缓存查找命中且数据状态合法，则直接返回； \n* 如果一级缓存没有命中，接下来Session会在当前NonExists记录（相当于一个查询黑名单，如果出现重复的无效查询可以迅速做出判断，从而提升性能）中进行查找，如果NonExists中存在同样的查询条件，则返回null； \n* 如果一级缓存查询失败则查询二级缓存，如果二级缓存命中则直接返回； \n* 如果之前的查询都未命中，则发出SQL语句，如果查询未发现对应记录则将此次查询添加到Session的NonExists中加以记录，并返回null； \n* 根据映射配置和SQL语句得到ResultSet，并创建对应的实体对象； \n* 将对象纳入Session（一级缓存）的管理； \n* 如果有对应的拦截器，则执行拦截器的onLoad方法； \n* 如果开启并设置了要使用二级缓存，则将数据对象纳入二级缓存； \n* 返回数据对象。\n\n## Query接口的list方法和iterate方法有什么区别？ \n答： \n* list()方法无法利用一级缓存和二级缓存（对缓存只写不读），它只能在开启查询缓存的前提下使用查询缓存；iterate()方法可以充分利用缓存，如果目标数据只读或者读取频繁，使用iterate()方法可以减少性能开销。 \n* list()方法不会引起N+1查询问题，而iterate()方法可能引起N+1查询问题\n## Hibernate如何实现分页查询？ \n答：通过Hibernate实现分页查询，开发人员只需要提供HQL语句（调用Session的createQuery()方法）或查询条件（调用Session的createCriteria()方法）、设置查询起始行数（调用Query或Criteria接口的setFirstResult()方法）和最大查询行数（调用Query或Criteria接口的setMaxResults()方法），并调用Query或Criteria接口的list()方法，Hibernate会自动生成分页查询的SQL语句。\n\n## 锁机制有什么用？简述Hibernate的悲观锁和乐观锁机制。 \n答：有些业务逻辑在执行过程中要求对数据进行排他性的访问，于是需要通过一些机制保证在此过程中数据被锁住不会被外界修改，这就是所谓的锁机制。 \nHibernate支持悲观锁和乐观锁两种锁机制。悲观锁，顾名思义悲观的认为在数据处理过程中极有可能存在修改数据的并发事务（包括本系统的其他事务或来自外部系统的事务），于是将处理的数据设置为锁定状态。悲观锁必须依赖数据库本身的锁机制才能真正保证数据访问的排他性，关于数据库的锁机制和事务隔离级别在《Java面试题大全（上）》中已经讨论过了。乐观锁，顾名思义，对并发事务持乐观态度（认为对数据的并发操作不会经常性的发生），通过更加宽松的锁机制来解决由于悲观锁排他性的数据访问对系统性能造成的严重影响。最常见的乐观锁是通过数据版本标识来实现的，读取数据时获得数据的版本号，更新数据时将此版本号加1，然后和数据库表对应记录的当前版本号进行比较，如果提交的数据版本号大于数据库中此记录的当前版本号则更新数据，否则认为是过期数据无法更新。Hibernate中通过Session的get()和load()方法从数据库中加载对象时可以通过参数指定使用悲观锁；而乐观锁可以通过给实体类加整型的版本字段再通过XML或@Version注解进行配置。\n\n> 提示：使用乐观锁会增加了一个版本字段，很明显这需要额外的空间来存储这个版本字段，浪费了空间，但是乐观锁会让系统具有更好的并发性，这是对时间的节省。因此乐观锁也是典型的空间换时间的策略。\n\n## 阐述实体对象的三种状态以及转换关系。 \n答：最新的Hibernate文档中为Hibernate对象定义了四种状态（原来是三种状态，面试的时候基本上问的也是三种状态），分别是：瞬时态（new, or transient）、持久态（managed, or persistent）、游状态（detached）和移除态（removed，以前Hibernate文档中定义的三种状态中没有移除态），如下图所示，就以前的Hibernate文档中移除态被视为是瞬时态。\n* 瞬时态：当new一个实体对象后，这个对象处于瞬时态，即这个对象只是一个保存临时数据的内存区域，如果没有变量引用这个对象，则会被JVM的垃圾回收机制回收。这个对象所保存的数据与数据库没有任何关系，除非通过Session的save()、saveOrUpdate()、persist()、merge()方法把瞬时态对象与数据库关联，并把数据插入或者更新到数据库，这个对象才转换为持久态对象。\n* 持久态：持久态对象的实例在数据库中有对应的记录，并拥有一个持久化标识（ID）。对持久态对象进行delete操作后，数据库中对应的记录将被删除，那么持久态对象与数据库记录不再存在对应关系，持久态对象变成移除态（可以视为瞬时态）。持久态对象被修改变更后，不会马上同步到数据库，直到数据库事务提交。\n* 游离态：当Session进行了close()、clear()、evict()或flush()后，实体对象从持久态变成游离态，对象虽然拥有持久和与数据库对应记录一致的标识值，但是因为对象已经从会话中清除掉，对象不在持久化管理之内，所以处于游离态（也叫脱管态）。游离态的对象与临时状态对象是十分相似的，只是它还含有持久化标识。\n  \n## 如何理解Hibernate的延迟加载机制？在实际应用中，延迟加载与Session关闭的矛盾是如何处理的？ \n答：延迟加载就是并不是在读取的时候就把数据加载进来，而是等到使用时再加载。Hibernate使用了虚拟代理机制实现延迟加载，我们使用Session的load()方法加载数据或者一对多关联映射在使用延迟加载的情况下从一的一方加载多的一方，得到的都是虚拟代理，简单的说返回给用户的并不是实体本身，而是实体对象的代理。代理对象在用户调用getter方法时才会去数据库加载数据。但加载数据就需要数据库连接。而当我们把会话关闭时，数据库连接就同时关闭了。\n\n延迟加载与session关闭的矛盾一般可以这样处理： \n* 关闭延迟加载特性。这种方式操作起来比较简单，因为Hibernate的延迟加载特性是可以通过映射文件或者注解进行配置的，但这种解决方案存在明显的缺陷。首先，出现\"no session or session was closed\"通常说明系统中已经存在主外键关联，如果去掉延迟加载的话，每次查询的开销都会变得很大。 \n* 在session关闭之前先获取需要查询的数据，可以使用工具方法Hibernate.isInitialized()判断对象是否被加载，如果没有被加载则可以使用Hibernate.initialize()方法加载对象。 \n* 使用拦截器或过滤器延长Session的生命周期直到视图获得数据。Spring整合Hibernate提供的OpenSessionInViewFilter和OpenSessionInViewInterceptor就是这种做法。\n\n## 举一个多对多关联的例子，并说明如何实现多对多关联映射。 \n答：例如：商品和订单、学生和课程都是典型的多对多关系。可以在实体类上通过@ManyToMany注解配置多对多关联或者通过映射文件中的和标签配置多对多关联，但是实际项目开发中，很多时候都是将多对多关联映射转换成两个多对一关联映射来实现的。\n\n## 谈一下你对继承映射的理解。\n答：继承关系的映射策略有三种： \n* 每个继承结构一张表（table per class hierarchy），不管多少个子类都用一张表。 \n* 每个子类一张表（table per subclass），公共信息放一张表，特有信息放单独的表。 \n* 每个具体类一张表（table per concrete class），有多少个子类就有多少张表。 \n第一种方式属于单表策略，其优点在于查询子类对象的时候无需表连接，查询速度快，适合多态查询；缺点是可能导致表很大。后两种方式属于多表策略，其优点在于数据存储紧凑，其缺点是需要进行连接查询，不适合多态查询。\n\n## 简述Hibernate常见优化策略。\n答：这个问题应当挑自己使用过的优化策略回答，常用的有： \n* 制定合理的缓存策略（二级缓存、查询缓存）。 \n* 采用合理的Session管理机制。 \n* 尽量使用延迟加载特性。 \n* 设定合理的批处理参数。 \n* 如果可以，选用UUID作为主键生成器。 \n* 如果可以，选用基于版本号的乐观锁替代悲观锁。 \n* 在开发过程中, 开启hibernate.show_sql选项查看生成的SQL，从而了解底层的状况；开发完成后关闭此选项。 \n* 考虑数据库本身的优化，合理的索引、恰当的数据分区策略等都会对持久层的性能带来可观的提升，但这些需要专业的DBA（数据库管理员）提供支持。\n\n## 谈一谈Hibernate的一级缓存、二级缓存和查询缓存。 \n答：Hibernate的Session提供了一级缓存的功能，默认总是有效的，当应用程序保存持久化实体、修改持久化实体时，Session并不会立即把这种改变提交到数据库，而是缓存在当前的Session中，除非显示调用了Session的flush()方法或通过close()方法关闭Session。通过一级缓存，可以减少程序与数据库的交互，从而提高数据库访问性能。 \nSessionFactory级别的二级缓存是全局性的，所有的Session可以共享这个二级缓存。不过二级缓存默认是关闭的，需要显示开启并指定需要使用哪种二级缓存实现类（可以使用第三方提供的实现）。一旦开启了二级缓存并设置了需要使用二级缓存的实体类，SessionFactory就会缓存访问过的该实体类的每个对象，除非缓存的数据超出了指定的缓存空间。 \n一级缓存和二级缓存都是对整个实体进行缓存，不会缓存普通属性，如果希望对普通属性进行缓存，可以使用查询缓存。查询缓存是将HQL或SQL语句以及它们的查询结果作为键值对进行缓存，对于同样的查询可以直接从缓存中获取数据。查询缓存默认也是关闭的，需要显示开启。\n\n## MyBatis中使用#和$书写占位符有什么区别？ \n答：#将传入的数据都当成一个字符串，会对传入的数据自动加上引号；$将传入的数据直接显示生成在SQL中。注意：使用$占位符可能会导致SQL注射攻击，能用#的地方就不要使用$，写order by子句的时候应该用$而不是#。\n## 解释一下MyBatis中命名空间（namespace）的作用。 \n答：在大型项目中，可能存在大量的SQL语句，这时候为每个SQL语句起一个唯一的标识（ID）就变得并不容易了。为了解决这个问题，在MyBatis中，可以为每个映射文件起一个唯一的命名空间，这样定义在这个映射文件中的每个SQL语句就成了定义在这个命名空间中的一个ID。只要我们能够保证每个命名空间中这个ID是唯一的，即使在不同映射文件中的语句ID相同，也不会再产生冲突了。\n\n## MyBatis中的动态SQL是什么意思？ \n答：对于一些复杂的查询，我们可能会指定多个查询条件，但是这些条件可能存在也可能不存在，例如在58同城上面找房子，我们可能会指定面积、楼层和所在位置来查找房源，也可能会指定面积、价格、户型和所在位置来查找房源，此时就需要根据用户指定的条件动态生成SQL语句。如果不使用持久层框架我们可能需要自己拼装SQL语句，还好MyBatis提供了动态SQL的功能来解决这个问题。MyBatis中用于实现动态SQL的元素主要有： \n - if \n - choose / when / otherwise \n - trim \n - where \n - set \n - foreach\n\n下面是映射文件的片段。\n```\n    <select id=\"foo\" parameterType=\"Blog\" resultType=\"Blog\">\n        select * from t_blog where 1 = 1\n        <if test=\"title != null\">\n            and title = #{title}\n        </if>\n        <if test=\"content != null\">\n            and content = #{content}\n        </if>\n        <if test=\"owner != null\">\n            and owner = #{owner}\n        </if>\n   </select>\n```\n当然也可以像下面这些书写。\n```\n    <select id=\"foo\" parameterType=\"Blog\" resultType=\"Blog\">\n        select * from t_blog where 1 = 1 \n        <choose>\n            <when test=\"title != null\">\n                and title = #{title}\n            </when>\n            <when test=\"content != null\">\n                and content = #{content}\n            </when>\n            <otherwise>\n                and owner = \"owner1\"\n            </otherwise>\n        </choose>\n    </select>\n```\n## 什么是IoC和DI？DI是如何实现的？ \n 答：IoC叫控制反转，是Inversion of Control的缩写，DI（Dependency Injection）叫依赖注入，是对IoC更简单的诠释。控制反转是把传统上由程序代码直接操控的对象的调用权交给容器，通过容器来实现对象组件的装配和管理。所谓的\"控制反转\"就是对组件对象控制权的转移，从程序代码本身转移到了外部容器，由容器来创建对象并管理对象之间的依赖关系。IoC体现了好莱坞原则 - \"Don’t call me, we will call you\"。依赖注入的基本原则是应用组件不应该负责查找资源或者其他依赖的协作对象。配置对象的工作应该由容器负责，查找资源的逻辑应该从应用组件的代码中抽取出来，交给容器来完成。DI是对IoC更准确的描述，即组件之间的依赖关系由容器在运行期决定，形象的来说，即由容器动态的将某种依赖关系注入到组件之中。\n \n 举个例子：一个类A需要用到接口B中的方法，那么就需要为类A和接口B建立关联或依赖关系，最原始的方法是在类A中创建一个接口B的实现类C的实例，但这种方法需要开发人员自行维护二者的依赖关系，也就是说当依赖关系发生变动的时候需要修改代码并重新构建整个系统。如果通过一个容器来管理这些对象以及对象的依赖关系，则只需要在类A中定义好用于关联接口B的方法（构造器或setter方法），将类A和接口B的实现类C放入容器中，通过对容器的配置来实现二者的关联。\n \n 依赖注入可以通过setter方法注入（设值注入）、构造器注入和接口注入三种方式来实现，Spring支持setter注入和构造器注入，通常使用构造器注入来注入必须的依赖关系，对于可选的依赖关系，则setter注入是更好的选择，setter注入需要类提供无参构造器或者无参的静态工厂方法来创建对象。\n\n## 解释一下什么叫AOP（面向切面编程）？ \n答：AOP（Aspect-Oriented Programming）指一种程序设计范型，该范型以一种称为切面（aspect）的语言构造为基础，切面是一种新的模块化机制，用来描述分散在对象、类或方法中的横切关注点（crosscutting concern）。\n\n## Spring中自动装配的方式有哪些？\n答： \n* no：不进行自动装配，手动设置Bean的依赖关系。 \n* byName：根据Bean的名字进行自动装配。 \n* byType：根据Bean的类型进行自动装配。 \n* constructor：类似于byType，不过是应用于构造器的参数，如果正好有一个Bean与构造器的参数类型相同则可以自动装配，否则会导致错误。 \n* autodetect：如果有默认的构造器，则通过constructor的方式进行自动装配，否则使用byType的方式进行自动装配。\n\n## Spring MVC的工作原理是怎样的？ \n答：Spring MVC的工作原理如下所示：\n* 客户端的所有请求都交给前端控制器DispatcherServlet来处理，它会负责调用系统的其他模块来真正处理用户的请求。 \n* DispatcherServlet收到请求后，将根据请求的信息（包括URL、HTTP协议方法、请求头、请求参数、Cookie等）以及HandlerMapping的配置找到处理该请求的Handler（任何一个对象都可以作为请求的Handler）。 \n* 在这个地方Spring会通过HandlerAdapter对该处理器进行封装。 \n* HandlerAdapter是一个适配器，它用统一的接口对各种Handler中的方法进行调用。 \n* Handler完成对用户请求的处理后，会返回一个ModelAndView对象给DispatcherServlet，ModelAndView顾名思义，包含了数据模型以及相应的视图的信息。 \n* ModelAndView的视图是逻辑视图，DispatcherServlet还要借助ViewResolver完成从逻辑视图到真实视图对象的解析工作。 \n* 当得到真正的视图对象后，DispatcherServlet会利用视图对象对模型数据进行渲染。 \n* 客户端得到响应，可能是一个普通的HTML页面，也可以是XML或JSON字符串，还可以是一张图片或者一个PDF文件。\n \n## 选择使用Spring框架的原因（Spring框架为企业级开发带来的好处有哪些）？\n 答：可以从以下几个方面作答： \n * 非侵入式：支持基于POJO的编程模式，不强制性的要求实现Spring框架中的接口或继承Spring框架中的类。 \n * IoC容器：IoC容器帮助应用程序管理对象以及对象之间的依赖关系，对象之间的依赖关系如果发生了改变只需要修改配置文件而不是修改代码，因为代码的修改可能意味着项目的重新构建和完整的回归测试。有了IoC容器，程序员再也不需要自己编写工厂、单例，这一点特别符合Spring的精神\"不要重复的发明轮子\"。 \n * AOP（面向切面编程）：将所有的横切关注功能封装到切面（aspect）中，通过配置的方式将横切关注功能动态添加到目标代码上，进一步实现了业务逻辑和系统服务之间的分离。另一方面，有了AOP程序员可以省去很多自己写代理类的工作。 \n * MVC：Spring的MVC框架是非常优秀的，从各个方面都可以甩Struts 2几条街，为Web表示层提供了更好的解决方案。 \n * 事务管理：Spring以宽广的胸怀接纳多种持久层技术，并且为其提供了声明式的事务管理，在不需要任何一行代码的情况下就能够完成事务管理。 \n * 其他：选择Spring框架的原因还远不止于此，Spring为Java企业级开发提供了一站式选择，你可以在需要的时候使用它的部分和全部，更重要的是，你甚至可以在感觉不到Spring存在的情况下，在你的项目中使用Spring提供的各种优秀的功能。\n \n\n## 阐述Spring框架中Bean的生命周期？ \n答： \n* Spring IoC容器找到关于Bean的定义并实例化该Bean。 \n* Spring IoC容器对Bean进行依赖注入。 \n* 如果Bean实现了BeanNameAware接口，则将该Bean的id传给setBeanName方法。 \n* 如果Bean实现了BeanFactoryAware接口，则将BeanFactory对象传给setBeanFactory方法。 \n* 如果Bean实现了BeanPostProcessor接口，则调用其postProcessBeforeInitialization方法。 \n* 如果Bean实现了InitializingBean接口，则调用其afterPropertySet方法。 \n* 如果有和Bean关联的BeanPostProcessors对象，则这些对象的postProcessAfterInitialization方法被调用。 \n* 当销毁Bean实例时，如果Bean实现了DisposableBean接口，则调用其destroy方法。\n\n## 你用过的网站前端优化的技术有哪些？ \n答： \n① 浏览器访问优化： \n* 减少HTTP请求数量：合并CSS、合并JavaScript、合并图片（CSS Sprite） \n* 使用浏览器缓存：通过设置HTTP响应头中的Cache-Control和Expires属性，将CSS、JavaScript、图片等在浏览器中缓存，当这些静态资源需要更新时，可以更新HTML文件中的引用来让浏览器重新请求新的资源 \n* 启用压缩 \n* CSS前置，JavaScript后置 \n* 减少Cookie传输 \n② CDN加速：CDN（Content Distribute Network）的本质仍然是缓存，将数据缓存在离用户最近的地方，CDN通常部署在网络运营商的机房，不仅可以提升响应速度，还可以减少应用服务器的压力。当然，CDN缓存的通常都是静态资源。 \n③ 反向代理：反向代理相当于应用服务器的一个门面，可以保护网站的安全性，也可以实现负载均衡的功能，当然最重要的是它缓存了用户访问的热点资源，可以直接从反向代理将某些内容返回给用户浏览器。\n\n## 什么是XSS攻击？什么是SQL注入攻击？什么是CSRF攻击？ \n答： \n* XSS（Cross Site Script，跨站脚本攻击）是向网页中注入恶意脚本在用户浏览网页时在用户浏览器中执行恶意脚本的攻击方式。跨站脚本攻击分有两种形式：反射型攻击（诱使用户点击一个嵌入恶意脚本的链接以达到攻击的目标，目前有很多攻击者利用论坛、微博发布含有恶意脚本的URL就属于这种方式）和持久型攻击（将恶意脚本提交到被攻击网站的数据库中，用户浏览网页时，恶意脚本从数据库中被加载到页面执行，QQ邮箱的早期版本就曾经被利用作为持久型跨站脚本攻击的平台）。XSS虽然不是什么新鲜玩意，但是攻击的手法却不断翻新，防范XSS主要有两方面：消毒（对危险字符进行转义）和HttpOnly（防范XSS攻击者窃取Cookie数据）。 \n* SQL注入攻击是注入攻击最常见的形式（此外还有OS注入攻击（Struts 2的高危漏洞就是通过OGNL实施OS注入攻击导致的）），当服务器使用请求参数构造SQL语句时，恶意的SQL被嵌入到SQL中交给数据库执行。SQL注入攻击需要攻击者对数据库结构有所了解才能进行，攻击者想要获得表结构有多种方式：（1）如果使用开源系统搭建网站，数据库结构也是公开的（目前有很多现成的系统可以直接搭建论坛，电商网站，虽然方便快捷但是风险是必须要认真评估的）；（2）错误回显（如果将服务器的错误信息直接显示在页面上，攻击者可以通过非法参数引发页面错误从而通过错误信息了解数据库结构，Web应用应当设置友好的错误页，一方面符合最小惊讶原则，一方面屏蔽掉可能给系统带来危险的错误回显信息）；（3）盲注。防范SQL注入攻击也可以采用消毒的方式，通过正则表达式对请求参数进行验证，此外，参数绑定也是很好的手段，这样恶意的SQL会被当做SQL的参数而不是命令被执行，JDBC中的PreparedStatement就是支持参数绑定的语句对象，从性能和安全性上都明显优于Statement。 \n* CSRF攻击（Cross Site Request Forgery，跨站请求伪造）是攻击者通过跨站请求，以合法的用户身份进行非法操作（如转账或发帖等）。CSRF的原理是利用浏览器的Cookie或服务器的Session，盗取用户身份，其原理如下图所示。防范CSRF的主要手段是识别请求者的身份，主要有以下几种方式：（1）在表单中添加令牌（token）；（2）验证码；（3）检查请求头中的Referer（前面提到防图片盗链接也是用的这种方式）。令牌和验证都具有一次消费性的特征，因此在原理上一致的，但是验证码是一种糟糕的用户体验，不是必要的情况下不要轻易使用验证码，目前很多网站的做法是如果在短时间内多次提交一个表单未获得成功后才要求提供验证码，这样会获得较好的用户体验。\n> 补充：防火墙的架设是Web安全的重要保障，ModSecurity是开源的Web防火墙中的佼佼者。企业级防火墙的架设应当有两级防火墙，Web服务器和部分应用服务器可以架设在两级防火墙之间的DMZ，而数据和资源服务器应当架设在第二级防火墙之后。\n","tags":["little_eight"],"categories":["杂类"]},{"title":"java面试题（二）","url":"/2018/10/03/java面试题（二）/","content":"\n## 面向对象的特征有哪些方面?\n答：面向对象的特征主要有以下几个方面：\n\n* 抽象：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。\n* 继承：继承是从已有类得到继承信息创建新类的过程。提供继承信息的类被称为父类（超类、基类）；得到继承信息的类被称为子类（派生类）。继承让变化中的软件系统有了一定的延续性，同时继承也是封装程序中可变因素的重要手段（如果不能理解请阅读阎宏博士的《Java与模式》或《设计模式精解》中关于桥梁模式的部分）。\n* 封装：通常认为封装是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。面向对象的本质就是将现实世界描绘成一系列完全自治、封闭的对象。我们在类中编写的方法就是对实现细节的一种封装；我们编写一个类就是对数据和数据操作的封装。可以说，封装就是隐藏一切可隐藏的东西，只向外界提供最简单的编程接口（可以想想普通洗衣机和全自动洗衣机的差别，明显全自动洗衣机封装更好因此操作起来更简单；我们现在使用的智能手机也是封装得足够好的，因为几个按键就搞定了所有的事情）。\n* 多态性：多态性是指允许不同子类型的对象对同一消息作出不同的响应。简单的说就是用同样的对象引用调用同样的方法但是做了不同的事情。多态性分为编译时的多态性和运行时的多态性。如果将对象的方法视为对象向外界提供的服务，那么运行时的多态性可以解释为：当A系统访问B系统提供的服务时，B系统有多种提供服务的方式，但一切对A系统来说都是透明的（就像电动剃须刀是A系统，它的供电系统是B系统，B系统可以使用电池供电或者用交流电，甚至还有可能是太阳能，A系统只会通过B类对象调用供电的方法，但并不知道供电系统的底层实现是什么，究竟通过何种方式获得了动力）。方法重载（overload）实现的是编译时的多态性（也称为前绑定），而方法重写（override）实现的是运行时的多态性（也称为后绑定）。运行时的多态是面向对象最精髓的东西，要实现多态需要做两件事：\n    * 方法重写（子类继承父类并重写父类中已有的或抽象的方法）\n    * 对象造型（用父类型引用引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。\n## 访问修饰符public,private,protected,以及不写（默认）时的区别？\n答：区别如下：\n\n| 作用域        | 当前类   |  同包  |  子类  |  其他  |\n| --------   | -----:  | :----:  | -----:  | :----:  |\n| public    |   √     |   √     |   √     |   √     |\n| protected   |   √   |   √   |   √     |   ×     |\n| default   |   √   |   √   |   ×     |   ×     |\n| private   |    √    |  ×  |  ×     |  ×     \n类的成员不写访问修饰时默认为default。默认对于同一个包中的其他类相当于公开（public），对于不是同一个包中的其他类相当于私有（private）。受保护（protected）对子类相当于公开，对不是同一包中的没有父子关系的类相当于私有。\n## String 是最基本的数据类型吗?\n答：不是。Java中的基本数据类型只有8个：byte、short、int、long、float、double、char、boolean；除了基本类型（primitive type）和枚举类型（enumeration type），剩下的都是引用类型（reference type）。\n## float f=3.4;是否正确?\n答:不正确。3.4是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成精度损失，因此需要强制类型转换float f =(float)3.4; 或者写成float f =3.4F;。\n## short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗?\n答：对于short s1 = 1; s1 = s1 + 1;由于1是int类型，因此s1+1运算结果也是int 型，需要强制转换类型才能赋值给short型。而short s1 = 1; s1 += 1;可以正确编译，因为s1+= 1;相当于s1 = (short)(s1 + 1);其中有隐含的强制类型转换。\n<!--more-->\n## Java 有没有goto?\n答：goto 是Java中的保留字，在目前版本的Java中没有使用。（根据James Gosling（Java之父）编写的《The Java Programming Language》一书的附录中给出了一个Java关键字列表，其中有goto和const，但是这两个是目前无法使用的关键字，因此有些地方将其称之为保留字，其实保留字这个词应该有更广泛的意义，因为熟悉C语言的程序员都知道，在系统类库中使用过的有特殊意义的单词或单词的组合都被视为保留字）\n## int 和Integer 有什么区别?\n答：Java是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入不是对象的基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java为每一个基本数据类型都引入了对应的包装类型（wrapper class），int的包装类就是Integer，从JDK 1.5开始引入了自动装箱/拆箱机制，使得二者可以相互转换。\nJava 为每个原始类型提供了包装类型：\n原始类型: boolean，char，byte，short，int，long，float，double\n包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double\n\n补充：最近还遇到一个面试题，也是和自动装箱和拆箱相关的，代码如下所示：\n```java\npublic class Test{\n    public static void main (String[] args){\n        Integer f1 = 100, f2 = 100, f3 = 150, f4 = 150;\n        System.out.println(f1 == f2);\n        System.out.println(f3 == f4);\n    }\n}\n\n```\n如果不明就里很容易认为两个输出要么都是true要么都是false。首先需要注意的是f1、f2、f3、f4四个变量都是Integer对象，所以下面的==运算比较的不是值而是引用。装箱的本质是什么呢？当我们给一个Integer对象赋一个int值的时候，会调用Integer类的静态方法valueOf，如果看看valueOf的源代码就知道发生了什么。\n```java\npublic static Integer valueOf(int i){\n     \n    if(i >= IntegerCache.low && i <= IntegerCache.high){\n        return IntegerCache.cache[i + (-IntegerCache.low)];\n    }\n    return new Integer(i);\n}\n```\nIntegerCache类就不贴出了，简单的说，如果字面量的值在-128到127之间，那么不会new新的Integer对象，而是直接引用常量池中的Integer对象，所以上面的面试题中f1==f2的结果是true，而f3==f4的结果是false。越是貌似简单的面试题其中的玄机就越多，需要面试者有相当深厚的功力。\n## &和&&的区别？\n答：&运算符有两种用法：(1)按位与；(2)逻辑与。&&运算符是短路与运算。逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true整个表达式的值才是true。&&之所以称为短路运算是因为，如果&&左边的表达式的值是false，右边的表达式会被直接短路掉，不会进行运算。很多时候我们可能都需要用&&而不是&，例如在验证用户登录时判定用户名不是null而且不是空字符串，应当写为：username != null &&!username.equals(“”)，二者的顺序不能交换，更不能用&运算符，因为第一个条件如果不成立，根本不能进行字符串的equals比较，否则会产生NullPointerException异常。注意：逻辑或运算符（|）和短路或运算符（||）的差别也是如此。\n## 解释内存中的栈（stack）、堆(heap)和静态存储区的用法。\n答：通常我们定义一个基本数据类型的变量，一个对象的引用，还有就是函数调用的现场保存都使用内存中的栈空间；而通过new关键字和构造器创建的对象放在堆空间；程序中的字面量（literal）如直接书写的100、“hello”和常量都是放在静态存储区中。栈空间操作最快但是也很小，通常大量的对象都是放在堆空间，整个内存包括硬盘上的虚拟内存都可以被当成堆空间来使用。\n```java\nString str = new String(“hello”);\n```\n上面的语句中str放在栈上，用new创建出来的字符串对象放在堆上，而“hello”这个字面量放在静态存储区。\n补充：较新版本的Java中使用了一项叫“逃逸分析“的技术，可以将一些局部对象放在栈上以提升对象的操作性能。\n \n## Math.round(11.5) 等于多少? Math.round(-11.5)等于多少?\n答：Math.round(11.5)的返回值是12，Math.round(-11.5)的返回值是-11。四舍五入的原理是在参数上加0.5然后进行下取整。\nMath的其他方法：\n```java\nMath.sqrt(a); //计算平方根\nMath.cbrt(a); //计算立方根\nMath.pow(a, b); //计算a的b次方\nMath.max(a, b); //计算最大值\nMath.min(a, b); //计算最小值\nMath.abs(a); //绝对值\nMath.ceil(-10.1); //-10.0，ceil天花板，返回最大值\nMath.floor(-10.1)); //-11.0，同理，返回最小值\nMath.random(); // 取得一个大于或者等于0.0小于不等于1.0的随机数\n\n```\n## swtich 是否能作用在byte 上，是否能作用在long 上，是否能作用在String上?\n答：早期的JDK中，switch（expr）中，expr可以是byte、short、char、int。从1.5版开始，Java中引入了枚举类型（enum），expr也可以是枚举，从JDK 1.7版开始，还可以是字符串（String）。长整型（long）是不可以的。\n## 用最有效率的方法计算2乘以8?\n答： 2 << 3（左移3位相当于乘以2的3次方，右移3位相当于除以2的3次方）。\n补充：我们为编写的类重写hashCode方法时，可能会看到如下所示的代码，其实我们不太理解为什么要使用这样的乘法运算来产生哈希码（散列码），而且为什么这个数是个素数，为什么通常选择31这个数？前两个问题的答案你可以自己百度一下，选择31是因为可以用移位和减法运算来代替乘法，从而得到更好的性能。说到这里你可能已经想到了：31 * num <==> (num << 5) - num，左移5位相当于乘以2的5次方（32）再减去自身就相当于乘以31。现在的VM都能自动完成这个优化。\n\n\n## 数组有没有length()方法?String 有没有length()方法？\n答：数组没有length()方法，有length 的属性。String 有length()方法。JavaScript中，获得字符串的长度是通过length属性得到的，这一点容易和Java混淆。\n \n## 在Java 中，如何跳出当前的多重嵌套循环？\n答：在最外层循环前加一个标记如A，然后用break A;可以跳出多重循环。（Java中支持带标签的break和continue语句，作用有点类似于C和C++中的goto语句，但是就像要避免使用goto一样，应该避免使用带标签的break和continue，因为它不会让你的程序变得更优雅，很多时候甚至有相反的作用，所以这种语法其实不知道更好）\n## 构造器（constructor）是否可被重写（override）?\n答：构造器不能被继承，因此不能被重写，但可以被重载。\n## 两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对？\n答：不对，如果两个对象x和y满足x.equals(y) == true，它们的哈希码（hash code）应当相同。Java对于eqauls方法和hashCode方法是这样规定的：(1)如果两个对象相同（equals方法返回true），那么它们的hashCode值一定要相同；(2)如果两个对象的hashCode相同，它们并不一定相同。当然，你未必要按照要求去做，但是如果你违背了上述原则就会发现在使用容器时，相同的对象可以出现在Set集合中，同时增加新元素的效率会大大下降（对于使用哈希存储的系统，如果哈希码频繁的冲突将会造成存取性能急剧下降）。\n补充：关于equals和hashCode方法，很多Java程序都知道，但很多人也就是仅仅知道而已，在Joshua Bloch的大作《Effective Java》（很多软件公司，《Effective Java》、《Java编程思想》以及《重构：改善既有代码质量》是Java程序员必看书籍）中是这样介绍equals方法的：首先equals方法必须满足自反性（x.equals(x)必须返回true）、对称性（x.equals(y)返回true时，y.equals(x)也必须返回true）、传递性（x.equals(y)和y.equals(z)都返回true时，x.equals(z)也必须返回true）和一致性（当x和y引用的对象信息没有被修改时，多次调用x.equals(y)应该得到同样的返回值），而且对于任何非null值的引用x，x.equals(null)必须返回false。实现高质量的equals方法的诀窍包括：\n* 使用==操作符检查“参数是否为这个对象的引用”\n* 使用instanceof操作符检查“参数是否为正确的类型”\n* 对于类中的关键属性，检查参数传入对象的属性是否与之相匹配\n* 编写完equals方法后，问自己它是否满足对称性、传递性、一致性\n* 重写equals时总是要重写hashCode\n* 不要将equals方法参数中的Object对象替换为其他的类型，在重写时不要忘掉@Override注解。\n## 是否可以继承String 类?\n答：String 类是final类，不可以被继承。\n补充：继承String本身就是一个错误的行为，对String类型最好的重用方式是关联（HAS-A）而不是继承（IS-A）。\n \n## 当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递?\n答：是值传递。Java 编程语言只有值传递参数。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的属性可以在被调用过程中被改变，但对象的引用是永远不会改变的。C++和C#中可以通过传引用或传输出参数来改变传入的参数的值。\n补充：Java中没有传引用实在是非常的不方便，这一点在Java 8中仍然没有得到改进，正是如此在Java编写的代码中才会出现大量的Wrapper类（将需要通过方法调用修改的引用置于一个Wrapper类中，再将Wrapper对象传入方法），这样的做法只会让代码变得臃肿，尤其是让从C和C++转型为Java程序员的开发者无法容忍。\n## 19、String 和StringBuilder、StringBuffer 的区别?\nJava 平台提供了两种类型的字符串：String和StringBuffer / StringBuilder，它们可以储存和操作字符串。其中String是只读字符串，也就意味着String引用的字符串内容是不能被改变的。而StringBuffer和StringBuilder类表示的字符串对象可以直接进行修改。StringBuilder是JDK 1.5中引入的，它和StringBuffer的方法完全相同，区别在于它是在单线程环境下使用的，因为它的所有方面都没有被synchronized修饰，因此它的效率也比StringBuffer略高。\n补充1：有一个面试题问：有没有哪种情况用+做字符串连接比调用StringBuffer / StringBuilder对象的append方法性能更好？如果连接后得到的字符串在静态存储区中是早已存在的，那么用+做字符串连接是优于StringBuffer / StringBuilder的append方法的。\n补充2：下面也是一个面试题，问程序的输出，看看自己能不能说出正确答案。\n```java\nString a = \"aaabbb\";\nString b = new String(\"aaabbb\");\nString c = \"aaa\" + \"bbb\";\nSystem.out.println(a == b);\nSystem.out.println(a == c);\nSystem.out.println(a.equals(b));\nSystem.out.println(a.equals(c));\nSystem.out.println(a.intern() == b.intern());\n```\n## 重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分?\n答：方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。重载对返回类型没有特殊的要求。\n补充：华为的面试题中曾经问过这样一个问题：为什么不能根据返回类型来区分重载，说出你的答案吧！\n \n## 描述一下JVM 加载class文件的原理机制?\n答：JVM 中类的装载是由类加载器（ClassLoader） 和它的子类来实现的，Java中的类加载器是一个重要的Java 运行时系统组件，它负责在运行时查找和装入类文件中的类。\n补充：\n\n* 由于Java的跨平台性，经过编译的Java源程序并不是一个可执行程序，而是一个或多个类文件。当Java程序需要使用某个类时，JVM会确保这个类已经被加载、连接(验证、准备和解析)和初始化。类的加载是指把类的.class文件中的数据读入到内存中，通常是创建一个字节数组读入.class文件，然后产生与所加载类对应的Class对象。加载完成后，Class对象还不完整，所以此时的类还不可用。当类被加载后就进入连接阶段，这一阶段包括验证、准备(为静态变量分配内存并设置默认的初始值)和解析(将符号引用替换为直接引用)三个步骤。最后JVM对类进行初始化，包括：\n    * 如果类存在直接的父类并且这个类还没有被初始化，那么就先初始化父类\n    * 如果类中存在初始化语句，就依次执行这些初始化语句。\n* 类的加载是由类加载器完成的，类加载器包括：根加载器（BootStrap）、扩展加载器（Extension）、系统加载器（System）和用户自定义类加载器（java.lang.ClassLoader的子类）。从JDK 1.2开始，类加载过程采取了父亲委托机制(PDM)。PDM更好的保证了Java平台的安全性，在该机制中，JVM自带的Bootstrap是根加载器，其他的加载器都有且仅有一个父类加载器。类的加载首先请求父类加载器加载，父类加载器无能为力时才由其子类加载器自行加载。JVM不会向Java程序提供对Bootstrap的引用。下面是关于几个类加载器的说明：\n    * Bootstrap：一般用本地代码实现，负责加载JVM基础核心类库（rt.jar）；\n    * Extension：从java.ext.dirs系统属性所指定的目录中加载类库，它的父加载器是Bootstrap；\n    * System：又叫应用类加载器，其父类是Extension。它是应用最广泛的类加载器。它从环境变量classpath或者系统属性java.class.path所指定的目录中记载类，是用户自定义加载器的默认父加载器。\n## char 型变量中能不能存贮一个中文汉字?为什么?\n答：char类型可以存储一个中文汉字，因为Java中使用的编码是Unicode（不选择任何特定的编码，直接使用字符在字符集中的编号，这是统一的唯一方法），一个char类型占2个字节（16bit），所以放一个中文是没问题的。\n补充：使用Unicode意味着字符在JVM内部和外部有不同的表现形式，在JVM内部都是Unicode，当这个字符被从JVM内部转移到外部时（例如存入文件系统中），需要进行编码转换。所以Java中有字节流和字符流，以及在字符流和字节流之间进行转换的转换流，如InputStreamReader和OutputStreamReader，这两个类是字节流和字符流之间的适配器类，承担了编码转换的任务；对于C程序员来说，要完成这样的编码转换恐怕要依赖于union（联合体/共用体）共享内存的特征来实现了。\n \n## 抽象类（abstract class）和接口（interface）有什么异同?\n答：抽象类和接口都不能够实例化，但可以定义抽象类和接口类型的引用。一个类如果继承了某个抽象类或者实现了某个接口都需要对其中的抽象方法全部进行实现，否则该类仍然需要被声明为抽象类。接口比抽象类更加抽象，因为抽象类中可以定义构造器，可以有抽象方法和具体方法，而接口中不能定义构造器而且其中的方法全部都是抽象方法。抽象类中的成员可以是private、默认、protected、public的，而接口中的成员全都是public的。抽象类中可以定义成员变量，而接口中定义的成员变量实际上都是常量。有抽象方法的类必须被声明为抽象类，而抽象类未必要有抽象方法。\n\n## Java 中会存在内存泄漏吗，请简单描述。\n答：理论上Java因为有垃圾回收机制（GC）不会存在内存泄露问题（这也是Java被广泛使用于服务器端编程的一个重要原因）；然而在实际开发中，可能会存在无用但可达的对象，这些对象不能被GC回收也会发生内存泄露。一个例子就是Hibernate的Session（一级缓存）中的对象属于持久态，垃圾回收器是不会回收这些对象的，然而这些对象中可能存在无用的垃圾对象。下面的例子也展示了Java中发生内存泄露的情况：\n```java\npublic class Test<T>{\n    private T[] elements;\n    private int size = 0;\n    private static final int INIT_CAPACITY = 16;\n    public Test(){\n        elements = (T[])new Object[INIT_CAPACITY];\n    }\n    public void push(T elem){\n        ensureCapacity();\n        elements[size++] = elem;\n    }\n    public T pop(){\n        if(size == 0){\n            throw new EmptyStackException();\n        }\n        retrun elements[--size];\n    }\n    private void ensureCapacity(){\n        if(elements.length == size){\n            elements = Arrays.copyOf(elements, 2 * size + 1)；\n        }\n    }\n}\n\n```\n上面的代码实现了一个栈（先进后出（FILO））结构，乍看之下似乎没有什么明显的问题，它甚至可以通过你编写的各种单元测试。然而其中的pop方法却存在内存泄露的问题，当我们用pop方法弹出栈中的对象时，该对象不会被当作垃圾回收，即使使用栈的程序不再引用这些对象，因为栈内部维护着对这些对象的过期引用（obsolete reference）。在支持垃圾回收的语言中，内存泄露是很隐蔽的，这种内存泄露其实就是无意识的对象保持。如果一个对象引用被无意识的保留起来了，那么垃圾回收器不会处理这个对象，也不会处理该对象引用的其他对象，即使这样的对象只有少数几个，也可能会导致很多的对象被排除在垃圾回收之外，从而对性能造成重大影响，极端情况下会引发Disk Paging（物理内存与硬盘的虚拟内存交换数据），甚至造成OutOfMemoryError。\n \n## 抽象的（abstract）方法是否可同时是静态的（static）,是否可同时是本地方法（native），是否可同时被synchronized修饰?\n答：都不能。抽象方法需要子类重写，而静态的方法是无法被重写的，因此二者是矛盾的。本地方法是由本地代码（如C代码）实现的方法，而抽象方法是没有实现的，也是矛盾的。synchronized和方法的实现细节有关，抽象方法不涉及实现细节，因此也是相互矛盾的。\n## 静态变量和实例变量的区别？\n答：静态变量是被static修饰符修饰的变量，也称为类变量，它属于类，不属于类的任何一个对象，一个类不管创建多少个对象，静态变量在内存中有且仅有一个拷贝；实例变量必须依存于某一实例，需要先创建对象然后通过对象才能访问到它。静态变量可以实现让多个对象共享内存。在Java开发中，上下文类和工具类中通常会有大量的静态成员。\n## 是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？\n答：不可以，静态方法只能访问静态成员，因为非静态方法的调用要先创建对象，因此在调用静态方法时可能对象并没有被初始化。\n## 如何实现对象克隆？\n答：有两种方式：\n\n* 实现Cloneable接口并重写Object类中的clone()方法；\n* 实现Serializable接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆，代码如下。\n```java\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\n\npublic class MyUtil {\n\n    private MyUtil() {\n        throw new AssertionError();\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public static <T extends Serializable> T clone(T obj) throws Exception {\n        ByteArrayOutputStream bout = new ByteArrayOutputStream();\n        ObjectOutputStream oos = new ObjectOutputStream(bout);\n        oos.writeObject(obj);\n\n        ByteArrayInputStream bin = new ByteArrayInputStream(bout.toByteArray());\n        ObjectInputStream ois = new ObjectInputStream(bin);\n        return (T) ois.readObject();\n\n        // 说明：调用ByteArrayInputStream或ByteArrayOutputStream对象的close方法没有任何意义\n        // 这两个基于内存的流只要垃圾回收器清理对象就能够释放资源，这一点不同于对外部资源（如文件流）的释放\n    }\n}\n```\n注意：基于序列化和反序列化实现的克隆不仅仅是深度克隆，更重要的是通过泛型限定，可以检查出要克隆的对象是否支持序列化，这项检查是编译器完成的，不是在运行时抛出异常，这种是方案明显优于使用Object类的clone方法克隆对象。\n## GC 是什么？为什么要有GC？\n答：GC是垃圾收集的意思，内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java语言没有提供释放已分配内存的显示操作方法。Java程序员不用担心内存管理，因为垃圾收集器会自动进行管理。要请求垃圾收集，可以调用下面的方法之一：System.gc() 或Runtime.getRuntime().gc() ，但JVM可以屏蔽掉显示的垃圾回收调用。\n垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存。垃圾回收器通常是作为一个单独的低优先级的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。在Java诞生初期，垃圾回收是Java最大的亮点之一，因为服务器端的编程需要有效的防止内存泄露问题，然而时过境迁，如今Java的垃圾回收机制已经成为被诟病的东西。移动智能终端用户通常觉得iOS的系统比Android系统有更好的用户体验，其中一个深层次的原因就在于Android系统中垃圾回收的不可预知性。\n补充：垃圾回收机制有很多种，包括：分代复制垃圾回收、标记垃圾回收、增量垃圾回收等方式。标准的Java进程既有栈又有堆。栈保存了原始型局部变量，堆保存了要创建的对象。Java平台对堆内存回收和再利用的基本算法被称为标记和清除，但是Java对其进行了改进，采用“分代式垃圾收集”。这种方法会跟Java对象的生命周期将堆内存划分为不同的区域，在垃圾收集过程中，可能会将对象移动到不同区域：\n\n* 伊甸园（Eden）：这是对象最初诞生的区域，并且对大多数对象来说，这里是它们唯一存在过的区域。\n* 幸存者乐园（Survivor）：从伊甸园幸存下来的对象会被挪到这里。\n* 终身颐养园（Tenured）：这是足够老的幸存对象的归宿。年轻代收集（Minor-GC）过程是不会触及这个地方的。当年轻代收集不能把对象放进终身颐养园时，就会触发一次完全收集（Major-GC），这里可能还会牵扯到压缩，以便为大对象腾出足够的空间。\n与垃圾回收相关的JVM参数：\n    * -Xms / -Xmx --- 堆的初始大小 / 堆的最大大小\n    * -Xmn --- 堆中年轻代的大小\n    * -XX:-DisableExplicitGC --- 让System.gc()不产生任何作用\n    * -XX:+PrintGCDetail --- 打印GC的细节\n    * -XX:+PrintGCDateStamps --- 打印GC操作的时间戳\n## String s=new String(“xyz”);创建了几个字符串对象？\n答：两个对象，一个是静态存储区的\"xyz\",一个是用new创建在堆上的对象。\n## 接口是否可继承（extends）接口? 抽象类是否可实现（implements）接口? 抽象类是否可继承具体类（concrete class）?\n答：接口可以继承接口。抽象类可以实现(implements)接口，抽象类可继承具体类，但前提是具体类必须有明确的构造函数。\n## 一个“.java”源文件中是否可以包含多个类（不是内部类）？有什么限制？\n答：可以，但一个源文件中最多只能有一个公开类（public class）而且文件名必须和公开类的类名完全保持一致。\n## Anonymous Inner Class(匿名内部类)是否可以继承其它类？是否可以实现接口？\n答：可以继承其他类或实现其他接口，在Swing编程中常用此方式来实现事件监听和回调。\n## 内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？\n答：一个内部类对象可以访问创建它的外部类对象的成员，包括私有成员。\n## Java 中的final关键字有哪些用法？\n答：\n\n* 修饰类：表示该类不能被继承\n* 修饰方法：表示方法不能被重写\n* 修饰变量：表示变量只能一次赋值以后值不能被修改（常量）。\n## 指出下面程序的运行结果:\n```java\nclass TestA{\n    static{\n        System.out.println(\"1\");\n    }\n    public TestA(){\n        System.out.println(\"2\");\n    }\n}\n\nclass TestB extend TestA{\n    static{\n        System.out.println(\"a\");\n    }\n    \n    public TestB(){\n        System.out.println(\"b\")\n    }\n}\n\npublic class Main{\n    public static void main (String[] args){\n        TestA a = new TestB();\n        a = new TestB();\n    }\n}\n```\n答：执行结果：1a2b2b。创建对象时构造器的调用顺序是：先初始化静态成员，然后调用父类构造器，再初始化非静态成员，最后调用自身构造器。\n## 数据类型之间的转换:\n\n* 如何将字符串转换为基本数据类型？\n* 如何将基本数据类型转换为字符串？\n答：\n\n* 调用基本数据类型对应的包装类中的方法parseXXX(String)或valueOf(String)即可返回相应基本类型；\n* 一种方法是将基本数据类型与空字符串（””）连接（+）即可获得其所对应的字符串；另一种方法是调用String 类中的valueOf(…)方法返回相应字符串\n \n## 如何实现字符串的反转及替换？\n答：方法很多，可以自己写实现也可以使用String或StringBuffer / StringBuilder中的方法。有一道很常见的面试题是用递归实现字符串反转，代码如下所示：\n```java\npublic static String reverse(String str){\n    if(str == null || str.length() < = 1){\n        retrun str;\n    }\n    return reverse(str.substring(1)) + str.charAt(0));\n}\n\n```\n## 怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串？\n答：代码如下所示:\n```java\nString s1 = \"你好\";\nString s2 = newString(s1.getBytes(\"GB2312\"), \"ISO-8859-1\");\n```\n\n## 日期和时间：\n\n* 如何取得年月日、小时分钟秒？\n* 如何取得从1970年1月1日0时0分0秒到现在的毫秒数？\n* 如何格式化日期？\n答：操作方法如下所示：\n* 创建java.util.Calendar 实例，调用其get()方法传入不同的参数即可获得参数所对应的值\n* 以下方法均可获得该毫秒数:\n```java\nCalendar.getInstance().getTimeInMillis();\nSystem.currentTimeMillis();\n```\n* 利用java.text.DataFormat 的子类（如SimpleDateFormat类）中的format(Date)方法可将日期格式化。\n\n## 比较一下Java 和JavaSciprt。\n答：JavaScript 与Java是两个公司开发的不同的两个产品。Java 是原Sun 公司推出的面向对象的程序设计语言，特别适合于互联网应用程序开发；而JavaScript是Netscape公司的产品，为了扩展Netscape浏览器的功能而开发的一种可以嵌入Web页面中运行的基于对象和事件驱动的解释性语言，它的前身是LiveScript；而Java 的前身是Oak语言。\n下面对两种语言间的异同作如下比较：\n\n* 基于对象和面向对象：Java是一种真正的面向对象的语言，即使是开发简单的程序，必须设计对象；JavaScript是种脚本语言，它可以用来制作与网络无关的，与用户交互作用的复杂软件。它是一种基于对象（Object-Based）和事件驱动（Event-Driven）的编程语言。因而它本身提供了非常丰富的内部对象供设计人员使用；\n* 解释和编译：Java 的源代码在执行之前，必须经过编译；JavaScript 是一种解释性编程语言，其源代码不需经过编译，由浏览器解释执行；\n* 强类型变量和类型弱变量：Java采用强类型变量检查，即所有变量在编译之前必须作声明；JavaScript中变量声明，采用其弱类型。即变量在使用前不需作声明，而是解释器在运行时检查其数据类型；\n* 代码格式不一样。\n补充：上面列出的四点是原来所谓的标准答案中给出的。其实Java和JavaScript最重要的区别是一个是静态语言，一个是动态语言。目前的编程语言的发展趋势是函数式语言和动态语言。在Java中类（class）是一等公民，而JavaScript中函数（function）是一等公民。对于这种问题，在面试时还是用自己的语言回答会更加靠谱。\n \n## 什么时候用assert？\n答：assertion(断言)在软件开发中是一种常用的调试方式，很多开发语言中都支持这种机制。一般来说，assertion用于保证程序最基本、关键的正确性。assertion检查通常在开发和测试时开启。为了提高性能，在软件发布后， assertion检查通常是关闭的。在实现中，断言是一个包含布尔表达式的语句，在执行这个语句时假定该表达式为true；如果表达式计算为false，那么系统会报告一个AssertionError。\n断言用于调试目的：\nassert(a > 0); // throws an AssertionError if a <= 0\n断言可以有两种形式：\nassert Expression1;\nassert Expression1 : Expression2 ;\nExpression1 应该总是产生一个布尔值。\nExpression2 可以是得出一个值的任意表达式；这个值用于生成显示更多调试信息的字符串消息。\n断言在默认情况下是禁用的，要在编译时启用断言，需使用source 1.4 标记：\njavac -source 1.4 Test.java\n要在运行时启用断言，可使用-enableassertions 或者-ea 标记。\n要在运行时选择禁用断言，可使用-da 或者-disableassertions 标记。\n要在系统类中启用断言，可使用-esa 或者-dsa 标记。还可以在包的基础上启用或者禁用断言。可以在预计正常情况下不会到达的任何位置上放置断言。断言可以用于验证传递给私有方法的参数。不过，断言不应该用于验证传递给公有方法的参数，因为不管是否启用了断言，公有方法都必须检查其参数。不过，既可以在公有方法中，也可以在非公有方法中利用断言测试后置条件。另外，断言不应该以任何方式改变程序的状态。\n## Error 和Exception 有什么区别?\n答：Error 表示系统级的错误和程序不必处理的异常，是恢复不是不可能但很困难的情况下的一种严重问题；比如内存溢出，不可能指望程序能处理这样的情况；Exception 表 示需要捕捉或者需要程序进行处理的异常，是一种设计或实现问题；也就是说，它表示如果程序运行正常，从不会发生的情况。\n补充：2005年摩托罗拉的面试中曾经问过这么一个问题“If a process reports a stack overflow run-time error, what’s the most possible cause?”，给了四个选项\n\n* a. lack of memory\n* b. write on an invalid memory space\n* c. recursive function calling\n* d. array index out of boundary\nJava程序在运行时也可能会遭遇StackOverflowError，这是一个错误无法恢复，只能重新修改代码了，这个面试题的答案是c。如果写了不能迅速收敛的递归，则很有可能引发栈溢出的错误，如下所示：\n\n因此，用递归编写程序时一定要牢记两点：\n\n* 递归公式\n* 收敛条件（什么时候就不再递归而是回溯了）。\n## try{}里有一个return语句，那么紧跟在这个try后的finally{}里的code会不会被执行，什么时候被执行，在return前还是后?\n答：会执行，在方法返回调用者前执行。Java允许在finally中改变返回值的做法是不好的，因为如果存在finally代码块，try中的return语句不会立马返回调用者，而是记录下返回值待finally代码块执行完毕之后再向调用者返回其值，然后如果在finally中修改了返回值，这会对程序造成很大的困扰，C#中就从语法上规定不能做这样的事。\n## Java 语言如何进行异常处理，关键字：throws、throw、try、catch、finally分别如何使用？\nJava 通过面向对象的方法进行异常处理，把各种不同的异常进行分类，并提供了良好的接口。在Java 中，每个异常都是一个对象，它是Throwable 类或其子类的实例。当一个方法出现异常后便抛出一个异常对象，该对象中包含有异常信息，调用这个对象的方法可以捕获到这个异常并进行处理。Java 的异常处理是通过5 个关键词来实现的：try、catch、throw、throws和finally。一般情况下是用try来执行一段程序，如果出现异常，系统会抛出（throw）一个异常，这时候你可以通过它的类型来捕捉（catch）它，或最后（finally）由缺省处理器来处理；try用来指定一块预防所有“异常”的程序；catch 子句紧跟在try块后面，用来指定你想要捕捉的“异常”的类型；throw 语句用来明确地抛出一个“异常”；throws用来标明一个成员函数可能抛出的各种“异常”；finally 为确保一段代码不管发生什么“异常”都被执行一段代码；可以在一个成员函数调用的外面写一个try语句，在这个成员函数内部写另一个try语句保护其他代码。每当遇到一个try 语句，“异常”的框架就放到栈上面，直到所有的try语句都完成。如果下一级的try语句没有对某种“异常”进行处理，栈就会展开，直到遇到有处理这种“异常”的try 语句。\n## 运行时异常与受检异常有何异同？\n答：异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误，只要程序设计得没有问题通常就不会发生。受检异常跟程序运行的上下文环境有关，即使程序设计无误，仍然可能因使用的问题而引发。Java编译器要求方法必须声明抛出可能发生的受检异常，但是并不要求必须声明抛出未被捕获的运行时异常。异常和继承一样，是面向对象程序设计中经常被滥用的东西，神作《Effective Java》中对异常的使用给出了以下指导原则：\n\n* 不要将异常处理用于正常的控制流（设计良好的API不应该强迫它的调用者为了正常的控制流而使用异常）\n* 对可以恢复的情况使用受检异常，对编程错误使用运行时异常\n* 避免不必要的使用受检异常（可以通过一些状态检测手段来避免异常的发生）\n* 优先使用标准的异常\n* 每个方法抛出的异常都要有文档\n* 保持异常的原子性\n* 不要在catch中忽略掉捕获到的异常\n## 列出一些你常见的运行时异常？\n\n* ArithmeticException（算术异常）\n* ClassCastException （类转换异常）\n* IllegalArgumentException （非法参数异常）\n* IndexOutOfBoundsException （下表越界异常）\n* NullPointerException （空指针异常）\n* SecurityException （安全异常）\n## final, finally, finalize 的区别?\n答：\n* final：修饰符（关键字）有三种用法：如果一个类被声明为final，意味着它不能再派生出新的子类，即不能被继承，因此它和abstract是反义词。将变量声明为final，可以保证它们在使用中不被改变，被声明为final 的变量必须在声明时给定初值，而在以后的引用中只能读取不可修改。被声明为final 的方法也同样只能使用，不能在子类中被重写。finally：通常放在try…catch的后面构造总是执行代码块，这就意味着程序无论正常执行还是发生异常，这里的代码只要JVM不关闭都能执行，可以将释放外部资源的代码写在finally块中。finalize：Object类中定义的方法，Java中允许使用finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在销毁对象时调用的，通过重写finalize() 方法可以整理系统资源或者执行其他清理工作。\n* finally：通常放在try…catch…的后面构造总是执行代码块，这就意味着程序无论正常执行还是发生异常，这里的代码只要JVM不关闭都能执行，可以将释放外部资源的代码写在finally块中。 \n* finalize：Object类中定义的方法，Java中允许使用finalize()方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在销毁对象时调用的，通过重写finalize()方法可以整理系统资源或者执行其他清理工作。\n\n## List、Set、Map是否继承自Collection接口？\n答：List、Set 是，Map 不是。Map是键值对映射容器，与List和Set有明显的区别，而Set存储的零散的元素且不允许有重复元素（数学中的集合也是如此），List是线性结构的容器，适用于按数值索引访问元素的情形。\n\n## 阐述ArrayList、Vector、LinkedList的存储性能和特性。 \n\n答：ArrayList 和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector中的方法由于添加了synchronized修饰，因此Vector是线程安全的容器，但性能上较ArrayList差，因此已经是Java中的遗留容器。LinkedList使用双向链表实现存储（将内存中零散的内存单元通过附加的引用关联起来，形成一个可以按序号索引的线性结构，这种链式存储方式与数组的连续存储方式相比，内存的利用率更高），按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。Vector属于遗留容器（Java早期的版本中提供的容器，除此之外，Hashtable、Dictionary、BitSet、Stack、Properties都是遗留容器），已经不推荐使用，但是由于ArrayList和LinkedListed都是非线程安全的，如果遇到多个线程操作同一个容器的场景，则可以通过工具类Collections中的synchronizedList方法将其转换成线程安全的容器后再使用（这是对装潢模式的应用，将已有对象传入另一个类的构造器中创建新的对象来增强实现）。\n\n> 补充：遗留容器中的Properties类和Stack类在设计上有严重的问题，Properties是一个键和值都是字符串的特殊的键值对映射，在设计上应该是关联一个Hashtable并将其两个泛型参数设置为String类型，但是Java API中的Properties直接继承了Hashtable，这很明显是对继承的滥用。这里复用代码的方式应该是Has-A关系而不是Is-A关系，另一方面容器都属于工具类，继承工具类本身就是一个错误的做法，使用工具类最好的方式是Has-A关系（关联）或Use-A关系（依赖）。同理，Stack类继承Vector也是不正确的。Sun公司的工程师们也会犯这种低级错误，让人唏嘘不已。\n\n## Collection和Collections的区别？\n答：Collection是一个接口，它是Set、List等容器的父接口；Collections是个一个工具类，提供了一系列的静态方法来辅助容器操作，这些方法包括对容器的搜索、排序、线程安全化等等。\n\n## List、Map、Set三个接口存取元素时，各有什么特点？ \n答：List以特定索引来存取元素，可以有重复元素。Set不能存放重复元素（用对象的equals()方法来区分元素是否重复）。Map保存键值对（key-value pair）映射，映射关系可以是一对一或多对一。Set和Map容器都有基于哈希存储和排序树的两种实现版本，基于哈希存储的版本理论存取时间复杂度为O(1)，而基于排序树版本的实现在插入或删除元素时会按照元素或元素的键（key）构成排序树从而达到排序和去重的效果。\n\n## TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort()方法如何比较元素？ \n答：TreeSet要求存放的对象所属的类必须实现Comparable接口，该接口提供了比较元素的compareTo()方法，当插入元素时会回调该方法比较元素的大小。TreeMap要求存放的键值对映射的键必须实现Comparable接口从而根据键对元素进行排序。Collections工具类的sort方法有两种重载的形式，第一种要求传入的待排序容器中存放的对象比较实现Comparable接口以实现元素的比较；第二种不强制性的要求容器中的元素必须可比较，但是要求传入第二个参数，参数是Comparator接口的子类型（需要重写compare方法实现元素的比较），相当于一个临时定义的排序规则，其实就是通过接口注入比较元素大小的算法，也是对回调模式的应用（Java中对函数式编程的支持）。 \n例子代码如下：\n```java\npublic class Student implements Comparable<Student> {\n    private String name;        // 姓名\n    private int age;            // 年龄\n\n    public Student(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    @Override\n    public String toString() {\n        return \"Student [name=\" + name + \", age=\" + age + \"]\";\n    }\n\n    @Override\n    public int compareTo(Student o) {\n        return this.age - o.age; // 比较年龄(年龄的升序)\n    }\n\n}\n```\n\n```java\nclass Test {\n\n    public static void main(String[] args) {\n        Set<Student> set = new TreeSet<>();     // Java 7的钻石语法(构造器后面的尖括号中不需要写类型)\n        set.add(new Student(\"Hao LUO\", 33));\n        set.add(new Student(\"XJ WANG\", 32));\n        set.add(new Student(\"Bruce LEE\", 60));\n        set.add(new Student(\"Bob YANG\", 22));\n\n        for(Student stu : set) {\n            System.out.println(stu);\n        }\n//      输出结果: \n//      Student [name=Bob YANG, age=22]\n//      Student [name=XJ WANG, age=32]\n//      Student [name=Hao LUO, age=33]\n//      Student [name=Bruce LEE, age=60]\n    }\n}\n```\n\n## Thread类的sleep()方法和对象的wait()方法都可以让线程暂停执行，它们有什么区别? \n答：sleep()方法（休眠）是线程类（Thread）的静态方法，调用此方法会让当前线程暂停执行指定的时间，将执行机会（CPU）让给其他线程，但是对象的锁依然保持，因此休眠时间结束后会自动恢复（线程回到就绪状态，请参考第66题中的线程状态转换图）。wait()是Object类的方法，调用对象的wait()方法导致当前线程放弃对象的锁（线程暂停执行），进入对象的等待池（wait pool），只有调用对象的notify()方法（或notifyAll()方法）时才能唤醒等待池中的线程进入等锁池（lock pool），如果线程重新获得对象的锁就可以进入就绪状态。\n\n> 补充：可能不少人对什么是进程，什么是线程还比较模糊，对于为什么需要多线程编程也不是特别理解。简单的说：进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，是操作系统进行资源分配和调度的一个独立单位；线程是进程的一个实体，是CPU调度和分派的基本单位，是比进程更小的能独立运行的基本单位。线程的划分尺度小于进程，这使得多线程程序的并发性高；进程在执行时通常拥有独立的内存单元，而线程之间可以共享内存。使用多线程的编程通常能够带来更好的性能和用户体验，但是多线程的程序对于其他程序是不友好的，因为它可能占用了更多的CPU资源。当然，也不是线程越多，程序的性能就越好，因为线程之间的调度和切换也会浪费CPU时间。时下很时髦的Node.js就采用了单线程异步I/O的工作模式。\n  \n## 线程的sleep()方法和yield()方法有什么区别？ \n答： \n* sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会； \n* 线程执行sleep()方法后转入阻塞（blocked）状态，而执行yield()方法后转入就绪（ready）状态； \n* sleep()方法声明抛出InterruptedException，而yield()方法没有声明任何异常； \n* sleep()方法比yield()方法（跟操作系统CPU调度相关）具有更好的可移植性。\n\n## 当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B？ \n 答：不能。其它线程只能访问该对象的非同步方法，同步方法则不能进入。因为非静态方法上的synchronized修饰符要求执行方法时要获得对象的锁，如果已经进入A方法说明对象锁已经被取走，那么试图进入B方法的线程就只能在等锁池（注意不是等待池哦）中等待对象的锁。\n \n## 请说出与线程同步以及线程调度相关的方法\n* wait()：使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁； \n* sleep()：使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要处理InterruptedException异常； \n* notify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且与优先级无关； \n* notityAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态；\n\n## 编写多线程程序有几种实现方式？ \n一种是继承Thread类；另一种是实现Runnable接口。两种方式都要通过重写run()方法来定义线程的行为，推荐使用后者，因为Java中的继承是单继承，一个类有一个父类，如果继承了Thread类就无法再继承其他类了，显然使用Runnable接口更为灵活。\n> 补充：还有就是实现Callable接口，该接口中的call方法可以在线程执行结束时产生一个返回值，代码如下所示：\n## 什么是线程池（thread pool）？ \n在面向对象编程中，创建和销毁对象是很费时间的，因为创建一个对象要获取内存资源或者其它更多资源。在Java中更是如此，虚拟机将试图跟踪每一个对象，以便能够在对象销毁后进行垃圾回收。所以提高服务程序效率的一个手段就是尽可能减少创建和销毁对象的次数，特别是一些很耗资源的对象创建和销毁，这就是”池化资源”技术产生的原因。线程池顾名思义就是事先创建若干个可执行的线程放入一个池（容器）中，需要的时候从池中获取线程不用自行创建，使用完毕不需要销毁线程而是放回池中，从而减少创建和销毁线程对象的开销。 \n一些常用的线程池，如下所示：\n* newSingleThreadExecutor：创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。 \n* newFixedThreadPool：创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。 \n* newCachedThreadPool：创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。 \n* newScheduledThreadPool：创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。 \n* newSingleThreadExecutor：创建一个单线程的线程池。此线程池支持定时以及周期性执行任务的需求。\n\n## 简述synchronized 和java.util.concurrent.locks.Lock的异同？ \nLock 能完成synchronized所实现的所有功能；主要不同点：Lock有比synchronized更精确的线程语义和更好的性能，而且不强制性的要求一定要获得锁。synchronized会自动释放锁，而Lock一定要求程序员手工释放，并且最好在finally 块中释放（这是释放外部资源的最好的地方）。\n\n## Java中如何实现序列化，有什么意义？ \n答：序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。序列化是为了解决对象流读写操作时可能引发的问题（如果不进行序列化可能会存在数据乱序的问题）。 \n要实现序列化，需要让一个类实现Serializable接口，该接口是一个标识性接口，标注该类对象是可被序列化的，然后使用一个输出流来构造一个对象输出流并通过writeObject(Object)方法就可以将实现对象写出（即保存其状态）；如果需要反序列化则可以用一个输入流建立对象输入流，然后通过readObject方法从流中读取对象。序列化除了能够实现对象的持久化之外，还能够用于对象的深度克隆\n\n## Java中有几种类型的流？ \n答：字节流和字符流。字节流继承于InputStream、OutputStream，字符流继承于Reader、Writer。在java.io 包中还有许多其他的流，主要是为了提高性能和使用方便。关于Java的I/O需要注意的有两点：一是两种对称性（输入和输出的对称性，字节和字符的对称性）；二是两种设计模式（适配器模式和装潢模式）。另外Java中的流不同于C#的是它只有一个维度一个方向。\n\n## 如何用Java代码列出一个目录下所有的文件？ \n如果只要求列出当前文件夹下的文件，代码如下所示：\n```java\nclass Test {\n\n    public static void main(String[] args) {\n        File f = new File(\"/Users/Downloads\");\n        for(File temp : f.listFiles()) {\n            if(temp.isFile()) {\n                System.out.println(temp.getName());\n            }\n        }\n    }\n}\n```\n如果需要对文件夹继续展开，代码如下所示：\n```java\n\nclass Test {\n\n    public static void main(String[] args) {\n        showDirectory(new File(\"/Users/Downloads\"));\n    }\n\n    public static void showDirectory(File f) {\n        _walkDirectory(f, 0);\n    }\n\n    private static void _walkDirectory(File f, int level) {\n        if(f.isDirectory()) {\n            for(File temp : f.listFiles()) {\n                _walkDirectory(temp, level + 1);\n            }\n        }\n        else {\n            for(int i = 0; i < level - 1; i++) {\n                System.out.print(\"\\t\");\n            }\n            System.out.println(f.getName());\n        }\n    }\n}\n```\n## 什么是DAO模式？\n答：DAO（Data Access Object）顾名思义是一个为数据库或其他持久化机制提供了抽象接口的对象，在不暴露底层持久化方案实现细节的前提下提供了各种数据访问操作。在实际的开发中，应该将所有对数据源的访问操作进行抽象化后封装在一个公共API中。用程序设计语言来说，就是建立一个接口，接口中定义了此应用程序中将会用到的所有事务方法。在这个应用程序中，当需要和数据源进行交互的时候则使用这个接口，并且编写一个单独的类来实现这个接口，在逻辑上该类对应一个特定的数据存储。DAO模式实际上包含了两个模式，一是Data Accessor（数据访问器），二是Data Object（数据对象），前者要解决如何访问数据的问题，而后者要解决的是如何用对象封装数据。\n\n## 事务的ACID是指什么？ \n\n答： \n* 原子性(Atomic)：事务中各项操作，要么全做要么全不做，任何一项操作的失败都会导致整个事务的失败； \n* 一致性(Consistent)：事务结束后系统状态是一致的； \n* 隔离性(Isolated)：并发执行的事务彼此无法看到对方的中间状态； \n* 持久性(Durable)：事务完成后所做的改动都会被持久化，即使发生灾难性的失败。通过日志和同步备份可以在故障发生后重建数据。\n> 补充：关于事务，在面试中被问到的概率是很高的，可以问的问题也是很多的。首先需要知道的是，只有存在并发数据访问时才需要事务。当多个事务访问同一数据时，可能会存在5类问题，包括3类数据读取问题（脏读、不可重复读和幻读）和2类数据更新问题（第1类丢失更新和第2类丢失更新）。\n\n## 简述正则表达式及其用途。 \n答：在编写处理字符串的程序时，经常会有查找符合某些复杂规则的字符串的需要。正则表达式就是用于描述这些规则的工具。换句话说，正则表达式就是记录文本规则的代码。\n> 说明：计算机诞生初期处理的信息几乎都是数值，但是时过境迁，今天我们使用计算机处理的信息更多的时候不是数值而是字符串，正则表达式就是在进行字符串匹配和处理的时候最为强大的工具，绝大多数语言都提供了对正则表达式的支持。\n\n## Java中是如何支持正则表达式操作的？ \n答：Java中的String类提供了支持正则表达式操作的方法，包括：matches()、replaceAll()、replaceFirst()、split()。此外，Java中可以用Pattern类表示正则表达式对象，它提供了丰富的API进行各种正则表达式操作，请参考下面面试题的代码。\n\n> 面试题： - 如果要从字符串中截取第一个英文左括号之前的字符串，例如：北京市(朝阳区)(西城区)(海淀区)，截取结果为：北京市，那么正则表达式怎么写？\n```java\n\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nclass RegExpTest {\n\n    public static void main(String[] args) {\n        String str = \"北京市(朝阳区)(西城区)(海淀区)\";\n        Pattern p = Pattern.compile(\".*?(?=\\\\()\");\n        Matcher m = p.matcher(str);\n        if(m.find()) {\n            System.out.println(m.group());\n        }\n    }\n}\n```\n## 获得一个类的类对象有哪些方式？ \n答： \n* 类型.class，例如：String.class \n* 对象.getClass()，例如：\"hello\".getClass() \n* Class.forName()，例如：Class.forName(\"java.lang.String\")\n## 如何通过反射创建对象？ \n答： \n* 通过类对象调用newInstance()方法，例如：String.class.newInstance() \n* 通过类对象的getConstructor()或getDeclaredConstructor()方法获得构造器（Constructor）对象并调用其newInstance()方法创建对象，例如：String.class.getConstructor(String.class).newInstance(\"Hello\");\n \n## 如何通过反射调用对象的方法？ \n答：请看下面的代码：\n```java\nimport java.lang.reflect.Method;\n\nclass MethodInvokeTest {\n\n    public static void main(String[] args) throws Exception {\n        String str = \"hello\";\n        Method m = str.getClass().getMethod(\"toUpperCase\");\n        System.out.println(m.invoke(str));  // HELLO\n    }\n}\n```\n## 简述一下你了解的设计模式。 \n答：所谓设计模式，就是一套被反复使用的代码设计经验的总结（情境中一个问题经过证实的一个解决方案）。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。设计模式使人们可以更加简单方便的复用成功的设计和体系结构。将已证实的技术表述成设计模式也会使新系统开发者更加容易理解其设计思路。 \n在GoF的《Design Patterns: Elements of Reusable Object-Oriented Software》中给出了三类（创建型[对类的实例化过程的抽象化]、结构型[描述如何将类或对象结合在一起形成更大的结构]、行为型[对在不同的对象之间划分责任和算法的抽象化]）共23种设计模式，包括：Abstract Factory（抽象工厂模式），Builder（建造者模式），Factory Method（工厂方法模式），Prototype（原始模型模式），Singleton（单例模式）；Facade（门面模式），Adapter（适配器模式），Bridge（桥梁模式），Composite（合成模式），Decorator（装饰模式），Flyweight（享元模式），Proxy（代理模式）；Command（命令模式），Interpreter（解释器模式），Visitor（访问者模式），Iterator（迭代子模式），Mediator（调停者模式），Memento（备忘录模式），Observer（观察者模式），State（状态模式），Strategy（策略模式），Template Method（模板方法模式）， Chain Of Responsibility（责任链模式）。 \n面试被问到关于设计模式的知识时，可以拣最常用的作答，例如： \n* 工厂模式：工厂类可以根据条件生成不同的子类实例，这些子类有一个公共的抽象父类并且实现了相同的方法，但是这些方法针对不同的数据进行了不同的操作（多态方法）。当得到子类的实例后，开发人员可以调用基类中的方法而不必考虑到底返回的是哪一个子类的实例。 \n* 代理模式：给一个对象提供一个代理对象，并由代理对象控制原对象的引用。实际开发中，按照使用目的的不同，代理可以分为：远程代理、虚拟代理、保护代理、Cache代理、防火墙代理、同步化代理、智能引用代理。 \n* 适配器模式：把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起使用的类能够一起工作。 \n* 模板方法模式：提供一个抽象类，将部分逻辑以具体方法或构造器的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法（多态实现），从而实现不同的业务逻辑。 \n除此之外，还可以讲讲上面提到的门面模式、桥梁模式、单例模式、装潢模式（Collections工具类和I/O系统中都使用装潢模式）等，反正基本原则就是拣自己最熟悉的、用得最多的作答，以免言多必失。\n\n## 用Java写一个单例类。 \n饿汉式单例:\n```java\npublic class Singleton {\n    private Singleton(){}\n    private static Singleton instance = new Singleton();\n    public static Singleton getInstance(){\n        return instance;\n    }\n}\n\n```\n\n懒汉式单例:\n```java\npublic class Singleton {\n    private static Singleton instance = null;\n    private Singleton() {}\n    public static synchronized Singleton getInstance(){\n        if (instance == null) instance ＝ new Singleton();\n        return instance;\n    }\n}\n\n```\n## 什么是UML？ \n答：UML是统一建模语言（Unified Modeling Language）的缩写，它发表于1997年，综合了当时已经存在的面向对象的建模语言、方法和过程，是一个支持模型化和软件系统开发的图形化语言，为软件开发的所有阶段提供模型化和可视化支持。使用UML可以帮助沟通与交流，辅助应用设计和文档的生成，还能够阐释系统的结构和行为。\n\n## UML中有哪些常用的图？ \nUML定义了多种图形化的符号来描述软件系统部分或全部的静态结构和动态结构，包括：用例图（use case diagram）、类图（class diagram）、时序图（sequence diagram）、协作图（collaboration diagram）、状态图（statechart diagram）、活动图（activity diagram）、构件图（component diagram）、部署图（deployment diagram）等。在这些图形化符号中，有三种图最为重要，分别是：用例图（用来捕获需求，描述系统的功能，通过该图可以迅速的了解系统的功能模块及其关系）、类图（描述类以及类与类之间的关系，通过该图可以快速了解系统）、时序图（描述执行特定任务时对象之间的交互关系以及执行顺序，通过该图可以了解对象能接收的消息也就是说对象能够向外界提供的服务）。\n\n## 用Java写一个折半查找。 \n答：折半查找，也称二分查找、二分搜索，是一种在有序数组中查找某一特定元素的搜索算法。搜素过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜素过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组已经为空，则表示找不到指定的元素。这种搜索算法每一次比较都使搜索范围缩小一半，其时间复杂度是O(logN)。\n\n```java\npublic class MyUtil {\n\n   public static <T extends Comparable<T>> int binarySearch(T[] x, T key) {\n      return binarySearch(x, 0, x.length- 1, key);\n   }\n\n   // 使用循环实现的二分查找\n   public static <T> int binarySearch(T[] x, T key, Comparator<T> comp) {\n      int low = 0;\n      int high = x.length - 1;\n      while (low <= high) {\n          int mid = (low + high) >>> 1;\n          int cmp = comp.compare(x[mid], key);\n          if (cmp < 0) {\n            low= mid + 1;\n          }\n          else if (cmp > 0) {\n            high= mid - 1;\n          }\n          else {\n            return mid;\n          }\n      }\n      return -1;\n   }\n\n   // 使用递归实现的二分查找\n   private static<T extends Comparable<T>> int binarySearch(T[] x, int low, int high, T key) {\n      if(low <= high) {\n        int mid = low + ((high -low) >> 1);\n        if(key.compareTo(x[mid])== 0) {\n           return mid;\n        }\n        else if(key.compareTo(x[mid])< 0) {\n           return binarySearch(x,low, mid - 1, key);\n        }\n        else {\n           return binarySearch(x,mid + 1, high, key);\n        }\n      }\n      return -1;\n   }\n}\n\n```","tags":["little_eight"],"categories":["杂类"]},{"title":"Spring实战笔记（一）","url":"/2018/10/01/Spring实战笔记（一）/","content":"\n## 装配bean\n\n它提供了三种主要的装配机制：\n\n * 隐式的Bean发现机制和自动装配\n * 在Java中进行显式配置\n * 在XML中进行显式配置\n\n### 自动化装配Bean\n\n* 组件扫描（Component Scanning）：Spring会自动发现应用上下文中所创建的Bean\n* 自动装配（Autowired）：Spring自动满足Bean之间的依赖\n\n#### @Component \n这个注解表明该类会作为组件类（还有个类似的注解--@Named(\"bean name\")，用法一样。）\n\n#### @ComponentScan\n不过，组件扫描默认是不开启的，用@ComponentScan注解，如果没有其他配置，它默认会扫描与配置类相同的包（包括这个包下的所有子包），查找带有@Component注解的类，并在Spring中自动为其创建一个Bean\n\n#### @ComponentScan的属性\n* basePackages,值为扫描对象包，如：@ComponentScan(basePackages={\"first\",\"second\"...})\n* basePackageClasses，值为扫描对象类，如：@ComponentScan(basePackageClasses={\"first\",\"second\"...})\n\n#### @Autowired（@Inject用法大致一样）\n自动装配，bean之间的依赖，有构造器、setter方法、其他方法注入。\n\n    在构造器上加此注解，如下，表明当Spring创建BeanA的bean时，会通过这个构造器来进行实例化并且会传入一个可设置给BeanB类型的bean\n```java\n@Component\npublic BeanA implement BeanDady{\n    private BeanB b；\n    @Autowired\n    public BeanA（BeanB b）{\n        this.b = b\n    }\n}\n<!--more-->\n```\n\n    用在属性的setter方法上，比如：\n```java\n@Component\npublic BeanA implement BeanDady{\n    private BeanB b；\n    @Autowired\n    public void setBeanB（BeanB b）{\n        this.b = b\n    }\n}\n```\n    用在方法上,比如：\n```java\n@Component\npublic BeanA implement BeanDady{\n    private BeanB b；\n    @Autowired\n    public void test（BeanB b）{\n        this.b = b\n    }\n}\n```\n不管什么方式，Spring都会尝试满足方法参数上所声明的依赖。假如有且只有一个bean匹配依赖需求的话，那么这个bean将会被装配起来，其他情况的话，在应用上下文创建时，Spring会抛出异常。为了避免异常，你可以将@Autowired的属性required设置为false\n```java\n@Autowired(required=false)\n```\n设置false后，如果没有匹配的bean，Spring会设置这个bean为未装配的状态，当然你的代码也有可能会出现空指针异常。\n\n### 通过Java代码装配bean\n\n#### @Configuration\n该注解表明这个类是一个配置类\n### Bean\n声明bean，我们给配置类里的方法加上此注解\n```java\n@Configuratione\npublic class BeanConfig{\n    @Bean\n    public BeanA beanA(){\n        return new BeanA();\n    }\n}\n```\n@Bean注解会告诉Spring这个方法将会返回一个对象，该对象要注册为Spring应用上下文的bean。默认情况下，bean的id跟此方法名一样，你也可以设置@Bean的属性name来指定一个不同的名字\n```java\n@Bean(name=\"xxx\")\n```\n\n### 通过XML装配bean\n不喜欢这种，，，\n\n#### 声明一个简单的bean\n```xml\n<bean id=\"beanA\" class=\"com.BeanA\"/>\n```\n### 小结\n建议使用自动化配置，减少维护成本。\n<!--more-->\n## 高技装配\n\n### @Primary\n在声明bean时，会有多个匹配的可能，比如BeanDady是一个接口，实现类有BeanA、BeanB\n```java\n@Autowired\npublic void setBean(BeanDady beanDady){\n    this.beanDady = beanDady;\n}\n\n```\n在组件扫描时，Spring就无法判断是装配哪个然后出现异常，所以我们将这个@Primary注解加到指定的类或者方法上，就可成为匹配首选,在匹配群里，此注解只能是唯一。\n```java\n@Component\n@Primary\npublic class BeanA implement BeanDady{\n}\n```\n```java\n@Bean\n@Primary\npublic BeanA beanA(){\n    return new BeanA();\n}\n```\n当然xml方式也有。。\n```xml\n<bean id=\"beanA\" class=\"com.BeanA\" primary=\"true\"/>\n```\n\n### @Qualifier\n这个注解是使用限定符的主要方式，在注入的时候指定想要注入的bean\n```java\n@Autowried\n@Qualifier(\"beanA\")\npublic void setBean(BeanDady beanDady){\n    this.beanDady = beanDady;\n}\n```\n这个注解的值默认是bean的id，当然你也可以自定义限定符,这样匹配的时候就以这个“a”为值，跟@Primary一样，此注解只能唯一\n```java\n@Component\n@Qualifier(\"a\")\npublic BeanA implement BeanDady{}\n```\n\n## bean的作用域\n\nSpring定义了多种作用域，可以基于这些作用域创建bean\n* 单例（singleton）：在整个应用中，只创建bean的一个实例\n* 原型（prototype）：每次注入或者通过Spring应用上下文获取的时候，都会创建一个新的bean实例\n* 会话（session）：在web应用中，为每个会话创建一个bean实例\n* 请求（request）：在web应用中，为每个请求创建一个bean实例\n\n### @Scope\n单例是默认的作用域，如果想选择其他作用域，在bean的类加上此注解,值的话，为了安全跟不易出错，用ConfigurationBeanFactory.SCOPE_PROTOTYPE常量更好。\n```java\n@Component\n@Scope(\"prototype\")\n//这个更好。。 @Scope(ConfigurationBeanFactory.SCOPE_PROTOTYPE)\npublic class BeanA...\n```\n```java\n@Bean\n@Scope(ConfigurationBeanFactory.SCOPE_PROTOTYPE)\npublic BeanA beanA（）{\n    return new BeanA（）；\n}\n```\n当然xml也有。。\n```xml\n<bean id=\"beanA\" class=\"com.BeanA\" scope=\"prototype\"/>\n```\n\n\n## 面向切面编程\n\n### AOP术语\n* 通知（advice）：定义切面是什么以及什么时候使用\n* 切点（poincut）：定义切面在哪里\n* 连接点（join point）：所有可能的切面\n* 切面（aspect）：通知和切点的结合\n* 引入（introduction）：向现有的类加入新方法或者属性\n* 织入（weaving）：\n\n#### 通知\n* 前置通知（before）：在目标方法被调用前通知功能\n* 后置通知（after）：在目标方法完成之后通知功能\n* 返回通知（after-retrning）：在目标成功执行后调用通知\n* 异常通知（after-throwing）：在目标方法抛出异常后通知\n* 环绕通知（around）：通知包裹了被通知的方法，在被通知的方法调用之前和之后执行自定义的行为\n\n### 编写切面\n\n#### 编写切点\n```java\nexecution(* com.Test.test(..)) && within(com.*)\n```\n* execution（），表示使用这种指示器\n* 里面的“*”，这里表示方法返回值的类型，星号表示全部\n* com.Test.test(..),指定类型和方法名，括号的..代表不在乎这个方法的参数是什么\n* &&,和的意思，可选，后面的within（com.*）代表仅匹配com包\n\n\n#### @Aspect、@Before、@AfterReturning、@AfterThrowing\n\n```java\n@Aspect\npublic class Qiemian{\n    //调用之前，其他类型通知类似\n    @Before(\"execution(* com.Test.test(..))\")\n    public void before(){}\n    ...\n} \n```\n#### @Pointcut\n当然每次都这么写切点表达式不麻烦死，所以这里可以用这个注解\n```java\n@Aspect\npublic class Qiemian {\n    //定义切点的方法,里面的实现最好是空的\n    @Pointcut(\"execution(* com.Test.test(..))\")\n    public void pointcutMethod()  {}\n    //调用之前，其他类型通知类似\n    @Before(\"pointcutMethod()\")\n    public void before() {}\n    ...\n} \n```\n\n#### @Around\n这个通知注解也是其他注解（@After是一定执行的。）的整合\n```java\npublic class Qiemian {\n    //定义切点的方法,里面的实现最好是空的\n    @Pointcut(\"execution(* com.Test.test(..))\")\n    public void pointcutMethod()  {}\n    //环绕通知 \n    @Around(\"pointcutMethod()\")\n    public void around(ProceedingJoinPoint jp) {\n        try{\n            //这里是调用之前通知\n            System.out.println(\"调用之前\");\n            //调用这个方法后，代表调用之后\n            jp.proceed();\n            // 这里是调用执行成功之后通知\n            System.out.println(\"调用执行成功之后\");\n        } catch (Exection e){\n            System.out.println(\"抛异常之后\");\n        }\n    }\n} \n```\n\n当然xml也有，这里不搞了。\n","tags":["little_eight"],"categories":["spring"]},{"title":"Linux的基本命令入门","url":"/2018/09/27/Linux的基本命令入门/","content":"\n# Linux的基本命令入门\n## 目录切换命令\n### 目录结构\n- / (根目录)\n  - bin（binaries）存放二进制可执行文件\n  - boot 存放用于系统引导时使用的各种文件\n  - dev （devices）用于存放设备文件\n  - etc （etcetera）存放系统配置文件\n  - home 存放用户文件的根目录\n    - 每个用户的根目录的存放的位置，home下创建每个用户的根目录。\n    - 例如：用户是test，那么在home下就会存在一个叫test的目录\n  - lib （library）存放跟文件系统中的程序运行所需要的共享库及内核模块\n  - sbin （super user binaries）存放二进制可执行文件，只有root才能访问\n  - usr （unix shared resources）用于存放共享的系统资源\n  - var （variable）用于存放运行时需要改变数据的文件\n  - ...\n### 目录切换命令\ncd usr\t\t切换到该目录下usr目录\ncd ../\t\t切换到上一层目录\ncd /\t\t切换到系统根目录\ncd ~\t\t切换到用户主目录\ncd -\t\t切换到上一个所在目录\n<!--more-->\n## 目录的操作命令\n### 增加目录操作\n命令：mkdir 目录名称\n示例：在根目录 / 下 mkdir test，就会在根目录 /下产生一个test问目录\n![Alt](https://github.com/little-eight-china/image/blob/master/bdbk/linux/add.png?raw=true)\n### 查看目录\n命令：ls [-al] 父目录\n示例：在根目录 / 下使用ls，可以看到该目录下的所有的目录和文件\n![Alt](https://github.com/little-eight-china/image/blob/master/bdbk/linux/query.png?raw=true)\n示例：在根目录 / 下使用ls -a，可以看到该目录下的所有文件和目录，包括隐藏的\n![Alt](https://github.com/little-eight-china/image/blob/master/bdbk/linux/q21.png?raw=true)\n示例：在根目录 / 下使用ls -l（ls -l 可以缩写成ll），可以看到该目录下的所有目录和文件的详细信息\n![Alt](https://github.com/little-eight-china/image/blob/master/bdbk/linux/query2.png?raw=true)\n### 寻找目录\n命令：find 目录 参数\n示例：查找/root下的与test相关的目录(文件)  find /root -name ‘test*’\n### 修改目录的名称\n命令：mv 目录名称 新目录名称（注意：mv的语法不仅可以对目录进行重命名而且也可以对各种文件，压缩包等进行\t重命名的操作）\n示例：test目录下有一个oldTest目录，使用mv oldTest newTest命令修改\n![Alt](https://github.com/little-eight-china/image/blob/master/bdbk/linux/mv.png?raw=true)\n### 移动目录的位置---剪切\n命令：mv 目录名称 目录的新位置（注意：mv语法不仅可以对目录进行剪切操作，对文件和压缩包等都可执行剪切操作）\n示例：在test下将newTest目录剪切到 /usr下面，使用mv newTest /usr\n![Alt](https://github.com/little-eight-china/image/blob/master/bdbk/linux/move.png?raw=true)\n\n### 拷贝目录\n命令：cp -r 目录名称 目录拷贝的目标位置 -----r代表递归拷贝（注意：cp命令不仅可以拷贝目录还可以拷贝文件，压缩包等，拷贝文件和压缩包时不\t用写-r递归）\n示例：将/usr下的newTest拷贝到根目录下的test中，使用cp -r /usr/newTest /test\n![Alt](https://github.com/little-eight-china/image/blob/master/bdbk/linux/copy.png?raw=true)\n\n### 删除目录\n命令：rm [-rf] 目录\n示例：删除/usr下的newTest，进入/usr下使用rm -r newTest\n![Alt](https://github.com/little-eight-china/image/blob/master/bdbk/linux/delete1.png?raw=true)\n示例：删除/test下的newTest而不需要询问强制删除，在/test下使用rm -rf newTest\n![Alt](https://github.com/little-eight-china/image/blob/master/bdbk/linux/delete2.png?raw=true)\n注意：rm不仅可以删除目录，也可以删除其他文件或压缩包，为了增强大家的记忆，无论删除任何目录或文件，都直接使用rm -rf 目录/文件/压缩包\n\n## 文件的操作命令\n### 文件的创建\n命令：touch 文件名称  ----- 空文件\n示例：在test目录下创建一个空文件 touch aaa.txt\n![Alt](https://github.com/little-eight-china/image/blob/master/bdbk/linux/add2.png?raw=true)\n### 文件的查看\n命令：cat/more/less/tail 文件\n示例：使用cat查看/etc/sudo.conf文件，只能显示最后一屏内容\n![Alt](https://github.com/little-eight-china/image/blob/master/bdbk/linux/query3.png?raw=true)\n示例：使用more查看/etc/sudo.conf文件，可以显示百分比，回车可以向下一行，\t空格可以向下一页，q可以退出查看\n![Alt](https://github.com/little-eight-china/image/blob/master/bdbk/linux/query4.png?raw=true)\n示例：使用less查看/etc/sudo.conf文件，可以使用键盘上的PgUp和PgDn向上\t和向下翻页，q结束查看\n![Alt](https://github.com/little-eight-china/image/blob/master/bdbk/linux/query5.png?raw=true)\n示例：使用tail -10 查看/etc/sudo.conf文件的后10行，Ctrl+C结束\n![Alt](https://github.com/little-eight-china/image/blob/master/bdbk/linux/query6.png?raw=true)\n注意：命令 tail -f 文件 可以对某个文件进行动态监控，例如tomcat的日志文件，\t会随着程序的运行，日志会变化，可以使用tail -f catalina-2018-11-11.log 监控\t文件的变化 \n\n### 修改文件的内容\n命令：vim 文件\n示例：编辑/test下的aaa.txt文件，使用vim aaa.txt\n进入文件内容后，此时并不能编辑，因为此时处于命令模式，点击键盘i/a/o进入编辑模式，可以\t编辑文件。编辑完成后，按下Esc，退回命令模式，此时文件虽然已经编辑完成，但是没有保存，需输入冒号：进入底行模式，在底行模\t式下输入wq代表写入内容并退出，即保存；输入q!代表强制退出不保存。\n关于vim使用过程：\n在实际开发中，使用vim编辑器主要作用就是修改配置文件\nvim 文件------>进入文件----->命令模式------>按i进入编辑模式----->编辑文件\t------->按Esc进入底行模式----->输入:wq/q!\n（关于vim的操作，这里只做最简单的阐述）\n\n## 压缩文件的操作命令\n### 打包并压缩文件\nLinux中的打包文件一般是以.tar结尾的，压缩的命令一般是以.gz结尾的。\n而一般情况下打包和压缩是一起进行的，打包并压缩后的文件的后缀名一般.tar.gz。\n命令：tar -zcvf 打包压缩后的文件名 要打包压缩的文件\n其中：z：调用gzip压缩命令进行压缩\n  c：打包文件\n  v：显示运行过程\n  f：指定文件名\n示例：打包并压缩/test下的所有文件 压缩后的压缩包指定名称为xxx.tar.gz\ntar -zcvf xxx.tar.gz aaa.txt bbb.txt ccc.txt\n或：tar -zcvf xxx.tar.gz /test/*\n![Alt](https://github.com/little-eight-china/image/blob/master/bdbk/linux/dabao1.png?raw=true)\n### 解压压缩包\n命令：tar [-xvf] 压缩文件\n其中：x：代表解压\n示例：将/test下的xxx.tar.gz解压到当前目录下\ntar -xvf xxx.tar.gz\n![Alt](https://github.com/little-eight-china/image/blob/master/bdbk/linux/jieya1.png?raw=true)\n示例：将/test下的xxx.tar.gz解压到根目录/usr下\ntar -xvf xxx.tar.gz -C /usr------C代表指定解压的位置\n![Alt](https://github.com/little-eight-china/image/blob/master/bdbk/linux/jieya2.png?raw=true)\n## 其他命令\n### 显示当前所在位置\n命令：pwd\n![Alt]()\n### 搜索命令\n命令：grep 要搜索的字符串 要搜索的文件\n示例：搜索/usr/sudu.conf文件中包含字符串to的行\n![Alt](https://github.com/little-eight-china/image/blob/master/bdbk/linux/sousuo1.png?raw=true)\n示例：搜索/usr/sudu.conf文件中包含字符串to的行 to要高亮显示\n![Alt](https://github.com/little-eight-china/image/blob/master/bdbk/linux/sousuo2.png?raw=true)\n### 管道命令\n命令：|   将前一个命令的输出作为本次目录的输入\n示例：查看当前系统中所有的进程中包括system字符串的进程\n![Alt](https://github.com/little-eight-china/image/blob/master/bdbk/linux/sousuo.png?raw=true)\n\n### 查看进程\n命令：ps -ef\n示例：查看当前系统中运行的进程 \n\n### 杀死进程\n命令：kill -9 进程的pid\n\n### 网络通信命令\n查看当前系统的网卡信息：ifconfig\n![Alt](https://github.com/little-eight-china/image/blob/master/bdbk/linux/ifconfig.png?raw=true)\n\n查看与某台机器的连接情况：ping\n![Alt](https://github.com/little-eight-china/image/blob/master/bdbk/linux/ping.png?raw=true)\n查看当前系统的端口使用：netstat -an\n![Alt](https://github.com/little-eight-china/image/blob/master/bdbk/linux/nes.png?raw=true)\n\n# Linux的权限命令\n## 权限说明\n权限是Linux中的重要概念，每个文件/目录等都具有权限，通过ls -l命令我们可以\t查看某个目录下的文件或目录的权限\n示例：在随意某个目录下ls -l（用缩写。。这里为了美观）\n![Alt](https://github.com/little-eight-china/image/blob/master/bdbk/linux/quanxian0.png?raw=true)\n第一列的内容的信息解释如下：\n![Alt](https://github.com/little-eight-china/image/blob/master/bdbk/linux/quanxian.png?raw=true)\n- 文件的类型:\n  -  d：代表目录\n  - -：代表文件\n  - l：代表链接（可以认为是window中的快捷方式）\n  - l：代表链接（可以认为是window中的快捷方式）\n后面的9位分为3组，每3位置一组，分别代表属主的权限，与当前用户同组的\t用户的权限，其他用户的权限\n  - r：代表权限是可读，r也可以用数字4表示\n  - w：代表权限是可写，w也可以用数字2表示\n  - x：代表权限是可执行，x也可以用数字1表示\n![Alt](https://github.com/little-eight-china/image/blob/master/bdbk/linux/quanxian2.jpg?raw=true)\n## 修改文件/目录的权限的命令：chmod\n示例：修改/test下的aaa.txt的权限为属主有全部权限，属主所在的组有读写权限，\n其他用户只有读的权限\nchmod u=rwx,g=rw,o=r aaa.txt\n![Alt](https://github.com/little-eight-china/image/blob/master/bdbk/linux/chmod.png?raw=true)\n上述示例还可以使用数字表示：\nchmod 764 aaa.txt\n\n## 切换用户\n有时候用户并不是root用户，没有权限修改文件权限\n命令：sudo su ，然后输入密码，回车\nroot用户转回普通用户\n命令：exit","tags":["little_eight"],"categories":["Linux"]},{"title":"科学上网：搬瓦工VPS搭建shadowsocks","url":"/2018/08/21/科学上网：搬瓦工搭建shadowsocks服务端/","content":"\n### 前言\nShadowsocks，中文名影梭，使用socks5代理，在中国大陆广泛用于翻墙，速度比 pptp和OpenVPN 要快，是一款翻墙必备神器。\n\n### VPS\nShadowsocks的正常使用需要服务器端，其实，所有的翻墙软件都是通过服务器端，而搭建服务器端，你就需要有自己的VPS，所以第一步你就是需要购买一个自己的VPS(或者你可以跟别人合租)，现在普遍使用的搭建服务器端的vps主要包括3种，一个是Linode，一个是DigitalOcean，一个是BandwagonHOST(搬瓦工)，这是从价格，性能等方面做出的推荐。\n\n### 搬瓦工\n搬瓦工VPS是一款性价比较高的便宜VPS主机，且适合入门级网友学习Linux和建站用途。（具体可在[搬瓦工VPS中文网](http://banwagong.cn/)查看） \n一、选择对应且需要的VPS方案\n![这里写图片描述](https://img-blog.csdn.net/20180821233117700?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2N6X3dzZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n<!--more-->\n二、核对方案配置以及选择时间期限和机房\n![这里写图片描述](http://banwagong.cn/images/jiaocheng-1.jpg)\n然后会看到上图所示的界面，根据图示我们需要确定选择的方案以及时间，默认是洛杉矶机房，我们也可以选择其他的几个机房之一，点击\"ADD TO CART\"添加购物车。\n![这里写图片描述](http://banwagong.cn/images/jiaocheng-2.jpg)\n\n> 搬瓦工优惠码：当前我们可以使用 BWH26FXH3HIQ 优惠码再节省5%\n\n三、登录或者新注册搬瓦工账户\n![这里写图片描述](http://banwagong.cn/images/jiaocheng-3.jpg)\n根据上图，如果我们有过账户，可以直接点击\"Click here to login\"登录以及付款就可以，如果还没有账户则需要注册账户。个人信息不要真实的，但也不能太离谱和乱写字符出来，好歹也要稍微用点拼音。\n\n> 我们不能用代理IP登录注册账户，国家需要真实，不要乱选择。\n\n四、付款成功以及使用\n目前只支持Paypal付款，所以我们需要有账户，如果没有可以注册，且可以用账户余额，也可以绑定信用卡、银联支付\n![这里写图片描述](http://banwagong.cn/images/jiaocheng-4.jpg)\n稍等一分钟左右，我们登录搬瓦工账户后台，就可以看到已经成功后买到的VPS主机，我们可以登录面板使用。\n### 使用\n点击 “KiwiVM Control Panel” 进入 VPS 控制面板。\n![这里写图片描述](http://s15.sinaimg.cn/mw690/006QTR5ezy7htKLALh4ae&690)\n接下来，使用xshell进行连接。\n\n> 温馨提示：如果出现死活连接不上linode的情况，可以ping一下你的Ip，看是否能ping通，如果ping不通，可能是你的ip已经被墙了，建议你删除此vps，重新建一个，或者在Linode中申请更换Ip的工单！\n\n### Shadowsocks服务端搭建\n1.环境安装与更新\n这一步，需要做的是依次执行下面的每条命令：\n> yum install epel-release\nyum update\nyum install python-setuptools m2crypto supervisor\neasy_install pip\npip install shadowsocks\n\n2.文件配置\n接下来需要编辑一下/etc/shadowsocks.json文件，命令如下：\n> vi /etc/shadowsocks.json\n\n执行上述命令后，此时的你已经进入文件编辑模式，这是你创建的一个新的空白文件，你需要做的事情就是将下面的内容粘贴后复制到shadowsocks.json文件里：\n\n###### 单用户配置：\n> {\n    \"server\":\"your_server_ip\", \n    \"server_port\":8388,\n    \"local_port\":1080,\n    \"password\":\"yourpassword\",\n    \"timeout\":600,\n    \"method\":\"aes-256-cfb\"\n}\n\n各字段的含义： \nserver：服务器 IP (IPv4/IPv6)，注意这也将是服务端监听的 IP 地址 \nserver_port：监听的服务器端口 \nlocal_address：本地监听的 IP 地址 \nlocal_port：本地端端口 \npassword：用来加密的密码 \ntimeout：超时时间（秒） \nmethod：加密方法，可选择 “bf-cfb”, “aes-256-cfb”, “des-cfb”, “rc4”, 等等。默认是一种不安全的加密，推荐用 “aes-256-cfb” \nfast_open：true 或 false \nworks：works数量，默认为 1\n###### 多用户配置：\n\n> {\n \"server\":\"my_server_ip\"，\n \"local_address\": \"127.0.0.1\",\n \"local_port\":1080,\n  \"port_password\": {\n     \"8381\": \"foobar1\",\n     \"8382\": \"foobar2\",\n     \"8383\": \"foobar3\",\n     \"8384\": \"foobar4\"\n },\n \"timeout\":300,\n \"method\":\"aes-256-cfb\",\n \"fast_open\": false\n}\n###### 启动\n> ssserver -c /etc/shadowsocks.json -d start #启动 \nssserver -c /etc/shadowsocks.json -d stop #停止\n###### 启动\n日志文件路径：/var/log/shadowsocks.log\n\n### 配置自动启动\n编辑/etc/supervisord.conf文件，命令如下：\n\n> vi /etc/supervisord.conf\n\n 此时，你已进入supervisord.conf文件的编辑模式，这不是一个空白文件，里面有很多英文，请把下面的内容粘贴到文件尾部的空行处，然后保存：\n> [program:shadowsocks]\ncommand=ssserver -c /etc/shadowsocks.json\nautostart=true\nautorestart=true\nuser=root\nlog_stderr=true\nlogfile=/var/log/shadowsocks.log\n\n接下来需要编辑/etc/rc.local文件，请执行以下命令：\n\n> vi /etc/rc.local\n\n此时，进入了rc.local文件的编辑模式，这也不是一个空白文件，请把以下内容粘贴到文件中部的空白处，然后保存\n\n> service supervisord start\n\n最后执行reboot命令或者vps的重启按钮，重启服务器。\n\n> 小提醒：搬瓦工的VPS在执行完reboot命令后有时会遇到重启失败的情况，这时候进入控制面板，看一下“Status”是不是“Running”，如果不是的话，点一下“Actions”里的“start”按钮即可。\n\n最后，可通过ps -ef|grep shadowsocks查看shadowsocks进程是否已启动\n","tags":["cz_wsd"],"categories":["杂类"]},{"title":"Spring Boot发送qq邮件","url":"/2018/08/11/Spring-Boot发送qq邮件/","content":"\n### Spring Boot中可以直接使用JavaMailSender发送邮件。\n* 新建工程，在pom.xml中引入相关依赖，注意加上版本号，不然可能有意想不到的bug。\n```\n <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-mail</artifactId>\n            <version>1.2.0.RELEASE</version>\n        </dependency>\n```\n\n* 配置application.yml，注意密码填的是授权码，填密码的话会报503错误。如何获取可自行百度，非常简单。\n``` \nspring:\n  mail:\n    #设置邮箱类型为qq\n    host: smtp.qq.com\n    #qq邮箱账户\n    username: xxx@qq.com\n    #qq邮箱授权码\n    password: iuxynhopeeqecb\n```\n配置完这些我们便可直接在测试用例中发送简单的邮件了\n\n* 在测试类中引入JavaMailSender，在测试方法里使用它的send方法，咦，发送成功。\n```\n   @Autowired\n    private JavaMailSender javaMailSender;\n    \n    @Test\n    public void sendSimpleMail() {\n        SimpleMailMessage message = new SimpleMailMessage();\n        // 发送方邮箱账户\n        message.setFrom(\"111@qq.com\");\n        // 接收方邮箱账户\n        message.setTo(\"222@qq.com\");\n        message.setSubject(\"测试邮件标题\");\n        message.setText(\"测试邮件内容\");\n\t\t// 发送邮件\n        javaMailSender.send(message);\n    }\n```\n\n","tags":["little_eight"],"categories":["springboot"]},{"title":"springboot整合RabbitMQ（windows环境）","url":"/2018/08/09/springboot整合RabbitMQ（windows环境）/","content":"\n### 安装 Erlang和RabbitMQ Server ，启动RabbitMQ Server\n\n**1、安装Erland，通过[官方下载页面](http://www.erlang.org/downloads)获取exe安装包，直接打开并完成安装。(好像要翻墙~自己解决)**\n**2、安装完Erland，配置好它的环境变量，变量值是你自己的安装地址，然后再在path变量加入它**\n\n> %ERLANG_HOME%\\bin\n\n\n**3、然后再安装[RabbitMQ服务端](https://www.rabbitmq.com/download.html),注意如果下载高版本的，对erland的版本也是有要求的，当然你两者都下最新的就没问题了。**\n\n\n**4、依然是配置好RabbitMQ的环境变量，和在path变量里新加**\n\n> %RABBITMQ_SERVER%\\sbin\n\n**5、然后打开命令行（注意要用管理员的身份打开，不然后面会提示错误~）然后输入**\n\n> rabbitmq-plugins.bat enable rabbitmq_management\n<!--more-->\n\n**开启Web管理插件，这样我们就可以通过浏览器来进行管理了，一般情况下这时候已经自动启动RabbitMQ服务了，我们也可以手动启动验证一下，输入**\n\n> net start RabbitMQ\n**要关闭服务的话，输入**\n>net stop RabbitMQ\n\n**6、打开web界面，地址 http://localhost:15672/  默认的用户名：guest 默认的密码为：guest**\n\n**你可以点击Admin去创建一个新的用户，我下面配置文件就会用到新的用户的用户名跟密码**\n\n-------------------------\n### springboot整合rabbitMQ\n\n**1、新建一个springboot工程，并在`pom.xml` 中引入与rabbitmq有关的依赖**\n``` xml\n  <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-amqp</artifactId>\n    </dependency>\n``` \n**2、修改application.yml,配置关于RabbitMQ的连接和用户信息（新建的工程配置文件不是这个名字，改成它即可。。。）**\n```yml\nspring:\n  application:\n    name: rabbitmq-test\n  rabbitmq:\n    host: localhost\n    port: 5672\n    username: admin\n    password: admin\n    \n```\n\n**3、创建RabbitMQ的配置类`RabbitConfig`**\n```\nimport org.springframework.amqp.core.Queue;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n/**\n * RabbitMQ的配置类\n */\n@Configuration\npublic class RabbitConfig {\n    @Bean\n    public Queue helloQueue() {\n        return new Queue(\"hello\");\n    }\n}\n```\n**4、我们建立一个消息生产类`Sender`，作为生产者的身边**\n``` java\nimport org.springframework.amqp.core.AmqpTemplate;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Component;\n\nimport java.util.Date;\n/**\n * 消息生产类\n */\n@Component\npublic class Sender {\n    @Autowired\n    private AmqpTemplate amqpTemplate;\n\n    public void send() {\n        String context = \"hello \" + new Date();\n        System.out.println(\"Sender : \" + context);\n        amqpTemplate.convertAndSend(\"hello\", context);\n    }\n\n}\n\n```\n\n**5、再建立一个消息消费类`Receiver`，作为消费者**\n\n``` java\nimport org.springframework.amqp.rabbit.annotation.RabbitHandler;\nimport org.springframework.amqp.rabbit.annotation.RabbitListener;\nimport org.springframework.stereotype.Component;\n\n/**\n * 消息消费类\n */\n@Component\n@RabbitListener(queues = \"hello\")\npublic class Receiver {\n\n    @RabbitHandler\n    public void process(String hello) {\n        System.out.println(\"Receiver : \" + hello);\n    }\n}\n```\n\n**6、最后再创建一个测试类`RabbitMQTest`**\n\n```\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.test.context.junit4.SpringRunner;\n\n@RunWith(SpringRunner.class)\n@SpringBootTest\npublic class RabbitMQTest {\n    @Autowired\n    private Sender sender;\n\n    @Test\n    public void testRabbitMQ(){\n        sender.send();\n    }\n}\n```\n\n**7、先启动主程序`RabbitmqApplication`,我这边碰到一个错误**\n![](https://raw.githubusercontent.com/little-eight-china/image/master/bdbk/rabbitmq/1.jpg?raw=true)\n**原来是没给admin这个用户设置管理队列的权限，去set一把即可**\n![](https://raw.githubusercontent.com/little-eight-china/image/master/bdbk/rabbitmq/2.jpg?raw=true)\n\n**再次运行主程序，成功连接RabbitMQ**\n![](https://raw.githubusercontent.com/little-eight-china/image/master/bdbk/rabbitmq/3.jpg?raw=true)\n\n**8、去run我们的测试用例方法，看到控制台输出，表示成功**\n![](https://raw.githubusercontent.com/little-eight-china/image/master/bdbk/rabbitmq/4.jpg?raw=true)\n**再切换回主程序，也可以看到输出日志**\n![](https://raw.githubusercontent.com/little-eight-china/image/master/bdbk/rabbitmq/5.jpg?raw=true)\n**当然我们在RabbitMQ的页面上也可以看到队列的消费信息记录**\n![](https://raw.githubusercontent.com/little-eight-china/image/master/bdbk/rabbitmq/6.jpg?raw=true)\n\n--------------\n#### 以上便是springboot对RabbitMQ的消息生产和消费的最简单的整合，想了解更多请查阅[RabbitMQ](https://www.rabbitmq.com/)官网","tags":["little_eight"],"categories":["springboot"]},{"title":"java面试题（一）","url":"/2018/07/18/java面试题（一）/","content":"# java面试题\n\n**基础问题**\n1.hashcode相等两个类一定相等吗？equals呢？相反呢？\n2.介绍一下集合框架\n3.hashmap和hashtable底层实现有什么区别？\nhashmap和concurrenthashmap呢？\n4.hashmap和treemap有什么区别？底层数据结构是什么？\n5.线程池用过吗?都有什么参数？底层如何实现的？\n6.sychnized和Lock的区别、sychnized什么情况是对象锁，什么情况是全局锁，为什么？\n7.ThreadLocal是什么？底层如何实现？写个例子呗？\n8.volitile的工作原理？\n9.cas知道吗？如何实现？\n10.请至少用4种写法 写一个单例模式\n<!--more-->\n**JVM**\n1.介绍一下JVM内存模型、用过什么垃圾回收器？都说说呗？\n2.线上发送频繁full gc如何处理？CPU使用率过高怎么办？\n如何定位问题？如何解决？说一下解决思路和处理方法。\n3.知道字节码吗？字节码都有哪些？\nInteger x=5,int y=5, 比较x==y都经历哪些步骤？\n4.讲讲类加载机制呗？都有哪些类加载器，这些类加载器都加载哪些文件？\n5.知道osgi吗？是如何实现的？\n6.请问你做过哪些JVM优化？使用什么方法？达到什么效果？？？","tags":["cz_wsd"],"categories":["杂类"]},{"title":"Github Page+Hexo搭建个人博客","url":"/2018/07/16/Github Page+Hexo搭建个人博客/","content":"\n简单介绍怎么搭起这个博客的\n\n### 首先执行四条命令（[Hexo官网](https://hexo.io/zh-cn)）\n\n``` bash\n$ npm install hexo-cli -g\n$ hexo init blog\n$ cd blog\n$ npm install\n$ hexo server\n```\n1、打开你的localhost:4000便可看到初始化的页面\n\n### 然后去下主题（现在用的是nexT）\n``` bash\ngit clone https://github.com/theme-next/hexo-theme-next.git\n```\n1、下完主题，把整个hexo-theme-next的文件夹拿到themes包下\n\n2、修改根目录的配置_config.yml，把theme: 后面的改成hexo-theme-next\n``` bash\ntheme: hexo-theme-next\n```\n<!--more-->\n3、再执行命令\n``` bash\n$ hexo clean\n$ hexo g\n$ hexo s\n```\n4、打开你的localhost:4000，是不是变化了，当然还是英文的，如果你想主题为中文，改根目录配置_config.yml\n``` bash\nlanguage: zh-cn\n``` \n### 上传到github\n1、在自己的github上面新建一个repository,然后在repository name里输入你的 “用户名+.github.io”，create\n\n2、在配置_config.yml修改对应的参数\n``` bash\ndeploy:\n  type: git\n  repository: git@github.com:xx/xx.github.io.git\n  branch: master\n```\n3、如果你是第一次装git，搞定你的ssh问题（[随便百度的教材](https://www.cnblogs.com/ayseeing/p/3572582.html)）\n\n3.5、如果步骤4会报错的话，就先装下git的插件。\n``` bash\nnpm install hexo-deployer-git --save\n```\n4、运行命令吧\n``` bash\nhexo d\n```\n5、等它部署完成，访问你的地址\n``` bash\nhttps://xx.github.io/\n```\n\n### 当然你也可以搞成自动化，参照这个\n[使用 Travis 自动部署 Hexo 到 Github 与 自己的服务器](https://segmentfault.com/a/1190000009054888)\n","tags":["little_eight"],"categories":["杂类"]}]